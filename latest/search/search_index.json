{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Open Translation Environment (OTE) API Core","text":"<p>Framework for accessing data resources, mapping data models, describing the data to ontologies and perform data transformations</p> <p> </p> <p>We highly recommend reading this page in the official documentation.</p>"},{"location":"#about-oteapi-core","title":"About OTEAPI Core","text":"<p>OTEAPI Core provides the core functionality of OTEAPI, which stands for the Open Translation Environment API.</p> <p>It uses the strategy software design pattern to implement a simple and easy to extend access to a large range of data resources. Semantic interoperability is supported via mapping of data models describing the data to ontologies. A set of strategy interfaces that can be considered abstract classes for the implementation of strategies, and data models used in their configuration, are provided. This repo also contains implementations for several standard strategies, e.g., downloading files, parsing Excel documents. Transformations, mainly intended to transform data between representations, are also supported, but transformations can also be used for running simulations in a simple workflow.</p> <p>OTEAPI Core includes:</p> <ul> <li>A set of standard strategies;</li> <li>A plugin system for loading the standard strategies, as well as third party strategies;</li> <li>Data models for configuring the strategies;</li> <li>A Python library, through which the data can be accessed; and</li> <li>An efficient data cache module that avoids downloading the same content several times.</li> </ul>"},{"location":"#types-of-strategies","title":"Types of strategies","text":""},{"location":"#download-strategy","title":"Download strategy","text":"<p>Download strategy patterns use a given protocol to download content into the data cache. They are configured with the <code>ResourceConfig</code> data model, using the scheme of the <code>downloadUrl</code> field for strategy selection. The <code>configuration</code> field can be used to configure how the downloaded content is stored in the cache using the <code>DownloadConfig</code> data model.</p> <p>Standard downloaded strategies: file, https, http, sftp, ftp</p>"},{"location":"#parse-strategy","title":"Parse strategy","text":"<p>Parse strategy patterns convert content from the data cache to a Python dict. Like download strategies, they are configured with the <code>ResourceConfig</code> data model, using the <code>mediaType</code> field for strategy selection. Additional strategy-specific configurations can be provided via the <code>configuration</code> field.</p> <p>Standard parse strategies: application/json, image/jpg, image/jpeg, image/jp2, image/png, image/gif, image/tiff, image/eps, application/vnd.openxmlformats-officedocument.spreadsheetml.sheet, application/vnd.sqlite3</p>"},{"location":"#resource-strategy","title":"Resource strategy","text":"<p>Resource strategy patterns can retrieve/upload data to external data services. They are configured with the <code>ResourceConfig</code> data model, using the scheme of the <code>accessUrl</code> and <code>accessService</code> fields. The scheme of the <code>accessUrl</code> is used for strategy selection.</p>"},{"location":"#mapping-strategy","title":"Mapping strategy","text":"<p>Strategies for mapping fields/properties in data models to ontological concepts.</p>"},{"location":"#filter-strategy","title":"Filter strategy","text":"<p>Filter strategies can update the configuration of other strategies. They can also update values in the data cache.</p> <p>Standard filter strategies: filter/crop, filter/sql</p>"},{"location":"#function-strategy","title":"Function strategy","text":"<p>Function strategies are synchronous transformations that (normally) run directly on the server hosting the OTE service.</p>"},{"location":"#transformation-strategy","title":"Transformation strategy","text":"<p>Transformation strategies are a special form of a function strategy intended for long-running transformations. In this sense, they represent asynchronous functions running in the background or on external resources.</p> <p>Standard transformation strategies: celery/remote</p> <p>The transformation strategy has consolidated the execution of the transformation with the <code>get()</code> method to unify the strategy interfaces. <code>get()</code> is intended to start an asynchronous process and return a task_id which can be queried using the <code>status()</code> method (outside of a pipeline).</p>"},{"location":"#entry-points-for-plugins","title":"Entry points for plugins","text":"<p>The way strategies are registered and found is through entry points.</p> <p>Special group names allow understanding the strategy type and the entry point values allow understanding of what kind of strategy a specific class implements. A full overview of recognized entry point group names can be seen in Table of entry point strategies.</p>"},{"location":"#defining-entry-points","title":"Defining entry points","text":"<p>In the following examples, let's imagine we have a package importable in Python through <code>my_plugin</code> and contains two download strategies and a single parse strategy:</p> <ol> <li>A peer-2-peer download strategy, implemented in a class named <code>Peer2PeerDownload</code> importable from <code>my_plugin.strategies.download.peer_2_peer</code>.</li> <li>A MongoDB download strategy, implemented in a class named <code>MongoRetrieve</code> importable from <code>my_plugin.strategies.mongo</code>.</li> <li>A MongoDB parse strategy, implemented in a class named <code>MongoParse</code> importable from <code>my_plugin.strategies.mongo</code>.</li> </ol> <p>There are now various different ways to let the Python environment know of these strategies through entry points.</p>"},{"location":"#setuppy","title":"<code>setup.py</code>","text":"<p>In the package's <code>setup.py</code> file, one can specify entry points. Here, an example snippet is shown using setuptools:</p> <pre><code># setup.py\nfrom setuptools import setup\n\nsetup(\n    # ...,\n    entry_points={\n        \"oteapi.download\": [\n            \"my_plugin.p2p = my_plugin.strategies.download.peer_2_peer:Peer2PeerDownload\",\n            \"my_plugin.mongo = my_plugin.strategies.mongo:MongoRetrieve\",\n        ],\n        \"oteapi.parse\": [\n            \"my_plugin.application/vnd.mongo+json = my_plugin.strategies.mongo:MongoParse\",\n        ]\n    },\n)\n</code></pre>"},{"location":"#yamljson-custom-files","title":"YAML/JSON custom files","text":"<p>Use custom files that are later parsed and used in a <code>setup.py</code> file.</p> <pre><code>entry_points:\noteapi.download:\n- \"my_plugin.p2p = my_plugin.strategies.download.peer_2_peer:Peer2PeerDownload\"\n- \"my_plugin.mongo = my_plugin.strategies.mongo:MongoRetrieve\"\noteapi.parse:\n- \"my_plugin.application/vnd.mongo+json = my_plugin.strategies.mongo:MongoParse\"\n</code></pre> <pre><code>{\n\"entry_points\": {\n\"oteapi.download\": [\n\"my_plugin.p2p = my_plugin.strategies.download.peer_2_peer:Peer2PeerDownload\",\n\"my_plugin.mongo = my_plugin.strategies.mongo:MongoRetrieve\"\n],\n\"oteapi.parse\": [\n\"my_plugin.application/vnd.mongo+json = my_plugin.strategies.mongo:MongoParse\"\n]\n}\n}\n</code></pre>"},{"location":"#setupcfgpyprojecttoml","title":"<code>setup.cfg</code>/<code>pyproject.toml</code>","text":"<p>A more modern approach is to use <code>setup.cfg</code> or <code>pyproject.toml</code>.</p> <pre><code>[options.entry_points]\noteapi.download =\nmy_plugin.p2p = my_plugin.strategies.download.peer_2_peer:Peer2PeerDownload\nmy_plugin.mongo = my_plugin.strategies.mongo:MongoRetrieve\noteapi.parse =\nmy_plugin.application/vnd.mongo+json = my_plugin.strategies.mongo:MongoParse\n</code></pre>"},{"location":"#syntax-and-semantics","title":"Syntax and semantics","text":"<p>As seen above, there are a few different syntactical flavors of how to list the entry points. However, the \"value\" stays the same throughout.</p>"},{"location":"#general-python-entry-points","title":"General Python entry points","text":"<p>The general syntax for entry points is based on <code>ini</code> files and parsed using the built-in <code>configparser</code> module described here. Specifically for entry points the nomenclature is the following:</p> <pre><code>[options.entry_points]\nGROUP =\nNAME = VALUE\n</code></pre> <p>The <code>VALUE</code> is then further split into: <code>PACKAGE.MODULE:OBJECT.ATTRIBUTE [EXTRA1, EXTRA2]</code>.</p>"},{"location":"#oteapi-strategy-entry-points","title":"OTEAPI strategy entry points","text":"<p>From the general syntax outlined above, OTEAPI Core then implements rules and requirements regarding the syntax for strategies.</p> <ol> <li>A class MUST be specified (as an <code>OBJECT</code>).</li> <li>The <code>NAME</code> MUST consist of exactly two parts: <code>PACKAGE</code> and strategy type value in the form of <code>PACKAGE.STRATEGY_TYPE_VALUE</code>.</li> <li>The <code>GROUP</code> MUST be a valid OTEAPI entry point group, see Table of entry point strategies for a full list of valid OTEAPI entry point group values.</li> </ol> <p>To understand what the strategy type value should be, see Table of entry point strategies.</p>"},{"location":"#table-of-entry-point-strategies","title":"Table of entry point strategies","text":"Strategy Type Name Strategy Type Value Entry Point Group Documentation Reference Download <code>scheme</code> <code>oteapi.download</code> Download strategy Filter <code>filterType</code> <code>oteapi.filter</code> Filter strategy Function <code>functionType</code> <code>oteapi.function</code> Function strategy Mapping <code>mappingType</code> <code>oteapi.mapping</code> Mapping strategy Parse <code>mediaType</code> <code>oteapi.parse</code> Parse strategy Resource <code>accessService</code> <code>oteapi.resource</code> Resource strategy Transformation <code>transformationType</code> <code>oteapi.transformation</code> Transformation strategy"},{"location":"#other-oteapi-related-repositories","title":"Other OTEAPI-related repositories","text":"<ul> <li>OTEAPI Services - a RESTful interface to OTEAPI Core</li> <li>OTELib - a Python interface to OTEAPI Services</li> <li>OTEAPI Plugin Template - a cookiecutter template for OTEAPI Plugins</li> </ul>"},{"location":"#installation","title":"Installation","text":"<p>OTEAPI Core can be installed with:</p> <pre><code>pip install oteapi-core\n</code></pre>"},{"location":"#for-developers","title":"For developers","text":"<p>If you want to install OTEAPI Core to have a developer environment, please clone down the repository from GitHub and install:</p> <pre><code>git clone https://github.com/EMMC-ASBL/oteapi-core /path/to/oteapi-core\npip install -U --upgrade-strategy=eager -e /path/to/oteapi-core[dev]\n</code></pre> <p>Note, <code>/path/to/oteapi-core</code> can be left out of the first line, but then it must be updated in the second line, either to <code>./oteapi-core</code>/<code>oteapi-core</code> or <code>.</code> if you <code>cd</code> into the generated folder wherein the repository has been cloned.</p> <p>The <code>--upgrade-strategy=eager</code> part can be left out. We recommend installing within a dedicated virtual environment.</p> <p>To test the installation, you can run:</p> <pre><code>cd /path/to/oteapi-core\npytest\n</code></pre> <p>If you run into issues at this stage, please open an issue.</p>"},{"location":"#using-docker-with-postgresql","title":"Using Docker with PostgreSQL","text":"<p>Docker is an effective tool for creating portable, isolated environments for your applications. Here's an example of setting up a PostgreSQL instance using Docker:</p> <ol> <li>Create a Docker volume: Docker volumes enable data to persist across uses of Docker containers. In this context, we create a volume called pgdata to store database data.</li> </ol> <pre><code>docker volume create pgdata\n</code></pre> <ol> <li>Start a Docker container: Use the <code>docker run</code> command to initiate a new Docker container using the postgres image. Here's a breakdown of the options used in the command:</li> </ol> <p><code>-d</code>: Runs the container in the background (detached mode), freeing up your terminal.</p> <p><code>--name postgres</code>: Names the container postgres, allowing it to be referenced in future Docker commands.</p> <p><code>-e POSTGRES_PASSWORD=postgres</code>: Sets an environment variable in the container to specify the PostgreSQL database password as postgres.</p> <p><code>-p 5432:5432</code>: Maps port 5432 of the container to port 5432 of the host machine, letting applications on the host connect to the PostgreSQL database in the container.</p> <p><code>-v pgdata:/var/lib/postgresql/data</code>: Mounts the pgdata volume at the path /var/lib/postgresql/data inside the container, which is the storage location for PostgreSQL data files.</p> <p><code>--restart always</code>: Ensures the container restarts whenever it stops, unless it is manually stopped, in which case it only restarts when the Docker daemon starts, usually on system boot.</p> <pre><code>docker run  -d --name postgres \\\n-e POSTGRES_PASSWORD=postgres \\\n-p 5432:5432 \\\n-v pgdata:/var/lib/postgresql/data \\\n--restart always postgres\n</code></pre>"},{"location":"#license","title":"License","text":"<p>OTEAPI Core is released under the MIT license with copyright \u00a9 SINTEF.</p>"},{"location":"#acknowledgment","title":"Acknowledgment","text":"<p>OTEAPI Core has been supported by the following projects:</p> <ul> <li> <p>OntoTrans (2020-2024) that receives funding from the European Union\u2019s Horizon 2020 Research and Innovation Programme, under Grant Agreement no. 862136.</p> </li> <li> <p>VIPCOAT (2021-2025) receives funding from the European Union\u2019s Horizon 2020 Research and Innovation Programme - DT-NMBP-11-2020 Open Innovation Platform for Materials Modelling, under Grant Agreement no: 952903.</p> </li> <li> <p>OpenModel (2021-2025) receives funding from the European Union\u2019s Horizon 2020 Research and Innovation Programme - DT-NMBP-11-2020 Open Innovation Platform for Materials Modelling, under Grant Agreement no: 953167.</p> </li> </ul>"},{"location":"CHANGELOG/","title":"Changelog","text":""},{"location":"CHANGELOG/#unreleased-changes-2023-09-21","title":"Unreleased changes (2023-09-21)","text":"<p>Full Changelog</p> <p>Implemented enhancements:</p> <ul> <li>Use ruff instead of pylint #331</li> <li>Consider using <code>flit</code> #267</li> </ul> <p>Fixed bugs:</p> <ul> <li>Update <code>full_docs_dirs</code> input for CI/CD #322</li> </ul> <p>Closed issues:</p> <ul> <li>Revert update of codecov-action from v4 to v3 #328</li> <li>Document that oteapi-core must be installed editable in order to test with pytest #62</li> </ul> <p>Merged pull requests:</p> <ul> <li>Extend codecov uploads with strategies-specific flag #335 (CasperWA)</li> <li>Use flit instead of setuptools #334 (CasperWA)</li> <li>[Auto-generated] Update dependencies #333 (TEAM4-0)</li> <li>Use ruff instead of pylint #332 (CasperWA)</li> <li>[Auto-generated] Update dependencies #324 (TEAM4-0)</li> <li>Add strategies folders to CI/CD workflows docs update #323 (CasperWA)</li> </ul>"},{"location":"CHANGELOG/#v050-2023-09-12","title":"v0.5.0 (2023-09-12)","text":"<p>Full Changelog</p> <p>Fixed bugs:</p> <ul> <li>datacache:  the hash is not updated if the value is a string #298</li> </ul> <p>Closed issues:</p> <ul> <li>Ensure all strategy models are fully expressed #312</li> <li>Importing oteapi.strategies.parse.image fails for Python 3.9 #269</li> </ul> <p>Merged pull requests:</p> <ul> <li>Added support for relative file paths #318 (jesper-friis)</li> <li>[Auto-generated] Update dependencies #315 (TEAM4-0)</li> <li>Fully document strategies #313 (CasperWA)</li> <li>Update .pre-commit-config.yaml #307 (Treesarj)</li> <li>Introduce ParserConfig Model  #306 (daniel-sintef)</li> <li>[Auto-generated] Update dependencies #282 (TEAM4-0)</li> </ul>"},{"location":"CHANGELOG/#v045-2023-08-11","title":"v0.4.5 (2023-08-11)","text":"<p>Full Changelog</p> <p>Merged pull requests:</p> <ul> <li>update key in datacachewhen value is added as string #299 (francescalb)</li> <li>[Auto-generated] Update dependencies #280 (TEAM4-0)</li> <li>[Auto-generated] Update dependencies #278 (TEAM4-0)</li> <li>Added DOI badge to readme #273 (jesper-friis)</li> </ul>"},{"location":"CHANGELOG/#v044-2023-05-24","title":"v0.4.4 (2023-05-24)","text":"<p>Full Changelog</p> <p>Closed issues:</p> <ul> <li>psycopg2/PostgreSQL datasource strategy #191</li> </ul> <p>Merged pull requests:</p> <ul> <li>191 psycopg2postgresql datasource strategy #196 (daniel-sintef)</li> </ul>"},{"location":"CHANGELOG/#v043-2023-05-23","title":"v0.4.3 (2023-05-23)","text":"<p>Full Changelog</p> <p>Merged pull requests:</p> <ul> <li>[Auto-generated] Update dependencies #272 (TEAM4-0)</li> <li>Use typing-extensions for Python \\&lt;= 3.9 #270 (CasperWA)</li> </ul>"},{"location":"CHANGELOG/#v042-2023-05-12","title":"v0.4.2 (2023-05-12)","text":"<p>Full Changelog</p> <p>Implemented enhancements:</p> <ul> <li>Update SINTEF/ci-cd #265</li> </ul> <p>Fixed bugs:</p> <ul> <li>Pin to using urllib3 v1.x #261</li> </ul> <p>Closed issues:</p> <ul> <li>Rename the pipeline get() method to execute() #250</li> <li>Clean up requirements #248</li> <li>Activate auto-merging for CI workflow to update dependencies #247</li> </ul> <p>Merged pull requests:</p> <ul> <li>Update to SINTEF/ci-cd v2 #266 (CasperWA)</li> <li>[Auto-generated] Update dependencies #264 (TEAM4-0)</li> <li>Pin urllib3 to v1.x #262 (CasperWA)</li> <li>[Auto-generated] Update dependencies #260 (TEAM4-0)</li> <li>[Auto-generated] Update dependencies #258 (TEAM4-0)</li> <li>[Auto-generated] Update dependencies #256 (TEAM4-0)</li> <li>[Auto-generated] Update dependencies #252 (TEAM4-0)</li> <li>[Auto-generated] Update dependencies #246 (TEAM4-0)</li> <li>[Auto-generated] Update dependencies #244 (TEAM4-0)</li> </ul>"},{"location":"CHANGELOG/#v041-2023-03-10","title":"v0.4.1 (2023-03-10)","text":"<p>Full Changelog</p> <p>Merged pull requests:</p> <ul> <li>[Auto-generated] Update dependencies #242 (TEAM4-0)</li> <li>Polish <code>celery/remote</code> transformation strategy #240 (CasperWA)</li> <li>[Auto-generated] Update dependencies #239 (TEAM4-0)</li> <li>[Auto-generated] Update dependencies #235 (TEAM4-0)</li> <li>[Auto-generated] Update dependencies #234 (TEAM4-0)</li> </ul>"},{"location":"CHANGELOG/#v040-2023-02-07","title":"v0.4.0 (2023-02-07)","text":"<p>Full Changelog</p> <p>Fixed bugs:</p> <ul> <li>pylint compliance #229</li> </ul> <p>Closed issues:</p> <ul> <li>Use get in transformation datamodels and celery_remote #232</li> </ul> <p>Merged pull requests:</p> <ul> <li>Updated the interfaces and implementation of the transformation strat\u2026 #233 (quaat)</li> <li>Move pylint config file to pyproject.toml #230 (CasperWA)</li> <li>[Auto-generated] Update dependencies #228 (TEAM4-0)</li> <li>[Auto-generated] Update dependencies #226 (TEAM4-0)</li> </ul>"},{"location":"CHANGELOG/#v030-2023-01-24","title":"v0.3.0 (2023-01-24)","text":"<p>Full Changelog</p> <p>Implemented enhancements:</p> <ul> <li>Add json-encoders for SecretStr/SecretByte #218</li> <li>Use SINTEF/ci-cd callable workflows and pre-commit hooks #205</li> </ul> <p>Fixed bugs:</p> <ul> <li>Update configuration files for MkDocs #203</li> </ul> <p>Closed issues:</p> <ul> <li>Reenable documentation CI/CD disabled in PR #200 #201</li> <li>Error in description of MappingConfig.prefixes #197</li> <li>Update pylint options #193</li> </ul> <p>Merged pull requests:</p> <ul> <li>[Auto-generated] Update dependencies #223 (TEAM4-0)</li> <li>Enh/secrets json encoders #222 (MBueschelberger)</li> <li>[Auto-generated] Update dependencies #220 (TEAM4-0)</li> <li>[Auto-generated] Update dependencies #217 (TEAM4-0)</li> <li>[Auto-generated] Update dependencies #215 (TEAM4-0)</li> <li>[Auto-generated] Update dependencies #214 (TEAM4-0)</li> <li>[Auto-generated] Update dependencies #213 (TEAM4-0)</li> <li>add optional secret to functionconfig and resourceconfig #212 (MBueschelberger)</li> <li>Updated documentation of prefixes in MappingConfig #209 (jesper-friis)</li> <li>Use SINTEF/ci-cd #206 (CasperWA)</li> <li>Revert removing <code>--strict</code> and fix docs build #204 (CasperWA)</li> <li>removed --strict option #202 (daniel-sintef)</li> <li>[Auto-generated] Update dependencies #199 (TEAM4-0)</li> <li>added a small clarification to the docs #198 (daniel-sintef)</li> <li>Use recursive option for pylint-tests CI #194 (CasperWA)</li> <li>[Auto-generated] Update dependencies #190 (TEAM4-0)</li> <li>[Auto-generated] Update dependencies #189 (TEAM4-0)</li> <li>[Auto-generated] Update dependencies #186 (TEAM4-0)</li> <li>[Auto-generated] Update dependencies #184 (TEAM4-0)</li> <li>[Auto-generated] Update dependencies #182 (TEAM4-0)</li> <li>[Auto-generated] Update dependencies #174 (TEAM4-0)</li> </ul>"},{"location":"CHANGELOG/#v021-2022-07-20","title":"v0.2.1 (2022-07-20)","text":"<p>Full Changelog</p> <p>Fixed bugs:</p> <ul> <li><code>filter/crop</code> not loading properly #170</li> </ul> <p>Merged pull requests:</p> <ul> <li>Test and fix registered strategies #171 (CasperWA)</li> <li>[Auto-generated] Update dependencies #169 (TEAM4-0)</li> </ul>"},{"location":"CHANGELOG/#v020-2022-07-11","title":"v0.2.0 (2022-07-11)","text":"<p>Full Changelog</p> <p>Implemented enhancements:</p> <ul> <li>Implement the CSV parse strategy #159</li> </ul> <p>Fixed bugs:</p> <ul> <li>Problems accessing configurations' fields #113</li> </ul> <p>Closed issues:</p> <ul> <li>Add VIPCOAT and OpenModel to acknowledgements on all repositories. #133</li> </ul> <p>Merged pull requests:</p> <ul> <li>[Auto-generated] Update dependencies #165 (TEAM4-0)</li> <li>[Auto-generated] Update dependencies #163 (TEAM4-0)</li> <li>CSV parse strategy #160 (CasperWA)</li> <li>[Auto-generated] Update dependencies #155 (TEAM4-0)</li> <li>[Auto-generated] Update dependencies #152 (TEAM4-0)</li> <li>[Auto-generated] Update dependencies #150 (TEAM4-0)</li> </ul>"},{"location":"CHANGELOG/#v016-2022-04-20","title":"v0.1.6 (2022-04-20)","text":"<p>Full Changelog</p> <p>Fixed bugs:</p> <ul> <li>Setting attributes in <code>AttrDict</code> should be handled by pydantic #143</li> </ul> <p>Closed issues:</p> <ul> <li>Add checklist for reviewers to all repositories. #137</li> </ul> <p>Merged pull requests:</p> <ul> <li>[Auto-generated] Update dependencies #149 (TEAM4-0)</li> <li>Modify excel parse #148 (daniel-sintef)</li> <li>[Auto-generated] Update dependencies #147 (TEAM4-0)</li> <li>Fix deleting entries in AttrDict #144 (CasperWA)</li> <li>[Auto-generated] Update dependencies #142 (TEAM4-0)</li> <li>Added PR template with checklist for reviewers. #139 (francescalb)</li> <li>[Auto-generated] Update dependencies #136 (TEAM4-0)</li> </ul>"},{"location":"CHANGELOG/#v015-2022-03-23","title":"v0.1.5 (2022-03-23)","text":"<p>Full Changelog</p> <p>Implemented enhancements:</p> <ul> <li>Create a triple store class #120</li> <li>Fix pydantic model types according to default values #117</li> </ul> <p>Closed issues:</p> <ul> <li>Fix badge links in README #122</li> </ul> <p>Merged pull requests:</p> <ul> <li>Update README.md #134 (quaat)</li> <li>[Auto-generated] Update dependencies #130 (TEAM4-0)</li> <li>triplestore class which does add, delete/update and get mappings/triples #128 (Treesarj)</li> <li>Add links to badges in README #126 (CasperWA)</li> <li>Fix pydantic model type and default values #125 (CasperWA)</li> </ul>"},{"location":"CHANGELOG/#v014-2022-03-11","title":"v0.1.4 (2022-03-11)","text":"<p>Full Changelog</p> <p>Implemented enhancements:</p> <ul> <li>Support passing a dictionary as config to <code>create_strategy()</code> #123</li> </ul> <p>Merged pull requests:</p> <ul> <li>Using the <code>StrategyType</code> to deliver the <code>*Config</code> cls #124 (CasperWA)</li> </ul>"},{"location":"CHANGELOG/#v013-2022-03-10","title":"v0.1.3 (2022-03-10)","text":"<p>Full Changelog</p> <p>Implemented enhancements:</p> <ul> <li>Move pytest fixtures into <code>oteapi</code> package #121</li> <li>Add <code>pop()</code> (and possibly <code>popitem()</code>) to <code>AttrDict</code> #118</li> <li>Allow to bind values added to the data cache to an object, such that they automatically will be remove when the object goes out of scope #114</li> <li>Add some badges to the README #91</li> </ul> <p>Fixed bugs:</p> <ul> <li>The image strategy puts binary data in the session #107</li> </ul> <p>Merged pull requests:</p> <ul> <li>Implement and test <code>pop()</code> and <code>popitem()</code> for AttrDict #119 (CasperWA)</li> <li>[Auto-generated] Update dependencies #116 (TEAM4-0)</li> <li>Allow to bind the lifetime of datacache values to the lifetime of the session #115 (jesper-friis)</li> <li>Added mapping strategy #112 (jesper-friis)</li> <li>Corrected the sql_query_filter. #110 (jesper-friis)</li> <li>Store image data in datacache instead of session #108 (jesper-friis)</li> <li>Update README #106 (CasperWA)</li> </ul>"},{"location":"CHANGELOG/#v012-2022-03-03","title":"v0.1.2 (2022-03-03)","text":"<p>Full Changelog</p> <p>Implemented enhancements:</p> <ul> <li>Go through ignored dev tools comments #76</li> </ul> <p>Fixed bugs:</p> <ul> <li>Issue with <code>AttrDict.update()</code> for <code>AttrDict</code> subclasses #101</li> <li>GH GraphQL type issue in auto-merge workflow #96</li> </ul> <p>Merged pull requests:</p> <ul> <li>Update \"ignore\" statements #103 (CasperWA)</li> <li>Add test for AttrDict.update() method #102 (CasperWA)</li> <li>[Auto-generated] Update dependencies #100 (TEAM4-0)</li> <li>Use <code>ID!</code> type instead of <code>String!</code> #97 (CasperWA)</li> </ul>"},{"location":"CHANGELOG/#v011-2022-02-24","title":"v0.1.1 (2022-02-24)","text":"<p>Full Changelog</p> <p>Implemented enhancements:</p> <ul> <li>Avoid registerring the incomplete <code>text/csv</code> parse strategy #95</li> <li>Use special <code>*Config</code> classes where necessary #93</li> </ul> <p>Closed issues:</p> <ul> <li>Clean up the handling of paths in the file download strategy #84</li> </ul> <p>Merged pull requests:</p> <ul> <li>Update data cache invocation #94 (CasperWA)</li> <li>[Auto-generated] Update dependencies #92 (TEAM4-0)</li> </ul>"},{"location":"CHANGELOG/#v010-2022-02-22","title":"v0.1.0 (2022-02-22)","text":"<p>Full Changelog</p> <p>Implemented enhancements:</p> <ul> <li>Clean up tests #75</li> <li>Image parser: Use datacache #63</li> </ul> <p>Fixed bugs:</p> <ul> <li>Entrypoint does not seem to be updated during rebuild #86</li> <li>Use proper file scheme URLs in tests #74</li> <li>xlsx parse strategy fails parsing file on Windows #23</li> </ul> <p>Closed issues:</p> <ul> <li>Use standard library functions instead of homemade code for handling file:// URIs #88</li> <li>Remove image/eps as supported image format #68</li> </ul> <p>Merged pull requests:</p> <ul> <li>EntryPoint duplicity #87 (CasperWA)</li> <li>Added support for dumping numpy arrays to the datacache #83 (jesper-friis)</li> <li>[Auto-generated] Update dependencies #82 (TEAM4-0)</li> <li>Pydantic dataclasses #81 (CasperWA)</li> <li>Made datacache accepting AttrDict configuration #70 (jesper-friis)</li> </ul>"},{"location":"CHANGELOG/#v006-2022-02-14","title":"v0.0.6 (2022-02-14)","text":"<p>Full Changelog</p> <p>Implemented enhancements:</p> <ul> <li>New Function strategy #19</li> </ul> <p>Fixed bugs:</p> <ul> <li>ResourceConfig.configuration should be a dict #65</li> <li>Configuration bug #34</li> <li>Change mediaType for json to application/json #24</li> </ul> <p>Closed issues:</p> <ul> <li>AttrDict cannot be **unpacked #69</li> <li>Add tests of configuration object subscripting functionality #61</li> <li>Tests require installation #50</li> <li>Rename image_jpeg.py #48</li> <li>Write unit tests #11</li> </ul> <p>Merged pull requests:</p> <ul> <li>Sg/session update model #78 (sygout)</li> <li>New Function strategy #73 (CasperWA)</li> <li>Made ResourceConfig.configuration a dict #67 (jesper-friis)</li> <li>[Auto-generated] Update dependencies #66 (TEAM4-0)</li> <li>Add some dictionary functionality to configuration models #53 (TorgeirUstad)</li> <li>All new tests #35 (TorgeirUstad)</li> </ul>"},{"location":"CHANGELOG/#v005-2022-02-04","title":"v0.0.5 (2022-02-04)","text":"<p>Full Changelog</p> <p>Implemented enhancements:</p> <ul> <li>Consider removing the <code>create_*_strategy()</code> functions #57</li> <li>Lazy strategy loading #21</li> <li>Extend and \"safeguard\" plugin loading through entry points #10</li> </ul> <p>Fixed bugs:</p> <ul> <li>Out-of-scope CVE from NumPy makes safety cry #54</li> <li>pyproject.toml addopts line doesn't work on Windows #51</li> <li>Ignore ID 44715 for safety #55 (CasperWA)</li> </ul> <p>Merged pull requests:</p> <ul> <li>[Auto-generated] Update dependencies #56 (TEAM4-0)</li> <li>Add Windows pytest CI job #52 (CasperWA)</li> <li>Start implementing entry point logic #47 (CasperWA)</li> </ul>"},{"location":"CHANGELOG/#v004-2022-01-26","title":"v0.0.4 (2022-01-26)","text":"<p>Full Changelog</p> <p>Implemented enhancements:</p> <ul> <li>Setup dependency handling via dependabot #31</li> <li>Attempt simplifying strategy factory function #13</li> </ul> <p>Fixed bugs:</p> <ul> <li>Update pytest command in CI to fix codecov #42</li> <li>Publish workflow failing - invoke not installed #40</li> </ul> <p>Closed issues:</p> <ul> <li>Use new TEAM 4.0[bot] email throughout #38</li> <li>Make datacache safe to call from within a running asyncio event loop #26</li> <li>Setup documentation framework #9</li> </ul> <p>Merged pull requests:</p> <ul> <li>[Auto-generated] Update dependencies #45 (TEAM4-0)</li> <li>Add pytest options to pyproject.toml #43 (CasperWA)</li> <li>Install the <code>dev</code> extra in publish workflow #41 (CasperWA)</li> <li>Use the updated @TEAM4-0 email address #39 (CasperWA)</li> <li>Implement CI/CD for dependabot #33 (CasperWA)</li> <li>Remove asyncio from datacache #32 (jesper-friis)</li> <li>Setup docs framework and implement creating any strategy function #29 (CasperWA)</li> </ul>"},{"location":"CHANGELOG/#v003-2022-01-21","title":"v0.0.3 (2022-01-21)","text":"<p>Full Changelog</p> <p>Implemented enhancements:</p> <ul> <li>Remove non-\"standard\" strategies #14</li> <li>Clean up the API #12</li> </ul> <p>Fixed bugs:</p> <ul> <li>Update CI/CD to only use Python 3.9 #25</li> <li>References in README are wrong #18</li> </ul> <p>Closed issues:</p> <ul> <li>Bring back <code>pre-commit</code> #16</li> <li>Publish docker image #15</li> </ul> <p>Merged pull requests:</p> <ul> <li>Updated cd_release.yml to python 3.9 #28 (kriwiik)</li> <li>Add back <code>pre-commit</code> #22 (CasperWA)</li> <li>Fixed README.md References #20 (anasayb)</li> <li>Clean up Python API #17 (CasperWA)</li> </ul>"},{"location":"CHANGELOG/#v002-2022-01-14","title":"v0.0.2 (2022-01-14)","text":"<p>Full Changelog</p> <p>Implemented enhancements:</p> <ul> <li>Release and tests CD/CI #1 (CasperWA)</li> </ul> <p>Fixed bugs:</p> <ul> <li>CD publish release workflow not working #4</li> <li>CD release not working - wrong utils path #2</li> </ul> <p>Merged pull requests:</p> <ul> <li>Cleanup #8 (jesper-friis)</li> <li>Renamed oteapi/strategy-interfaces to oteapi/interfaces and updated paths in all Python modules #6 (jesper-friis)</li> <li>Update workflows to make CD work #5 (CasperWA)</li> <li>Fix location of utility files for GH Actions #3 (CasperWA)</li> </ul> <p>* This Changelog was automatically generated by github_changelog_generator</p>"},{"location":"LICENSE/","title":"License","text":"<p>MIT License</p> <p>Copyright (c) 2020-2022 SINTEF</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"all_models/","title":"OTE-API Configuration Models","text":"<p>This page provides documentation for the <code>oteapi.models</code> submodule, where all the OTE-API strategy configuration data models are located.</p> <p>When creating instances of these models, the data types are automatically validated.</p> <p><code>oteapi.models</code> module.</p> <p>This module contains all the <code>pydantic</code> configuration models.</p>"},{"location":"all_models/#oteapi.models.RDFTriple","title":"<code>RDFTriple = Tuple[str, str, str]</code>  <code>module-attribute</code>","text":""},{"location":"all_models/#oteapi.models.StrategyConfig","title":"<code>StrategyConfig = Union[FilterConfig, FunctionConfig, MappingConfig, ParserConfig, ResourceConfig, TransformationConfig]</code>  <code>module-attribute</code>","text":""},{"location":"all_models/#oteapi.models.AttrDict","title":"<code>AttrDict</code>","text":"<p>             Bases: <code>BaseModel</code>, <code>Mapping</code></p> <p>An object whose attributes can also be accessed through subscription, like with a dictionary.</p> Source code in <code>oteapi/models/genericconfig.py</code> <pre><code>class AttrDict(BaseModel, Mapping):\n\"\"\"An object whose attributes can also be accessed through\n    subscription, like with a dictionary.\"\"\"\n\n    def __contains__(self, name: \"Any\") -&gt; bool:\n\"\"\"Enable using the 'in' operator on this object.\"\"\"\n        return self.__dict__.__contains__(name)\n\n    def __delitem__(self, key: str) -&gt; None:\n\"\"\"Enable deletion access through subscription.\n\n        If the item is a pydantic field, reset it and remove it from the set of set\n        fields. Otherwise, delete the attribute.\n\n        \"\"\"\n        if key in self.__dict__:\n            if key in self.__fields__:\n                # Reset field to default and remove from set of set fields\n                setattr(self, key, self.__fields__[key].default)\n                self.__fields_set__.remove(key)\n            else:\n                self.__delattr__(key)\n        else:\n            raise KeyError(key)\n\n    def __getitem__(self, key: str) -&gt; \"Any\":\n\"\"\"Enable read access through subscription.\"\"\"\n        if key in self.__dict__:\n            return getattr(self, key)\n        raise KeyError(key)\n\n    def __setitem__(self, key: str, value: \"Any\") -&gt; None:\n\"\"\"Enable write access through subscription.\"\"\"\n        setattr(self, key, value)\n\n    def __len__(self):\n\"\"\"Return number of items.\"\"\"\n        return self.__dict__.__len__()\n\n    def __iter__(self):\n\"\"\"Enable **unpacking.\"\"\"\n        return self.__dict__.__iter__()\n\n    def items(self):\n\"\"\"Return a view of all (key, value) pairs.\"\"\"\n        return self.__dict__.items()\n\n    def keys(self):\n\"\"\"Return a view of all keys.\"\"\"\n        return self.__dict__.keys()\n\n    def values(self):\n\"\"\"Return a view of all values.\"\"\"\n        return self.__dict__.values()\n\n    def get(self, key: str, default: \"Optional[Any]\" = None) -&gt; \"Any\":\n\"\"\"Mapping `get`-method.\"\"\"\n        return self.__dict__.get(key, default)\n\n    def __ne__(self, other: \"Any\") -&gt; bool:\n\"\"\"Implement the != operator.\"\"\"\n        if isinstance(other, BaseModel):\n            return self.dict() != other.dict()\n        return self.dict() != other\n\n    def update(\n        self, other: \"Optional[Union[dict, AttrDict, Iterable[Any]]]\" = None, **kwargs\n    ) -&gt; None:\n\"\"\"MutableMapping `update`-method.\"\"\"\n        if other and isinstance(other, (dict, Mapping)):\n            for key, value in other.items():\n                setattr(self, key, value)\n        elif other and isinstance(other, BaseModel):\n            for key, value in other.dict().items():\n                setattr(self, key, value)\n        elif other and isinstance(other, Iterable):\n            for entry in other:\n                if not len(entry) == 2:\n                    raise ValueError(\n                        \"`other` must be an iterable of objects of length two.\"\n                    )\n            for key, value in other:\n                setattr(self, key, value)\n        if kwargs:\n            for key, value in kwargs.items():\n                setattr(self, key, value)\n\n    def pop(self, key: str, default: \"Optional[Any]\" = Undefined) -&gt; \"Any\":\n\"\"\"MutableMapping `pop`-method.\"\"\"\n        value = self.get(key, default)\n        if value == Undefined:\n            raise KeyError(key)\n        if key in self:\n            del self[key]\n        return value\n\n    def popitem(self) -&gt; \"Tuple[str, Any]\":\n\"\"\"MutableMapping `popitem`-method.\n\n        Important:\n            Unlike the regular `dict.popitem()` method, this one does _not_ respect\n            LIFO (last-in, first-out).\n            This is due to the fact that attributes are stored in a random order when\n            initializing the model.\n\n            However, it will respect LIFO with respect to the internal `__dict__`.\n\n        \"\"\"\n        if not self:\n            raise KeyError(f\"popitem(): {self.__class__.__name__} is empty\")\n\n        key = list(self.__dict__)[-1]\n        value = self.pop(key)\n        return key, value\n\n    class Config:\n\"\"\"Pydantic configuration for `AttrDict`.\n\n        * **`extra`**\n          Allow any attributes/fields to be defined - this is what makes this pydantic\n          model an attribute dictionary.\n        * **`validate_assignment`**\n          Validate and cast set values.\n          This is mainly relevant for sub-classes of `AttrDict`, where specific\n          attributes have been defined.\n        * **`arbitrary_types_allowed`**\n          If a custom type is used for an attribute that doesn't have a `validate()`\n          method, don't fail setting the attribute.\n\n        \"\"\"\n\n        extra = \"allow\"\n        validate_assignment = True\n        arbitrary_types_allowed = True\n</code></pre>"},{"location":"all_models/#oteapi.models.AttrDict.Config","title":"<code>Config</code>","text":"<p>Pydantic configuration for <code>AttrDict</code>.</p> <ul> <li><code>extra</code>   Allow any attributes/fields to be defined - this is what makes this pydantic   model an attribute dictionary.</li> <li><code>validate_assignment</code>   Validate and cast set values.   This is mainly relevant for sub-classes of <code>AttrDict</code>, where specific   attributes have been defined.</li> <li><code>arbitrary_types_allowed</code>   If a custom type is used for an attribute that doesn't have a <code>validate()</code>   method, don't fail setting the attribute.</li> </ul> Source code in <code>oteapi/models/genericconfig.py</code> <pre><code>class Config:\n\"\"\"Pydantic configuration for `AttrDict`.\n\n    * **`extra`**\n      Allow any attributes/fields to be defined - this is what makes this pydantic\n      model an attribute dictionary.\n    * **`validate_assignment`**\n      Validate and cast set values.\n      This is mainly relevant for sub-classes of `AttrDict`, where specific\n      attributes have been defined.\n    * **`arbitrary_types_allowed`**\n      If a custom type is used for an attribute that doesn't have a `validate()`\n      method, don't fail setting the attribute.\n\n    \"\"\"\n\n    extra = \"allow\"\n    validate_assignment = True\n    arbitrary_types_allowed = True\n</code></pre>"},{"location":"all_models/#oteapi.models.AttrDict.Config.arbitrary_types_allowed","title":"<code>arbitrary_types_allowed = True</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_models/#oteapi.models.AttrDict.Config.extra","title":"<code>extra = 'allow'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_models/#oteapi.models.AttrDict.Config.validate_assignment","title":"<code>validate_assignment = True</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_models/#oteapi.models.AttrDict.get","title":"<code>get(key, default=None)</code>","text":"<p>Mapping <code>get</code>-method.</p> Source code in <code>oteapi/models/genericconfig.py</code> <pre><code>def get(self, key: str, default: \"Optional[Any]\" = None) -&gt; \"Any\":\n\"\"\"Mapping `get`-method.\"\"\"\n    return self.__dict__.get(key, default)\n</code></pre>"},{"location":"all_models/#oteapi.models.AttrDict.items","title":"<code>items()</code>","text":"<p>Return a view of all (key, value) pairs.</p> Source code in <code>oteapi/models/genericconfig.py</code> <pre><code>def items(self):\n\"\"\"Return a view of all (key, value) pairs.\"\"\"\n    return self.__dict__.items()\n</code></pre>"},{"location":"all_models/#oteapi.models.AttrDict.keys","title":"<code>keys()</code>","text":"<p>Return a view of all keys.</p> Source code in <code>oteapi/models/genericconfig.py</code> <pre><code>def keys(self):\n\"\"\"Return a view of all keys.\"\"\"\n    return self.__dict__.keys()\n</code></pre>"},{"location":"all_models/#oteapi.models.AttrDict.pop","title":"<code>pop(key, default=Undefined)</code>","text":"<p>MutableMapping <code>pop</code>-method.</p> Source code in <code>oteapi/models/genericconfig.py</code> <pre><code>def pop(self, key: str, default: \"Optional[Any]\" = Undefined) -&gt; \"Any\":\n\"\"\"MutableMapping `pop`-method.\"\"\"\n    value = self.get(key, default)\n    if value == Undefined:\n        raise KeyError(key)\n    if key in self:\n        del self[key]\n    return value\n</code></pre>"},{"location":"all_models/#oteapi.models.AttrDict.popitem","title":"<code>popitem()</code>","text":"<p>MutableMapping <code>popitem</code>-method.</p> Important <p>Unlike the regular <code>dict.popitem()</code> method, this one does not respect LIFO (last-in, first-out). This is due to the fact that attributes are stored in a random order when initializing the model.</p> <p>However, it will respect LIFO with respect to the internal <code>__dict__</code>.</p> Source code in <code>oteapi/models/genericconfig.py</code> <pre><code>def popitem(self) -&gt; \"Tuple[str, Any]\":\n\"\"\"MutableMapping `popitem`-method.\n\n    Important:\n        Unlike the regular `dict.popitem()` method, this one does _not_ respect\n        LIFO (last-in, first-out).\n        This is due to the fact that attributes are stored in a random order when\n        initializing the model.\n\n        However, it will respect LIFO with respect to the internal `__dict__`.\n\n    \"\"\"\n    if not self:\n        raise KeyError(f\"popitem(): {self.__class__.__name__} is empty\")\n\n    key = list(self.__dict__)[-1]\n    value = self.pop(key)\n    return key, value\n</code></pre>"},{"location":"all_models/#oteapi.models.AttrDict.update","title":"<code>update(other=None, **kwargs)</code>","text":"<p>MutableMapping <code>update</code>-method.</p> Source code in <code>oteapi/models/genericconfig.py</code> <pre><code>def update(\n    self, other: \"Optional[Union[dict, AttrDict, Iterable[Any]]]\" = None, **kwargs\n) -&gt; None:\n\"\"\"MutableMapping `update`-method.\"\"\"\n    if other and isinstance(other, (dict, Mapping)):\n        for key, value in other.items():\n            setattr(self, key, value)\n    elif other and isinstance(other, BaseModel):\n        for key, value in other.dict().items():\n            setattr(self, key, value)\n    elif other and isinstance(other, Iterable):\n        for entry in other:\n            if not len(entry) == 2:\n                raise ValueError(\n                    \"`other` must be an iterable of objects of length two.\"\n                )\n        for key, value in other:\n            setattr(self, key, value)\n    if kwargs:\n        for key, value in kwargs.items():\n            setattr(self, key, value)\n</code></pre>"},{"location":"all_models/#oteapi.models.AttrDict.values","title":"<code>values()</code>","text":"<p>Return a view of all values.</p> Source code in <code>oteapi/models/genericconfig.py</code> <pre><code>def values(self):\n\"\"\"Return a view of all values.\"\"\"\n    return self.__dict__.values()\n</code></pre>"},{"location":"all_models/#oteapi.models.DataCacheConfig","title":"<code>DataCacheConfig</code>","text":"<p>             Bases: <code>AttrDict</code></p> <p>DataCache Configuration.</p> <p>This class should not be used directly as a configuration object for a strategy object, but only as a configuration field inside a configuration object.</p> Source code in <code>oteapi/models/datacacheconfig.py</code> <pre><code>class DataCacheConfig(AttrDict):\n\"\"\"DataCache Configuration.\n\n    This class should not be used directly as a configuration object\n    for a strategy object, but only as a configuration field inside\n    a configuration object.\n    \"\"\"\n\n    cacheDir: Path = Field(Path(\"oteapi\"), description=\"Cache directory.\")\n    accessKey: Optional[str] = Field(\n        None,\n        description=\"Key with which the downloaded content can be accessed. \"\n        \"Should preferable be the hash (corresponding to `hashType`) of the \"\n        \"content if it is known.\",\n    )\n    hashType: str = Field(\n        \"md5\",\n        description=\"Hash algorithm to use for creating hash keys for stored \"\n        \"data. Can be any algorithm supported by hashlib.\",\n    )\n    expireTime: int = Field(\n        3600 * 24 * 14,\n        description=\"Number of seconds before the cache entry expires. \"\n        \"Zero means no expiration. Default is two weeks.\",\n    )\n    tag: Optional[str] = Field(\n        None,\n        description=\"Tag assigned to the downloaded content, typically \"\n        \"identifying a session. Used with the `evict()` method to clean up a \"\n        \"all cache entries with a given tag.\",\n    )\n</code></pre>"},{"location":"all_models/#oteapi.models.DataCacheConfig.accessKey","title":"<code>accessKey: Optional[str] = Field(None, description='Key with which the downloaded content can be accessed. Should preferable be the hash (corresponding to `hashType`) of the content if it is known.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_models/#oteapi.models.DataCacheConfig.cacheDir","title":"<code>cacheDir: Path = Field(Path('oteapi'), description='Cache directory.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_models/#oteapi.models.DataCacheConfig.expireTime","title":"<code>expireTime: int = Field(3600 * 24 * 14, description='Number of seconds before the cache entry expires. Zero means no expiration. Default is two weeks.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_models/#oteapi.models.DataCacheConfig.hashType","title":"<code>hashType: str = Field('md5', description='Hash algorithm to use for creating hash keys for stored data. Can be any algorithm supported by hashlib.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_models/#oteapi.models.DataCacheConfig.tag","title":"<code>tag: Optional[str] = Field(None, description='Tag assigned to the downloaded content, typically identifying a session. Used with the `evict()` method to clean up a all cache entries with a given tag.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_models/#oteapi.models.FilterConfig","title":"<code>FilterConfig</code>","text":"<p>             Bases: <code>GenericConfig</code></p> <p>Filter Strategy Data Configuration.</p> Source code in <code>oteapi/models/filterconfig.py</code> <pre><code>class FilterConfig(GenericConfig):\n\"\"\"Filter Strategy Data Configuration.\"\"\"\n\n    filterType: str = Field(\n        ..., description=\"Type of registered filter strategy. E.g., `filter/sql`.\"\n    )\n    query: Optional[str] = Field(None, description=\"Define a query operation.\")\n    condition: Optional[str] = Field(\n        None,\n        description=\"Logical statement indicating when a filter should be applied.\",\n    )\n    limit: Optional[int] = Field(\n        None, description=\"Number of items remaining after a filter expression.\"\n    )\n</code></pre>"},{"location":"all_models/#oteapi.models.FilterConfig.condition","title":"<code>condition: Optional[str] = Field(None, description='Logical statement indicating when a filter should be applied.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_models/#oteapi.models.FilterConfig.filterType","title":"<code>filterType: str = Field(..., description='Type of registered filter strategy. E.g., `filter/sql`.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_models/#oteapi.models.FilterConfig.limit","title":"<code>limit: Optional[int] = Field(None, description='Number of items remaining after a filter expression.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_models/#oteapi.models.FilterConfig.query","title":"<code>query: Optional[str] = Field(None, description='Define a query operation.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_models/#oteapi.models.FunctionConfig","title":"<code>FunctionConfig</code>","text":"<p>             Bases: <code>GenericConfig</code>, <code>SecretConfig</code></p> <p>Function Strategy Data Configuration.</p> Source code in <code>oteapi/models/functionconfig.py</code> <pre><code>class FunctionConfig(GenericConfig, SecretConfig):\n\"\"\"Function Strategy Data Configuration.\"\"\"\n\n    functionType: str = Field(\n        ...,\n        description=(\"Type of registered function strategy.\"),\n    )\n</code></pre>"},{"location":"all_models/#oteapi.models.FunctionConfig.functionType","title":"<code>functionType: str = Field(..., description='Type of registered function strategy.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_models/#oteapi.models.GenericConfig","title":"<code>GenericConfig</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>Generic class for configuration objects.</p> Source code in <code>oteapi/models/genericconfig.py</code> <pre><code>class GenericConfig(BaseModel):\n\"\"\"Generic class for configuration objects.\"\"\"\n\n    configuration: AttrDict = Field(\n        AttrDict(),\n        description=\"Model-specific configuration options which can either \"\n        \"be given as key/value-pairs or set as attributes.\",\n    )\n\n    description: str = Field(\n        __doc__,\n        description=\"A description of the configuration model.\",\n    )\n\n    @classmethod\n    def __init_subclass__(cls) -&gt; None:\n\"\"\"Initialize subclass descriptions with their docstrings.\"\"\"\n        cls.__fields__[\"description\"].default = cls.__doc__\n\n    class Config:\n\"\"\"Pydantic configuration for `GenericConfig`.\n\n        * **`validate_assignment`**\n          Validate and cast set values.\n          This is mainly relevant for sub-classes of `AttrDict`, where specific\n          attributes have been defined.\n        * **`arbitrary_types_allowed`**\n          If a custom type is used for an attribute that doesn't have a `validate()`\n          method, don't fail setting the attribute.\n\n        \"\"\"\n\n        validate_assignment = True\n        arbitrary_types_allowed = True\n</code></pre>"},{"location":"all_models/#oteapi.models.GenericConfig.configuration","title":"<code>configuration: AttrDict = Field(AttrDict(), description='Model-specific configuration options which can either be given as key/value-pairs or set as attributes.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_models/#oteapi.models.GenericConfig.description","title":"<code>description: str = Field(__doc__, description='A description of the configuration model.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_models/#oteapi.models.GenericConfig.Config","title":"<code>Config</code>","text":"<p>Pydantic configuration for <code>GenericConfig</code>.</p> <ul> <li><code>validate_assignment</code>   Validate and cast set values.   This is mainly relevant for sub-classes of <code>AttrDict</code>, where specific   attributes have been defined.</li> <li><code>arbitrary_types_allowed</code>   If a custom type is used for an attribute that doesn't have a <code>validate()</code>   method, don't fail setting the attribute.</li> </ul> Source code in <code>oteapi/models/genericconfig.py</code> <pre><code>class Config:\n\"\"\"Pydantic configuration for `GenericConfig`.\n\n    * **`validate_assignment`**\n      Validate and cast set values.\n      This is mainly relevant for sub-classes of `AttrDict`, where specific\n      attributes have been defined.\n    * **`arbitrary_types_allowed`**\n      If a custom type is used for an attribute that doesn't have a `validate()`\n      method, don't fail setting the attribute.\n\n    \"\"\"\n\n    validate_assignment = True\n    arbitrary_types_allowed = True\n</code></pre>"},{"location":"all_models/#oteapi.models.GenericConfig.Config.arbitrary_types_allowed","title":"<code>arbitrary_types_allowed = True</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_models/#oteapi.models.GenericConfig.Config.validate_assignment","title":"<code>validate_assignment = True</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_models/#oteapi.models.MappingConfig","title":"<code>MappingConfig</code>","text":"<p>             Bases: <code>GenericConfig</code></p> <p>Mapping Strategy Data Configuration.</p> Source code in <code>oteapi/models/mappingconfig.py</code> <pre><code>class MappingConfig(GenericConfig):\n\"\"\"Mapping Strategy Data Configuration.\"\"\"\n\n    mappingType: str = Field(\n        ...,\n        description=\"Type of registered mapping strategy.\",\n    )\n    prefixes: Optional[Dict[str, str]] = Field(\n        None,\n        description=(\n            \"Dictionary of shortnames that expands to an IRI given as local \"\n            \"value/IRI-expansion-pairs.\"\n        ),\n    )\n    triples: Optional[Set[RDFTriple]] = Field(\n        None,\n        description=\"Set of RDF triples given as (subject, predicate, object).\",\n    )\n</code></pre>"},{"location":"all_models/#oteapi.models.MappingConfig.mappingType","title":"<code>mappingType: str = Field(..., description='Type of registered mapping strategy.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_models/#oteapi.models.MappingConfig.prefixes","title":"<code>prefixes: Optional[Dict[str, str]] = Field(None, description='Dictionary of shortnames that expands to an IRI given as local value/IRI-expansion-pairs.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_models/#oteapi.models.MappingConfig.triples","title":"<code>triples: Optional[Set[RDFTriple]] = Field(None, description='Set of RDF triples given as (subject, predicate, object).')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_models/#oteapi.models.ParserConfig","title":"<code>ParserConfig</code>","text":"<p>             Bases: <code>GenericConfig</code></p> <p>Parser Strategy Data Configuration.</p> Source code in <code>oteapi/models/parserconfig.py</code> <pre><code>class ParserConfig(GenericConfig):\n\"\"\"Parser Strategy Data Configuration.\"\"\"\n\n    parserType: str = Field(..., description=\"Type of registered parser strategy.\")\n</code></pre>"},{"location":"all_models/#oteapi.models.ParserConfig.parserType","title":"<code>parserType: str = Field(..., description='Type of registered parser strategy.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_models/#oteapi.models.ResourceConfig","title":"<code>ResourceConfig</code>","text":"<p>             Bases: <code>GenericConfig</code>, <code>SecretConfig</code></p> <p>Resource Strategy Data Configuration.</p> Important <p>Either of the pairs of attributes <code>downloadUrl</code>/<code>mediaType</code> or <code>accessUrl</code>/<code>accessService</code> MUST be specified.</p> Source code in <code>oteapi/models/resourceconfig.py</code> <pre><code>class ResourceConfig(GenericConfig, SecretConfig):\n\"\"\"Resource Strategy Data Configuration.\n\n    Important:\n        Either of the pairs of attributes `downloadUrl`/`mediaType` or\n        `accessUrl`/`accessService` MUST be specified.\n\n    \"\"\"\n\n    downloadUrl: Optional[HostlessAnyUrl] = Field(\n        None,\n        description=(\n            \"Definition: The URL of the downloadable file in a given format. E.g. CSV \"\n            \"file or RDF file.\\n\\nUsage: `downloadURL` *SHOULD* be used for the URL at\"\n            \" which this distribution is available directly, typically through a HTTPS\"\n            \" GET request or SFTP.\"\n        ),\n    )\n    mediaType: Optional[str] = Field(\n        None,\n        description=(\n            \"The media type of the distribution as defined by IANA \"\n            \"[[IANA-MEDIA-TYPES](https://www.w3.org/TR/vocab-dcat-2/#bib-iana-media-types)]\"\n            \".\\n\\nUsage: This property *SHOULD* be used when the media\"\n            \" type of the distribution is defined in IANA \"\n            \"[[IANA-MEDIA-TYPES](https://www.w3.org/TR/vocab-dcat-2/#bib-iana-media-types)].\"\n        ),\n    )\n    accessUrl: Optional[HostlessAnyUrl] = Field(\n        None,\n        description=(\n            \"A URL of the resource that gives access to a distribution of \"\n            \"the dataset. E.g. landing page, feed, SPARQL endpoint.\\n\\nUsage: \"\n            \"`accessURL` *SHOULD* be used for the URL of a service or location that \"\n            \"can provide access to this distribution, typically through a Web form, \"\n            \"query or API call.\\n`downloadURL` is preferred for direct links to \"\n            \"downloadable resources.\"\n        ),\n    )\n    accessService: Optional[str] = Field(\n        None,\n        description=(\n            \"A data service that gives access to the distribution of the dataset.\"\n        ),\n    )\n    license: Optional[str] = Field(\n        None,\n        description=(\n            \"A legal document under which the distribution is made available.\"\n        ),\n    )\n    accessRights: Optional[str] = Field(\n        None,\n        description=(\n            \"A rights statement that concerns how the distribution is accessed.\"\n        ),\n    )\n    publisher: Optional[str] = Field(\n        None,\n        description=\"The entity responsible for making the resource/item available.\",\n    )\n\n    @root_validator\n    def ensure_unique_url_pairs(cls, values: \"Dict[str, Any]\") -&gt; \"Dict[str, Any]\":\n\"\"\"Ensure either downloadUrl/mediaType or accessUrl/accessService are defined.\n\n        It's fine to define them all, but at least one complete pair MUST be specified.\n        \"\"\"\n        if not (\n            all(values.get(_) for _ in [\"downloadUrl\", \"mediaType\"])\n            or all(values.get(_) for _ in [\"accessUrl\", \"accessService\"])\n        ):\n            raise ValueError(\n                \"Either of the pairs of attributes downloadUrl/mediaType or \"\n                \"accessUrl/accessService MUST be specified.\"\n            )\n        return values\n</code></pre>"},{"location":"all_models/#oteapi.models.ResourceConfig.accessRights","title":"<code>accessRights: Optional[str] = Field(None, description='A rights statement that concerns how the distribution is accessed.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_models/#oteapi.models.ResourceConfig.accessService","title":"<code>accessService: Optional[str] = Field(None, description='A data service that gives access to the distribution of the dataset.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_models/#oteapi.models.ResourceConfig.accessUrl","title":"<code>accessUrl: Optional[HostlessAnyUrl] = Field(None, description='A URL of the resource that gives access to a distribution of the dataset. E.g. landing page, feed, SPARQL endpoint.\\n\\nUsage: `accessURL` *SHOULD* be used for the URL of a service or location that can provide access to this distribution, typically through a Web form, query or API call.\\n`downloadURL` is preferred for direct links to downloadable resources.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_models/#oteapi.models.ResourceConfig.downloadUrl","title":"<code>downloadUrl: Optional[HostlessAnyUrl] = Field(None, description='Definition: The URL of the downloadable file in a given format. E.g. CSV file or RDF file.\\n\\nUsage: `downloadURL` *SHOULD* be used for the URL at which this distribution is available directly, typically through a HTTPS GET request or SFTP.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_models/#oteapi.models.ResourceConfig.license","title":"<code>license: Optional[str] = Field(None, description='A legal document under which the distribution is made available.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_models/#oteapi.models.ResourceConfig.mediaType","title":"<code>mediaType: Optional[str] = Field(None, description='The media type of the distribution as defined by IANA [[IANA-MEDIA-TYPES](https://www.w3.org/TR/vocab-dcat-2/#bib-iana-media-types)].\\n\\nUsage: This property *SHOULD* be used when the media type of the distribution is defined in IANA [[IANA-MEDIA-TYPES](https://www.w3.org/TR/vocab-dcat-2/#bib-iana-media-types)].')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_models/#oteapi.models.ResourceConfig.publisher","title":"<code>publisher: Optional[str] = Field(None, description='The entity responsible for making the resource/item available.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_models/#oteapi.models.ResourceConfig.ensure_unique_url_pairs","title":"<code>ensure_unique_url_pairs(values)</code>","text":"<p>Ensure either downloadUrl/mediaType or accessUrl/accessService are defined.</p> <p>It's fine to define them all, but at least one complete pair MUST be specified.</p> Source code in <code>oteapi/models/resourceconfig.py</code> <pre><code>@root_validator\ndef ensure_unique_url_pairs(cls, values: \"Dict[str, Any]\") -&gt; \"Dict[str, Any]\":\n\"\"\"Ensure either downloadUrl/mediaType or accessUrl/accessService are defined.\n\n    It's fine to define them all, but at least one complete pair MUST be specified.\n    \"\"\"\n    if not (\n        all(values.get(_) for _ in [\"downloadUrl\", \"mediaType\"])\n        or all(values.get(_) for _ in [\"accessUrl\", \"accessService\"])\n    ):\n        raise ValueError(\n            \"Either of the pairs of attributes downloadUrl/mediaType or \"\n            \"accessUrl/accessService MUST be specified.\"\n        )\n    return values\n</code></pre>"},{"location":"all_models/#oteapi.models.SecretConfig","title":"<code>SecretConfig</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>Simple model for handling secret in other config-models.</p> Source code in <code>oteapi/models/secretconfig.py</code> <pre><code>class SecretConfig(BaseModel, json_dumps=json_dumps):\n\"\"\"Simple model for handling secret in other config-models.\"\"\"\n\n    user: Optional[SecretStr] = Field(None, description=\"User name for authentication.\")\n    password: Optional[SecretStr] = Field(\n        None, description=\"Password for authentication.\"\n    )\n    token: Optional[SecretStr] = Field(\n        None,\n        description=(\n            \"An access token for providing access and meta data to an application.\"\n        ),\n    )\n    client_id: Optional[SecretStr] = Field(\n        None, description=\"Client ID for an OAUTH2 client.\"\n    )\n    client_secret: Optional[SecretStr] = Field(\n        None, description=\"Client secret for an OAUTH2 client.\"\n    )\n</code></pre>"},{"location":"all_models/#oteapi.models.SecretConfig.client_id","title":"<code>client_id: Optional[SecretStr] = Field(None, description='Client ID for an OAUTH2 client.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_models/#oteapi.models.SecretConfig.client_secret","title":"<code>client_secret: Optional[SecretStr] = Field(None, description='Client secret for an OAUTH2 client.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_models/#oteapi.models.SecretConfig.password","title":"<code>password: Optional[SecretStr] = Field(None, description='Password for authentication.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_models/#oteapi.models.SecretConfig.token","title":"<code>token: Optional[SecretStr] = Field(None, description='An access token for providing access and meta data to an application.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_models/#oteapi.models.SecretConfig.user","title":"<code>user: Optional[SecretStr] = Field(None, description='User name for authentication.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_models/#oteapi.models.SessionUpdate","title":"<code>SessionUpdate</code>","text":"<p>             Bases: <code>AttrDict</code></p> <p>Session Update Data Model for returning values.</p> Source code in <code>oteapi/models/sessionupdate.py</code> <pre><code>class SessionUpdate(AttrDict):\n\"\"\"Session Update Data Model for returning values.\"\"\"\n</code></pre>"},{"location":"all_models/#oteapi.models.TransformationConfig","title":"<code>TransformationConfig</code>","text":"<p>             Bases: <code>GenericConfig</code>, <code>SecretConfig</code></p> <p>Transformation Strategy Data Configuration.</p> Source code in <code>oteapi/models/transformationconfig.py</code> <pre><code>class TransformationConfig(GenericConfig, SecretConfig):\n\"\"\"Transformation Strategy Data Configuration.\"\"\"\n\n    transformationType: str = Field(\n        ...,\n        description=(\n            \"Type of registered transformation strategy. E.g., `celery/remote`.\"\n        ),\n    )\n    name: Optional[str] = Field(\n        None, description=\"Human-readable name of the transformation strategy.\"\n    )\n    due: Optional[datetime] = Field(\n        None,\n        description=(\n            \"Optional field to indicate a due data/time for when a transformation \"\n            \"should finish.\"\n        ),\n    )\n    priority: Optional[ProcessPriority] = Field(\n        ProcessPriority.MEDIUM,\n        description=\"Define the process priority of the transformation execution.\",\n    )\n</code></pre>"},{"location":"all_models/#oteapi.models.TransformationConfig.due","title":"<code>due: Optional[datetime] = Field(None, description='Optional field to indicate a due data/time for when a transformation should finish.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_models/#oteapi.models.TransformationConfig.name","title":"<code>name: Optional[str] = Field(None, description='Human-readable name of the transformation strategy.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_models/#oteapi.models.TransformationConfig.priority","title":"<code>priority: Optional[ProcessPriority] = Field(ProcessPriority.MEDIUM, description='Define the process priority of the transformation execution.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_models/#oteapi.models.TransformationConfig.transformationType","title":"<code>transformationType: str = Field(..., description='Type of registered transformation strategy. E.g., `celery/remote`.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_models/#oteapi.models.TransformationStatus","title":"<code>TransformationStatus</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>Return from transformation status.</p> Source code in <code>oteapi/models/transformationconfig.py</code> <pre><code>class TransformationStatus(BaseModel):\n\"\"\"Return from transformation status.\"\"\"\n\n    id: str = Field(..., description=\"ID for the given transformation process.\")\n    status: Optional[str] = Field(\n        None, description=\"Status for the transformation process.\"\n    )\n    messages: Optional[List[str]] = Field(\n        None, description=\"Messages related to the transformation process.\"\n    )\n    created: Optional[datetime] = Field(\n        None,\n        description=\"Time of creation for the transformation process. Given in UTC.\",\n    )\n    startTime: Optional[datetime] = Field(\n        None, description=\"Time when the transformation process started. Given in UTC.\"\n    )\n    finishTime: Optional[datetime] = Field(\n        None, description=\"Time when the tranformation process finished. Given in UTC.\"\n    )\n</code></pre>"},{"location":"all_models/#oteapi.models.TransformationStatus.created","title":"<code>created: Optional[datetime] = Field(None, description='Time of creation for the transformation process. Given in UTC.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_models/#oteapi.models.TransformationStatus.finishTime","title":"<code>finishTime: Optional[datetime] = Field(None, description='Time when the tranformation process finished. Given in UTC.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_models/#oteapi.models.TransformationStatus.id","title":"<code>id: str = Field(..., description='ID for the given transformation process.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_models/#oteapi.models.TransformationStatus.messages","title":"<code>messages: Optional[List[str]] = Field(None, description='Messages related to the transformation process.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_models/#oteapi.models.TransformationStatus.startTime","title":"<code>startTime: Optional[datetime] = Field(None, description='Time when the transformation process started. Given in UTC.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_models/#oteapi.models.TransformationStatus.status","title":"<code>status: Optional[str] = Field(None, description='Status for the transformation process.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_models/#oteapi.models.TripleStoreConfig","title":"<code>TripleStoreConfig</code>","text":"<p>             Bases: <code>GenericConfig</code>, <code>SecretConfig</code></p> <p>TripleStore Configuration.</p> <p>This is a configuration for the <code>TripleStore</code>.</p> <p>This class should not be used directly as a configuration object for a strategy object, but only as a configuration field inside a configuration object.</p> Source code in <code>oteapi/models/triplestoreconfig.py</code> <pre><code>class TripleStoreConfig(GenericConfig, SecretConfig):\n\"\"\"TripleStore Configuration.\n\n    This is a configuration for the\n    [`TripleStore`][oteapi.triplestore.triplestore.TripleStore].\n\n    This class should not be used directly as a configuration object\n    for a strategy object, but only as a configuration field inside\n    a configuration object.\n    \"\"\"\n\n    repositoryName: str = Field(\n        ..., description=\"The repository name, where the mappings are stored.\"\n    )\n    agraphHost: str = Field(\n        ...,\n        description=\"AllegroGraph host name.\",\n    )\n    agraphPort: int = Field(\n        ...,\n        description=\"AllegroGraph port number.\",\n    )\n\n    @root_validator\n    def ensure_user_pass(cls, values: \"Dict[str, Any]\") -&gt; \"Dict[str, Any]\":\n\"\"\"Ensure that user/password are set, since they are optional in the\n        SecretConfig.\"\"\"\n        if not all(values.get(_) for _ in [\"user\", \"password\"]):\n            raise ValueError(\"User and password must be defined.\")\n        return values\n\n    class Config:\n\"\"\"Pydantic configuration for TripleStoreConfig.\"\"\"\n\n        fields = {\n            \"token\": {\"exclude\": True},\n            \"client_id\": {\"exclude\": True},\n            \"client_secret\": {\"exclude\": True},\n        }\n\"\"\"The `fields`-config enables that `token`, `client_id` and `client_secret`\n        will be excluded, when the model is serialized.\"\"\"\n</code></pre>"},{"location":"all_models/#oteapi.models.TripleStoreConfig.agraphHost","title":"<code>agraphHost: str = Field(..., description='AllegroGraph host name.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_models/#oteapi.models.TripleStoreConfig.agraphPort","title":"<code>agraphPort: int = Field(..., description='AllegroGraph port number.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_models/#oteapi.models.TripleStoreConfig.repositoryName","title":"<code>repositoryName: str = Field(..., description='The repository name, where the mappings are stored.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_models/#oteapi.models.TripleStoreConfig.Config","title":"<code>Config</code>","text":"<p>Pydantic configuration for TripleStoreConfig.</p> Source code in <code>oteapi/models/triplestoreconfig.py</code> <pre><code>class Config:\n\"\"\"Pydantic configuration for TripleStoreConfig.\"\"\"\n\n    fields = {\n        \"token\": {\"exclude\": True},\n        \"client_id\": {\"exclude\": True},\n        \"client_secret\": {\"exclude\": True},\n    }\n\"\"\"The `fields`-config enables that `token`, `client_id` and `client_secret`\n    will be excluded, when the model is serialized.\"\"\"\n</code></pre>"},{"location":"all_models/#oteapi.models.TripleStoreConfig.Config.fields","title":"<code>fields = {'token': {'exclude': True}, 'client_id': {'exclude': True}, 'client_secret': {'exclude': True}}</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The <code>fields</code>-config enables that <code>token</code>, <code>client_id</code> and <code>client_secret</code> will be excluded, when the model is serialized.</p>"},{"location":"all_models/#oteapi.models.TripleStoreConfig.ensure_user_pass","title":"<code>ensure_user_pass(values)</code>","text":"<p>Ensure that user/password are set, since they are optional in the SecretConfig.</p> Source code in <code>oteapi/models/triplestoreconfig.py</code> <pre><code>@root_validator\ndef ensure_user_pass(cls, values: \"Dict[str, Any]\") -&gt; \"Dict[str, Any]\":\n\"\"\"Ensure that user/password are set, since they are optional in the\n    SecretConfig.\"\"\"\n    if not all(values.get(_) for _ in [\"user\", \"password\"]):\n        raise ValueError(\"User and password must be defined.\")\n    return values\n</code></pre>"},{"location":"all_models/#oteapi.models.datacacheconfig","title":"<code>datacacheconfig</code>","text":"<p>Pydantic DataCache Configuration Data Model.</p>"},{"location":"all_models/#oteapi.models.datacacheconfig.DataCacheConfig","title":"<code>DataCacheConfig</code>","text":"<p>             Bases: <code>AttrDict</code></p> <p>DataCache Configuration.</p> <p>This class should not be used directly as a configuration object for a strategy object, but only as a configuration field inside a configuration object.</p> Source code in <code>oteapi/models/datacacheconfig.py</code> <pre><code>class DataCacheConfig(AttrDict):\n\"\"\"DataCache Configuration.\n\n    This class should not be used directly as a configuration object\n    for a strategy object, but only as a configuration field inside\n    a configuration object.\n    \"\"\"\n\n    cacheDir: Path = Field(Path(\"oteapi\"), description=\"Cache directory.\")\n    accessKey: Optional[str] = Field(\n        None,\n        description=\"Key with which the downloaded content can be accessed. \"\n        \"Should preferable be the hash (corresponding to `hashType`) of the \"\n        \"content if it is known.\",\n    )\n    hashType: str = Field(\n        \"md5\",\n        description=\"Hash algorithm to use for creating hash keys for stored \"\n        \"data. Can be any algorithm supported by hashlib.\",\n    )\n    expireTime: int = Field(\n        3600 * 24 * 14,\n        description=\"Number of seconds before the cache entry expires. \"\n        \"Zero means no expiration. Default is two weeks.\",\n    )\n    tag: Optional[str] = Field(\n        None,\n        description=\"Tag assigned to the downloaded content, typically \"\n        \"identifying a session. Used with the `evict()` method to clean up a \"\n        \"all cache entries with a given tag.\",\n    )\n</code></pre>"},{"location":"all_models/#oteapi.models.datacacheconfig.DataCacheConfig.accessKey","title":"<code>accessKey: Optional[str] = Field(None, description='Key with which the downloaded content can be accessed. Should preferable be the hash (corresponding to `hashType`) of the content if it is known.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_models/#oteapi.models.datacacheconfig.DataCacheConfig.cacheDir","title":"<code>cacheDir: Path = Field(Path('oteapi'), description='Cache directory.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_models/#oteapi.models.datacacheconfig.DataCacheConfig.expireTime","title":"<code>expireTime: int = Field(3600 * 24 * 14, description='Number of seconds before the cache entry expires. Zero means no expiration. Default is two weeks.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_models/#oteapi.models.datacacheconfig.DataCacheConfig.hashType","title":"<code>hashType: str = Field('md5', description='Hash algorithm to use for creating hash keys for stored data. Can be any algorithm supported by hashlib.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_models/#oteapi.models.datacacheconfig.DataCacheConfig.tag","title":"<code>tag: Optional[str] = Field(None, description='Tag assigned to the downloaded content, typically identifying a session. Used with the `evict()` method to clean up a all cache entries with a given tag.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_models/#oteapi.models.filterconfig","title":"<code>filterconfig</code>","text":"<p>Pydantic Filter Configuration Data Model.</p>"},{"location":"all_models/#oteapi.models.filterconfig.FilterConfig","title":"<code>FilterConfig</code>","text":"<p>             Bases: <code>GenericConfig</code></p> <p>Filter Strategy Data Configuration.</p> Source code in <code>oteapi/models/filterconfig.py</code> <pre><code>class FilterConfig(GenericConfig):\n\"\"\"Filter Strategy Data Configuration.\"\"\"\n\n    filterType: str = Field(\n        ..., description=\"Type of registered filter strategy. E.g., `filter/sql`.\"\n    )\n    query: Optional[str] = Field(None, description=\"Define a query operation.\")\n    condition: Optional[str] = Field(\n        None,\n        description=\"Logical statement indicating when a filter should be applied.\",\n    )\n    limit: Optional[int] = Field(\n        None, description=\"Number of items remaining after a filter expression.\"\n    )\n</code></pre>"},{"location":"all_models/#oteapi.models.filterconfig.FilterConfig.condition","title":"<code>condition: Optional[str] = Field(None, description='Logical statement indicating when a filter should be applied.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_models/#oteapi.models.filterconfig.FilterConfig.filterType","title":"<code>filterType: str = Field(..., description='Type of registered filter strategy. E.g., `filter/sql`.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_models/#oteapi.models.filterconfig.FilterConfig.limit","title":"<code>limit: Optional[int] = Field(None, description='Number of items remaining after a filter expression.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_models/#oteapi.models.filterconfig.FilterConfig.query","title":"<code>query: Optional[str] = Field(None, description='Define a query operation.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_models/#oteapi.models.functionconfig","title":"<code>functionconfig</code>","text":"<p>Pydantic Function Configuration Data Model.</p>"},{"location":"all_models/#oteapi.models.functionconfig.FunctionConfig","title":"<code>FunctionConfig</code>","text":"<p>             Bases: <code>GenericConfig</code>, <code>SecretConfig</code></p> <p>Function Strategy Data Configuration.</p> Source code in <code>oteapi/models/functionconfig.py</code> <pre><code>class FunctionConfig(GenericConfig, SecretConfig):\n\"\"\"Function Strategy Data Configuration.\"\"\"\n\n    functionType: str = Field(\n        ...,\n        description=(\"Type of registered function strategy.\"),\n    )\n</code></pre>"},{"location":"all_models/#oteapi.models.functionconfig.FunctionConfig.functionType","title":"<code>functionType: str = Field(..., description='Type of registered function strategy.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_models/#oteapi.models.genericconfig","title":"<code>genericconfig</code>","text":"<p>Generic data model for configuration attributes.</p>"},{"location":"all_models/#oteapi.models.genericconfig.AttrDict","title":"<code>AttrDict</code>","text":"<p>             Bases: <code>BaseModel</code>, <code>Mapping</code></p> <p>An object whose attributes can also be accessed through subscription, like with a dictionary.</p> Source code in <code>oteapi/models/genericconfig.py</code> <pre><code>class AttrDict(BaseModel, Mapping):\n\"\"\"An object whose attributes can also be accessed through\n    subscription, like with a dictionary.\"\"\"\n\n    def __contains__(self, name: \"Any\") -&gt; bool:\n\"\"\"Enable using the 'in' operator on this object.\"\"\"\n        return self.__dict__.__contains__(name)\n\n    def __delitem__(self, key: str) -&gt; None:\n\"\"\"Enable deletion access through subscription.\n\n        If the item is a pydantic field, reset it and remove it from the set of set\n        fields. Otherwise, delete the attribute.\n\n        \"\"\"\n        if key in self.__dict__:\n            if key in self.__fields__:\n                # Reset field to default and remove from set of set fields\n                setattr(self, key, self.__fields__[key].default)\n                self.__fields_set__.remove(key)\n            else:\n                self.__delattr__(key)\n        else:\n            raise KeyError(key)\n\n    def __getitem__(self, key: str) -&gt; \"Any\":\n\"\"\"Enable read access through subscription.\"\"\"\n        if key in self.__dict__:\n            return getattr(self, key)\n        raise KeyError(key)\n\n    def __setitem__(self, key: str, value: \"Any\") -&gt; None:\n\"\"\"Enable write access through subscription.\"\"\"\n        setattr(self, key, value)\n\n    def __len__(self):\n\"\"\"Return number of items.\"\"\"\n        return self.__dict__.__len__()\n\n    def __iter__(self):\n\"\"\"Enable **unpacking.\"\"\"\n        return self.__dict__.__iter__()\n\n    def items(self):\n\"\"\"Return a view of all (key, value) pairs.\"\"\"\n        return self.__dict__.items()\n\n    def keys(self):\n\"\"\"Return a view of all keys.\"\"\"\n        return self.__dict__.keys()\n\n    def values(self):\n\"\"\"Return a view of all values.\"\"\"\n        return self.__dict__.values()\n\n    def get(self, key: str, default: \"Optional[Any]\" = None) -&gt; \"Any\":\n\"\"\"Mapping `get`-method.\"\"\"\n        return self.__dict__.get(key, default)\n\n    def __ne__(self, other: \"Any\") -&gt; bool:\n\"\"\"Implement the != operator.\"\"\"\n        if isinstance(other, BaseModel):\n            return self.dict() != other.dict()\n        return self.dict() != other\n\n    def update(\n        self, other: \"Optional[Union[dict, AttrDict, Iterable[Any]]]\" = None, **kwargs\n    ) -&gt; None:\n\"\"\"MutableMapping `update`-method.\"\"\"\n        if other and isinstance(other, (dict, Mapping)):\n            for key, value in other.items():\n                setattr(self, key, value)\n        elif other and isinstance(other, BaseModel):\n            for key, value in other.dict().items():\n                setattr(self, key, value)\n        elif other and isinstance(other, Iterable):\n            for entry in other:\n                if not len(entry) == 2:\n                    raise ValueError(\n                        \"`other` must be an iterable of objects of length two.\"\n                    )\n            for key, value in other:\n                setattr(self, key, value)\n        if kwargs:\n            for key, value in kwargs.items():\n                setattr(self, key, value)\n\n    def pop(self, key: str, default: \"Optional[Any]\" = Undefined) -&gt; \"Any\":\n\"\"\"MutableMapping `pop`-method.\"\"\"\n        value = self.get(key, default)\n        if value == Undefined:\n            raise KeyError(key)\n        if key in self:\n            del self[key]\n        return value\n\n    def popitem(self) -&gt; \"Tuple[str, Any]\":\n\"\"\"MutableMapping `popitem`-method.\n\n        Important:\n            Unlike the regular `dict.popitem()` method, this one does _not_ respect\n            LIFO (last-in, first-out).\n            This is due to the fact that attributes are stored in a random order when\n            initializing the model.\n\n            However, it will respect LIFO with respect to the internal `__dict__`.\n\n        \"\"\"\n        if not self:\n            raise KeyError(f\"popitem(): {self.__class__.__name__} is empty\")\n\n        key = list(self.__dict__)[-1]\n        value = self.pop(key)\n        return key, value\n\n    class Config:\n\"\"\"Pydantic configuration for `AttrDict`.\n\n        * **`extra`**\n          Allow any attributes/fields to be defined - this is what makes this pydantic\n          model an attribute dictionary.\n        * **`validate_assignment`**\n          Validate and cast set values.\n          This is mainly relevant for sub-classes of `AttrDict`, where specific\n          attributes have been defined.\n        * **`arbitrary_types_allowed`**\n          If a custom type is used for an attribute that doesn't have a `validate()`\n          method, don't fail setting the attribute.\n\n        \"\"\"\n\n        extra = \"allow\"\n        validate_assignment = True\n        arbitrary_types_allowed = True\n</code></pre>"},{"location":"all_models/#oteapi.models.genericconfig.AttrDict.Config","title":"<code>Config</code>","text":"<p>Pydantic configuration for <code>AttrDict</code>.</p> <ul> <li><code>extra</code>   Allow any attributes/fields to be defined - this is what makes this pydantic   model an attribute dictionary.</li> <li><code>validate_assignment</code>   Validate and cast set values.   This is mainly relevant for sub-classes of <code>AttrDict</code>, where specific   attributes have been defined.</li> <li><code>arbitrary_types_allowed</code>   If a custom type is used for an attribute that doesn't have a <code>validate()</code>   method, don't fail setting the attribute.</li> </ul> Source code in <code>oteapi/models/genericconfig.py</code> <pre><code>class Config:\n\"\"\"Pydantic configuration for `AttrDict`.\n\n    * **`extra`**\n      Allow any attributes/fields to be defined - this is what makes this pydantic\n      model an attribute dictionary.\n    * **`validate_assignment`**\n      Validate and cast set values.\n      This is mainly relevant for sub-classes of `AttrDict`, where specific\n      attributes have been defined.\n    * **`arbitrary_types_allowed`**\n      If a custom type is used for an attribute that doesn't have a `validate()`\n      method, don't fail setting the attribute.\n\n    \"\"\"\n\n    extra = \"allow\"\n    validate_assignment = True\n    arbitrary_types_allowed = True\n</code></pre>"},{"location":"all_models/#oteapi.models.genericconfig.AttrDict.Config.arbitrary_types_allowed","title":"<code>arbitrary_types_allowed = True</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_models/#oteapi.models.genericconfig.AttrDict.Config.extra","title":"<code>extra = 'allow'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_models/#oteapi.models.genericconfig.AttrDict.Config.validate_assignment","title":"<code>validate_assignment = True</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_models/#oteapi.models.genericconfig.AttrDict.get","title":"<code>get(key, default=None)</code>","text":"<p>Mapping <code>get</code>-method.</p> Source code in <code>oteapi/models/genericconfig.py</code> <pre><code>def get(self, key: str, default: \"Optional[Any]\" = None) -&gt; \"Any\":\n\"\"\"Mapping `get`-method.\"\"\"\n    return self.__dict__.get(key, default)\n</code></pre>"},{"location":"all_models/#oteapi.models.genericconfig.AttrDict.items","title":"<code>items()</code>","text":"<p>Return a view of all (key, value) pairs.</p> Source code in <code>oteapi/models/genericconfig.py</code> <pre><code>def items(self):\n\"\"\"Return a view of all (key, value) pairs.\"\"\"\n    return self.__dict__.items()\n</code></pre>"},{"location":"all_models/#oteapi.models.genericconfig.AttrDict.keys","title":"<code>keys()</code>","text":"<p>Return a view of all keys.</p> Source code in <code>oteapi/models/genericconfig.py</code> <pre><code>def keys(self):\n\"\"\"Return a view of all keys.\"\"\"\n    return self.__dict__.keys()\n</code></pre>"},{"location":"all_models/#oteapi.models.genericconfig.AttrDict.pop","title":"<code>pop(key, default=Undefined)</code>","text":"<p>MutableMapping <code>pop</code>-method.</p> Source code in <code>oteapi/models/genericconfig.py</code> <pre><code>def pop(self, key: str, default: \"Optional[Any]\" = Undefined) -&gt; \"Any\":\n\"\"\"MutableMapping `pop`-method.\"\"\"\n    value = self.get(key, default)\n    if value == Undefined:\n        raise KeyError(key)\n    if key in self:\n        del self[key]\n    return value\n</code></pre>"},{"location":"all_models/#oteapi.models.genericconfig.AttrDict.popitem","title":"<code>popitem()</code>","text":"<p>MutableMapping <code>popitem</code>-method.</p> Important <p>Unlike the regular <code>dict.popitem()</code> method, this one does not respect LIFO (last-in, first-out). This is due to the fact that attributes are stored in a random order when initializing the model.</p> <p>However, it will respect LIFO with respect to the internal <code>__dict__</code>.</p> Source code in <code>oteapi/models/genericconfig.py</code> <pre><code>def popitem(self) -&gt; \"Tuple[str, Any]\":\n\"\"\"MutableMapping `popitem`-method.\n\n    Important:\n        Unlike the regular `dict.popitem()` method, this one does _not_ respect\n        LIFO (last-in, first-out).\n        This is due to the fact that attributes are stored in a random order when\n        initializing the model.\n\n        However, it will respect LIFO with respect to the internal `__dict__`.\n\n    \"\"\"\n    if not self:\n        raise KeyError(f\"popitem(): {self.__class__.__name__} is empty\")\n\n    key = list(self.__dict__)[-1]\n    value = self.pop(key)\n    return key, value\n</code></pre>"},{"location":"all_models/#oteapi.models.genericconfig.AttrDict.update","title":"<code>update(other=None, **kwargs)</code>","text":"<p>MutableMapping <code>update</code>-method.</p> Source code in <code>oteapi/models/genericconfig.py</code> <pre><code>def update(\n    self, other: \"Optional[Union[dict, AttrDict, Iterable[Any]]]\" = None, **kwargs\n) -&gt; None:\n\"\"\"MutableMapping `update`-method.\"\"\"\n    if other and isinstance(other, (dict, Mapping)):\n        for key, value in other.items():\n            setattr(self, key, value)\n    elif other and isinstance(other, BaseModel):\n        for key, value in other.dict().items():\n            setattr(self, key, value)\n    elif other and isinstance(other, Iterable):\n        for entry in other:\n            if not len(entry) == 2:\n                raise ValueError(\n                    \"`other` must be an iterable of objects of length two.\"\n                )\n        for key, value in other:\n            setattr(self, key, value)\n    if kwargs:\n        for key, value in kwargs.items():\n            setattr(self, key, value)\n</code></pre>"},{"location":"all_models/#oteapi.models.genericconfig.AttrDict.values","title":"<code>values()</code>","text":"<p>Return a view of all values.</p> Source code in <code>oteapi/models/genericconfig.py</code> <pre><code>def values(self):\n\"\"\"Return a view of all values.\"\"\"\n    return self.__dict__.values()\n</code></pre>"},{"location":"all_models/#oteapi.models.genericconfig.GenericConfig","title":"<code>GenericConfig</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>Generic class for configuration objects.</p> Source code in <code>oteapi/models/genericconfig.py</code> <pre><code>class GenericConfig(BaseModel):\n\"\"\"Generic class for configuration objects.\"\"\"\n\n    configuration: AttrDict = Field(\n        AttrDict(),\n        description=\"Model-specific configuration options which can either \"\n        \"be given as key/value-pairs or set as attributes.\",\n    )\n\n    description: str = Field(\n        __doc__,\n        description=\"A description of the configuration model.\",\n    )\n\n    @classmethod\n    def __init_subclass__(cls) -&gt; None:\n\"\"\"Initialize subclass descriptions with their docstrings.\"\"\"\n        cls.__fields__[\"description\"].default = cls.__doc__\n\n    class Config:\n\"\"\"Pydantic configuration for `GenericConfig`.\n\n        * **`validate_assignment`**\n          Validate and cast set values.\n          This is mainly relevant for sub-classes of `AttrDict`, where specific\n          attributes have been defined.\n        * **`arbitrary_types_allowed`**\n          If a custom type is used for an attribute that doesn't have a `validate()`\n          method, don't fail setting the attribute.\n\n        \"\"\"\n\n        validate_assignment = True\n        arbitrary_types_allowed = True\n</code></pre>"},{"location":"all_models/#oteapi.models.genericconfig.GenericConfig.configuration","title":"<code>configuration: AttrDict = Field(AttrDict(), description='Model-specific configuration options which can either be given as key/value-pairs or set as attributes.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_models/#oteapi.models.genericconfig.GenericConfig.description","title":"<code>description: str = Field(__doc__, description='A description of the configuration model.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_models/#oteapi.models.genericconfig.GenericConfig.Config","title":"<code>Config</code>","text":"<p>Pydantic configuration for <code>GenericConfig</code>.</p> <ul> <li><code>validate_assignment</code>   Validate and cast set values.   This is mainly relevant for sub-classes of <code>AttrDict</code>, where specific   attributes have been defined.</li> <li><code>arbitrary_types_allowed</code>   If a custom type is used for an attribute that doesn't have a <code>validate()</code>   method, don't fail setting the attribute.</li> </ul> Source code in <code>oteapi/models/genericconfig.py</code> <pre><code>class Config:\n\"\"\"Pydantic configuration for `GenericConfig`.\n\n    * **`validate_assignment`**\n      Validate and cast set values.\n      This is mainly relevant for sub-classes of `AttrDict`, where specific\n      attributes have been defined.\n    * **`arbitrary_types_allowed`**\n      If a custom type is used for an attribute that doesn't have a `validate()`\n      method, don't fail setting the attribute.\n\n    \"\"\"\n\n    validate_assignment = True\n    arbitrary_types_allowed = True\n</code></pre>"},{"location":"all_models/#oteapi.models.genericconfig.GenericConfig.Config.arbitrary_types_allowed","title":"<code>arbitrary_types_allowed = True</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_models/#oteapi.models.genericconfig.GenericConfig.Config.validate_assignment","title":"<code>validate_assignment = True</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_models/#oteapi.models.mappingconfig","title":"<code>mappingconfig</code>","text":"<p>Pydantic Mapping Configuration Data Model.</p>"},{"location":"all_models/#oteapi.models.mappingconfig.RDFTriple","title":"<code>RDFTriple = Tuple[str, str, str]</code>  <code>module-attribute</code>","text":""},{"location":"all_models/#oteapi.models.mappingconfig.MappingConfig","title":"<code>MappingConfig</code>","text":"<p>             Bases: <code>GenericConfig</code></p> <p>Mapping Strategy Data Configuration.</p> Source code in <code>oteapi/models/mappingconfig.py</code> <pre><code>class MappingConfig(GenericConfig):\n\"\"\"Mapping Strategy Data Configuration.\"\"\"\n\n    mappingType: str = Field(\n        ...,\n        description=\"Type of registered mapping strategy.\",\n    )\n    prefixes: Optional[Dict[str, str]] = Field(\n        None,\n        description=(\n            \"Dictionary of shortnames that expands to an IRI given as local \"\n            \"value/IRI-expansion-pairs.\"\n        ),\n    )\n    triples: Optional[Set[RDFTriple]] = Field(\n        None,\n        description=\"Set of RDF triples given as (subject, predicate, object).\",\n    )\n</code></pre>"},{"location":"all_models/#oteapi.models.mappingconfig.MappingConfig.mappingType","title":"<code>mappingType: str = Field(..., description='Type of registered mapping strategy.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_models/#oteapi.models.mappingconfig.MappingConfig.prefixes","title":"<code>prefixes: Optional[Dict[str, str]] = Field(None, description='Dictionary of shortnames that expands to an IRI given as local value/IRI-expansion-pairs.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_models/#oteapi.models.mappingconfig.MappingConfig.triples","title":"<code>triples: Optional[Set[RDFTriple]] = Field(None, description='Set of RDF triples given as (subject, predicate, object).')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_models/#oteapi.models.parserconfig","title":"<code>parserconfig</code>","text":"<p>Pydantic Parser Configuration Data Model.</p>"},{"location":"all_models/#oteapi.models.parserconfig.ParserConfig","title":"<code>ParserConfig</code>","text":"<p>             Bases: <code>GenericConfig</code></p> <p>Parser Strategy Data Configuration.</p> Source code in <code>oteapi/models/parserconfig.py</code> <pre><code>class ParserConfig(GenericConfig):\n\"\"\"Parser Strategy Data Configuration.\"\"\"\n\n    parserType: str = Field(..., description=\"Type of registered parser strategy.\")\n</code></pre>"},{"location":"all_models/#oteapi.models.parserconfig.ParserConfig.parserType","title":"<code>parserType: str = Field(..., description='Type of registered parser strategy.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_models/#oteapi.models.resourceconfig","title":"<code>resourceconfig</code>","text":"<p>Pydantic Resource Configuration Data Model.</p>"},{"location":"all_models/#oteapi.models.resourceconfig.HostlessAnyUrl","title":"<code>HostlessAnyUrl</code>","text":"<p>             Bases: <code>AnyUrl</code></p> <p>AnyUrl, but allow not having a host.</p> Source code in <code>oteapi/models/resourceconfig.py</code> <pre><code>class HostlessAnyUrl(AnyUrl):\n\"\"\"AnyUrl, but allow not having a host.\"\"\"\n\n    host_required = False\n</code></pre>"},{"location":"all_models/#oteapi.models.resourceconfig.HostlessAnyUrl.host_required","title":"<code>host_required = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_models/#oteapi.models.resourceconfig.ResourceConfig","title":"<code>ResourceConfig</code>","text":"<p>             Bases: <code>GenericConfig</code>, <code>SecretConfig</code></p> <p>Resource Strategy Data Configuration.</p> Important <p>Either of the pairs of attributes <code>downloadUrl</code>/<code>mediaType</code> or <code>accessUrl</code>/<code>accessService</code> MUST be specified.</p> Source code in <code>oteapi/models/resourceconfig.py</code> <pre><code>class ResourceConfig(GenericConfig, SecretConfig):\n\"\"\"Resource Strategy Data Configuration.\n\n    Important:\n        Either of the pairs of attributes `downloadUrl`/`mediaType` or\n        `accessUrl`/`accessService` MUST be specified.\n\n    \"\"\"\n\n    downloadUrl: Optional[HostlessAnyUrl] = Field(\n        None,\n        description=(\n            \"Definition: The URL of the downloadable file in a given format. E.g. CSV \"\n            \"file or RDF file.\\n\\nUsage: `downloadURL` *SHOULD* be used for the URL at\"\n            \" which this distribution is available directly, typically through a HTTPS\"\n            \" GET request or SFTP.\"\n        ),\n    )\n    mediaType: Optional[str] = Field(\n        None,\n        description=(\n            \"The media type of the distribution as defined by IANA \"\n            \"[[IANA-MEDIA-TYPES](https://www.w3.org/TR/vocab-dcat-2/#bib-iana-media-types)]\"\n            \".\\n\\nUsage: This property *SHOULD* be used when the media\"\n            \" type of the distribution is defined in IANA \"\n            \"[[IANA-MEDIA-TYPES](https://www.w3.org/TR/vocab-dcat-2/#bib-iana-media-types)].\"\n        ),\n    )\n    accessUrl: Optional[HostlessAnyUrl] = Field(\n        None,\n        description=(\n            \"A URL of the resource that gives access to a distribution of \"\n            \"the dataset. E.g. landing page, feed, SPARQL endpoint.\\n\\nUsage: \"\n            \"`accessURL` *SHOULD* be used for the URL of a service or location that \"\n            \"can provide access to this distribution, typically through a Web form, \"\n            \"query or API call.\\n`downloadURL` is preferred for direct links to \"\n            \"downloadable resources.\"\n        ),\n    )\n    accessService: Optional[str] = Field(\n        None,\n        description=(\n            \"A data service that gives access to the distribution of the dataset.\"\n        ),\n    )\n    license: Optional[str] = Field(\n        None,\n        description=(\n            \"A legal document under which the distribution is made available.\"\n        ),\n    )\n    accessRights: Optional[str] = Field(\n        None,\n        description=(\n            \"A rights statement that concerns how the distribution is accessed.\"\n        ),\n    )\n    publisher: Optional[str] = Field(\n        None,\n        description=\"The entity responsible for making the resource/item available.\",\n    )\n\n    @root_validator\n    def ensure_unique_url_pairs(cls, values: \"Dict[str, Any]\") -&gt; \"Dict[str, Any]\":\n\"\"\"Ensure either downloadUrl/mediaType or accessUrl/accessService are defined.\n\n        It's fine to define them all, but at least one complete pair MUST be specified.\n        \"\"\"\n        if not (\n            all(values.get(_) for _ in [\"downloadUrl\", \"mediaType\"])\n            or all(values.get(_) for _ in [\"accessUrl\", \"accessService\"])\n        ):\n            raise ValueError(\n                \"Either of the pairs of attributes downloadUrl/mediaType or \"\n                \"accessUrl/accessService MUST be specified.\"\n            )\n        return values\n</code></pre>"},{"location":"all_models/#oteapi.models.resourceconfig.ResourceConfig.accessRights","title":"<code>accessRights: Optional[str] = Field(None, description='A rights statement that concerns how the distribution is accessed.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_models/#oteapi.models.resourceconfig.ResourceConfig.accessService","title":"<code>accessService: Optional[str] = Field(None, description='A data service that gives access to the distribution of the dataset.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_models/#oteapi.models.resourceconfig.ResourceConfig.accessUrl","title":"<code>accessUrl: Optional[HostlessAnyUrl] = Field(None, description='A URL of the resource that gives access to a distribution of the dataset. E.g. landing page, feed, SPARQL endpoint.\\n\\nUsage: `accessURL` *SHOULD* be used for the URL of a service or location that can provide access to this distribution, typically through a Web form, query or API call.\\n`downloadURL` is preferred for direct links to downloadable resources.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_models/#oteapi.models.resourceconfig.ResourceConfig.downloadUrl","title":"<code>downloadUrl: Optional[HostlessAnyUrl] = Field(None, description='Definition: The URL of the downloadable file in a given format. E.g. CSV file or RDF file.\\n\\nUsage: `downloadURL` *SHOULD* be used for the URL at which this distribution is available directly, typically through a HTTPS GET request or SFTP.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_models/#oteapi.models.resourceconfig.ResourceConfig.license","title":"<code>license: Optional[str] = Field(None, description='A legal document under which the distribution is made available.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_models/#oteapi.models.resourceconfig.ResourceConfig.mediaType","title":"<code>mediaType: Optional[str] = Field(None, description='The media type of the distribution as defined by IANA [[IANA-MEDIA-TYPES](https://www.w3.org/TR/vocab-dcat-2/#bib-iana-media-types)].\\n\\nUsage: This property *SHOULD* be used when the media type of the distribution is defined in IANA [[IANA-MEDIA-TYPES](https://www.w3.org/TR/vocab-dcat-2/#bib-iana-media-types)].')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_models/#oteapi.models.resourceconfig.ResourceConfig.publisher","title":"<code>publisher: Optional[str] = Field(None, description='The entity responsible for making the resource/item available.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_models/#oteapi.models.resourceconfig.ResourceConfig.ensure_unique_url_pairs","title":"<code>ensure_unique_url_pairs(values)</code>","text":"<p>Ensure either downloadUrl/mediaType or accessUrl/accessService are defined.</p> <p>It's fine to define them all, but at least one complete pair MUST be specified.</p> Source code in <code>oteapi/models/resourceconfig.py</code> <pre><code>@root_validator\ndef ensure_unique_url_pairs(cls, values: \"Dict[str, Any]\") -&gt; \"Dict[str, Any]\":\n\"\"\"Ensure either downloadUrl/mediaType or accessUrl/accessService are defined.\n\n    It's fine to define them all, but at least one complete pair MUST be specified.\n    \"\"\"\n    if not (\n        all(values.get(_) for _ in [\"downloadUrl\", \"mediaType\"])\n        or all(values.get(_) for _ in [\"accessUrl\", \"accessService\"])\n    ):\n        raise ValueError(\n            \"Either of the pairs of attributes downloadUrl/mediaType or \"\n            \"accessUrl/accessService MUST be specified.\"\n        )\n    return values\n</code></pre>"},{"location":"all_models/#oteapi.models.secretconfig","title":"<code>secretconfig</code>","text":"<p>AttrDict for specifying user credentials or secrets.</p>"},{"location":"all_models/#oteapi.models.secretconfig.SecretConfig","title":"<code>SecretConfig</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>Simple model for handling secret in other config-models.</p> Source code in <code>oteapi/models/secretconfig.py</code> <pre><code>class SecretConfig(BaseModel, json_dumps=json_dumps):\n\"\"\"Simple model for handling secret in other config-models.\"\"\"\n\n    user: Optional[SecretStr] = Field(None, description=\"User name for authentication.\")\n    password: Optional[SecretStr] = Field(\n        None, description=\"Password for authentication.\"\n    )\n    token: Optional[SecretStr] = Field(\n        None,\n        description=(\n            \"An access token for providing access and meta data to an application.\"\n        ),\n    )\n    client_id: Optional[SecretStr] = Field(\n        None, description=\"Client ID for an OAUTH2 client.\"\n    )\n    client_secret: Optional[SecretStr] = Field(\n        None, description=\"Client secret for an OAUTH2 client.\"\n    )\n</code></pre>"},{"location":"all_models/#oteapi.models.secretconfig.SecretConfig.client_id","title":"<code>client_id: Optional[SecretStr] = Field(None, description='Client ID for an OAUTH2 client.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_models/#oteapi.models.secretconfig.SecretConfig.client_secret","title":"<code>client_secret: Optional[SecretStr] = Field(None, description='Client secret for an OAUTH2 client.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_models/#oteapi.models.secretconfig.SecretConfig.password","title":"<code>password: Optional[SecretStr] = Field(None, description='Password for authentication.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_models/#oteapi.models.secretconfig.SecretConfig.token","title":"<code>token: Optional[SecretStr] = Field(None, description='An access token for providing access and meta data to an application.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_models/#oteapi.models.secretconfig.SecretConfig.user","title":"<code>user: Optional[SecretStr] = Field(None, description='User name for authentication.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_models/#oteapi.models.secretconfig.json_dumps","title":"<code>json_dumps(model, default)</code>","text":"<p>Alternative function for dumping exposed secrets to json when model is serialized.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>dict</code> <p>The pydantic model to serialize.</p> required <code>default</code> <code>Callable[[Any], Any]</code> <p>A pass-through to the standard <code>json.dumps()</code>'s <code>default</code> parameter. From the <code>json.dumps()</code> doc-string: <code>default(obj)</code> is a function that should return a serializable version of <code>obj</code> or raise <code>TypeError</code>. The default simply raises <code>TypeError</code>.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The result of <code>json.dumps()</code> after handling possible secrets.</p> Source code in <code>oteapi/models/secretconfig.py</code> <pre><code>def json_dumps(model: dict, default: \"Callable[[Any], Any]\") -&gt; \"str\":\n\"\"\"Alternative function for dumping exposed\n    secrets to json when model is serialized.\n\n    Parameters:\n        model: The pydantic model to serialize.\n        default: A pass-through to the standard `json.dumps()`'s `default` parameter.\n            From the `json.dumps()` doc-string: `default(obj)` is a function that should\n            return a serializable version of `obj` or raise `TypeError`.\n            The default simply raises `TypeError`.\n\n    Returns:\n        The result of `json.dumps()` after handling possible secrets.\n\n    \"\"\"\n    return json.dumps(\n        {\n            key: (\n                value.get_secret_value()\n                if settings.expose_secrets and isinstance(value, SecretStr)\n                else value\n            )\n            for key, value in model.items()\n        },\n        default=default,\n    )\n</code></pre>"},{"location":"all_models/#oteapi.models.sessionupdate","title":"<code>sessionupdate</code>","text":"<p>Pydantic SessionUpdate Data Model.</p>"},{"location":"all_models/#oteapi.models.sessionupdate.SessionUpdate","title":"<code>SessionUpdate</code>","text":"<p>             Bases: <code>AttrDict</code></p> <p>Session Update Data Model for returning values.</p> Source code in <code>oteapi/models/sessionupdate.py</code> <pre><code>class SessionUpdate(AttrDict):\n\"\"\"Session Update Data Model for returning values.\"\"\"\n</code></pre>"},{"location":"all_models/#oteapi.models.transformationconfig","title":"<code>transformationconfig</code>","text":"<p>Pydantic Transformation Configuration Data Model.</p> <p>A transformation status data model is provided as well. This data model represents what should be returned from the strategy's <code>status()</code> method.</p>"},{"location":"all_models/#oteapi.models.transformationconfig.ProcessPriority","title":"<code>ProcessPriority</code>","text":"<p>             Bases: <code>str</code>, <code>Enum</code></p> <p>Defining process priority enumerators.</p> <p>Process priorities:</p> <ul> <li>Low</li> <li>Medium</li> <li>High</li> </ul> Source code in <code>oteapi/models/transformationconfig.py</code> <pre><code>class ProcessPriority(str, Enum):\n\"\"\"Defining process priority enumerators.\n\n    Process priorities:\n\n    - Low\n    - Medium\n    - High\n\n    \"\"\"\n\n    LOW = \"Low\"\n    MEDIUM = \"Medium\"\n    HIGH = \"High\"\n</code></pre>"},{"location":"all_models/#oteapi.models.transformationconfig.ProcessPriority.HIGH","title":"<code>HIGH = 'High'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_models/#oteapi.models.transformationconfig.ProcessPriority.LOW","title":"<code>LOW = 'Low'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_models/#oteapi.models.transformationconfig.ProcessPriority.MEDIUM","title":"<code>MEDIUM = 'Medium'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_models/#oteapi.models.transformationconfig.TransformationConfig","title":"<code>TransformationConfig</code>","text":"<p>             Bases: <code>GenericConfig</code>, <code>SecretConfig</code></p> <p>Transformation Strategy Data Configuration.</p> Source code in <code>oteapi/models/transformationconfig.py</code> <pre><code>class TransformationConfig(GenericConfig, SecretConfig):\n\"\"\"Transformation Strategy Data Configuration.\"\"\"\n\n    transformationType: str = Field(\n        ...,\n        description=(\n            \"Type of registered transformation strategy. E.g., `celery/remote`.\"\n        ),\n    )\n    name: Optional[str] = Field(\n        None, description=\"Human-readable name of the transformation strategy.\"\n    )\n    due: Optional[datetime] = Field(\n        None,\n        description=(\n            \"Optional field to indicate a due data/time for when a transformation \"\n            \"should finish.\"\n        ),\n    )\n    priority: Optional[ProcessPriority] = Field(\n        ProcessPriority.MEDIUM,\n        description=\"Define the process priority of the transformation execution.\",\n    )\n</code></pre>"},{"location":"all_models/#oteapi.models.transformationconfig.TransformationConfig.due","title":"<code>due: Optional[datetime] = Field(None, description='Optional field to indicate a due data/time for when a transformation should finish.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_models/#oteapi.models.transformationconfig.TransformationConfig.name","title":"<code>name: Optional[str] = Field(None, description='Human-readable name of the transformation strategy.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_models/#oteapi.models.transformationconfig.TransformationConfig.priority","title":"<code>priority: Optional[ProcessPriority] = Field(ProcessPriority.MEDIUM, description='Define the process priority of the transformation execution.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_models/#oteapi.models.transformationconfig.TransformationConfig.transformationType","title":"<code>transformationType: str = Field(..., description='Type of registered transformation strategy. E.g., `celery/remote`.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_models/#oteapi.models.transformationconfig.TransformationStatus","title":"<code>TransformationStatus</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>Return from transformation status.</p> Source code in <code>oteapi/models/transformationconfig.py</code> <pre><code>class TransformationStatus(BaseModel):\n\"\"\"Return from transformation status.\"\"\"\n\n    id: str = Field(..., description=\"ID for the given transformation process.\")\n    status: Optional[str] = Field(\n        None, description=\"Status for the transformation process.\"\n    )\n    messages: Optional[List[str]] = Field(\n        None, description=\"Messages related to the transformation process.\"\n    )\n    created: Optional[datetime] = Field(\n        None,\n        description=\"Time of creation for the transformation process. Given in UTC.\",\n    )\n    startTime: Optional[datetime] = Field(\n        None, description=\"Time when the transformation process started. Given in UTC.\"\n    )\n    finishTime: Optional[datetime] = Field(\n        None, description=\"Time when the tranformation process finished. Given in UTC.\"\n    )\n</code></pre>"},{"location":"all_models/#oteapi.models.transformationconfig.TransformationStatus.created","title":"<code>created: Optional[datetime] = Field(None, description='Time of creation for the transformation process. Given in UTC.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_models/#oteapi.models.transformationconfig.TransformationStatus.finishTime","title":"<code>finishTime: Optional[datetime] = Field(None, description='Time when the tranformation process finished. Given in UTC.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_models/#oteapi.models.transformationconfig.TransformationStatus.id","title":"<code>id: str = Field(..., description='ID for the given transformation process.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_models/#oteapi.models.transformationconfig.TransformationStatus.messages","title":"<code>messages: Optional[List[str]] = Field(None, description='Messages related to the transformation process.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_models/#oteapi.models.transformationconfig.TransformationStatus.startTime","title":"<code>startTime: Optional[datetime] = Field(None, description='Time when the transformation process started. Given in UTC.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_models/#oteapi.models.transformationconfig.TransformationStatus.status","title":"<code>status: Optional[str] = Field(None, description='Status for the transformation process.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_models/#oteapi.models.triplestoreconfig","title":"<code>triplestoreconfig</code>","text":"<p>Pydantic TripleStore Configuration Data Model.</p>"},{"location":"all_models/#oteapi.models.triplestoreconfig.TripleStoreConfig","title":"<code>TripleStoreConfig</code>","text":"<p>             Bases: <code>GenericConfig</code>, <code>SecretConfig</code></p> <p>TripleStore Configuration.</p> <p>This is a configuration for the <code>TripleStore</code>.</p> <p>This class should not be used directly as a configuration object for a strategy object, but only as a configuration field inside a configuration object.</p> Source code in <code>oteapi/models/triplestoreconfig.py</code> <pre><code>class TripleStoreConfig(GenericConfig, SecretConfig):\n\"\"\"TripleStore Configuration.\n\n    This is a configuration for the\n    [`TripleStore`][oteapi.triplestore.triplestore.TripleStore].\n\n    This class should not be used directly as a configuration object\n    for a strategy object, but only as a configuration field inside\n    a configuration object.\n    \"\"\"\n\n    repositoryName: str = Field(\n        ..., description=\"The repository name, where the mappings are stored.\"\n    )\n    agraphHost: str = Field(\n        ...,\n        description=\"AllegroGraph host name.\",\n    )\n    agraphPort: int = Field(\n        ...,\n        description=\"AllegroGraph port number.\",\n    )\n\n    @root_validator\n    def ensure_user_pass(cls, values: \"Dict[str, Any]\") -&gt; \"Dict[str, Any]\":\n\"\"\"Ensure that user/password are set, since they are optional in the\n        SecretConfig.\"\"\"\n        if not all(values.get(_) for _ in [\"user\", \"password\"]):\n            raise ValueError(\"User and password must be defined.\")\n        return values\n\n    class Config:\n\"\"\"Pydantic configuration for TripleStoreConfig.\"\"\"\n\n        fields = {\n            \"token\": {\"exclude\": True},\n            \"client_id\": {\"exclude\": True},\n            \"client_secret\": {\"exclude\": True},\n        }\n\"\"\"The `fields`-config enables that `token`, `client_id` and `client_secret`\n        will be excluded, when the model is serialized.\"\"\"\n</code></pre>"},{"location":"all_models/#oteapi.models.triplestoreconfig.TripleStoreConfig.agraphHost","title":"<code>agraphHost: str = Field(..., description='AllegroGraph host name.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_models/#oteapi.models.triplestoreconfig.TripleStoreConfig.agraphPort","title":"<code>agraphPort: int = Field(..., description='AllegroGraph port number.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_models/#oteapi.models.triplestoreconfig.TripleStoreConfig.repositoryName","title":"<code>repositoryName: str = Field(..., description='The repository name, where the mappings are stored.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_models/#oteapi.models.triplestoreconfig.TripleStoreConfig.Config","title":"<code>Config</code>","text":"<p>Pydantic configuration for TripleStoreConfig.</p> Source code in <code>oteapi/models/triplestoreconfig.py</code> <pre><code>class Config:\n\"\"\"Pydantic configuration for TripleStoreConfig.\"\"\"\n\n    fields = {\n        \"token\": {\"exclude\": True},\n        \"client_id\": {\"exclude\": True},\n        \"client_secret\": {\"exclude\": True},\n    }\n\"\"\"The `fields`-config enables that `token`, `client_id` and `client_secret`\n    will be excluded, when the model is serialized.\"\"\"\n</code></pre>"},{"location":"all_models/#oteapi.models.triplestoreconfig.TripleStoreConfig.Config.fields","title":"<code>fields = {'token': {'exclude': True}, 'client_id': {'exclude': True}, 'client_secret': {'exclude': True}}</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The <code>fields</code>-config enables that <code>token</code>, <code>client_id</code> and <code>client_secret</code> will be excluded, when the model is serialized.</p>"},{"location":"all_models/#oteapi.models.triplestoreconfig.TripleStoreConfig.ensure_user_pass","title":"<code>ensure_user_pass(values)</code>","text":"<p>Ensure that user/password are set, since they are optional in the SecretConfig.</p> Source code in <code>oteapi/models/triplestoreconfig.py</code> <pre><code>@root_validator\ndef ensure_user_pass(cls, values: \"Dict[str, Any]\") -&gt; \"Dict[str, Any]\":\n\"\"\"Ensure that user/password are set, since they are optional in the\n    SecretConfig.\"\"\"\n    if not all(values.get(_) for _ in [\"user\", \"password\"]):\n        raise ValueError(\"User and password must be defined.\")\n    return values\n</code></pre>"},{"location":"all_strategies/","title":"OTE-API Core Strategies","text":"<p>This page provides documentation for the <code>oteapi.strategies</code> submodule, where all the core OTE-API strategies are located.</p> <p>These strategies will always be available when setting up a server based on the OTE-API Core package.</p>"},{"location":"all_strategies/#oteapi.strategies.download","title":"<code>download</code>","text":""},{"location":"all_strategies/#oteapi.strategies.download.file","title":"<code>file</code>","text":"<p>Download strategy class for the <code>file</code> scheme.</p>"},{"location":"all_strategies/#oteapi.strategies.download.file.FileConfig","title":"<code>FileConfig</code>","text":"<p>             Bases: <code>AttrDict</code></p> <p>File-specific Configuration Data Model.</p> Source code in <code>oteapi/strategies/download/file.py</code> <pre><code>class FileConfig(AttrDict):\n\"\"\"File-specific Configuration Data Model.\"\"\"\n\n    text: bool = Field(\n        False,\n        description=(\n            \"Whether the file should be opened in text mode. If `False`, the file will\"\n            \" be opened in bytes mode.\"\n        ),\n    )\n    encoding: Optional[str] = Field(\n        None,\n        description=(\n            \"Encoding used when opening the file. The default is platform dependent.\"\n        ),\n    )\n    datacache_config: Optional[DataCacheConfig] = Field(\n        None,\n        description=(\n            \"Configurations for the data cache for storing the downloaded file \"\n            \"content.\"\n        ),\n    )\n</code></pre>"},{"location":"all_strategies/#oteapi.strategies.download.file.FileConfig.datacache_config","title":"<code>datacache_config: Optional[DataCacheConfig] = Field(None, description='Configurations for the data cache for storing the downloaded file content.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.download.file.FileConfig.encoding","title":"<code>encoding: Optional[str] = Field(None, description='Encoding used when opening the file. The default is platform dependent.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.download.file.FileConfig.text","title":"<code>text: bool = Field(False, description='Whether the file should be opened in text mode. If `False`, the file will be opened in bytes mode.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.download.file.FileResourceConfig","title":"<code>FileResourceConfig</code>","text":"<p>             Bases: <code>ResourceConfig</code></p> <p>File download strategy filter config.</p> Source code in <code>oteapi/strategies/download/file.py</code> <pre><code>class FileResourceConfig(ResourceConfig):\n\"\"\"File download strategy filter config.\"\"\"\n\n    downloadUrl: FileUrl = Field(  # type: ignore[assignment]\n        ..., description=\"The file URL, which will be downloaded.\"\n    )\n    configuration: FileConfig = Field(\n        FileConfig(), description=\"File download strategy-specific configuration.\"\n    )\n\n    @validator(\"downloadUrl\")\n    def ensure_path_exists(cls, value: FileUrl) -&gt; FileUrl:\n\"\"\"Ensure `path` is defined in `downloadUrl`.\"\"\"\n        if not value.path:\n            raise ValueError(\"downloadUrl must contain a `path` part.\")\n        return value\n</code></pre>"},{"location":"all_strategies/#oteapi.strategies.download.file.FileResourceConfig.configuration","title":"<code>configuration: FileConfig = Field(FileConfig(), description='File download strategy-specific configuration.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.download.file.FileResourceConfig.downloadUrl","title":"<code>downloadUrl: FileUrl = Field(..., description='The file URL, which will be downloaded.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.download.file.FileResourceConfig.ensure_path_exists","title":"<code>ensure_path_exists(value)</code>","text":"<p>Ensure <code>path</code> is defined in <code>downloadUrl</code>.</p> Source code in <code>oteapi/strategies/download/file.py</code> <pre><code>@validator(\"downloadUrl\")\ndef ensure_path_exists(cls, value: FileUrl) -&gt; FileUrl:\n\"\"\"Ensure `path` is defined in `downloadUrl`.\"\"\"\n    if not value.path:\n        raise ValueError(\"downloadUrl must contain a `path` part.\")\n    return value\n</code></pre>"},{"location":"all_strategies/#oteapi.strategies.download.file.FileStrategy","title":"<code>FileStrategy</code>","text":"<p>Strategy for retrieving data from a local file.</p> <p>Registers strategies:</p> <ul> <li><code>(\"scheme\", \"file\")</code></li> </ul> Source code in <code>oteapi/strategies/download/file.py</code> <pre><code>@dataclass\nclass FileStrategy:\n\"\"\"Strategy for retrieving data from a local file.\n\n    **Registers strategies**:\n\n    - `(\"scheme\", \"file\")`\n\n    \"\"\"\n\n    download_config: FileResourceConfig\n\n    def initialize(self, session: \"Optional[Dict[str, Any]]\" = None) -&gt; SessionUpdate:\n\"\"\"Initialize.\"\"\"\n        return SessionUpdate()\n\n    def get(self, session: \"Optional[Dict[str, Any]]\" = None) -&gt; SessionUpdateFile:\n\"\"\"Read local file.\"\"\"\n        filename = uri_to_path(self.download_config.downloadUrl).resolve()\n\n        if not filename.exists():\n            raise FileNotFoundError(f\"File not found at {filename}\")\n\n        cache = DataCache(self.download_config.configuration.datacache_config)\n        if cache.config.accessKey and cache.config.accessKey in cache:\n            key = cache.config.accessKey\n        else:\n            key = cache.add(\n                filename.read_text(encoding=self.download_config.configuration.encoding)\n                if self.download_config.configuration.text\n                else filename.read_bytes()\n            )\n\n        return SessionUpdateFile(key=key)\n</code></pre>"},{"location":"all_strategies/#oteapi.strategies.download.file.FileStrategy.download_config","title":"<code>download_config: FileResourceConfig</code>  <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.download.file.FileStrategy.get","title":"<code>get(session=None)</code>","text":"<p>Read local file.</p> Source code in <code>oteapi/strategies/download/file.py</code> <pre><code>def get(self, session: \"Optional[Dict[str, Any]]\" = None) -&gt; SessionUpdateFile:\n\"\"\"Read local file.\"\"\"\n    filename = uri_to_path(self.download_config.downloadUrl).resolve()\n\n    if not filename.exists():\n        raise FileNotFoundError(f\"File not found at {filename}\")\n\n    cache = DataCache(self.download_config.configuration.datacache_config)\n    if cache.config.accessKey and cache.config.accessKey in cache:\n        key = cache.config.accessKey\n    else:\n        key = cache.add(\n            filename.read_text(encoding=self.download_config.configuration.encoding)\n            if self.download_config.configuration.text\n            else filename.read_bytes()\n        )\n\n    return SessionUpdateFile(key=key)\n</code></pre>"},{"location":"all_strategies/#oteapi.strategies.download.file.FileStrategy.initialize","title":"<code>initialize(session=None)</code>","text":"<p>Initialize.</p> Source code in <code>oteapi/strategies/download/file.py</code> <pre><code>def initialize(self, session: \"Optional[Dict[str, Any]]\" = None) -&gt; SessionUpdate:\n\"\"\"Initialize.\"\"\"\n    return SessionUpdate()\n</code></pre>"},{"location":"all_strategies/#oteapi.strategies.download.file.SessionUpdateFile","title":"<code>SessionUpdateFile</code>","text":"<p>             Bases: <code>SessionUpdate</code></p> <p>Class for returning values from Download File strategy.</p> Source code in <code>oteapi/strategies/download/file.py</code> <pre><code>class SessionUpdateFile(SessionUpdate):\n\"\"\"Class for returning values from Download File strategy.\"\"\"\n\n    key: str = Field(..., description=\"Key to access the data in the cache.\")\n</code></pre>"},{"location":"all_strategies/#oteapi.strategies.download.file.SessionUpdateFile.key","title":"<code>key: str = Field(..., description='Key to access the data in the cache.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.download.https","title":"<code>https</code>","text":"<p>Download strategy class for http/https</p>"},{"location":"all_strategies/#oteapi.strategies.download.https.HTTPSConfig","title":"<code>HTTPSConfig</code>","text":"<p>             Bases: <code>AttrDict</code></p> <p>HTTP(S)-specific Configuration Data Model.</p> Source code in <code>oteapi/strategies/download/https.py</code> <pre><code>class HTTPSConfig(AttrDict):\n\"\"\"HTTP(S)-specific Configuration Data Model.\"\"\"\n\n    datacache_config: Optional[DataCacheConfig] = Field(\n        None,\n        description=(\n            \"Configurations for the data cache for storing the downloaded file \"\n            \"content.\"\n        ),\n    )\n</code></pre>"},{"location":"all_strategies/#oteapi.strategies.download.https.HTTPSConfig.datacache_config","title":"<code>datacache_config: Optional[DataCacheConfig] = Field(None, description='Configurations for the data cache for storing the downloaded file content.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.download.https.HTTPSResourceConfig","title":"<code>HTTPSResourceConfig</code>","text":"<p>             Bases: <code>ResourceConfig</code></p> <p>HTTP(S) download strategy filter config.</p> Source code in <code>oteapi/strategies/download/https.py</code> <pre><code>class HTTPSResourceConfig(ResourceConfig):\n\"\"\"HTTP(S) download strategy filter config.\"\"\"\n\n    downloadUrl: AnyHttpUrl = Field(  # type: ignore[assignment]\n        ..., description=\"The HTTP(S) URL, which will be downloaded.\"\n    )\n    configuration: HTTPSConfig = Field(\n        HTTPSConfig(), description=\"HTTP(S) download strategy-specific configuration.\"\n    )\n</code></pre>"},{"location":"all_strategies/#oteapi.strategies.download.https.HTTPSResourceConfig.configuration","title":"<code>configuration: HTTPSConfig = Field(HTTPSConfig(), description='HTTP(S) download strategy-specific configuration.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.download.https.HTTPSResourceConfig.downloadUrl","title":"<code>downloadUrl: AnyHttpUrl = Field(..., description='The HTTP(S) URL, which will be downloaded.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.download.https.HTTPSStrategy","title":"<code>HTTPSStrategy</code>","text":"<p>Strategy for retrieving data via http.</p> <p>Registers strategies:</p> <ul> <li><code>(\"scheme\", \"http\")</code></li> <li><code>(\"scheme\", \"https\")</code></li> </ul> Source code in <code>oteapi/strategies/download/https.py</code> <pre><code>@dataclass\nclass HTTPSStrategy:\n\"\"\"Strategy for retrieving data via http.\n\n    **Registers strategies**:\n\n    - `(\"scheme\", \"http\")`\n    - `(\"scheme\", \"https\")`\n\n    \"\"\"\n\n    download_config: HTTPSResourceConfig\n\n    def initialize(self, session: \"Optional[Dict[str, Any]]\" = None) -&gt; SessionUpdate:\n\"\"\"Initialize.\"\"\"\n        return SessionUpdate()\n\n    def get(self, session: \"Optional[Dict[str, Any]]\" = None) -&gt; SessionUpdateHTTPS:\n\"\"\"Download via http/https and store on local cache.\"\"\"\n        cache = DataCache(self.download_config.configuration.datacache_config)\n        if cache.config.accessKey and cache.config.accessKey in cache:\n            key = cache.config.accessKey\n        else:\n            req = requests.get(\n                self.download_config.downloadUrl,\n                allow_redirects=True,\n                timeout=(3, 27),  # timeout: (connect, read) in seconds\n            )\n            key = cache.add(req.content)\n\n        return SessionUpdateHTTPS(key=key)\n</code></pre>"},{"location":"all_strategies/#oteapi.strategies.download.https.HTTPSStrategy.download_config","title":"<code>download_config: HTTPSResourceConfig</code>  <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.download.https.HTTPSStrategy.get","title":"<code>get(session=None)</code>","text":"<p>Download via http/https and store on local cache.</p> Source code in <code>oteapi/strategies/download/https.py</code> <pre><code>def get(self, session: \"Optional[Dict[str, Any]]\" = None) -&gt; SessionUpdateHTTPS:\n\"\"\"Download via http/https and store on local cache.\"\"\"\n    cache = DataCache(self.download_config.configuration.datacache_config)\n    if cache.config.accessKey and cache.config.accessKey in cache:\n        key = cache.config.accessKey\n    else:\n        req = requests.get(\n            self.download_config.downloadUrl,\n            allow_redirects=True,\n            timeout=(3, 27),  # timeout: (connect, read) in seconds\n        )\n        key = cache.add(req.content)\n\n    return SessionUpdateHTTPS(key=key)\n</code></pre>"},{"location":"all_strategies/#oteapi.strategies.download.https.HTTPSStrategy.initialize","title":"<code>initialize(session=None)</code>","text":"<p>Initialize.</p> Source code in <code>oteapi/strategies/download/https.py</code> <pre><code>def initialize(self, session: \"Optional[Dict[str, Any]]\" = None) -&gt; SessionUpdate:\n\"\"\"Initialize.\"\"\"\n    return SessionUpdate()\n</code></pre>"},{"location":"all_strategies/#oteapi.strategies.download.https.SessionUpdateHTTPS","title":"<code>SessionUpdateHTTPS</code>","text":"<p>             Bases: <code>SessionUpdate</code></p> <p>Class for returning values from Download HTTPS strategy.</p> Source code in <code>oteapi/strategies/download/https.py</code> <pre><code>class SessionUpdateHTTPS(SessionUpdate):\n\"\"\"Class for returning values from Download HTTPS strategy.\"\"\"\n\n    key: str = Field(..., description=\"Key to access the data in the cache.\")\n</code></pre>"},{"location":"all_strategies/#oteapi.strategies.download.https.SessionUpdateHTTPS.key","title":"<code>key: str = Field(..., description='Key to access the data in the cache.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.download.sftp","title":"<code>sftp</code>","text":"<p>Strategy class for sftp/ftp</p>"},{"location":"all_strategies/#oteapi.strategies.download.sftp.AnyFtpUrl","title":"<code>AnyFtpUrl</code>","text":"<p>             Bases: <code>AnyUrl</code></p> <p>A (S)FTP URL model.</p> Source code in <code>oteapi/strategies/download/sftp.py</code> <pre><code>class AnyFtpUrl(AnyUrl):\n\"\"\"A (S)FTP URL model.\"\"\"\n\n    allowed_schemes = {\"ftp\", \"sftp\"}\n</code></pre>"},{"location":"all_strategies/#oteapi.strategies.download.sftp.AnyFtpUrl.allowed_schemes","title":"<code>allowed_schemes = {'ftp', 'sftp'}</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.download.sftp.SFTPConfig","title":"<code>SFTPConfig</code>","text":"<p>             Bases: <code>AttrDict</code></p> <p>(S)FTP-specific Configuration Data Model.</p> Source code in <code>oteapi/strategies/download/sftp.py</code> <pre><code>class SFTPConfig(AttrDict):\n\"\"\"(S)FTP-specific Configuration Data Model.\"\"\"\n\n    datacache_config: Optional[DataCacheConfig] = Field(\n        None,\n        description=(\n            \"Configurations for the data cache for storing the downloaded file \"\n            \"content.\"\n        ),\n    )\n</code></pre>"},{"location":"all_strategies/#oteapi.strategies.download.sftp.SFTPConfig.datacache_config","title":"<code>datacache_config: Optional[DataCacheConfig] = Field(None, description='Configurations for the data cache for storing the downloaded file content.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.download.sftp.SFTPResourceConfig","title":"<code>SFTPResourceConfig</code>","text":"<p>             Bases: <code>ResourceConfig</code></p> <p>(S)FTP download strategy filter config.</p> Source code in <code>oteapi/strategies/download/sftp.py</code> <pre><code>class SFTPResourceConfig(ResourceConfig):\n\"\"\"(S)FTP download strategy filter config.\"\"\"\n\n    downloadUrl: AnyFtpUrl = Field(  # type: ignore[assignment]\n        ..., description=\"The (S)FTP URL, which will be downloaded.\"\n    )\n    configuration: SFTPConfig = Field(\n        SFTPConfig(), description=\"(S)FTP download strategy-specific configuration.\"\n    )\n</code></pre>"},{"location":"all_strategies/#oteapi.strategies.download.sftp.SFTPResourceConfig.configuration","title":"<code>configuration: SFTPConfig = Field(SFTPConfig(), description='(S)FTP download strategy-specific configuration.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.download.sftp.SFTPResourceConfig.downloadUrl","title":"<code>downloadUrl: AnyFtpUrl = Field(..., description='The (S)FTP URL, which will be downloaded.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.download.sftp.SFTPStrategy","title":"<code>SFTPStrategy</code>","text":"<p>Strategy for retrieving data via sftp.</p> <p>Registers strategies:</p> <ul> <li><code>(\"scheme\", \"ftp\")</code></li> <li><code>(\"scheme\", \"sftp\")</code></li> </ul> Source code in <code>oteapi/strategies/download/sftp.py</code> <pre><code>@dataclass\nclass SFTPStrategy:\n\"\"\"Strategy for retrieving data via sftp.\n\n    **Registers strategies**:\n\n    - `(\"scheme\", \"ftp\")`\n    - `(\"scheme\", \"sftp\")`\n\n    \"\"\"\n\n    download_config: SFTPResourceConfig\n\n    def initialize(self, session: \"Optional[Dict[str, Any]]\" = None) -&gt; SessionUpdate:\n\"\"\"Initialize.\"\"\"\n        return SessionUpdate()\n\n    def get(self, session: \"Optional[Dict[str, Any]]\" = None) -&gt; SessionUpdateSFTP:\n\"\"\"Download via sftp\"\"\"\n        cache = DataCache(self.download_config.configuration.datacache_config)\n        if cache.config.accessKey and cache.config.accessKey in cache:\n            key = cache.config.accessKey\n        else:\n            # Setup connection options\n            cnopts = pysftp.CnOpts()\n            cnopts.hostkeys = None\n\n            # open connection and store data locally\n            with pysftp.Connection(\n                host=self.download_config.downloadUrl.host,\n                username=self.download_config.downloadUrl.user,\n                password=self.download_config.downloadUrl.password,\n                port=self.download_config.downloadUrl.port,\n                cnopts=cnopts,\n            ) as sftp:\n                # Because of insane locking on Windows, we have to close\n                # the downloaded file before adding it to the cache\n                with NamedTemporaryFile(prefix=\"oteapi-sftp-\", delete=False) as handle:\n                    localpath = Path(handle.name).resolve()\n                try:\n                    sftp.get(self.download_config.downloadUrl.path, localpath=localpath)\n                    key = cache.add(localpath.read_bytes())\n                finally:\n                    localpath.unlink()\n\n        return SessionUpdateSFTP(key=key)\n</code></pre>"},{"location":"all_strategies/#oteapi.strategies.download.sftp.SFTPStrategy.download_config","title":"<code>download_config: SFTPResourceConfig</code>  <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.download.sftp.SFTPStrategy.get","title":"<code>get(session=None)</code>","text":"<p>Download via sftp</p> Source code in <code>oteapi/strategies/download/sftp.py</code> <pre><code>def get(self, session: \"Optional[Dict[str, Any]]\" = None) -&gt; SessionUpdateSFTP:\n\"\"\"Download via sftp\"\"\"\n    cache = DataCache(self.download_config.configuration.datacache_config)\n    if cache.config.accessKey and cache.config.accessKey in cache:\n        key = cache.config.accessKey\n    else:\n        # Setup connection options\n        cnopts = pysftp.CnOpts()\n        cnopts.hostkeys = None\n\n        # open connection and store data locally\n        with pysftp.Connection(\n            host=self.download_config.downloadUrl.host,\n            username=self.download_config.downloadUrl.user,\n            password=self.download_config.downloadUrl.password,\n            port=self.download_config.downloadUrl.port,\n            cnopts=cnopts,\n        ) as sftp:\n            # Because of insane locking on Windows, we have to close\n            # the downloaded file before adding it to the cache\n            with NamedTemporaryFile(prefix=\"oteapi-sftp-\", delete=False) as handle:\n                localpath = Path(handle.name).resolve()\n            try:\n                sftp.get(self.download_config.downloadUrl.path, localpath=localpath)\n                key = cache.add(localpath.read_bytes())\n            finally:\n                localpath.unlink()\n\n    return SessionUpdateSFTP(key=key)\n</code></pre>"},{"location":"all_strategies/#oteapi.strategies.download.sftp.SFTPStrategy.initialize","title":"<code>initialize(session=None)</code>","text":"<p>Initialize.</p> Source code in <code>oteapi/strategies/download/sftp.py</code> <pre><code>def initialize(self, session: \"Optional[Dict[str, Any]]\" = None) -&gt; SessionUpdate:\n\"\"\"Initialize.\"\"\"\n    return SessionUpdate()\n</code></pre>"},{"location":"all_strategies/#oteapi.strategies.download.sftp.SessionUpdateSFTP","title":"<code>SessionUpdateSFTP</code>","text":"<p>             Bases: <code>SessionUpdate</code></p> <p>Class for returning values from Download SFTP strategy.</p> Source code in <code>oteapi/strategies/download/sftp.py</code> <pre><code>class SessionUpdateSFTP(SessionUpdate):\n\"\"\"Class for returning values from Download SFTP strategy.\"\"\"\n\n    key: str = Field(..., description=\"Key to access the data in the cache.\")\n</code></pre>"},{"location":"all_strategies/#oteapi.strategies.download.sftp.SessionUpdateSFTP.key","title":"<code>key: str = Field(..., description='Key to access the data in the cache.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.filter","title":"<code>filter</code>","text":""},{"location":"all_strategies/#oteapi.strategies.filter.crop_filter","title":"<code>crop_filter</code>","text":"<p>Demo-filter strategy</p>"},{"location":"all_strategies/#oteapi.strategies.filter.crop_filter.CropImageConfig","title":"<code>CropImageConfig</code>","text":"<p>             Bases: <code>AttrDict</code></p> <p>Configuration model for crop data.</p> Source code in <code>oteapi/strategies/filter/crop_filter.py</code> <pre><code>class CropImageConfig(AttrDict):\n\"\"\"Configuration model for crop data.\"\"\"\n\n    crop: Tuple[int, int, int, int] = Field(\n        ..., description=\"Box cropping parameters (left, top, right, bottom).\"\n    )\n</code></pre>"},{"location":"all_strategies/#oteapi.strategies.filter.crop_filter.CropImageConfig.crop","title":"<code>crop: Tuple[int, int, int, int] = Field(..., description='Box cropping parameters (left, top, right, bottom).')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.filter.crop_filter.CropImageFilter","title":"<code>CropImageFilter</code>","text":"<p>Strategy for cropping an image.</p> <p>Registers strategies:</p> <ul> <li><code>(\"filterType\", \"filter/crop\")</code></li> </ul> Source code in <code>oteapi/strategies/filter/crop_filter.py</code> <pre><code>@dataclass\nclass CropImageFilter:\n\"\"\"Strategy for cropping an image.\n\n    **Registers strategies**:\n\n    - `(\"filterType\", \"filter/crop\")`\n\n    \"\"\"\n\n    filter_config: CropImageFilterConfig\n\n    def initialize(\n        self,\n        session: \"Optional[Dict[str, Any]]\" = None,\n    ) -&gt; SessionUpdateCropFilter:\n\"\"\"Initialize strategy and return a dictionary.\"\"\"\n        return SessionUpdateCropFilter(\n            imagecrop=self.filter_config.configuration.crop,\n        )\n\n    def get(\n        self,\n        session: \"Optional[Dict[str, Any]]\" = None,\n    ) -&gt; SessionUpdate:\n\"\"\"Execute strategy and return a dictionary\"\"\"\n        return SessionUpdate()\n</code></pre>"},{"location":"all_strategies/#oteapi.strategies.filter.crop_filter.CropImageFilter.filter_config","title":"<code>filter_config: CropImageFilterConfig</code>  <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.filter.crop_filter.CropImageFilter.get","title":"<code>get(session=None)</code>","text":"<p>Execute strategy and return a dictionary</p> Source code in <code>oteapi/strategies/filter/crop_filter.py</code> <pre><code>def get(\n    self,\n    session: \"Optional[Dict[str, Any]]\" = None,\n) -&gt; SessionUpdate:\n\"\"\"Execute strategy and return a dictionary\"\"\"\n    return SessionUpdate()\n</code></pre>"},{"location":"all_strategies/#oteapi.strategies.filter.crop_filter.CropImageFilter.initialize","title":"<code>initialize(session=None)</code>","text":"<p>Initialize strategy and return a dictionary.</p> Source code in <code>oteapi/strategies/filter/crop_filter.py</code> <pre><code>def initialize(\n    self,\n    session: \"Optional[Dict[str, Any]]\" = None,\n) -&gt; SessionUpdateCropFilter:\n\"\"\"Initialize strategy and return a dictionary.\"\"\"\n    return SessionUpdateCropFilter(\n        imagecrop=self.filter_config.configuration.crop,\n    )\n</code></pre>"},{"location":"all_strategies/#oteapi.strategies.filter.crop_filter.CropImageFilterConfig","title":"<code>CropImageFilterConfig</code>","text":"<p>             Bases: <code>FilterConfig</code></p> <p>Crop filter strategy filter config.</p> Source code in <code>oteapi/strategies/filter/crop_filter.py</code> <pre><code>class CropImageFilterConfig(FilterConfig):\n\"\"\"Crop filter strategy filter config.\"\"\"\n\n    filterType: str = Field(\n        \"filter/crop\",\n        const=True,\n        description=FilterConfig.__fields__[\"filterType\"].field_info.description,\n    )\n    configuration: CropImageConfig = Field(\n        ..., description=\"Image crop filter strategy-specific configuration.\"\n    )\n</code></pre>"},{"location":"all_strategies/#oteapi.strategies.filter.crop_filter.CropImageFilterConfig.configuration","title":"<code>configuration: CropImageConfig = Field(..., description='Image crop filter strategy-specific configuration.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.filter.crop_filter.CropImageFilterConfig.filterType","title":"<code>filterType: str = Field('filter/crop', const=True, description=FilterConfig.__fields__['filterType'].field_info.description)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.filter.crop_filter.SessionUpdateCropFilter","title":"<code>SessionUpdateCropFilter</code>","text":"<p>             Bases: <code>SessionUpdate</code></p> <p>Return model for <code>CropImageFilter</code>.</p> Source code in <code>oteapi/strategies/filter/crop_filter.py</code> <pre><code>class SessionUpdateCropFilter(SessionUpdate):\n\"\"\"Return model for `CropImageFilter`.\"\"\"\n\n    imagecrop: Tuple[int, int, int, int] = Field(\n        ..., description=\"Box cropping parameters (left, top, right, bottom).\"\n    )\n</code></pre>"},{"location":"all_strategies/#oteapi.strategies.filter.crop_filter.SessionUpdateCropFilter.imagecrop","title":"<code>imagecrop: Tuple[int, int, int, int] = Field(..., description='Box cropping parameters (left, top, right, bottom).')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.filter.sql_query_filter","title":"<code>sql_query_filter</code>","text":"<p>SQL query filter strategy.</p>"},{"location":"all_strategies/#oteapi.strategies.filter.sql_query_filter.SQLQueryFilter","title":"<code>SQLQueryFilter</code>","text":"<p>Strategy for a SQL query filter.</p> <p>Registers strategies:</p> <ul> <li><code>(\"filterType\", \"filter/sql\")</code></li> </ul> Source code in <code>oteapi/strategies/filter/sql_query_filter.py</code> <pre><code>@dataclass\nclass SQLQueryFilter:\n\"\"\"Strategy for a SQL query filter.\n\n    **Registers strategies**:\n\n    - `(\"filterType\", \"filter/sql\")`\n\n    \"\"\"\n\n    filter_config: SqlQueryFilterConfig\n\n    def initialize(\n        self,\n        session: \"Optional[Dict[str, Any]]\" = None,\n    ) -&gt; SessionUpdateSqlQuery:\n\"\"\"Initialize strategy.\"\"\"\n        return SessionUpdateSqlQuery(sqlquery=self.filter_config.query)\n\n    def get(self, session: \"Optional[Dict[str, Any]]\" = None) -&gt; SessionUpdate:\n\"\"\"Execute strategy and return a dictionary.\"\"\"\n        return SessionUpdate()\n</code></pre>"},{"location":"all_strategies/#oteapi.strategies.filter.sql_query_filter.SQLQueryFilter.filter_config","title":"<code>filter_config: SqlQueryFilterConfig</code>  <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.filter.sql_query_filter.SQLQueryFilter.get","title":"<code>get(session=None)</code>","text":"<p>Execute strategy and return a dictionary.</p> Source code in <code>oteapi/strategies/filter/sql_query_filter.py</code> <pre><code>def get(self, session: \"Optional[Dict[str, Any]]\" = None) -&gt; SessionUpdate:\n\"\"\"Execute strategy and return a dictionary.\"\"\"\n    return SessionUpdate()\n</code></pre>"},{"location":"all_strategies/#oteapi.strategies.filter.sql_query_filter.SQLQueryFilter.initialize","title":"<code>initialize(session=None)</code>","text":"<p>Initialize strategy.</p> Source code in <code>oteapi/strategies/filter/sql_query_filter.py</code> <pre><code>def initialize(\n    self,\n    session: \"Optional[Dict[str, Any]]\" = None,\n) -&gt; SessionUpdateSqlQuery:\n\"\"\"Initialize strategy.\"\"\"\n    return SessionUpdateSqlQuery(sqlquery=self.filter_config.query)\n</code></pre>"},{"location":"all_strategies/#oteapi.strategies.filter.sql_query_filter.SessionUpdateSqlQuery","title":"<code>SessionUpdateSqlQuery</code>","text":"<p>             Bases: <code>SessionUpdate</code></p> <p>Class for returning values from SQL Query data model.</p> Source code in <code>oteapi/strategies/filter/sql_query_filter.py</code> <pre><code>class SessionUpdateSqlQuery(SessionUpdate):\n\"\"\"Class for returning values from SQL Query data model.\"\"\"\n\n    sqlquery: str = Field(..., description=\"A SQL query string.\")\n</code></pre>"},{"location":"all_strategies/#oteapi.strategies.filter.sql_query_filter.SessionUpdateSqlQuery.sqlquery","title":"<code>sqlquery: str = Field(..., description='A SQL query string.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.filter.sql_query_filter.SqlQueryFilterConfig","title":"<code>SqlQueryFilterConfig</code>","text":"<p>             Bases: <code>FilterConfig</code></p> <p>SQL query filter strategy filter config.</p> Source code in <code>oteapi/strategies/filter/sql_query_filter.py</code> <pre><code>class SqlQueryFilterConfig(FilterConfig):\n\"\"\"SQL query filter strategy filter config.\"\"\"\n\n    filterType: str = Field(\n        \"filter/sql\",\n        const=True,\n        description=FilterConfig.__fields__[\"filterType\"].field_info.description,\n    )\n    query: str = Field(..., description=\"A SQL query string.\")\n</code></pre>"},{"location":"all_strategies/#oteapi.strategies.filter.sql_query_filter.SqlQueryFilterConfig.filterType","title":"<code>filterType: str = Field('filter/sql', const=True, description=FilterConfig.__fields__['filterType'].field_info.description)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.filter.sql_query_filter.SqlQueryFilterConfig.query","title":"<code>query: str = Field(..., description='A SQL query string.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.mapping","title":"<code>mapping</code>","text":""},{"location":"all_strategies/#oteapi.strategies.mapping.mapping","title":"<code>mapping</code>","text":"<p>Mapping filter strategy.</p>"},{"location":"all_strategies/#oteapi.strategies.mapping.mapping.MappingSessionUpdate","title":"<code>MappingSessionUpdate</code>","text":"<p>             Bases: <code>SessionUpdate</code></p> <p>SessionUpdate model for mappings.</p> Source code in <code>oteapi/strategies/mapping/mapping.py</code> <pre><code>class MappingSessionUpdate(SessionUpdate):\n\"\"\"SessionUpdate model for mappings.\"\"\"\n\n    prefixes: Dict[str, str] = Field(\n        ...,\n        description=(\n            \"Dictionary of shortnames that expands to an IRI \"\n            \"given as local value/IRI-expansion-pairs.\"\n        ),\n    )\n    triples: List[RDFTriple] = Field(\n        ...,\n        description=\"List of semantic triples given as (subject, predicate, object).\",\n    )\n</code></pre>"},{"location":"all_strategies/#oteapi.strategies.mapping.mapping.MappingSessionUpdate.prefixes","title":"<code>prefixes: Dict[str, str] = Field(..., description='Dictionary of shortnames that expands to an IRI given as local value/IRI-expansion-pairs.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.mapping.mapping.MappingSessionUpdate.triples","title":"<code>triples: List[RDFTriple] = Field(..., description='List of semantic triples given as (subject, predicate, object).')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.mapping.mapping.MappingStrategy","title":"<code>MappingStrategy</code>","text":"<p>Strategy for a mapping.</p> <p>The mapping strategy simply adds more prefixes and triples to the <code>prefixes</code> and <code>triples</code> fields in the session such that they are available for other strategies, like function strategies that convert between data models.</p> <p>Nothing is returned to avoid deleting existing mappings.</p> <p>Registers strategies:</p> <ul> <li><code>(\"mappingType\", \"triples\")</code></li> </ul> Source code in <code>oteapi/strategies/mapping/mapping.py</code> <pre><code>@dataclass\nclass MappingStrategy:\n\"\"\"Strategy for a mapping.\n\n    The mapping strategy simply adds more prefixes and triples to the\n    `prefixes` and `triples` fields in the session such that they are\n    available for other strategies, like function strategies that convert\n    between data models.\n\n    Nothing is returned to avoid deleting existing mappings.\n\n    **Registers strategies**:\n\n    - `(\"mappingType\", \"triples\")`\n\n    \"\"\"\n\n    mapping_config: MappingConfig\n\n    def initialize(\n        self, session: \"Optional[Dict[str, Any]]\" = None\n    ) -&gt; MappingSessionUpdate:\n\"\"\"Initialize strategy.\"\"\"\n        prefixes = session.get(\"prefixes\", {}) if session else {}\n        triples = set(session.get(\"triples\", []) if session else [])\n\n        if self.mapping_config.prefixes:\n            prefixes.update(self.mapping_config.prefixes)\n        if self.mapping_config.triples:\n            triples.update(self.mapping_config.triples)\n\n        return MappingSessionUpdate(prefixes=prefixes, triples=triples)\n\n    def get(self, session: \"Optional[Dict[str, Any]]\" = None) -&gt; SessionUpdate:\n\"\"\"Execute strategy and return a dictionary.\"\"\"\n        return SessionUpdate()\n</code></pre>"},{"location":"all_strategies/#oteapi.strategies.mapping.mapping.MappingStrategy.mapping_config","title":"<code>mapping_config: MappingConfig</code>  <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.mapping.mapping.MappingStrategy.get","title":"<code>get(session=None)</code>","text":"<p>Execute strategy and return a dictionary.</p> Source code in <code>oteapi/strategies/mapping/mapping.py</code> <pre><code>def get(self, session: \"Optional[Dict[str, Any]]\" = None) -&gt; SessionUpdate:\n\"\"\"Execute strategy and return a dictionary.\"\"\"\n    return SessionUpdate()\n</code></pre>"},{"location":"all_strategies/#oteapi.strategies.mapping.mapping.MappingStrategy.initialize","title":"<code>initialize(session=None)</code>","text":"<p>Initialize strategy.</p> Source code in <code>oteapi/strategies/mapping/mapping.py</code> <pre><code>def initialize(\n    self, session: \"Optional[Dict[str, Any]]\" = None\n) -&gt; MappingSessionUpdate:\n\"\"\"Initialize strategy.\"\"\"\n    prefixes = session.get(\"prefixes\", {}) if session else {}\n    triples = set(session.get(\"triples\", []) if session else [])\n\n    if self.mapping_config.prefixes:\n        prefixes.update(self.mapping_config.prefixes)\n    if self.mapping_config.triples:\n        triples.update(self.mapping_config.triples)\n\n    return MappingSessionUpdate(prefixes=prefixes, triples=triples)\n</code></pre>"},{"location":"all_strategies/#oteapi.strategies.parse","title":"<code>parse</code>","text":""},{"location":"all_strategies/#oteapi.strategies.parse.application_json","title":"<code>application_json</code>","text":"<p>Strategy class for application/json.</p>"},{"location":"all_strategies/#oteapi.strategies.parse.application_json.JSONConfig","title":"<code>JSONConfig</code>","text":"<p>             Bases: <code>AttrDict</code></p> <p>JSON parse-specific Configuration Data Model.</p> Source code in <code>oteapi/strategies/parse/application_json.py</code> <pre><code>class JSONConfig(AttrDict):\n\"\"\"JSON parse-specific Configuration Data Model.\"\"\"\n\n    datacache_config: Optional[DataCacheConfig] = Field(\n        None,\n        description=(\n            \"Configurations for the data cache for storing the downloaded file \"\n            \"content.\"\n        ),\n    )\n</code></pre>"},{"location":"all_strategies/#oteapi.strategies.parse.application_json.JSONConfig.datacache_config","title":"<code>datacache_config: Optional[DataCacheConfig] = Field(None, description='Configurations for the data cache for storing the downloaded file content.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.parse.application_json.JSONDataParseStrategy","title":"<code>JSONDataParseStrategy</code>","text":"<p>Parse strategy for JSON.</p> <p>Registers strategies:</p> <ul> <li><code>(\"mediaType\", \"application/json\")</code></li> </ul> Source code in <code>oteapi/strategies/parse/application_json.py</code> <pre><code>@dataclass\nclass JSONDataParseStrategy:\n\"\"\"Parse strategy for JSON.\n\n    **Registers strategies**:\n\n    - `(\"mediaType\", \"application/json\")`\n\n    \"\"\"\n\n    parse_config: JSONResourceConfig\n\n    def initialize(self, session: \"Optional[Dict[str, Any]]\" = None) -&gt; SessionUpdate:\n\"\"\"Initialize.\"\"\"\n        return SessionUpdate()\n\n    def get(self, session: \"Optional[Dict[str, Any]]\" = None) -&gt; SessionUpdateJSONParse:\n\"\"\"Parse json.\"\"\"\n        downloader = create_strategy(\"download\", self.parse_config)\n        output = downloader.get()\n        cache = DataCache(self.parse_config.configuration.datacache_config)\n        content = cache.get(output[\"key\"])\n\n        if isinstance(content, dict):\n            return SessionUpdateJSONParse(content=content)\n        return SessionUpdateJSONParse(content=json.loads(content))\n</code></pre>"},{"location":"all_strategies/#oteapi.strategies.parse.application_json.JSONDataParseStrategy.parse_config","title":"<code>parse_config: JSONResourceConfig</code>  <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.parse.application_json.JSONDataParseStrategy.get","title":"<code>get(session=None)</code>","text":"<p>Parse json.</p> Source code in <code>oteapi/strategies/parse/application_json.py</code> <pre><code>def get(self, session: \"Optional[Dict[str, Any]]\" = None) -&gt; SessionUpdateJSONParse:\n\"\"\"Parse json.\"\"\"\n    downloader = create_strategy(\"download\", self.parse_config)\n    output = downloader.get()\n    cache = DataCache(self.parse_config.configuration.datacache_config)\n    content = cache.get(output[\"key\"])\n\n    if isinstance(content, dict):\n        return SessionUpdateJSONParse(content=content)\n    return SessionUpdateJSONParse(content=json.loads(content))\n</code></pre>"},{"location":"all_strategies/#oteapi.strategies.parse.application_json.JSONDataParseStrategy.initialize","title":"<code>initialize(session=None)</code>","text":"<p>Initialize.</p> Source code in <code>oteapi/strategies/parse/application_json.py</code> <pre><code>def initialize(self, session: \"Optional[Dict[str, Any]]\" = None) -&gt; SessionUpdate:\n\"\"\"Initialize.\"\"\"\n    return SessionUpdate()\n</code></pre>"},{"location":"all_strategies/#oteapi.strategies.parse.application_json.JSONResourceConfig","title":"<code>JSONResourceConfig</code>","text":"<p>             Bases: <code>ResourceConfig</code></p> <p>JSON parse strategy filter config.</p> Source code in <code>oteapi/strategies/parse/application_json.py</code> <pre><code>class JSONResourceConfig(ResourceConfig):\n\"\"\"JSON parse strategy filter config.\"\"\"\n\n    mediaType: str = Field(\n        \"application/json\",\n        const=True,\n        description=ResourceConfig.__fields__[\"mediaType\"].field_info.description,\n    )\n    configuration: JSONConfig = Field(\n        JSONConfig(), description=\"JSON parse strategy-specific configuration.\"\n    )\n</code></pre>"},{"location":"all_strategies/#oteapi.strategies.parse.application_json.JSONResourceConfig.configuration","title":"<code>configuration: JSONConfig = Field(JSONConfig(), description='JSON parse strategy-specific configuration.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.parse.application_json.JSONResourceConfig.mediaType","title":"<code>mediaType: str = Field('application/json', const=True, description=ResourceConfig.__fields__['mediaType'].field_info.description)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.parse.application_json.SessionUpdateJSONParse","title":"<code>SessionUpdateJSONParse</code>","text":"<p>             Bases: <code>SessionUpdate</code></p> <p>Class for returning values from JSON Parse.</p> Source code in <code>oteapi/strategies/parse/application_json.py</code> <pre><code>class SessionUpdateJSONParse(SessionUpdate):\n\"\"\"Class for returning values from JSON Parse.\"\"\"\n\n    content: dict = Field(..., description=\"Content of the JSON document.\")\n</code></pre>"},{"location":"all_strategies/#oteapi.strategies.parse.application_json.SessionUpdateJSONParse.content","title":"<code>content: dict = Field(..., description='Content of the JSON document.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.parse.application_vnd_sqlite","title":"<code>application_vnd_sqlite</code>","text":"<p>Strategy class for application/vnd.sqlite3.</p>"},{"location":"all_strategies/#oteapi.strategies.parse.application_vnd_sqlite.SessionUpdateSqLiteParse","title":"<code>SessionUpdateSqLiteParse</code>","text":"<p>             Bases: <code>SessionUpdate</code></p> <p>Configuration model for SqLiteParse.</p> Source code in <code>oteapi/strategies/parse/application_vnd_sqlite.py</code> <pre><code>class SessionUpdateSqLiteParse(SessionUpdate):\n\"\"\"Configuration model for SqLiteParse.\"\"\"\n\n    result: list = Field(..., description=\"List of results from the query.\")\n</code></pre>"},{"location":"all_strategies/#oteapi.strategies.parse.application_vnd_sqlite.SessionUpdateSqLiteParse.result","title":"<code>result: list = Field(..., description='List of results from the query.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.parse.application_vnd_sqlite.SqliteParseConfig","title":"<code>SqliteParseConfig</code>","text":"<p>             Bases: <code>AttrDict</code></p> <p>Configuration data model for <code>SqliteParseStrategy</code>.</p> Source code in <code>oteapi/strategies/parse/application_vnd_sqlite.py</code> <pre><code>class SqliteParseConfig(AttrDict):\n\"\"\"Configuration data model for\n    [`SqliteParseStrategy`][oteapi.strategies.parse.application_vnd_sqlite.SqliteParseStrategy].\n    \"\"\"\n\n    sqlquery: str = Field(\"\", description=\"A SQL query string.\")\n    datacache_config: Optional[DataCacheConfig] = Field(\n        None,\n        description=\"Configuration options for the local data cache.\",\n    )\n</code></pre>"},{"location":"all_strategies/#oteapi.strategies.parse.application_vnd_sqlite.SqliteParseConfig.datacache_config","title":"<code>datacache_config: Optional[DataCacheConfig] = Field(None, description='Configuration options for the local data cache.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.parse.application_vnd_sqlite.SqliteParseConfig.sqlquery","title":"<code>sqlquery: str = Field('', description='A SQL query string.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.parse.application_vnd_sqlite.SqliteParseStrategy","title":"<code>SqliteParseStrategy</code>","text":"<p>Parse strategy for SQLite.</p> <p>Registers strategies:</p> <ul> <li><code>(\"mediaType\", \"application/vnd.sqlite3\")</code></li> </ul> <p>Purpose of this strategy: Download a SQLite database using <code>downloadUrl</code> and run a SQL query on the database to return all relevant rows.</p> Source code in <code>oteapi/strategies/parse/application_vnd_sqlite.py</code> <pre><code>@dataclass\nclass SqliteParseStrategy:\n\"\"\"Parse strategy for SQLite.\n\n    **Registers strategies**:\n\n    - `(\"mediaType\", \"application/vnd.sqlite3\")`\n\n    Purpose of this strategy: Download a SQLite database using `downloadUrl` and run a\n    SQL query on the database to return all relevant rows.\n\n    \"\"\"\n\n    parse_config: SqliteParserResourceConfig\n\n    def initialize(self, session: \"Optional[Dict[str, Any]]\" = None) -&gt; SessionUpdate:\n\"\"\"Initialize strategy.\"\"\"\n        return SessionUpdate()\n\n    def get(\n        self, session: \"Optional[Dict[str, Any]]\" = None\n    ) -&gt; SessionUpdateSqLiteParse:\n\"\"\"Parse SQLite query responses.\"\"\"\n        if session:\n            self._use_filters(session)\n        session = session if session else {}\n\n        # Retrieve SQLite file\n        download_config = self.parse_config.copy()\n        del download_config.configuration\n        downloader = create_strategy(\"download\", download_config)\n        session.update(downloader.initialize(session))\n        cache_key = downloader.get(session).get(\"key\", \"\")\n\n        cache = DataCache(self.parse_config.configuration.datacache_config)\n        with cache.getfile(cache_key, suffix=\"db\") as filename:\n            connection = create_connection(filename)\n            cursor = connection.cursor()\n            result = cursor.execute(self.parse_config.configuration.sqlquery).fetchall()\n            connection.close()\n        return SessionUpdateSqLiteParse(result=result)\n\n    def _use_filters(self, session: \"Dict[str, Any]\") -&gt; None:\n\"\"\"Update `config` according to filter values found in the session.\"\"\"\n        if \"sqlquery\" in session and not self.parse_config.configuration.sqlquery:\n            # Use SQL query available in session\n            self.parse_config.configuration.sqlquery = session[\"sqlquery\"]\n</code></pre>"},{"location":"all_strategies/#oteapi.strategies.parse.application_vnd_sqlite.SqliteParseStrategy.parse_config","title":"<code>parse_config: SqliteParserResourceConfig</code>  <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.parse.application_vnd_sqlite.SqliteParseStrategy.get","title":"<code>get(session=None)</code>","text":"<p>Parse SQLite query responses.</p> Source code in <code>oteapi/strategies/parse/application_vnd_sqlite.py</code> <pre><code>def get(\n    self, session: \"Optional[Dict[str, Any]]\" = None\n) -&gt; SessionUpdateSqLiteParse:\n\"\"\"Parse SQLite query responses.\"\"\"\n    if session:\n        self._use_filters(session)\n    session = session if session else {}\n\n    # Retrieve SQLite file\n    download_config = self.parse_config.copy()\n    del download_config.configuration\n    downloader = create_strategy(\"download\", download_config)\n    session.update(downloader.initialize(session))\n    cache_key = downloader.get(session).get(\"key\", \"\")\n\n    cache = DataCache(self.parse_config.configuration.datacache_config)\n    with cache.getfile(cache_key, suffix=\"db\") as filename:\n        connection = create_connection(filename)\n        cursor = connection.cursor()\n        result = cursor.execute(self.parse_config.configuration.sqlquery).fetchall()\n        connection.close()\n    return SessionUpdateSqLiteParse(result=result)\n</code></pre>"},{"location":"all_strategies/#oteapi.strategies.parse.application_vnd_sqlite.SqliteParseStrategy.initialize","title":"<code>initialize(session=None)</code>","text":"<p>Initialize strategy.</p> Source code in <code>oteapi/strategies/parse/application_vnd_sqlite.py</code> <pre><code>def initialize(self, session: \"Optional[Dict[str, Any]]\" = None) -&gt; SessionUpdate:\n\"\"\"Initialize strategy.\"\"\"\n    return SessionUpdate()\n</code></pre>"},{"location":"all_strategies/#oteapi.strategies.parse.application_vnd_sqlite.SqliteParserResourceConfig","title":"<code>SqliteParserResourceConfig</code>","text":"<p>             Bases: <code>ResourceConfig</code></p> <p>SQLite parse strategy resource config.</p> Source code in <code>oteapi/strategies/parse/application_vnd_sqlite.py</code> <pre><code>class SqliteParserResourceConfig(ResourceConfig):\n\"\"\"SQLite parse strategy resource config.\"\"\"\n\n    mediaType: str = Field(\n        \"application/vnd.sqlite3\",\n        const=True,\n        description=ResourceConfig.__fields__[\"mediaType\"].field_info.description,\n    )\n    configuration: SqliteParseConfig = Field(\n        SqliteParseConfig(), description=\"SQLite parse strategy-specific configuration.\"\n    )\n</code></pre>"},{"location":"all_strategies/#oteapi.strategies.parse.application_vnd_sqlite.SqliteParserResourceConfig.configuration","title":"<code>configuration: SqliteParseConfig = Field(SqliteParseConfig(), description='SQLite parse strategy-specific configuration.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.parse.application_vnd_sqlite.SqliteParserResourceConfig.mediaType","title":"<code>mediaType: str = Field('application/vnd.sqlite3', const=True, description=ResourceConfig.__fields__['mediaType'].field_info.description)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.parse.application_vnd_sqlite.create_connection","title":"<code>create_connection(db_file)</code>","text":"<p>Create a database connection to SQLite database.</p> <p>Parameters:</p> Name Type Description Default <code>db_file</code> <code>Path</code> <p>Full path to SQLite database file.</p> required <p>Raises:</p> Type Description <code>Error</code> <p>If a DB connection cannot be made.</p> <p>Returns:</p> Type Description <code>Connection</code> <p>Connection object.</p> Source code in <code>oteapi/strategies/parse/application_vnd_sqlite.py</code> <pre><code>def create_connection(db_file: Path) -&gt; sqlite3.Connection:\n\"\"\"Create a database connection to SQLite database.\n\n    Parameters:\n        db_file: Full path to SQLite database file.\n\n    Raises:\n        sqlite3.Error: If a DB connection cannot be made.\n\n    Returns:\n        Connection object.\n\n    \"\"\"\n    try:\n        return sqlite3.connect(db_file)\n    except sqlite3.Error as exc:\n        raise sqlite3.Error(\"Could not connect to given SQLite DB.\") from exc\n</code></pre>"},{"location":"all_strategies/#oteapi.strategies.parse.excel_xlsx","title":"<code>excel_xlsx</code>","text":"<p>Strategy class for workbook/xlsx.</p>"},{"location":"all_strategies/#oteapi.strategies.parse.excel_xlsx.SessionUpdateXLSXParse","title":"<code>SessionUpdateXLSXParse</code>","text":"<p>             Bases: <code>SessionUpdate</code></p> <p>Class for returning values from XLSXParse.</p> Source code in <code>oteapi/strategies/parse/excel_xlsx.py</code> <pre><code>class SessionUpdateXLSXParse(SessionUpdate):\n\"\"\"Class for returning values from XLSXParse.\"\"\"\n\n    data: Dict[str, list] = Field(\n        ...,\n        description=\"A dict with column-name/column-value pairs. The values are lists.\",\n    )\n</code></pre>"},{"location":"all_strategies/#oteapi.strategies.parse.excel_xlsx.SessionUpdateXLSXParse.data","title":"<code>data: Dict[str, list] = Field(..., description='A dict with column-name/column-value pairs. The values are lists.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.parse.excel_xlsx.XLSXParseConfig","title":"<code>XLSXParseConfig</code>","text":"<p>             Bases: <code>AttrDict</code></p> <p>Data model for retrieving a rectangular section of an Excel sheet.</p> Source code in <code>oteapi/strategies/parse/excel_xlsx.py</code> <pre><code>class XLSXParseConfig(AttrDict):\n\"\"\"Data model for retrieving a rectangular section of an Excel sheet.\"\"\"\n\n    worksheet: str = Field(..., description=\"Name of worksheet to load.\")\n    row_from: Optional[int] = Field(\n        None,\n        description=\"Excel row number of first row. Defaults to first assigned row.\",\n    )\n    col_from: Optional[Union[int, str]] = Field(\n        None,\n        description=(\n            \"Excel column number or label of first column. Defaults to first assigned \"\n            \"column.\"\n        ),\n    )\n    row_to: Optional[int] = Field(\n        None, description=\"Excel row number of last row. Defaults to last assigned row.\"\n    )\n    col_to: Optional[Union[int, str]] = Field(\n        None,\n        description=(\n            \"Excel column number or label of last column. Defaults to last assigned \"\n            \"column.\"\n        ),\n    )\n    header_row: Optional[int] = Field(\n        None,\n        description=(\n            \"Row number with the headers. Defaults to `1` if header is given, \"\n            \"otherwise `None`.\"\n        ),\n    )\n    header: Optional[List[str]] = Field(\n        None,\n        description=(\n            \"Optional list of column names, specifying the columns to return. \"\n            \"These names they should match cells in `header_row`.\"\n        ),\n    )\n    new_header: Optional[List[str]] = Field(\n        None,\n        description=(\n            \"Optional list of new column names replacing `header` in the output.\"\n        ),\n    )\n    download_config: AttrDict = Field(\n        AttrDict(),\n        description=\"Configurations provided to a download strategy.\",\n    )\n    datacache_config: Optional[DataCacheConfig] = Field(\n        None,\n        description=(\n            \"Configurations for the data cache for retrieving the downloaded file \"\n            \"content.\"\n        ),\n    )\n</code></pre>"},{"location":"all_strategies/#oteapi.strategies.parse.excel_xlsx.XLSXParseConfig.col_from","title":"<code>col_from: Optional[Union[int, str]] = Field(None, description='Excel column number or label of first column. Defaults to first assigned column.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.parse.excel_xlsx.XLSXParseConfig.col_to","title":"<code>col_to: Optional[Union[int, str]] = Field(None, description='Excel column number or label of last column. Defaults to last assigned column.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.parse.excel_xlsx.XLSXParseConfig.datacache_config","title":"<code>datacache_config: Optional[DataCacheConfig] = Field(None, description='Configurations for the data cache for retrieving the downloaded file content.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.parse.excel_xlsx.XLSXParseConfig.download_config","title":"<code>download_config: AttrDict = Field(AttrDict(), description='Configurations provided to a download strategy.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.parse.excel_xlsx.XLSXParseConfig.header","title":"<code>header: Optional[List[str]] = Field(None, description='Optional list of column names, specifying the columns to return. These names they should match cells in `header_row`.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.parse.excel_xlsx.XLSXParseConfig.header_row","title":"<code>header_row: Optional[int] = Field(None, description='Row number with the headers. Defaults to `1` if header is given, otherwise `None`.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.parse.excel_xlsx.XLSXParseConfig.new_header","title":"<code>new_header: Optional[List[str]] = Field(None, description='Optional list of new column names replacing `header` in the output.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.parse.excel_xlsx.XLSXParseConfig.row_from","title":"<code>row_from: Optional[int] = Field(None, description='Excel row number of first row. Defaults to first assigned row.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.parse.excel_xlsx.XLSXParseConfig.row_to","title":"<code>row_to: Optional[int] = Field(None, description='Excel row number of last row. Defaults to last assigned row.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.parse.excel_xlsx.XLSXParseConfig.worksheet","title":"<code>worksheet: str = Field(..., description='Name of worksheet to load.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.parse.excel_xlsx.XLSXParseParserConfig","title":"<code>XLSXParseParserConfig</code>","text":"<p>             Bases: <code>ParserConfig</code></p> <p>XLSX parse strategy resource config.</p> Source code in <code>oteapi/strategies/parse/excel_xlsx.py</code> <pre><code>class XLSXParseParserConfig(ParserConfig):\n\"\"\"XLSX parse strategy resource config.\"\"\"\n\n    parserType: str = Field(\n        \"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\",\n        const=True,\n        description=ParserConfig.__fields__[\"parserType\"].field_info.description,\n    )\n    configuration: XLSXParseConfig = Field(\n        ..., description=\"SQLite parse strategy-specific configuration.\"\n    )\n</code></pre>"},{"location":"all_strategies/#oteapi.strategies.parse.excel_xlsx.XLSXParseParserConfig.configuration","title":"<code>configuration: XLSXParseConfig = Field(..., description='SQLite parse strategy-specific configuration.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.parse.excel_xlsx.XLSXParseParserConfig.parserType","title":"<code>parserType: str = Field('application/vnd.openxmlformats-officedocument.spreadsheetml.sheet', const=True, description=ParserConfig.__fields__['parserType'].field_info.description)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.parse.excel_xlsx.XLSXParseStrategy","title":"<code>XLSXParseStrategy</code>","text":"<p>Parse strategy for Excel XLSX files.</p> <p>Registers strategies:</p> <ul> <li><code>(\"parserType\", \"excel_xlsx\")</code></li> </ul> Source code in <code>oteapi/strategies/parse/excel_xlsx.py</code> <pre><code>@dataclass\nclass XLSXParseStrategy:\n\"\"\"Parse strategy for Excel XLSX files.\n\n    **Registers strategies**:\n\n    - `(\"parserType\", \"excel_xlsx\")`\n\n    \"\"\"\n\n    parse_config: XLSXParseParserConfig\n\n    def initialize(self, session: \"Optional[Dict[str, Any]]\" = None) -&gt; SessionUpdate:\n\"\"\"Initialize.\"\"\"\n        return SessionUpdate()\n\n    def get(self, session: \"Optional[Dict[str, Any]]\" = None) -&gt; SessionUpdateXLSXParse:\n\"\"\"Parses selected region of an excel file.\n\n        Returns:\n            A dict with column-name/column-value pairs. The values are lists.\n\n        \"\"\"\n\n        cache = DataCache(self.parse_config.configuration.datacache_config)\n        if session is None:\n            raise ValueError(\"Missing session\")\n        with cache.getfile(key=session[\"key\"], suffix=\".xlsx\") as filename:\n            # Note that we have to set read_only=False to ensure that\n            # load_workbook() properly closes the xlsx file after reading.\n            # Otherwise Windows will fail when the temporary file is removed\n            # when leaving the with statement.\n            workbook = load_workbook(filename=filename, read_only=False, data_only=True)\n\n        worksheet = workbook[self.parse_config.configuration.worksheet]\n        set_model_defaults(self.parse_config.configuration, worksheet)\n        columns = get_column_indices(self.parse_config.configuration, worksheet)\n\n        data = []\n        for row in worksheet.iter_rows(\n            min_row=self.parse_config.configuration.row_from,\n            max_row=self.parse_config.configuration.row_to,\n            min_col=min(columns),\n            max_col=max(columns),\n        ):\n            data.append([row[c - 1].value for c in columns])\n\n        if self.parse_config.configuration.header_row:\n            row = worksheet.iter_rows(\n                min_row=self.parse_config.configuration.header_row,\n                max_row=self.parse_config.configuration.header_row,\n                min_col=min(columns),\n                max_col=max(columns),\n            ).__next__()\n            header = [row[c - 1].value for c in columns]\n        else:\n            header = None\n\n        if self.parse_config.configuration.new_header:\n            nhead = len(header) if header else len(data[0]) if data else 0\n            if len(self.parse_config.configuration.new_header) != nhead:\n                raise TypeError(\n                    \"length of `new_header` \"\n                    f\"(={len(self.parse_config.configuration.new_header)}) \"\n                    f\"doesn't match number of columns (={len(header) if header else 0})\"\n                )\n            if header:\n                for i, val in enumerate(self.parse_config.configuration.new_header):\n                    if val is not None:\n                        header[i] = val\n            elif data:\n                header = self.parse_config.configuration.new_header\n\n        if header is None:\n            header = [get_column_letter(col + 1) for col in range(len(data))]\n\n        transposed = [list(datum) for datum in zip(*data)]\n        return SessionUpdateXLSXParse(\n            data={key: value for key, value in zip(header, transposed)}\n        )\n</code></pre>"},{"location":"all_strategies/#oteapi.strategies.parse.excel_xlsx.XLSXParseStrategy.parse_config","title":"<code>parse_config: XLSXParseParserConfig</code>  <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.parse.excel_xlsx.XLSXParseStrategy.get","title":"<code>get(session=None)</code>","text":"<p>Parses selected region of an excel file.</p> <p>Returns:</p> Type Description <code>SessionUpdateXLSXParse</code> <p>A dict with column-name/column-value pairs. The values are lists.</p> Source code in <code>oteapi/strategies/parse/excel_xlsx.py</code> <pre><code>def get(self, session: \"Optional[Dict[str, Any]]\" = None) -&gt; SessionUpdateXLSXParse:\n\"\"\"Parses selected region of an excel file.\n\n    Returns:\n        A dict with column-name/column-value pairs. The values are lists.\n\n    \"\"\"\n\n    cache = DataCache(self.parse_config.configuration.datacache_config)\n    if session is None:\n        raise ValueError(\"Missing session\")\n    with cache.getfile(key=session[\"key\"], suffix=\".xlsx\") as filename:\n        # Note that we have to set read_only=False to ensure that\n        # load_workbook() properly closes the xlsx file after reading.\n        # Otherwise Windows will fail when the temporary file is removed\n        # when leaving the with statement.\n        workbook = load_workbook(filename=filename, read_only=False, data_only=True)\n\n    worksheet = workbook[self.parse_config.configuration.worksheet]\n    set_model_defaults(self.parse_config.configuration, worksheet)\n    columns = get_column_indices(self.parse_config.configuration, worksheet)\n\n    data = []\n    for row in worksheet.iter_rows(\n        min_row=self.parse_config.configuration.row_from,\n        max_row=self.parse_config.configuration.row_to,\n        min_col=min(columns),\n        max_col=max(columns),\n    ):\n        data.append([row[c - 1].value for c in columns])\n\n    if self.parse_config.configuration.header_row:\n        row = worksheet.iter_rows(\n            min_row=self.parse_config.configuration.header_row,\n            max_row=self.parse_config.configuration.header_row,\n            min_col=min(columns),\n            max_col=max(columns),\n        ).__next__()\n        header = [row[c - 1].value for c in columns]\n    else:\n        header = None\n\n    if self.parse_config.configuration.new_header:\n        nhead = len(header) if header else len(data[0]) if data else 0\n        if len(self.parse_config.configuration.new_header) != nhead:\n            raise TypeError(\n                \"length of `new_header` \"\n                f\"(={len(self.parse_config.configuration.new_header)}) \"\n                f\"doesn't match number of columns (={len(header) if header else 0})\"\n            )\n        if header:\n            for i, val in enumerate(self.parse_config.configuration.new_header):\n                if val is not None:\n                    header[i] = val\n        elif data:\n            header = self.parse_config.configuration.new_header\n\n    if header is None:\n        header = [get_column_letter(col + 1) for col in range(len(data))]\n\n    transposed = [list(datum) for datum in zip(*data)]\n    return SessionUpdateXLSXParse(\n        data={key: value for key, value in zip(header, transposed)}\n    )\n</code></pre>"},{"location":"all_strategies/#oteapi.strategies.parse.excel_xlsx.XLSXParseStrategy.initialize","title":"<code>initialize(session=None)</code>","text":"<p>Initialize.</p> Source code in <code>oteapi/strategies/parse/excel_xlsx.py</code> <pre><code>def initialize(self, session: \"Optional[Dict[str, Any]]\" = None) -&gt; SessionUpdate:\n\"\"\"Initialize.\"\"\"\n    return SessionUpdate()\n</code></pre>"},{"location":"all_strategies/#oteapi.strategies.parse.excel_xlsx.get_column_indices","title":"<code>get_column_indices(model, worksheet)</code>","text":"<p>Helper function returning a list of column indices.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>XLSXParseConfig</code> <p>The parsed data model.</p> required <code>worksheet</code> <code>Worksheet</code> <p>Excel worksheet, from which the header values will be retrieved.</p> required <p>Returns:</p> Type Description <code>Iterable[int]</code> <p>A list of column indices.</p> Source code in <code>oteapi/strategies/parse/excel_xlsx.py</code> <pre><code>def get_column_indices(\n    model: XLSXParseConfig, worksheet: \"Worksheet\"\n) -&gt; \"Iterable[int]\":\n\"\"\"Helper function returning a list of column indices.\n\n    Parameters:\n        model: The parsed data model.\n        worksheet: Excel worksheet, from which the header values will be retrieved.\n\n    Returns:\n        A list of column indices.\n\n    \"\"\"\n    if not isinstance(model.col_from, int) or not isinstance(model.col_to, int):\n        raise TypeError(\"Expected `model.col_from` and `model.col_to` to be integers.\")\n\n    if model.header:\n        header_dict = {\n            worksheet.cell(model.header_row, col).value: col\n            for col in range(model.col_from, model.col_to + 1)\n        }\n        return [header_dict[h] for h in model.header]\n    return range(model.col_from, model.col_to + 1)\n</code></pre>"},{"location":"all_strategies/#oteapi.strategies.parse.excel_xlsx.set_model_defaults","title":"<code>set_model_defaults(model, worksheet)</code>","text":"<p>Update data model <code>model</code> with default values obtained from <code>worksheet</code>.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>XLSXParseConfig</code> <p>The parsed data model.</p> required <code>worksheet</code> <code>Worksheet</code> <p>Excel worksheet, from which the default values will be obtained.</p> required Source code in <code>oteapi/strategies/parse/excel_xlsx.py</code> <pre><code>def set_model_defaults(model: XLSXParseConfig, worksheet: \"Worksheet\") -&gt; None:\n\"\"\"Update data model `model` with default values obtained from `worksheet`.\n\n    Parameters:\n        model: The parsed data model.\n        worksheet: Excel worksheet, from which the default values will be obtained.\n\n    \"\"\"\n    if model.row_from is None:\n        if model.header:\n            # assume that data starts on the first row after the header\n            model.row_from = model.header_row + 1 if model.header_row else 1\n        else:\n            model.row_from = worksheet.min_row\n\n    if model.row_to is None:\n        model.row_to = worksheet.max_row\n\n    if model.col_from is None:\n        model.col_from = worksheet.min_column\n    elif isinstance(model.col_from, str):\n        model.col_from = column_index_from_string(model.col_from)\n\n    if model.col_to is None:\n        model.col_to = worksheet.max_column\n    elif isinstance(model.col_to, str):\n        model.col_to = column_index_from_string(model.col_to)\n\n    if model.header and not model.header_row:\n        model.header_row = 1\n</code></pre>"},{"location":"all_strategies/#oteapi.strategies.parse.image","title":"<code>image</code>","text":"<p>Strategy class for image/jpg.</p>"},{"location":"all_strategies/#oteapi.strategies.parse.image.ImageDataParseStrategy","title":"<code>ImageDataParseStrategy</code>","text":"<p>Parse strategy for images.</p> <p>This strategy uses Pillow to read a raw image from the data cache, converts it into a NumPy array and stores the new array in the data cache.</p> <p>It also supports simple cropping and image conversions.</p> <p>The key to the new array and other metadata is stored in the session. See <code>SessionUpdateImageParse</code> for more info.</p> <p>Registers strategies:</p> <ul> <li><code>(\"mediaType\", \"image/jpg\")</code></li> <li><code>(\"mediaType\", \"image/jpeg\")</code></li> <li><code>(\"mediaType\", \"image/jp2\")</code></li> <li><code>(\"mediaType\", \"image/png\")</code></li> <li><code>(\"mediaType\", \"image/gif\")</code></li> <li><code>(\"mediaType\", \"image/tiff\")</code></li> <li><code>(\"mediaType\", \"image/eps\")</code></li> </ul> Source code in <code>oteapi/strategies/parse/image.py</code> <pre><code>@dataclass\nclass ImageDataParseStrategy:\n\"\"\"Parse strategy for images.\n\n    This strategy uses Pillow to read a raw image from the data cache,\n    converts it into a NumPy array and stores the new array in the\n    data cache.\n\n    It also supports simple cropping and image conversions.\n\n    The key to the new array and other metadata is stored in the session. See\n    [`SessionUpdateImageParse`][oteapi.strategies.parse.image.SessionUpdateImageParse]\n    for more info.\n\n    **Registers strategies**:\n\n    - `(\"mediaType\", \"image/jpg\")`\n    - `(\"mediaType\", \"image/jpeg\")`\n    - `(\"mediaType\", \"image/jp2\")`\n    - `(\"mediaType\", \"image/png\")`\n    - `(\"mediaType\", \"image/gif\")`\n    - `(\"mediaType\", \"image/tiff\")`\n    - `(\"mediaType\", \"image/eps\")`\n\n    \"\"\"\n\n    parse_config: ImageParserResourceConfig\n\n    def initialize(self, session: \"Optional[Dict[str, Any]]\" = None) -&gt; SessionUpdate:\n\"\"\"Initialize strategy.\"\"\"\n        return SessionUpdate()\n\n    def get(\n        self, session: \"Optional[Dict[str, Any]]\" = None\n    ) -&gt; SessionUpdateImageParse:\n\"\"\"Execute the strategy.\"\"\"\n        if not session:\n            session = {}\n\n        config = self.parse_config.configuration\n        crop = config.crop if config.crop else session.get(\"imagecrop\")\n\n        mime_format = self.parse_config.mediaType.split(\"/\")[1]\n        image_format = SupportedFormat[mime_format].value\n\n        # Proper download configurations\n        conf = self.parse_config.dict()\n        conf[\"configuration\"] = config.download_config or {}\n        download_config = ResourceConfig(**conf)\n\n        downloader = create_strategy(\"download\", download_config)\n        session.update(downloader.initialize(session))\n\n        downloader = create_strategy(\"download\", download_config)\n        output = downloader.get(session)\n        session.update(output)\n\n        if config.datacache_config and config.datacache_config.accessKey:\n            cache_key = config.datacache_config.accessKey\n        elif \"key\" in output:\n            cache_key = output[\"key\"]\n        else:\n            raise RuntimeError(\"No data cache key provided to the downloaded content\")\n\n        cache = DataCache(config.datacache_config)\n\n        # Treat image according to filter values\n        with cache.getfile(cache_key, suffix=mime_format) as filename:\n            image = Image.open(filename, formats=[image_format])\n            if crop:\n                image = image.crop(crop)\n            if config.image_mode:\n                image = image.convert(mode=config.image_mode)\n\n            if image_format == \"GIF\":\n                if image.info.get(\"version\", b\"\").startswith(b\"GIF\"):\n                    image.info.update(\n                        {\"version\": image.info.get(\"version\", b\"\")[len(b\"GIF\") :]}\n                    )\n\n            # Use the buffer protocol to store the image in the datacache\n            data = np.asarray(image)\n            image_key = cache.add(\n                data,\n                key=config.image_key,\n                tag=str(id(session)),\n            )\n\n            if image.mode == \"P\":\n                image_palette_key = cache.add(\n                    np.asarray(image.getpalette()), tag=str(id(session))\n                )\n            else:\n                image_palette_key = None\n\n            # The session must be json serialisable - filter out all\n            # non-json serialisable fields in image.info\n            if image.info:\n                image_info = {\n                    key: val\n                    for key, val in image.info.items()\n                    if isinstance(val, (str, int, float, type(None), bool, tuple, list))\n                }\n            else:\n                image_info = {}\n\n            session_update = SessionUpdateImageParse(\n                image_key=image_key,\n                image_size=image.size,\n                image_mode=image.mode,\n                image_palette_key=image_palette_key,\n                image_info=image_info,\n            )\n\n            # Explicitly close the image to avoid crashes on Windows\n            image.close()\n\n        return session_update\n</code></pre>"},{"location":"all_strategies/#oteapi.strategies.parse.image.ImageDataParseStrategy.parse_config","title":"<code>parse_config: ImageParserResourceConfig</code>  <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.parse.image.ImageDataParseStrategy.get","title":"<code>get(session=None)</code>","text":"<p>Execute the strategy.</p> Source code in <code>oteapi/strategies/parse/image.py</code> <pre><code>def get(\n    self, session: \"Optional[Dict[str, Any]]\" = None\n) -&gt; SessionUpdateImageParse:\n\"\"\"Execute the strategy.\"\"\"\n    if not session:\n        session = {}\n\n    config = self.parse_config.configuration\n    crop = config.crop if config.crop else session.get(\"imagecrop\")\n\n    mime_format = self.parse_config.mediaType.split(\"/\")[1]\n    image_format = SupportedFormat[mime_format].value\n\n    # Proper download configurations\n    conf = self.parse_config.dict()\n    conf[\"configuration\"] = config.download_config or {}\n    download_config = ResourceConfig(**conf)\n\n    downloader = create_strategy(\"download\", download_config)\n    session.update(downloader.initialize(session))\n\n    downloader = create_strategy(\"download\", download_config)\n    output = downloader.get(session)\n    session.update(output)\n\n    if config.datacache_config and config.datacache_config.accessKey:\n        cache_key = config.datacache_config.accessKey\n    elif \"key\" in output:\n        cache_key = output[\"key\"]\n    else:\n        raise RuntimeError(\"No data cache key provided to the downloaded content\")\n\n    cache = DataCache(config.datacache_config)\n\n    # Treat image according to filter values\n    with cache.getfile(cache_key, suffix=mime_format) as filename:\n        image = Image.open(filename, formats=[image_format])\n        if crop:\n            image = image.crop(crop)\n        if config.image_mode:\n            image = image.convert(mode=config.image_mode)\n\n        if image_format == \"GIF\":\n            if image.info.get(\"version\", b\"\").startswith(b\"GIF\"):\n                image.info.update(\n                    {\"version\": image.info.get(\"version\", b\"\")[len(b\"GIF\") :]}\n                )\n\n        # Use the buffer protocol to store the image in the datacache\n        data = np.asarray(image)\n        image_key = cache.add(\n            data,\n            key=config.image_key,\n            tag=str(id(session)),\n        )\n\n        if image.mode == \"P\":\n            image_palette_key = cache.add(\n                np.asarray(image.getpalette()), tag=str(id(session))\n            )\n        else:\n            image_palette_key = None\n\n        # The session must be json serialisable - filter out all\n        # non-json serialisable fields in image.info\n        if image.info:\n            image_info = {\n                key: val\n                for key, val in image.info.items()\n                if isinstance(val, (str, int, float, type(None), bool, tuple, list))\n            }\n        else:\n            image_info = {}\n\n        session_update = SessionUpdateImageParse(\n            image_key=image_key,\n            image_size=image.size,\n            image_mode=image.mode,\n            image_palette_key=image_palette_key,\n            image_info=image_info,\n        )\n\n        # Explicitly close the image to avoid crashes on Windows\n        image.close()\n\n    return session_update\n</code></pre>"},{"location":"all_strategies/#oteapi.strategies.parse.image.ImageDataParseStrategy.initialize","title":"<code>initialize(session=None)</code>","text":"<p>Initialize strategy.</p> Source code in <code>oteapi/strategies/parse/image.py</code> <pre><code>def initialize(self, session: \"Optional[Dict[str, Any]]\" = None) -&gt; SessionUpdate:\n\"\"\"Initialize strategy.\"\"\"\n    return SessionUpdate()\n</code></pre>"},{"location":"all_strategies/#oteapi.strategies.parse.image.ImageParserConfig","title":"<code>ImageParserConfig</code>","text":"<p>             Bases: <code>AttrDict</code></p> <p>Configuration data model for <code>ImageDataParseStrategy</code>.</p> Source code in <code>oteapi/strategies/parse/image.py</code> <pre><code>class ImageParserConfig(AttrDict):\n\"\"\"Configuration data model for\n    [`ImageDataParseStrategy`][oteapi.strategies.parse.image.ImageDataParseStrategy].\"\"\"\n\n    crop: Optional[Tuple[int, int, int, int]] = Field(\n        None,\n        description=\"Box cropping parameters (left, top, right, bottom).\",\n    )\n    datacache_config: Optional[DataCacheConfig] = Field(\n        None,\n        description=\"Configuration options for the local data cache.\",\n    )\n    download_config: AttrDict = Field(\n        AttrDict(),\n        description=\"Configurations passed to the downloader.\",\n    )\n    image_key: Optional[str] = Field(\n        None,\n        description=\"Key to use when storing the image data in datacache.\",\n    )\n    image_mode: Optional[str] = Field(\n        None,\n        description=(\n            \"Pillow mode to convert image into. See \"\n            \"https://pillow.readthedocs.io/en/stable/handbook/concepts.html \"\n            \"for details.\"\n        ),\n    )\n</code></pre>"},{"location":"all_strategies/#oteapi.strategies.parse.image.ImageParserConfig.crop","title":"<code>crop: Optional[Tuple[int, int, int, int]] = Field(None, description='Box cropping parameters (left, top, right, bottom).')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.parse.image.ImageParserConfig.datacache_config","title":"<code>datacache_config: Optional[DataCacheConfig] = Field(None, description='Configuration options for the local data cache.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.parse.image.ImageParserConfig.download_config","title":"<code>download_config: AttrDict = Field(AttrDict(), description='Configurations passed to the downloader.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.parse.image.ImageParserConfig.image_key","title":"<code>image_key: Optional[str] = Field(None, description='Key to use when storing the image data in datacache.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.parse.image.ImageParserConfig.image_mode","title":"<code>image_mode: Optional[str] = Field(None, description='Pillow mode to convert image into. See https://pillow.readthedocs.io/en/stable/handbook/concepts.html for details.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.parse.image.ImageParserResourceConfig","title":"<code>ImageParserResourceConfig</code>","text":"<p>             Bases: <code>ResourceConfig</code></p> <p>Image parse strategy resource config.</p> Source code in <code>oteapi/strategies/parse/image.py</code> <pre><code>class ImageParserResourceConfig(ResourceConfig):\n\"\"\"Image parse strategy resource config.\"\"\"\n\n    mediaType: Literal[\n        \"image/jpg\",\n        \"image/jpeg\",\n        \"image/jp2\",\n        \"image/png\",\n        \"image/gif\",\n        \"image/tiff\",\n        \"image/eps\",\n    ] = Field(\n        ...,\n        description=ResourceConfig.__fields__[\"mediaType\"].field_info.description,\n    )\n    configuration: ImageParserConfig = Field(\n        ImageParserConfig(),\n        description=\"Image parse strategy-specific configuration.\",\n    )\n</code></pre>"},{"location":"all_strategies/#oteapi.strategies.parse.image.ImageParserResourceConfig.configuration","title":"<code>configuration: ImageParserConfig = Field(ImageParserConfig(), description='Image parse strategy-specific configuration.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.parse.image.ImageParserResourceConfig.mediaType","title":"<code>mediaType: Literal['image/jpg', 'image/jpeg', 'image/jp2', 'image/png', 'image/gif', 'image/tiff', 'image/eps'] = Field(..., description=ResourceConfig.__fields__['mediaType'].field_info.description)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.parse.image.SessionUpdateImageParse","title":"<code>SessionUpdateImageParse</code>","text":"<p>             Bases: <code>SessionUpdate</code></p> <p>Configuration model for ImageParse.</p> <p>See Pillow handbook for more details on <code>image_mode</code>, <code>image_palette</code>, and <code>image_info</code>.</p> Source code in <code>oteapi/strategies/parse/image.py</code> <pre><code>class SessionUpdateImageParse(SessionUpdate):\n\"\"\"Configuration model for ImageParse.\n\n    See\n    [Pillow handbook](https://pillow.readthedocs.io/en/stable/handbook/concepts.html)\n    for more details on `image_mode`, `image_palette`, and `image_info`.\n    \"\"\"\n\n    image_key: str = Field(\n        ...,\n        description=\"Key with which the image content is stored in the data cache.\",\n    )\n    image_size: Tuple[int, int] = Field(\n        ...,\n        description=\"Image size (width, height).\",\n    )\n    image_mode: str = Field(\n        ...,\n        description=\"Image mode. Examples: 'L', 'P', 'RGB', 'RGBA'...\",\n    )\n    image_palette_key: Optional[str] = Field(\n        None,\n        description=\"Datacache key for colour palette if mode is 'P'.\",\n    )\n    image_info: dict = Field(\n        {},\n        description=\"Additional information about the image.\",\n    )\n</code></pre>"},{"location":"all_strategies/#oteapi.strategies.parse.image.SessionUpdateImageParse.image_info","title":"<code>image_info: dict = Field({}, description='Additional information about the image.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.parse.image.SessionUpdateImageParse.image_key","title":"<code>image_key: str = Field(..., description='Key with which the image content is stored in the data cache.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.parse.image.SessionUpdateImageParse.image_mode","title":"<code>image_mode: str = Field(..., description=\"Image mode. Examples: 'L', 'P', 'RGB', 'RGBA'...\")</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.parse.image.SessionUpdateImageParse.image_palette_key","title":"<code>image_palette_key: Optional[str] = Field(None, description=\"Datacache key for colour palette if mode is 'P'.\")</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.parse.image.SessionUpdateImageParse.image_size","title":"<code>image_size: Tuple[int, int] = Field(..., description='Image size (width, height).')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.parse.image.SupportedFormat","title":"<code>SupportedFormat</code>","text":"<p>             Bases: <code>Enum</code></p> <p>Supported formats for <code>ImageDataParseStrategy</code>.</p> Source code in <code>oteapi/strategies/parse/image.py</code> <pre><code>class SupportedFormat(Enum):\n\"\"\"Supported formats for `ImageDataParseStrategy`.\"\"\"\n\n    jpeg = \"JPEG\"\n    jpg = \"JPEG\"\n    jp2 = \"JPEG2000\"\n    png = \"PNG\"\n    gif = \"GIF\"\n    tiff = \"TIFF\"\n    eps = \"EPS\"\n</code></pre>"},{"location":"all_strategies/#oteapi.strategies.parse.image.SupportedFormat.eps","title":"<code>eps = 'EPS'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.parse.image.SupportedFormat.gif","title":"<code>gif = 'GIF'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.parse.image.SupportedFormat.jp2","title":"<code>jp2 = 'JPEG2000'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.parse.image.SupportedFormat.jpeg","title":"<code>jpeg = 'JPEG'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.parse.image.SupportedFormat.jpg","title":"<code>jpg = 'JPEG'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.parse.image.SupportedFormat.png","title":"<code>png = 'PNG'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.parse.image.SupportedFormat.tiff","title":"<code>tiff = 'TIFF'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.parse.postgres","title":"<code>postgres</code>","text":"<p>Strategy class for application/vnd.postgresql</p>"},{"location":"all_strategies/#oteapi.strategies.parse.postgres.PostgresConfig","title":"<code>PostgresConfig</code>","text":"<p>             Bases: <code>AttrDict</code></p> <p>Configuration data model for <code>PostgresResourceStrategy</code>.</p> Source code in <code>oteapi/strategies/parse/postgres.py</code> <pre><code>class PostgresConfig(AttrDict):\n\"\"\"Configuration data model for\n    [`PostgresResourceStrategy`][oteapi.strategies.parse.postgres.PostgresResourceConfig].\n    \"\"\"\n\n    user: Optional[str] = Field(None, description=\"postgres server username\")\n    dbname: Optional[str] = Field(None, description=\"postgres dbname name\")\n    password: Optional[str] = Field(None, description=\"postgres password\")\n\n    sqlquery: Optional[str] = Field(\"\", description=\"A SQL query string.\")\n</code></pre>"},{"location":"all_strategies/#oteapi.strategies.parse.postgres.PostgresConfig.dbname","title":"<code>dbname: Optional[str] = Field(None, description='postgres dbname name')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.parse.postgres.PostgresConfig.password","title":"<code>password: Optional[str] = Field(None, description='postgres password')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.parse.postgres.PostgresConfig.sqlquery","title":"<code>sqlquery: Optional[str] = Field('', description='A SQL query string.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.parse.postgres.PostgresConfig.user","title":"<code>user: Optional[str] = Field(None, description='postgres server username')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.parse.postgres.PostgresResourceConfig","title":"<code>PostgresResourceConfig</code>","text":"<p>             Bases: <code>ResourceConfig</code></p> <p>Postgresql parse strategy config</p> Source code in <code>oteapi/strategies/parse/postgres.py</code> <pre><code>class PostgresResourceConfig(ResourceConfig):\n\"\"\"Postgresql parse strategy config\"\"\"\n\n    configuration: PostgresConfig = Field(\n        PostgresConfig(),\n        description=(\n            \"Configuration for resource. \" \"Values in the accessURL take precedence.\"\n        ),\n    )\n    datacache_config: Optional[DataCacheConfig] = Field(\n        None,\n        description=\"Configuration options for the local data cache.\",\n    )\n\n    @classmethod\n    def _urlconstruct(\n        cls,  # PEP8 - Always use cls for the first argument to class methods.\n        scheme: Optional[str] = \"\",  # Schema defining link format\n        user: Optional[str] = None,  # Username\n        password: Optional[str] = None,  # Password\n        host: Optional[str] = None,\n        port: Optional[int] = None,\n        path: Optional[str] = \"\",\n        params: Optional[str] = \"\",\n        query: Optional[str] = \"\",\n        fragment: Optional[str] = \"\",\n    ):\n\"\"\"Construct a pydantic AnyUrl based on the given URL properties\"\"\"\n\n        # Hostname should always be given\n        if not host:\n            raise ValueError(\"hostname must be specified\")\n\n        # Update netloc of username or username|password pair is defined\n        netloc = host\n        if user and not password:  # Only username is provided. OK\n            netloc = f\"{user}@{host}\"\n        elif user and password:  # Username and password is provided. OK\n            netloc = f\"{user}:{password}@{host}\"\n        else:  # Password and no username is provided. ERROR\n            raise ValueError(\"username not provided\")\n\n        # Append port if port is defined\n        netloc = netloc if not port else f\"{netloc}:{port}\"\n\n        # Construct a URL from a tuple of URL-properties\n        unparsed = urlunparse([scheme, netloc, path, params, query, fragment])\n\n        # Populate and return a Pydantic URL\n        return parse_obj_as(AnyUrl, unparsed)\n\n    @root_validator\n    def adjust_url(cls, values):\n\"\"\"Root Validator\n        Verifies configuration consistency, merge configurations\n        and update the accessUrl property.\n        \"\"\"\n\n        # Copy model-state into placeholders\n        config = values.get(\"configuration\")\n        accessUrl = values[\"accessUrl\"]\n\n        # Check and merge user configuration\n        user = accessUrl.user if accessUrl.user else config[\"user\"]\n        if config[\"user\"] and user != config[\"user\"]:\n            raise ValueError(\"mismatching username in accessUrl and configuration\")\n\n        # Check and merge password configuration\n        password = accessUrl.password if accessUrl.password else config[\"password\"]\n        if config[\"password\"] and password != config[\"password\"]:\n            raise ValueError(\"mismatching password in accessUrl and configuration\")\n\n        # Check and merge database name configuration\n        dbname = accessUrl.path if accessUrl.path else config[\"dbname\"]\n        if config[\"dbname\"] and dbname != config[\"dbname\"]:\n            raise ValueError(\"mismatching dbname in accessUrl and configuration\")\n\n        # Reconstruct accessUrl from the updated properties\n        values[\"accessUrl\"] = cls._urlconstruct(\n            scheme=accessUrl.scheme,\n            host=accessUrl.host,\n            port=accessUrl.port,\n            user=user,\n            password=password,\n        )\n        return values\n</code></pre>"},{"location":"all_strategies/#oteapi.strategies.parse.postgres.PostgresResourceConfig.configuration","title":"<code>configuration: PostgresConfig = Field(PostgresConfig(), description='Configuration for resource. Values in the accessURL take precedence.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.parse.postgres.PostgresResourceConfig.datacache_config","title":"<code>datacache_config: Optional[DataCacheConfig] = Field(None, description='Configuration options for the local data cache.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.parse.postgres.PostgresResourceConfig.adjust_url","title":"<code>adjust_url(values)</code>","text":"<p>Root Validator Verifies configuration consistency, merge configurations and update the accessUrl property.</p> Source code in <code>oteapi/strategies/parse/postgres.py</code> <pre><code>@root_validator\ndef adjust_url(cls, values):\n\"\"\"Root Validator\n    Verifies configuration consistency, merge configurations\n    and update the accessUrl property.\n    \"\"\"\n\n    # Copy model-state into placeholders\n    config = values.get(\"configuration\")\n    accessUrl = values[\"accessUrl\"]\n\n    # Check and merge user configuration\n    user = accessUrl.user if accessUrl.user else config[\"user\"]\n    if config[\"user\"] and user != config[\"user\"]:\n        raise ValueError(\"mismatching username in accessUrl and configuration\")\n\n    # Check and merge password configuration\n    password = accessUrl.password if accessUrl.password else config[\"password\"]\n    if config[\"password\"] and password != config[\"password\"]:\n        raise ValueError(\"mismatching password in accessUrl and configuration\")\n\n    # Check and merge database name configuration\n    dbname = accessUrl.path if accessUrl.path else config[\"dbname\"]\n    if config[\"dbname\"] and dbname != config[\"dbname\"]:\n        raise ValueError(\"mismatching dbname in accessUrl and configuration\")\n\n    # Reconstruct accessUrl from the updated properties\n    values[\"accessUrl\"] = cls._urlconstruct(\n        scheme=accessUrl.scheme,\n        host=accessUrl.host,\n        port=accessUrl.port,\n        user=user,\n        password=password,\n    )\n    return values\n</code></pre>"},{"location":"all_strategies/#oteapi.strategies.parse.postgres.PostgresResourceStrategy","title":"<code>PostgresResourceStrategy</code>","text":"<p>Resource strategy for Postgres.</p> <p>Registers strategies:</p> <ul> <li><code>(\"accessService\", \"postgres\")</code></li> </ul> <p>Purpose of this strategy: Connect to a postgres DB and run a SQL query on the dbname to return all relevant rows.</p> Source code in <code>oteapi/strategies/parse/postgres.py</code> <pre><code>@dataclass\nclass PostgresResourceStrategy:\n\"\"\"Resource strategy for Postgres.\n\n    **Registers strategies**:\n\n    - `(\"accessService\", \"postgres\")`\n\n    Purpose of this strategy: Connect to a postgres DB and run a\n    SQL query on the dbname to return all relevant rows.\n\n    \"\"\"\n\n    resource_config: PostgresResourceConfig\n\n    def initialize(self, session: \"Optional[Dict[str, Any]]\" = None) -&gt; SessionUpdate:\n\"\"\"Initialize strategy.\"\"\"\n        return SessionUpdate()\n\n    def get(\n        self, session: \"Optional[Dict[str, Any]]\" = None\n    ) -&gt; SessionUpdatePostgresResource:\n\"\"\"Resource Postgres query responses.\"\"\"\n        if session:\n            self._use_filters(session)\n        session = session if session else {}\n\n        connection = create_connection(self.resource_config)\n        cursor = connection.cursor()\n        result = cursor.execute(self.resource_config.configuration.sqlquery).fetchall()\n        connection.close()\n        return SessionUpdatePostgresResource(result=result)\n\n    def _use_filters(self, session: \"Dict[str, Any]\") -&gt; None:\n\"\"\"Update `config` according to filter values found in the session.\"\"\"\n        if \"sqlquery\" in session and not self.resource_config.configuration.sqlquery:\n            # Use SQL query available in session\n            self.resource_config.configuration.sqlquery = session[\"sqlquery\"]\n</code></pre>"},{"location":"all_strategies/#oteapi.strategies.parse.postgres.PostgresResourceStrategy.resource_config","title":"<code>resource_config: PostgresResourceConfig</code>  <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.parse.postgres.PostgresResourceStrategy.get","title":"<code>get(session=None)</code>","text":"<p>Resource Postgres query responses.</p> Source code in <code>oteapi/strategies/parse/postgres.py</code> <pre><code>def get(\n    self, session: \"Optional[Dict[str, Any]]\" = None\n) -&gt; SessionUpdatePostgresResource:\n\"\"\"Resource Postgres query responses.\"\"\"\n    if session:\n        self._use_filters(session)\n    session = session if session else {}\n\n    connection = create_connection(self.resource_config)\n    cursor = connection.cursor()\n    result = cursor.execute(self.resource_config.configuration.sqlquery).fetchall()\n    connection.close()\n    return SessionUpdatePostgresResource(result=result)\n</code></pre>"},{"location":"all_strategies/#oteapi.strategies.parse.postgres.PostgresResourceStrategy.initialize","title":"<code>initialize(session=None)</code>","text":"<p>Initialize strategy.</p> Source code in <code>oteapi/strategies/parse/postgres.py</code> <pre><code>def initialize(self, session: \"Optional[Dict[str, Any]]\" = None) -&gt; SessionUpdate:\n\"\"\"Initialize strategy.\"\"\"\n    return SessionUpdate()\n</code></pre>"},{"location":"all_strategies/#oteapi.strategies.parse.postgres.SessionUpdatePostgresResource","title":"<code>SessionUpdatePostgresResource</code>","text":"<p>             Bases: <code>SessionUpdate</code></p> <p>Configuration model for PostgresResource.</p> Source code in <code>oteapi/strategies/parse/postgres.py</code> <pre><code>class SessionUpdatePostgresResource(SessionUpdate):\n\"\"\"Configuration model for PostgresResource.\"\"\"\n\n    result: list = Field(..., description=\"List of results from the query.\")\n</code></pre>"},{"location":"all_strategies/#oteapi.strategies.parse.postgres.SessionUpdatePostgresResource.result","title":"<code>result: list = Field(..., description='List of results from the query.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.parse.postgres.create_connection","title":"<code>create_connection(resource_config)</code>","text":"<p>Create a dbname connection to Postgres dbname.</p> <p>Parameters:</p> Name Type Description Default <code>resource_config</code> <code>PostgresResourceConfig</code> <p>A dictionary providing everything needed for a psycopg          connection configuration</p> required <p>Raises:</p> Type Description <code>Error</code> <p>If a DB connection cannot be made.</p> <p>Returns:</p> Type Description <code>Connection</code> <p>Connection object.</p> Source code in <code>oteapi/strategies/parse/postgres.py</code> <pre><code>def create_connection(resource_config: PostgresResourceConfig) -&gt; psycopg.Connection:\n\"\"\"Create a dbname connection to Postgres dbname.\n\n    Parameters:\n        resource_config: A dictionary providing everything needed for a psycopg\n                     connection configuration\n\n    Raises:\n        psycopg.Error: If a DB connection cannot be made.\n\n    Returns:\n        Connection object.\n\n    \"\"\"\n    try:\n        return psycopg.connect(resource_config.accessUrl)\n    except psycopg.Error as exc:\n        raise psycopg.Error(\"Could not connect to given Postgres DB.\") from exc\n</code></pre>"},{"location":"all_strategies/#oteapi.strategies.parse.text_csv","title":"<code>text_csv</code>","text":"<p>Strategy class for text/csv.</p>"},{"location":"all_strategies/#oteapi.strategies.parse.text_csv.CSVDialect","title":"<code>CSVDialect: Type[Enum] = Enum(value='CSVDialect', names={dialect.upper(): dialectfor dialect in csv.list_dialects()}, module=__name__, type=str)</code>  <code>module-attribute</code>","text":"<p>CSV dialects.</p> <p>All available dialects are retrieved through the <code>csv.list_dialects()</code> function, and will thus depend on the currently loaded and used Python interpreter.</p>"},{"location":"all_strategies/#oteapi.strategies.parse.text_csv.CSVConfig","title":"<code>CSVConfig</code>","text":"<p>             Bases: <code>AttrDict</code></p> <p>CSV parse-specific Configuration Data Model.</p> Source code in <code>oteapi/strategies/parse/text_csv.py</code> <pre><code>class CSVConfig(AttrDict):\n\"\"\"CSV parse-specific Configuration Data Model.\"\"\"\n\n    datacache_config: Optional[DataCacheConfig] = Field(\n        None,\n        description=(\n            \"Configurations for the data cache for storing the downloaded file \"\n            \"content.\"\n        ),\n    )\n    dialect: DialectFormatting = Field(\n        DialectFormatting(),\n        description=(\n            \"Dialect and formatting parameters. See [the Python docs]\"\n            \"(https://docs.python.org/3/library/csv.html#csv-fmt-params) for more \"\n            \"information.\"\n        ),\n    )\n    reader: ReaderConfig = Field(\n        ReaderConfig(),\n        description=(\n            \"CSV DictReader configuration parameters. See [the Python docs]\"\n            \"(https://docs.python.org/3/library/csv.html#csv.DictReader) for more \"\n            \"information.\"\n        ),\n    )\n</code></pre>"},{"location":"all_strategies/#oteapi.strategies.parse.text_csv.CSVConfig.datacache_config","title":"<code>datacache_config: Optional[DataCacheConfig] = Field(None, description='Configurations for the data cache for storing the downloaded file content.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.parse.text_csv.CSVConfig.dialect","title":"<code>dialect: DialectFormatting = Field(DialectFormatting(), description='Dialect and formatting parameters. See [the Python docs](https://docs.python.org/3/library/csv.html#csv-fmt-params) for more information.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.parse.text_csv.CSVConfig.reader","title":"<code>reader: ReaderConfig = Field(ReaderConfig(), description='CSV DictReader configuration parameters. See [the Python docs](https://docs.python.org/3/library/csv.html#csv.DictReader) for more information.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.parse.text_csv.CSVParseStrategy","title":"<code>CSVParseStrategy</code>","text":"<p>Parse strategy for CSV files.</p> <p>Registers strategies:</p> <ul> <li><code>(\"mediaType\", \"text/csv\")</code></li> </ul> Source code in <code>oteapi/strategies/parse/text_csv.py</code> <pre><code>@dataclass\nclass CSVParseStrategy:\n\"\"\"Parse strategy for CSV files.\n\n    **Registers strategies**:\n\n    - `(\"mediaType\", \"text/csv\")`\n\n    \"\"\"\n\n    parse_config: CSVResourceConfig\n\n    def initialize(self, session: \"Optional[dict[str, Any]]\" = None) -&gt; SessionUpdate:\n\"\"\"Initialize.\"\"\"\n        return SessionUpdate()\n\n    def get(self, session: \"Optional[dict[str, Any]]\" = None) -&gt; SessionUpdateCSVParse:\n\"\"\"Parse CSV.\"\"\"\n        downloader = create_strategy(\"download\", self.parse_config)\n        output = downloader.get()\n        cache = DataCache(self.parse_config.configuration.datacache_config)\n\n        with cache.getfile(output[\"key\"]) as csvfile_path:\n            kwargs = self.parse_config.configuration.dialect.dict(\n                exclude={\"base\", \"quoting\"}, exclude_unset=True\n            )\n\n            dialect = self.parse_config.configuration.dialect.base\n            if dialect:\n                kwargs[\"dialect\"] = dialect.value\n            quoting = self.parse_config.configuration.dialect.quoting\n            if quoting:\n                kwargs[\"quoting\"] = quoting.csv_constant()\n\n            kwargs.update(\n                self.parse_config.configuration.reader.dict(exclude_unset=True)\n            )\n\n            with open(\n                csvfile_path,\n                newline=\"\",\n                encoding=self.parse_config.configuration.reader.encoding,\n            ) as csvfile:\n                csvreader = csv.DictReader(csvfile, **kwargs)\n                content: dict[Union[str, None], list[Any]] = defaultdict(list)\n                for row in csvreader:\n                    for field, value in row.items():\n                        if (\n                            csvreader.reader.dialect.quoting == csv.QUOTE_NONNUMERIC\n                            and isinstance(value, float)\n                            and value.is_integer()\n                        ):\n                            value = int(value)\n                        content[field].append(value)\n            for key in list(content):\n                if any(isinstance(value, float) for value in content[key]):\n                    content[key] = [\n                        float(value)\n                        if (value or value == 0.0 or value == 0)\n                        and value != csvreader.restval\n                        else float(\"nan\")\n                        for value in content[key]\n                    ]\n                    continue\n                if any(isinstance(value, int) for value in content[key]):\n                    content[key] = [\n                        int(value)\n                        if (value or value == 0) and value != csvreader.restval\n                        else csvreader.restval\n                        for value in content[key]\n                    ]\n\n            return SessionUpdateCSVParse(content=content)\n</code></pre>"},{"location":"all_strategies/#oteapi.strategies.parse.text_csv.CSVParseStrategy.parse_config","title":"<code>parse_config: CSVResourceConfig</code>  <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.parse.text_csv.CSVParseStrategy.get","title":"<code>get(session=None)</code>","text":"<p>Parse CSV.</p> Source code in <code>oteapi/strategies/parse/text_csv.py</code> <pre><code>def get(self, session: \"Optional[dict[str, Any]]\" = None) -&gt; SessionUpdateCSVParse:\n\"\"\"Parse CSV.\"\"\"\n    downloader = create_strategy(\"download\", self.parse_config)\n    output = downloader.get()\n    cache = DataCache(self.parse_config.configuration.datacache_config)\n\n    with cache.getfile(output[\"key\"]) as csvfile_path:\n        kwargs = self.parse_config.configuration.dialect.dict(\n            exclude={\"base\", \"quoting\"}, exclude_unset=True\n        )\n\n        dialect = self.parse_config.configuration.dialect.base\n        if dialect:\n            kwargs[\"dialect\"] = dialect.value\n        quoting = self.parse_config.configuration.dialect.quoting\n        if quoting:\n            kwargs[\"quoting\"] = quoting.csv_constant()\n\n        kwargs.update(\n            self.parse_config.configuration.reader.dict(exclude_unset=True)\n        )\n\n        with open(\n            csvfile_path,\n            newline=\"\",\n            encoding=self.parse_config.configuration.reader.encoding,\n        ) as csvfile:\n            csvreader = csv.DictReader(csvfile, **kwargs)\n            content: dict[Union[str, None], list[Any]] = defaultdict(list)\n            for row in csvreader:\n                for field, value in row.items():\n                    if (\n                        csvreader.reader.dialect.quoting == csv.QUOTE_NONNUMERIC\n                        and isinstance(value, float)\n                        and value.is_integer()\n                    ):\n                        value = int(value)\n                    content[field].append(value)\n        for key in list(content):\n            if any(isinstance(value, float) for value in content[key]):\n                content[key] = [\n                    float(value)\n                    if (value or value == 0.0 or value == 0)\n                    and value != csvreader.restval\n                    else float(\"nan\")\n                    for value in content[key]\n                ]\n                continue\n            if any(isinstance(value, int) for value in content[key]):\n                content[key] = [\n                    int(value)\n                    if (value or value == 0) and value != csvreader.restval\n                    else csvreader.restval\n                    for value in content[key]\n                ]\n\n        return SessionUpdateCSVParse(content=content)\n</code></pre>"},{"location":"all_strategies/#oteapi.strategies.parse.text_csv.CSVParseStrategy.initialize","title":"<code>initialize(session=None)</code>","text":"<p>Initialize.</p> Source code in <code>oteapi/strategies/parse/text_csv.py</code> <pre><code>def initialize(self, session: \"Optional[dict[str, Any]]\" = None) -&gt; SessionUpdate:\n\"\"\"Initialize.\"\"\"\n    return SessionUpdate()\n</code></pre>"},{"location":"all_strategies/#oteapi.strategies.parse.text_csv.CSVResourceConfig","title":"<code>CSVResourceConfig</code>","text":"<p>             Bases: <code>ResourceConfig</code></p> <p>CSV parse strategy filter config.</p> Source code in <code>oteapi/strategies/parse/text_csv.py</code> <pre><code>class CSVResourceConfig(ResourceConfig):\n\"\"\"CSV parse strategy filter config.\"\"\"\n\n    mediaType: str = Field(\n        \"text/csv\",\n        const=True,\n        description=ResourceConfig.__fields__[\"mediaType\"].field_info.description,\n    )\n    configuration: CSVConfig = Field(\n        CSVConfig(), description=\"CSV parse strategy-specific configuration.\"\n    )\n</code></pre>"},{"location":"all_strategies/#oteapi.strategies.parse.text_csv.CSVResourceConfig.configuration","title":"<code>configuration: CSVConfig = Field(CSVConfig(), description='CSV parse strategy-specific configuration.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.parse.text_csv.CSVResourceConfig.mediaType","title":"<code>mediaType: str = Field('text/csv', const=True, description=ResourceConfig.__fields__['mediaType'].field_info.description)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.parse.text_csv.DialectFormatting","title":"<code>DialectFormatting</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>Dialect and formatting parameters for CSV.</p> <p>See the Python docs for more information.</p> Note <p>As <code>Dialect.lineterminator</code> is hardcoded in <code>csv.reader</code>, it is left out of this model.</p> Source code in <code>oteapi/strategies/parse/text_csv.py</code> <pre><code>class DialectFormatting(BaseModel):\n\"\"\"Dialect and formatting parameters for CSV.\n\n    See [the Python docs](https://docs.python.org/3/library/csv.html#csv-fmt-params)\n    for more information.\n\n    Note:\n        As `Dialect.lineterminator` is hardcoded in `csv.reader`, it is left out of\n        this model.\n\n    \"\"\"\n\n    base: Optional[CSVDialect] = Field(\n        None,\n        description=(\n            \"A specific CSV dialect, e.g., 'excel'. Any other parameters here will \"\n            \"overwrite the preset dialect parameters for the specified dialect.\"\n        ),\n    )\n    delimiter: Optional[str] = Field(\n        None,\n        description=(\n            \"A one-character string used to separate fields. \"\n            \"See [the Python docs entry](https://docs.python.org/3/library/csv.html\"\n            \"#csv.Dialect.delimiter) for more information.\"\n        ),\n        min_length=1,\n        max_length=1,\n    )\n    doublequote: Optional[bool] = Field(\n        None,\n        description=(\n            \"Controls how instances of [`quotechar`]\"\n            \"[oteapi.strategies.parse.text_csv.DialectFormatting.quotechar] \"\n            \"appearing inside a field should themselves be quoted. When `True`, the \"\n            \"character is doubled. When `False`, the [`escapechar`]\"\n            \"[oteapi.strategies.parse.text_csv.DialectFormatting.escapechar] \"\n            \"is used as a prefix to the [`quotechar`]\"\n            \"[oteapi.strategies.parse.text_csv.DialectFormatting.quotechar]. \"\n            \"See [the Python docs entry]\"\n            \"(https://docs.python.org/3/library/csv.html#csv.Dialect.doublequote) \"\n            \"for more information.\"\n        ),\n    )\n    escapechar: Optional[str] = Field(\n        None,\n        description=(\n            \"A one-character string used by the writer to escape the [`delimiter`]\"\n            \"[oteapi.strategies.parse.text_csv.DialectFormatting.delimiter] if \"\n            \"[`quoting`][oteapi.strategies.parse.text_csv.DialectFormatting.quoting] \"\n            \"is set to [`QUOTE_NONE`]\"\n            \"[oteapi.strategies.parse.text_csv.QuoteConstants.QUOTE_NONE] and the \"\n            \"[`quotechar`][oteapi.strategies.parse.text_csv.DialectFormatting.\"\n            \"quotechar] if [`doublequote`][oteapi.strategies.parse.text_csv.\"\n            \"DialectFormatting.doublequote] is `False`. On reading, the \"\n            \"[`escapechar`][oteapi.strategies.parse.text_csv.DialectFormatting.\"\n            \"escapechar] removes any special meaning from the following character. \"\n            \"See [the Python docs entry]\"\n            \"(https://docs.python.org/3/library/csv.html#csv.Dialect.escapechar) \"\n            \"for more information.\"\n        ),\n        min_length=1,\n        max_length=1,\n    )\n    quotechar: Optional[str] = Field(\n        None,\n        description=(\n            \"A one-character string used to quote fields containing special \"\n            \"characters, such as the [`delimiter`]\"\n            \"[oteapi.strategies.parse.text_csv.DialectFormatting.delimiter] or \"\n            \"[`quotechar`][oteapi.strategies.parse.text_csv.DialectFormatting.\"\n            \"quotechar], or which contain new-line characters. See \"\n            \"[the Python docs entry](https://docs.python.org/3/library/csv.html\"\n            \"#csv.Dialect.quotechar) for more information.\"\n        ),\n        min_length=1,\n        max_length=1,\n    )\n    quoting: Optional[QuoteConstants] = Field(\n        None,\n        description=(\n            \"Controls when quotes should be generated by the writer and recognised by \"\n            \"the reader. It can take on any of the `QUOTE_*` constants (see section \"\n            \"[Module Contents](https://docs.python.org/3/library/csv.html\"\n            \"#csv-contents)). See [the Python docs entry]\"\n            \"(https://docs.python.org/3/library/csv.html#csv.Dialect.quoting) \"\n            \"for more information.\"\n        ),\n    )\n    skipinitialspace: Optional[bool] = Field(\n        None,\n        description=(\n            \"When `True`, whitespace immediately following the [`delimiter`]\"\n            \"[oteapi.strategies.parse.text_csv.DialectFormatting.delimiter] is \"\n            \"ignored. See [the Python docs entry]\"\n            \"(https://docs.python.org/3/library/csv.html#csv.Dialect.skipinitialspace)\"\n            \" for more information.\"\n        ),\n    )\n    strict: Optional[bool] = Field(\n        None,\n        description=(\n            \"When `True`, raise exception [Error]\"\n            \"(https://docs.python.org/3/library/csv.html#csv.Error) on bad CSV input. \"\n            \"See [the Python docs entry](https://docs.python.org/3/library/csv.html\"\n            \"#csv.Dialect.strict) for more information.\"\n        ),\n    )\n\n    @validator(\"base\")\n    def validate_dialect_base(cls, value: str) -&gt; str:\n\"\"\"Ensure the given `base` dialect is registered locally.\"\"\"\n        if value not in csv.list_dialects():\n            raise ValueError(\n                f\"{value!r} is not a known registered CSV dialect. \"\n                f\"Registered dialects: {', '.join(csv.list_dialects())}.\"\n            )\n        return value\n</code></pre>"},{"location":"all_strategies/#oteapi.strategies.parse.text_csv.DialectFormatting.base","title":"<code>base: Optional[CSVDialect] = Field(None, description=\"A specific CSV dialect, e.g., 'excel'. Any other parameters here will overwrite the preset dialect parameters for the specified dialect.\")</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.parse.text_csv.DialectFormatting.delimiter","title":"<code>delimiter: Optional[str] = Field(None, description='A one-character string used to separate fields. See [the Python docs entry](https://docs.python.org/3/library/csv.html#csv.Dialect.delimiter) for more information.', min_length=1, max_length=1)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.parse.text_csv.DialectFormatting.doublequote","title":"<code>doublequote: Optional[bool] = Field(None, description='Controls how instances of [`quotechar`][oteapi.strategies.parse.text_csv.DialectFormatting.quotechar] appearing inside a field should themselves be quoted. When `True`, the character is doubled. When `False`, the [`escapechar`][oteapi.strategies.parse.text_csv.DialectFormatting.escapechar] is used as a prefix to the [`quotechar`][oteapi.strategies.parse.text_csv.DialectFormatting.quotechar]. See [the Python docs entry](https://docs.python.org/3/library/csv.html#csv.Dialect.doublequote) for more information.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.parse.text_csv.DialectFormatting.escapechar","title":"<code>escapechar: Optional[str] = Field(None, description='A one-character string used by the writer to escape the [`delimiter`][oteapi.strategies.parse.text_csv.DialectFormatting.delimiter] if [`quoting`][oteapi.strategies.parse.text_csv.DialectFormatting.quoting] is set to [`QUOTE_NONE`][oteapi.strategies.parse.text_csv.QuoteConstants.QUOTE_NONE] and the [`quotechar`][oteapi.strategies.parse.text_csv.DialectFormatting.quotechar] if [`doublequote`][oteapi.strategies.parse.text_csv.DialectFormatting.doublequote] is `False`. On reading, the [`escapechar`][oteapi.strategies.parse.text_csv.DialectFormatting.escapechar] removes any special meaning from the following character. See [the Python docs entry](https://docs.python.org/3/library/csv.html#csv.Dialect.escapechar) for more information.', min_length=1, max_length=1)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.parse.text_csv.DialectFormatting.quotechar","title":"<code>quotechar: Optional[str] = Field(None, description='A one-character string used to quote fields containing special characters, such as the [`delimiter`][oteapi.strategies.parse.text_csv.DialectFormatting.delimiter] or [`quotechar`][oteapi.strategies.parse.text_csv.DialectFormatting.quotechar], or which contain new-line characters. See [the Python docs entry](https://docs.python.org/3/library/csv.html#csv.Dialect.quotechar) for more information.', min_length=1, max_length=1)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.parse.text_csv.DialectFormatting.quoting","title":"<code>quoting: Optional[QuoteConstants] = Field(None, description='Controls when quotes should be generated by the writer and recognised by the reader. It can take on any of the `QUOTE_*` constants (see section [Module Contents](https://docs.python.org/3/library/csv.html#csv-contents)). See [the Python docs entry](https://docs.python.org/3/library/csv.html#csv.Dialect.quoting) for more information.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.parse.text_csv.DialectFormatting.skipinitialspace","title":"<code>skipinitialspace: Optional[bool] = Field(None, description='When `True`, whitespace immediately following the [`delimiter`][oteapi.strategies.parse.text_csv.DialectFormatting.delimiter] is ignored. See [the Python docs entry](https://docs.python.org/3/library/csv.html#csv.Dialect.skipinitialspace) for more information.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.parse.text_csv.DialectFormatting.strict","title":"<code>strict: Optional[bool] = Field(None, description='When `True`, raise exception [Error](https://docs.python.org/3/library/csv.html#csv.Error) on bad CSV input. See [the Python docs entry](https://docs.python.org/3/library/csv.html#csv.Dialect.strict) for more information.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.parse.text_csv.DialectFormatting.validate_dialect_base","title":"<code>validate_dialect_base(value)</code>","text":"<p>Ensure the given <code>base</code> dialect is registered locally.</p> Source code in <code>oteapi/strategies/parse/text_csv.py</code> <pre><code>@validator(\"base\")\ndef validate_dialect_base(cls, value: str) -&gt; str:\n\"\"\"Ensure the given `base` dialect is registered locally.\"\"\"\n    if value not in csv.list_dialects():\n        raise ValueError(\n            f\"{value!r} is not a known registered CSV dialect. \"\n            f\"Registered dialects: {', '.join(csv.list_dialects())}.\"\n        )\n    return value\n</code></pre>"},{"location":"all_strategies/#oteapi.strategies.parse.text_csv.QuoteConstants","title":"<code>QuoteConstants</code>","text":"<p>             Bases: <code>str</code>, <code>Enum</code></p> <p>CSV module <code>QUOTE_*</code> constants.</p> Source code in <code>oteapi/strategies/parse/text_csv.py</code> <pre><code>class QuoteConstants(str, Enum):\n\"\"\"CSV module `QUOTE_*` constants.\"\"\"\n\n    QUOTE_ALL = \"QUOTE_ALL\"\n    QUOTE_MINIMAL = \"QUOTE_MINIMAL\"\n    QUOTE_NONUMERIC = \"QUOTE_NONNUMERIC\"\n    QUOTE_NONE = \"QUOTE_NONE\"\n\n    def csv_constant(self) -&gt; int:\n\"\"\"Return the CSV lib equivalent constant.\"\"\"\n        return {\n            self.QUOTE_ALL: csv.QUOTE_ALL,\n            self.QUOTE_MINIMAL: csv.QUOTE_MINIMAL,\n            self.QUOTE_NONUMERIC: csv.QUOTE_NONNUMERIC,\n            self.QUOTE_NONE: csv.QUOTE_NONE,\n        }[self]\n</code></pre>"},{"location":"all_strategies/#oteapi.strategies.parse.text_csv.QuoteConstants.QUOTE_ALL","title":"<code>QUOTE_ALL = 'QUOTE_ALL'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.parse.text_csv.QuoteConstants.QUOTE_MINIMAL","title":"<code>QUOTE_MINIMAL = 'QUOTE_MINIMAL'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.parse.text_csv.QuoteConstants.QUOTE_NONE","title":"<code>QUOTE_NONE = 'QUOTE_NONE'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.parse.text_csv.QuoteConstants.QUOTE_NONUMERIC","title":"<code>QUOTE_NONUMERIC = 'QUOTE_NONNUMERIC'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.parse.text_csv.QuoteConstants.csv_constant","title":"<code>csv_constant()</code>","text":"<p>Return the CSV lib equivalent constant.</p> Source code in <code>oteapi/strategies/parse/text_csv.py</code> <pre><code>def csv_constant(self) -&gt; int:\n\"\"\"Return the CSV lib equivalent constant.\"\"\"\n    return {\n        self.QUOTE_ALL: csv.QUOTE_ALL,\n        self.QUOTE_MINIMAL: csv.QUOTE_MINIMAL,\n        self.QUOTE_NONUMERIC: csv.QUOTE_NONNUMERIC,\n        self.QUOTE_NONE: csv.QUOTE_NONE,\n    }[self]\n</code></pre>"},{"location":"all_strategies/#oteapi.strategies.parse.text_csv.ReaderConfig","title":"<code>ReaderConfig</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>CSV DictReader configuration parameters.</p> <p>See the Python docs for more information.</p> Source code in <code>oteapi/strategies/parse/text_csv.py</code> <pre><code>class ReaderConfig(BaseModel):\n\"\"\"CSV DictReader configuration parameters.\n\n    See [the Python docs](https://docs.python.org/3/library/csv.html#csv.DictReader)\n    for more information.\n    \"\"\"\n\n    fieldnames: Optional[list[str]] = Field(\n        None,\n        description=(\n            \"List of headers. If not set, the values in the first row of the CSV file \"\n            \"will be used as the field names.\"\n        ),\n    )\n    restkey: Optional[Hashable] = Field(\n        None,\n        description=(\n            \"If a row has more fields than [`fieldnames`]\"\n            \"[oteapi.strategies.parse.text_csv.ReaderConfig.fieldnames], the \"\n            \"remaining data is put in a list and stored with the field name specified \"\n            \"by [`restkey`][oteapi.strategies.parse.text_csv.ReaderConfig.restkey].\"\n        ),\n    )\n    restval: Optional[Any] = Field(\n        None,\n        description=(\n            \"If a non-blank row has fewer fields than the length of [`fieldnames`]\"\n            \"[oteapi.strategies.parse.text_csv.ReaderConfig.fieldnames], the missing \"\n            \"values are filled-in with the value of [`restval`]\"\n            \"[oteapi.strategies.parse.text_csv.ReaderConfig.restval].\"\n        ),\n    )\n    encoding: str = Field(\n        \"utf8\",\n        description=\"The file encoding.\",\n    )\n</code></pre>"},{"location":"all_strategies/#oteapi.strategies.parse.text_csv.ReaderConfig.encoding","title":"<code>encoding: str = Field('utf8', description='The file encoding.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.parse.text_csv.ReaderConfig.fieldnames","title":"<code>fieldnames: Optional[list[str]] = Field(None, description='List of headers. If not set, the values in the first row of the CSV file will be used as the field names.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.parse.text_csv.ReaderConfig.restkey","title":"<code>restkey: Optional[Hashable] = Field(None, description='If a row has more fields than [`fieldnames`][oteapi.strategies.parse.text_csv.ReaderConfig.fieldnames], the remaining data is put in a list and stored with the field name specified by [`restkey`][oteapi.strategies.parse.text_csv.ReaderConfig.restkey].')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.parse.text_csv.ReaderConfig.restval","title":"<code>restval: Optional[Any] = Field(None, description='If a non-blank row has fewer fields than the length of [`fieldnames`][oteapi.strategies.parse.text_csv.ReaderConfig.fieldnames], the missing values are filled-in with the value of [`restval`][oteapi.strategies.parse.text_csv.ReaderConfig.restval].')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.parse.text_csv.SessionUpdateCSVParse","title":"<code>SessionUpdateCSVParse</code>","text":"<p>             Bases: <code>SessionUpdate</code></p> <p>Class for returning values from CSV Parse.</p> Source code in <code>oteapi/strategies/parse/text_csv.py</code> <pre><code>class SessionUpdateCSVParse(SessionUpdate):\n\"\"\"Class for returning values from CSV Parse.\"\"\"\n\n    content: dict[Union[str, None], list[Any]] = Field(\n        ..., description=\"Content of the CSV document.\"\n    )\n</code></pre>"},{"location":"all_strategies/#oteapi.strategies.parse.text_csv.SessionUpdateCSVParse.content","title":"<code>content: dict[Union[str, None], list[Any]] = Field(..., description='Content of the CSV document.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.resource","title":"<code>resource</code>","text":""},{"location":"all_strategies/#oteapi.strategies.transformation","title":"<code>transformation</code>","text":""},{"location":"all_strategies/#oteapi.strategies.transformation.celery_remote","title":"<code>celery_remote</code>","text":"<p>Transformation Plugin that uses the Celery framework to call remote workers.</p>"},{"location":"all_strategies/#oteapi.strategies.transformation.celery_remote.CELERY_APP","title":"<code>CELERY_APP = Celery(broker=f'redis://{REDIS_HOST}:{REDIS_PORT}', backend=f'redis://{REDIS_HOST}:{REDIS_PORT}')</code>  <code>module-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.transformation.celery_remote.REDIS_HOST","title":"<code>REDIS_HOST = os.getenv('OTEAPI_REDIS_HOST', 'redis')</code>  <code>module-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.transformation.celery_remote.REDIS_PORT","title":"<code>REDIS_PORT = int(os.getenv('OTEAPI_REDIS_PORT', '6379'))</code>  <code>module-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.transformation.celery_remote.CeleryConfig","title":"<code>CeleryConfig</code>","text":"<p>             Bases: <code>AttrDict</code></p> <p>Celery configuration.</p> <p>All fields here (including those added from the session through the <code>get()</code> method, as well as those added \"anonymously\") will be used as keyword arguments to the <code>send_task()</code> method for the Celery App.</p> Note <p>Using <code>alias</code> for the <code>name</code> field to favor populating it with <code>task_name</code> arguments, since this is the \"original\" field name. I.e., this is done for backwards compatibility.</p> <p>Setting <code>allow_population_by_field_name=True</code> as pydantic model configuration in order to allow populating it using <code>name</code> as well as <code>task_name</code>.</p> Source code in <code>oteapi/strategies/transformation/celery_remote.py</code> <pre><code>class CeleryConfig(AttrDict, allow_population_by_field_name=True):\n\"\"\"Celery configuration.\n\n    All fields here (including those added from the session through the `get()` method,\n    as well as those added \"anonymously\") will be used as keyword arguments to the\n    `send_task()` method for the Celery App.\n\n    Note:\n        Using `alias` for the `name` field to favor populating it with `task_name`\n        arguments, since this is the \"original\" field name. I.e., this is done for\n        backwards compatibility.\n\n    Setting `allow_population_by_field_name=True` as pydantic model configuration in\n    order to allow populating it using `name` as well as `task_name`.\n\n    \"\"\"\n\n    name: str = Field(..., description=\"A task name.\", alias=\"task_name\")\n    args: list = Field(..., description=\"List of arguments for the task.\")\n</code></pre>"},{"location":"all_strategies/#oteapi.strategies.transformation.celery_remote.CeleryConfig.args","title":"<code>args: list = Field(..., description='List of arguments for the task.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.transformation.celery_remote.CeleryConfig.name","title":"<code>name: str = Field(..., description='A task name.', alias='task_name')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.transformation.celery_remote.CeleryRemoteStrategy","title":"<code>CeleryRemoteStrategy</code>","text":"<p>Submit job to remote Celery runner.</p> <p>Registers strategies:</p> <ul> <li><code>(\"transformationType\", \"celery/remote\")</code></li> </ul> Source code in <code>oteapi/strategies/transformation/celery_remote.py</code> <pre><code>@dataclass\nclass CeleryRemoteStrategy:\n\"\"\"Submit job to remote Celery runner.\n\n    **Registers strategies**:\n\n    - `(\"transformationType\", \"celery/remote\")`\n\n    \"\"\"\n\n    transformation_config: CeleryStrategyConfig\n\n    def get(self, session: \"Optional[Dict[str, Any]]\" = None) -&gt; SessionUpdateCelery:\n\"\"\"Run a job, return a job ID.\"\"\"\n        if session:\n            self._use_session(session)\n\n        result: \"Union[AsyncResult, Any]\" = CELERY_APP.send_task(\n            **self.transformation_config.configuration\n        )\n        return SessionUpdateCelery(celery_task_id=result.task_id)\n\n    def initialize(self, session: \"Optional[Dict[str, Any]]\" = None) -&gt; SessionUpdate:\n\"\"\"Initialize a job.\"\"\"\n        return SessionUpdate()\n\n    def status(self, task_id: str) -&gt; TransformationStatus:\n\"\"\"Get job status.\"\"\"\n        result = AsyncResult(id=task_id, app=CELERY_APP)\n        return TransformationStatus(id=task_id, status=result.state)\n\n    def _use_session(self, session: \"Dict[str, Any]\") -&gt; None:\n\"\"\"Update the configuration with values from the sesssion.\n\n        Check all fields (non-aliased and aliased) in `CeleryConfig` if they exist in\n        the session. Override the given field values in the current strategy-specific\n        configuration (the `CeleryConfig` instance) with the values found in the\n        session.\n\n        Parameters:\n            session: The current OTE session.\n\n        \"\"\"\n        alias_mapping: dict[str, str] = {\n            field.alias: field_name\n            for field_name, field in CeleryConfig.__fields__.items()\n        }\n\n        fields = set(CeleryConfig.__fields__)\n        fields |= {_.alias for _ in CeleryConfig.__fields__.values()}\n\n        for field in fields:\n            if field in session:\n                setattr(\n                    self.transformation_config.configuration,\n                    alias_mapping[field],\n                    session[field],\n                )\n</code></pre>"},{"location":"all_strategies/#oteapi.strategies.transformation.celery_remote.CeleryRemoteStrategy.transformation_config","title":"<code>transformation_config: CeleryStrategyConfig</code>  <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.transformation.celery_remote.CeleryRemoteStrategy.get","title":"<code>get(session=None)</code>","text":"<p>Run a job, return a job ID.</p> Source code in <code>oteapi/strategies/transformation/celery_remote.py</code> <pre><code>def get(self, session: \"Optional[Dict[str, Any]]\" = None) -&gt; SessionUpdateCelery:\n\"\"\"Run a job, return a job ID.\"\"\"\n    if session:\n        self._use_session(session)\n\n    result: \"Union[AsyncResult, Any]\" = CELERY_APP.send_task(\n        **self.transformation_config.configuration\n    )\n    return SessionUpdateCelery(celery_task_id=result.task_id)\n</code></pre>"},{"location":"all_strategies/#oteapi.strategies.transformation.celery_remote.CeleryRemoteStrategy.initialize","title":"<code>initialize(session=None)</code>","text":"<p>Initialize a job.</p> Source code in <code>oteapi/strategies/transformation/celery_remote.py</code> <pre><code>def initialize(self, session: \"Optional[Dict[str, Any]]\" = None) -&gt; SessionUpdate:\n\"\"\"Initialize a job.\"\"\"\n    return SessionUpdate()\n</code></pre>"},{"location":"all_strategies/#oteapi.strategies.transformation.celery_remote.CeleryRemoteStrategy.status","title":"<code>status(task_id)</code>","text":"<p>Get job status.</p> Source code in <code>oteapi/strategies/transformation/celery_remote.py</code> <pre><code>def status(self, task_id: str) -&gt; TransformationStatus:\n\"\"\"Get job status.\"\"\"\n    result = AsyncResult(id=task_id, app=CELERY_APP)\n    return TransformationStatus(id=task_id, status=result.state)\n</code></pre>"},{"location":"all_strategies/#oteapi.strategies.transformation.celery_remote.CeleryStrategyConfig","title":"<code>CeleryStrategyConfig</code>","text":"<p>             Bases: <code>TransformationConfig</code></p> <p>Celery strategy-specific configuration.</p> Source code in <code>oteapi/strategies/transformation/celery_remote.py</code> <pre><code>class CeleryStrategyConfig(TransformationConfig):\n\"\"\"Celery strategy-specific configuration.\"\"\"\n\n    transformationType: str = Field(\n        \"celery/remote\",\n        const=True,\n        description=TransformationConfig.__fields__[\n            \"transformationType\"\n        ].field_info.description,\n    )\n    configuration: CeleryConfig = Field(\n        ..., description=\"Celery transformation strategy-specific configuration.\"\n    )\n</code></pre>"},{"location":"all_strategies/#oteapi.strategies.transformation.celery_remote.CeleryStrategyConfig.configuration","title":"<code>configuration: CeleryConfig = Field(..., description='Celery transformation strategy-specific configuration.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.transformation.celery_remote.CeleryStrategyConfig.transformationType","title":"<code>transformationType: str = Field('celery/remote', const=True, description=TransformationConfig.__fields__['transformationType'].field_info.description)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.transformation.celery_remote.SessionUpdateCelery","title":"<code>SessionUpdateCelery</code>","text":"<p>             Bases: <code>SessionUpdate</code></p> <p>Class for returning values from a Celery task.</p> Source code in <code>oteapi/strategies/transformation/celery_remote.py</code> <pre><code>class SessionUpdateCelery(SessionUpdate):\n\"\"\"Class for returning values from a Celery task.\"\"\"\n\n    celery_task_id: str = Field(..., description=\"A Celery task identifier.\")\n</code></pre>"},{"location":"all_strategies/#oteapi.strategies.transformation.celery_remote.SessionUpdateCelery.celery_task_id","title":"<code>celery_task_id: str = Field(..., description='A Celery task identifier.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/settings/","title":"settings","text":"<p>BaseSettings for oteapi-core. This <code>configuration/settings</code>-class is intended to be incorporated as a parentclass into the configuration of an FastAPI application. See <code>https://fastapi.tiangolo.com/advanced/settings/</code> as reference.</p> <p>Otherwise, check <code>https://github.com/EMMC-ASBL/oteapi-services/blob/master/app/main.py</code> for a direct example of an inclusion of the OTE api and its settings into an FastAPI instance.</p>"},{"location":"api_reference/settings/#oteapi.settings.OteApiCoreSettings","title":"<code>OteApiCoreSettings</code>","text":"<p>             Bases: <code>BaseSettings</code></p> <p>Basic configuration for the oteapi-core.</p> Source code in <code>oteapi/settings.py</code> <pre><code>class OteApiCoreSettings(BaseSettings):\n\"\"\"Basic configuration for the oteapi-core.\"\"\"\n\n    expose_secrets: bool = Field(\n        False,\n        description=\"\"\"Whether `SecretStr` in `pydantic` should be exposed or not.\n\n!!! warning\n    Depending on the configuration and user management of the services\n    using oteapi-core, secrets might be readable by other users when serialized!\n    This especially takes place when then models and configs are put into the cache.\n    Hence be careful while using this option in production.\n\"\"\",\n    )\n\n    class Config:\n\"\"\"Pydantic config for the OteApiCoreSettings.\"\"\"\n\n        env_prefix = \"OTEAPI_\"\n</code></pre>"},{"location":"api_reference/settings/#oteapi.settings.OteApiCoreSettings.Config","title":"<code>Config</code>","text":"<p>Pydantic config for the OteApiCoreSettings.</p> Source code in <code>oteapi/settings.py</code> <pre><code>class Config:\n\"\"\"Pydantic config for the OteApiCoreSettings.\"\"\"\n\n    env_prefix = \"OTEAPI_\"\n</code></pre>"},{"location":"api_reference/datacache/datacache/","title":"datacache","text":"<p>Data cache based on DiskCache. See Python-DiskCache.</p> <p>Features:</p> <ul> <li>Persistent cache between sessions.</li> <li>Default keys are hashes of the stored data.</li> <li>Automatic expiration of cached data.</li> <li>Sessions can selectively be cleaned up via tags.</li> <li>Store small values in SQLite database and large values in files.</li> <li>Underlying library is actively developed and tested on Linux, Mac and Windows.</li> <li>High performance.</li> </ul>"},{"location":"api_reference/datacache/datacache/#oteapi.datacache.datacache.DataCache","title":"<code>DataCache</code>","text":"<p>Initialize a cache instance with the given download configuration.</p> <p>This class is also available to import from <code>oteapi.datacache</code>, e.g.:</p> <pre><code>from oteapi.datacache import DataCache\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>Union[DataCacheConfig, Dict[str, Any]]</code> <p>Download configurations.</p> <code>None</code> <code>cache_dir</code> <code>Optional[Union[Path, str]]</code> <p>Cache directory overriding the config.</p> <code>None</code> <p>Attributes:</p> Name Type Description <code>config</code> <p>DataCacheConfig instance.</p> <code>cache_dir</code> <p>Subdirectory used for the Path to cache directory, e.g., <code>\"my_oteapi\"</code>.</p> Source code in <code>oteapi/datacache/datacache.py</code> <pre><code>class DataCache:\n\"\"\"Initialize a cache instance with the given download configuration.\n\n    This class is also available to import from `oteapi.datacache`, e.g.:\n\n    ```python\n    from oteapi.datacache import DataCache\n    ```\n\n    Args:\n        config (Union[DataCacheConfig, Dict[str, Any]]): Download configurations.\n        cache_dir (Optional[Union[Path, str]]): Cache directory overriding the config.\n\n    Attributes:\n        config: DataCacheConfig instance.\n        cache_dir: Subdirectory used for the Path to cache directory, e.g.,\n            `\"my_oteapi\"`.\n\n    \"\"\"\n\n    def __init__(\n        self,\n        config: \"Optional[Union[DataCacheConfig, Dict[str, Any]]]\" = None,\n        cache_dir: \"Optional[Union[Path, str]]\" = None,\n    ) -&gt; None:\n        if config is None:\n            self.config = DataCacheConfig()\n        elif isinstance(config, (dict, AttrDict)):\n            self.config = DataCacheConfig(**config)\n        elif isinstance(config, DataCacheConfig):\n            self.config = config\n        else:\n            raise TypeError(\n                \"config should be either a `DataCacheConfig` data model or a \"\n                \"dictionary.\"\n            )\n\n        if not cache_dir:\n            cache_dir = self.config.cacheDir\n        if isinstance(cache_dir, str):\n            cache_dir = Path(cache_dir)\n        if cache_dir.is_absolute():\n            self.cache_dir = cache_dir\n        else:\n            self.cache_dir = Path(tempfile.gettempdir()).resolve() / cache_dir\n\n        self.diskcache = DiskCache(directory=self.cache_dir)\n\n    def __contains__(self, key) -&gt; bool:\n        return key in self.diskcache\n\n    def __len__(self) -&gt; int:\n        return len(self.diskcache)\n\n    def __getitem__(self, key) -&gt; \"Any\":\n        return self.get(key)\n\n    def __setitem__(self, key, value) -&gt; None:\n        self.add(value, key=key)\n\n    def __delitem__(self, key) -&gt; None:\n        del self.diskcache[key]\n\n    def __del__(self) -&gt; None:\n        self.diskcache.expire()\n        self.diskcache.close()\n\n    def add(\n        self,\n        value: \"Any\",\n        key: \"Optional[str]\" = None,\n        expire: \"Optional[int]\" = None,\n        tag: \"Optional[str]\" = None,\n        bind: \"Any\" = None,\n        json_encoder: \"Optional[Type[json.JSONEncoder]]\" = None,\n    ) -&gt; str:\n\"\"\"Add a value to cache.\n\n        Existing value is overwritten if `key` is given and it already\n        exists in the cache.\n\n        Args:\n            value: The value to add to the cache.\n            key: If given, use this as the retrieval key. Otherwise the key is either\n                taken from the `accessKey` configuration or generated as a hash of\n                `value`.\n            expire: If given, the number of seconds before the value expire. Otherwise\n                it is taken from the configuration.\n            tag: Tag used with [`evict()`][oteapi.datacache.datacache.DataCache.evict]\n                for cleaning up a session.\n            bind: Remove `value` from the cache when the object provided with\n                this argument goes out of scope.  Note that `bind` must be a\n                weakref'able object.\n\n                The argument name refers to that we bind `value` to this\n                argument.\n            json_encoder: Customised json encoder forcomplex Python objects.\n\n        Returns:\n            A key that can be used to retrieve `value` from cache later.\n\n        \"\"\"\n        key = (\n            key\n            if key\n            else (\n                self.config.accessKey\n                if self.config.accessKey\n                else gethash(\n                    value,\n                    hashtype=self.config.hashType,\n                    json_encoder=json_encoder,\n                )\n            )\n        )\n\n        if bind is not None:\n\n            def remover(key):\n                del self[key]\n\n            weakref.finalize(bind, remover, key)\n\n        self.diskcache.set(\n            key,\n            value,\n            expire=expire if expire else self.config.expireTime,\n            tag=tag,\n        )\n        return key\n\n    def get(self, key: str) -&gt; \"Any\":\n\"\"\"Return the value corresponding to `key`.\n\n        Args:\n            key: The requested cached object to retrieve a value for.\n\n        Returns:\n            The value corresponding to the `key` value.\n\n        \"\"\"\n        if key not in self.diskcache:\n            raise KeyError(key)\n        return self.diskcache.get(key)\n\n    @contextmanager\n    def getfile(\n        self,\n        key: str,\n        delete: bool = True,\n        filename: \"Optional[Union[Path, str]]\" = None,\n        prefix: \"Optional[str]\" = None,\n        suffix: \"Optional[str]\" = None,\n        directory: \"Optional[str]\" = None,\n    ) -&gt; \"Iterator[Path]\":\n\"\"\"Write the value for `key` to file and return the filename.\n\n        The file is created in the default directory for temporary\n        files (which can be controlled by the `TEMPDIR`, `TEMP` or `TMP`\n        environment variables). It is readable and writable only for\n        the current user.\n\n        Example:\n            This method is intended to be used in a `with` statement, to\n            automatically delete the file when leaving the context:\n\n            ```python\n            cache = DataCache()\n            with cache.getfile('mykey') as filename:\n                # do something with filename...\n            # filename is deleted\n            ```\n\n        Args:\n            key: Key of value to write to file.\n            delete: Whether to automatically delete the created file when leaving the\n                context.\n            filename: Full path to created file. If not given, a unique filename will\n                be created.\n            prefix: Prefix to prepend to the returned file name (default is\n                `\"oteapi-download-\"`).\n            suffix: Suffix to append to the returned file name.\n            directory: File directory if `filename` is not provided (is `None`).\n\n        Yields:\n            Path object, referencing and representing the created file.\n\n        \"\"\"\n        if filename:\n            filename = Path(filename).resolve()\n            filename.write_bytes(self.get(key))\n        else:\n            prefix = prefix if prefix else \"oteapi-download-\"\n            with tempfile.NamedTemporaryFile(\n                prefix=prefix,\n                suffix=suffix,\n                dir=directory,\n                delete=False,\n            ) as handle:\n                handle.write(self.get(key))\n                filename = Path(handle.name).resolve()\n\n        try:\n            yield filename\n        finally:\n            if delete:\n                filename.unlink()\n\n    def evict(self, tag: str) -&gt; None:\n\"\"\"Remove all cache items with the given tag.\n\n        Useful for cleaning up a session.\n\n        Args:\n            tag: Tag identifying objects.\n\n        \"\"\"\n        self.diskcache.evict(tag)\n\n    def clear(self) -&gt; None:\n\"\"\"Remove all items from cache.\"\"\"\n        self.diskcache.clear()\n</code></pre>"},{"location":"api_reference/datacache/datacache/#oteapi.datacache.datacache.DataCache.add","title":"<code>add(value, key=None, expire=None, tag=None, bind=None, json_encoder=None)</code>","text":"<p>Add a value to cache.</p> <p>Existing value is overwritten if <code>key</code> is given and it already exists in the cache.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Any</code> <p>The value to add to the cache.</p> required <code>key</code> <code>Optional[str]</code> <p>If given, use this as the retrieval key. Otherwise the key is either taken from the <code>accessKey</code> configuration or generated as a hash of <code>value</code>.</p> <code>None</code> <code>expire</code> <code>Optional[int]</code> <p>If given, the number of seconds before the value expire. Otherwise it is taken from the configuration.</p> <code>None</code> <code>tag</code> <code>Optional[str]</code> <p>Tag used with <code>evict()</code> for cleaning up a session.</p> <code>None</code> <code>bind</code> <code>Any</code> <p>Remove <code>value</code> from the cache when the object provided with this argument goes out of scope.  Note that <code>bind</code> must be a weakref'able object.</p> <p>The argument name refers to that we bind <code>value</code> to this argument.</p> <code>None</code> <code>json_encoder</code> <code>Optional[Type[JSONEncoder]]</code> <p>Customised json encoder forcomplex Python objects.</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>A key that can be used to retrieve <code>value</code> from cache later.</p> Source code in <code>oteapi/datacache/datacache.py</code> <pre><code>def add(\n    self,\n    value: \"Any\",\n    key: \"Optional[str]\" = None,\n    expire: \"Optional[int]\" = None,\n    tag: \"Optional[str]\" = None,\n    bind: \"Any\" = None,\n    json_encoder: \"Optional[Type[json.JSONEncoder]]\" = None,\n) -&gt; str:\n\"\"\"Add a value to cache.\n\n    Existing value is overwritten if `key` is given and it already\n    exists in the cache.\n\n    Args:\n        value: The value to add to the cache.\n        key: If given, use this as the retrieval key. Otherwise the key is either\n            taken from the `accessKey` configuration or generated as a hash of\n            `value`.\n        expire: If given, the number of seconds before the value expire. Otherwise\n            it is taken from the configuration.\n        tag: Tag used with [`evict()`][oteapi.datacache.datacache.DataCache.evict]\n            for cleaning up a session.\n        bind: Remove `value` from the cache when the object provided with\n            this argument goes out of scope.  Note that `bind` must be a\n            weakref'able object.\n\n            The argument name refers to that we bind `value` to this\n            argument.\n        json_encoder: Customised json encoder forcomplex Python objects.\n\n    Returns:\n        A key that can be used to retrieve `value` from cache later.\n\n    \"\"\"\n    key = (\n        key\n        if key\n        else (\n            self.config.accessKey\n            if self.config.accessKey\n            else gethash(\n                value,\n                hashtype=self.config.hashType,\n                json_encoder=json_encoder,\n            )\n        )\n    )\n\n    if bind is not None:\n\n        def remover(key):\n            del self[key]\n\n        weakref.finalize(bind, remover, key)\n\n    self.diskcache.set(\n        key,\n        value,\n        expire=expire if expire else self.config.expireTime,\n        tag=tag,\n    )\n    return key\n</code></pre>"},{"location":"api_reference/datacache/datacache/#oteapi.datacache.datacache.DataCache.clear","title":"<code>clear()</code>","text":"<p>Remove all items from cache.</p> Source code in <code>oteapi/datacache/datacache.py</code> <pre><code>def clear(self) -&gt; None:\n\"\"\"Remove all items from cache.\"\"\"\n    self.diskcache.clear()\n</code></pre>"},{"location":"api_reference/datacache/datacache/#oteapi.datacache.datacache.DataCache.evict","title":"<code>evict(tag)</code>","text":"<p>Remove all cache items with the given tag.</p> <p>Useful for cleaning up a session.</p> <p>Parameters:</p> Name Type Description Default <code>tag</code> <code>str</code> <p>Tag identifying objects.</p> required Source code in <code>oteapi/datacache/datacache.py</code> <pre><code>def evict(self, tag: str) -&gt; None:\n\"\"\"Remove all cache items with the given tag.\n\n    Useful for cleaning up a session.\n\n    Args:\n        tag: Tag identifying objects.\n\n    \"\"\"\n    self.diskcache.evict(tag)\n</code></pre>"},{"location":"api_reference/datacache/datacache/#oteapi.datacache.datacache.DataCache.get","title":"<code>get(key)</code>","text":"<p>Return the value corresponding to <code>key</code>.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The requested cached object to retrieve a value for.</p> required <p>Returns:</p> Type Description <code>Any</code> <p>The value corresponding to the <code>key</code> value.</p> Source code in <code>oteapi/datacache/datacache.py</code> <pre><code>def get(self, key: str) -&gt; \"Any\":\n\"\"\"Return the value corresponding to `key`.\n\n    Args:\n        key: The requested cached object to retrieve a value for.\n\n    Returns:\n        The value corresponding to the `key` value.\n\n    \"\"\"\n    if key not in self.diskcache:\n        raise KeyError(key)\n    return self.diskcache.get(key)\n</code></pre>"},{"location":"api_reference/datacache/datacache/#oteapi.datacache.datacache.DataCache.getfile","title":"<code>getfile(key, delete=True, filename=None, prefix=None, suffix=None, directory=None)</code>","text":"<p>Write the value for <code>key</code> to file and return the filename.</p> <p>The file is created in the default directory for temporary files (which can be controlled by the <code>TEMPDIR</code>, <code>TEMP</code> or <code>TMP</code> environment variables). It is readable and writable only for the current user.</p> Example <p>This method is intended to be used in a <code>with</code> statement, to automatically delete the file when leaving the context:</p> <pre><code>cache = DataCache()\nwith cache.getfile('mykey') as filename:\n    # do something with filename...\n# filename is deleted\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>Key of value to write to file.</p> required <code>delete</code> <code>bool</code> <p>Whether to automatically delete the created file when leaving the context.</p> <code>True</code> <code>filename</code> <code>Optional[Union[Path, str]]</code> <p>Full path to created file. If not given, a unique filename will be created.</p> <code>None</code> <code>prefix</code> <code>Optional[str]</code> <p>Prefix to prepend to the returned file name (default is <code>\"oteapi-download-\"</code>).</p> <code>None</code> <code>suffix</code> <code>Optional[str]</code> <p>Suffix to append to the returned file name.</p> <code>None</code> <code>directory</code> <code>Optional[str]</code> <p>File directory if <code>filename</code> is not provided (is <code>None</code>).</p> <code>None</code> <p>Yields:</p> Type Description <code>Path</code> <p>Path object, referencing and representing the created file.</p> Source code in <code>oteapi/datacache/datacache.py</code> <pre><code>@contextmanager\ndef getfile(\n    self,\n    key: str,\n    delete: bool = True,\n    filename: \"Optional[Union[Path, str]]\" = None,\n    prefix: \"Optional[str]\" = None,\n    suffix: \"Optional[str]\" = None,\n    directory: \"Optional[str]\" = None,\n) -&gt; \"Iterator[Path]\":\n\"\"\"Write the value for `key` to file and return the filename.\n\n    The file is created in the default directory for temporary\n    files (which can be controlled by the `TEMPDIR`, `TEMP` or `TMP`\n    environment variables). It is readable and writable only for\n    the current user.\n\n    Example:\n        This method is intended to be used in a `with` statement, to\n        automatically delete the file when leaving the context:\n\n        ```python\n        cache = DataCache()\n        with cache.getfile('mykey') as filename:\n            # do something with filename...\n        # filename is deleted\n        ```\n\n    Args:\n        key: Key of value to write to file.\n        delete: Whether to automatically delete the created file when leaving the\n            context.\n        filename: Full path to created file. If not given, a unique filename will\n            be created.\n        prefix: Prefix to prepend to the returned file name (default is\n            `\"oteapi-download-\"`).\n        suffix: Suffix to append to the returned file name.\n        directory: File directory if `filename` is not provided (is `None`).\n\n    Yields:\n        Path object, referencing and representing the created file.\n\n    \"\"\"\n    if filename:\n        filename = Path(filename).resolve()\n        filename.write_bytes(self.get(key))\n    else:\n        prefix = prefix if prefix else \"oteapi-download-\"\n        with tempfile.NamedTemporaryFile(\n            prefix=prefix,\n            suffix=suffix,\n            dir=directory,\n            delete=False,\n        ) as handle:\n            handle.write(self.get(key))\n            filename = Path(handle.name).resolve()\n\n    try:\n        yield filename\n    finally:\n        if delete:\n            filename.unlink()\n</code></pre>"},{"location":"api_reference/datacache/datacache/#oteapi.datacache.datacache.gethash","title":"<code>gethash(value, hashtype='sha256', encoding='utf-8', json_encoder=None)</code>","text":"<p>Return a hash of <code>value</code>.</p> <p>Can hash most python objects. Bytes and bytearrays are hashed directly. Strings are converted to bytes with the given encoding. All other objects are first serialised using json.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Any</code> <p>Value to hash.</p> required <code>hashtype</code> <code>str</code> <p>Any of the hash algorithms supported by hashlib.</p> <code>'sha256'</code> <code>encoding</code> <code>str</code> <p>Encoding used to convert strings to bytes before calculating the hash.</p> <code>'utf-8'</code> <code>json_encoder</code> <code>Optional[Type[JSONEncoder]]</code> <p>Customised json encoder for complex Python objects.</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>A hash of the input <code>value</code>.</p> Source code in <code>oteapi/datacache/datacache.py</code> <pre><code>def gethash(\n    value: \"Any\",\n    hashtype: str = \"sha256\",\n    encoding: str = \"utf-8\",\n    json_encoder: \"Optional[Type[json.JSONEncoder]]\" = None,\n) -&gt; str:\n\"\"\"Return a hash of `value`.\n\n    Can hash most python objects. Bytes and bytearrays are hashed directly.\n    Strings are converted to bytes with the given encoding.\n    All other objects are first serialised using json.\n\n    Args:\n        value: Value to hash.\n        hashtype: Any of the hash algorithms supported by hashlib.\n        encoding: Encoding used to convert strings to bytes before\n            calculating the hash.\n        json_encoder: Customised json encoder for complex Python objects.\n\n    Returns:\n        A hash of the input `value`.\n\n    \"\"\"\n    hash_ = hashlib.new(hashtype)\n\n    if isinstance(value, str):\n        data = value.encode(encoding)\n    else:\n        data = value\n\n    try:\n        hash_.update(data)\n    except TypeError:\n        # Fallback, try to serialise using json...\n        data = json.dumps(\n            value,\n            ensure_ascii=False,\n            cls=json_encoder,\n            sort_keys=True,\n        ).encode(encoding)\n\n        hash_.update(data)\n\n    return hash_.hexdigest()\n</code></pre>"},{"location":"api_reference/interfaces/idownloadstrategy/","title":"idownloadstrategy","text":"<p>Download Strategy Interface</p>"},{"location":"api_reference/interfaces/idownloadstrategy/#oteapi.interfaces.idownloadstrategy.IDownloadStrategy","title":"<code>IDownloadStrategy</code>  <code>dataclass</code>","text":"<p>             Bases: <code>Protocol</code></p> <p>Download Strategy Interface.</p> Source code in <code>oteapi/interfaces/idownloadstrategy.py</code> <pre><code>@dataclass  # type: ignore[misc]\nclass IDownloadStrategy(Protocol):\n\"\"\"Download Strategy Interface.\"\"\"\n\n    download_config: \"ResourceConfig\"\n\n    def get(self, session: \"Optional[Dict[str, Any]]\" = None) -&gt; \"SessionUpdate\":\n\"\"\"Execute the strategy.\n\n        Parameters:\n            session: A session-specific dictionary context.\n\n        Returns:\n            An update model of key/value-pairs to be stored in the\n            session-specific context from services.\n\n        \"\"\"\n\n    def initialize(self, session: \"Optional[Dict[str, Any]]\" = None) -&gt; \"SessionUpdate\":\n\"\"\"Initialize data class.\n\n        This method will be called through the `/initialize` endpoint of the OTE-API\n        Services.\n\n        Parameters:\n            session: A session-specific dictionary context.\n\n        Returns:\n            An update model of key/value-pairs to be stored in the\n            session-specific context from services.\n\n        \"\"\"\n</code></pre>"},{"location":"api_reference/interfaces/idownloadstrategy/#oteapi.interfaces.idownloadstrategy.IDownloadStrategy.get","title":"<code>get(session=None)</code>","text":"<p>Execute the strategy.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>Optional[Dict[str, Any]]</code> <p>A session-specific dictionary context.</p> <code>None</code> <p>Returns:</p> Type Description <code>SessionUpdate</code> <p>An update model of key/value-pairs to be stored in the</p> <code>SessionUpdate</code> <p>session-specific context from services.</p> Source code in <code>oteapi/interfaces/idownloadstrategy.py</code> <pre><code>def get(self, session: \"Optional[Dict[str, Any]]\" = None) -&gt; \"SessionUpdate\":\n\"\"\"Execute the strategy.\n\n    Parameters:\n        session: A session-specific dictionary context.\n\n    Returns:\n        An update model of key/value-pairs to be stored in the\n        session-specific context from services.\n\n    \"\"\"\n</code></pre>"},{"location":"api_reference/interfaces/idownloadstrategy/#oteapi.interfaces.idownloadstrategy.IDownloadStrategy.initialize","title":"<code>initialize(session=None)</code>","text":"<p>Initialize data class.</p> <p>This method will be called through the <code>/initialize</code> endpoint of the OTE-API Services.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>Optional[Dict[str, Any]]</code> <p>A session-specific dictionary context.</p> <code>None</code> <p>Returns:</p> Type Description <code>SessionUpdate</code> <p>An update model of key/value-pairs to be stored in the</p> <code>SessionUpdate</code> <p>session-specific context from services.</p> Source code in <code>oteapi/interfaces/idownloadstrategy.py</code> <pre><code>def initialize(self, session: \"Optional[Dict[str, Any]]\" = None) -&gt; \"SessionUpdate\":\n\"\"\"Initialize data class.\n\n    This method will be called through the `/initialize` endpoint of the OTE-API\n    Services.\n\n    Parameters:\n        session: A session-specific dictionary context.\n\n    Returns:\n        An update model of key/value-pairs to be stored in the\n        session-specific context from services.\n\n    \"\"\"\n</code></pre>"},{"location":"api_reference/interfaces/ifilterstrategy/","title":"ifilterstrategy","text":"<p>Filter Strategy Interface</p>"},{"location":"api_reference/interfaces/ifilterstrategy/#oteapi.interfaces.ifilterstrategy.IFilterStrategy","title":"<code>IFilterStrategy</code>  <code>dataclass</code>","text":"<p>             Bases: <code>Protocol</code></p> <p>Filter Strategy Interface.</p> Source code in <code>oteapi/interfaces/ifilterstrategy.py</code> <pre><code>@dataclass  # type: ignore[misc]\nclass IFilterStrategy(Protocol):\n\"\"\"Filter Strategy Interface.\"\"\"\n\n    filter_config: \"FilterConfig\"\n\n    def get(self, session: \"Optional[Dict[str, Any]]\" = None) -&gt; \"SessionUpdate\":\n\"\"\"Execute the strategy.\n\n        Parameters:\n            session: A session-specific dictionary context.\n\n        Returns:\n            An update model of key/value-pairs to be stored in the\n            session-specific context from services.\n\n        \"\"\"\n\n    def initialize(self, session: \"Optional[Dict[str, Any]]\" = None) -&gt; \"SessionUpdate\":\n\"\"\"Initialize data class.\n\n        This method will be called through the `/initialize` endpoint of the OTE-API\n        Services.\n\n        Parameters:\n            session: A session-specific dictionary context.\n\n        Returns:\n            An update model of key/value-pairs to be stored in the\n            session-specific context from services.\n\n        \"\"\"\n</code></pre>"},{"location":"api_reference/interfaces/ifilterstrategy/#oteapi.interfaces.ifilterstrategy.IFilterStrategy.get","title":"<code>get(session=None)</code>","text":"<p>Execute the strategy.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>Optional[Dict[str, Any]]</code> <p>A session-specific dictionary context.</p> <code>None</code> <p>Returns:</p> Type Description <code>SessionUpdate</code> <p>An update model of key/value-pairs to be stored in the</p> <code>SessionUpdate</code> <p>session-specific context from services.</p> Source code in <code>oteapi/interfaces/ifilterstrategy.py</code> <pre><code>def get(self, session: \"Optional[Dict[str, Any]]\" = None) -&gt; \"SessionUpdate\":\n\"\"\"Execute the strategy.\n\n    Parameters:\n        session: A session-specific dictionary context.\n\n    Returns:\n        An update model of key/value-pairs to be stored in the\n        session-specific context from services.\n\n    \"\"\"\n</code></pre>"},{"location":"api_reference/interfaces/ifilterstrategy/#oteapi.interfaces.ifilterstrategy.IFilterStrategy.initialize","title":"<code>initialize(session=None)</code>","text":"<p>Initialize data class.</p> <p>This method will be called through the <code>/initialize</code> endpoint of the OTE-API Services.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>Optional[Dict[str, Any]]</code> <p>A session-specific dictionary context.</p> <code>None</code> <p>Returns:</p> Type Description <code>SessionUpdate</code> <p>An update model of key/value-pairs to be stored in the</p> <code>SessionUpdate</code> <p>session-specific context from services.</p> Source code in <code>oteapi/interfaces/ifilterstrategy.py</code> <pre><code>def initialize(self, session: \"Optional[Dict[str, Any]]\" = None) -&gt; \"SessionUpdate\":\n\"\"\"Initialize data class.\n\n    This method will be called through the `/initialize` endpoint of the OTE-API\n    Services.\n\n    Parameters:\n        session: A session-specific dictionary context.\n\n    Returns:\n        An update model of key/value-pairs to be stored in the\n        session-specific context from services.\n\n    \"\"\"\n</code></pre>"},{"location":"api_reference/interfaces/ifunctionstrategy/","title":"ifunctionstrategy","text":"<p>Function Strategy Interface</p>"},{"location":"api_reference/interfaces/ifunctionstrategy/#oteapi.interfaces.ifunctionstrategy.IFunctionStrategy","title":"<code>IFunctionStrategy</code>  <code>dataclass</code>","text":"<p>             Bases: <code>Protocol</code></p> <p>Function Strategy Interface.</p> Source code in <code>oteapi/interfaces/ifunctionstrategy.py</code> <pre><code>@dataclass  # type: ignore[misc]\nclass IFunctionStrategy(Protocol):\n\"\"\"Function Strategy Interface.\"\"\"\n\n    function_config: \"FunctionConfig\"\n\n    def get(self, session: \"Optional[Dict[str, Any]]\" = None) -&gt; \"SessionUpdate\":\n\"\"\"Execute the strategy.\n\n        Parameters:\n            session: A session-specific dictionary context.\n\n        Returns:\n            An update model of key/value-pairs to be stored in the\n            session-specific context from services.\n\n        \"\"\"\n\n    def initialize(self, session: \"Optional[Dict[str, Any]]\" = None) -&gt; \"SessionUpdate\":\n\"\"\"Initialize data class.\n\n        This method will be called through the `/initialize` endpoint of the OTE-API\n        Services.\n\n        Parameters:\n            session: A session-specific dictionary context.\n\n        Returns:\n            An update model of key/value-pairs to be stored in the\n            session-specific context from services.\n\n        \"\"\"\n</code></pre>"},{"location":"api_reference/interfaces/ifunctionstrategy/#oteapi.interfaces.ifunctionstrategy.IFunctionStrategy.get","title":"<code>get(session=None)</code>","text":"<p>Execute the strategy.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>Optional[Dict[str, Any]]</code> <p>A session-specific dictionary context.</p> <code>None</code> <p>Returns:</p> Type Description <code>SessionUpdate</code> <p>An update model of key/value-pairs to be stored in the</p> <code>SessionUpdate</code> <p>session-specific context from services.</p> Source code in <code>oteapi/interfaces/ifunctionstrategy.py</code> <pre><code>def get(self, session: \"Optional[Dict[str, Any]]\" = None) -&gt; \"SessionUpdate\":\n\"\"\"Execute the strategy.\n\n    Parameters:\n        session: A session-specific dictionary context.\n\n    Returns:\n        An update model of key/value-pairs to be stored in the\n        session-specific context from services.\n\n    \"\"\"\n</code></pre>"},{"location":"api_reference/interfaces/ifunctionstrategy/#oteapi.interfaces.ifunctionstrategy.IFunctionStrategy.initialize","title":"<code>initialize(session=None)</code>","text":"<p>Initialize data class.</p> <p>This method will be called through the <code>/initialize</code> endpoint of the OTE-API Services.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>Optional[Dict[str, Any]]</code> <p>A session-specific dictionary context.</p> <code>None</code> <p>Returns:</p> Type Description <code>SessionUpdate</code> <p>An update model of key/value-pairs to be stored in the</p> <code>SessionUpdate</code> <p>session-specific context from services.</p> Source code in <code>oteapi/interfaces/ifunctionstrategy.py</code> <pre><code>def initialize(self, session: \"Optional[Dict[str, Any]]\" = None) -&gt; \"SessionUpdate\":\n\"\"\"Initialize data class.\n\n    This method will be called through the `/initialize` endpoint of the OTE-API\n    Services.\n\n    Parameters:\n        session: A session-specific dictionary context.\n\n    Returns:\n        An update model of key/value-pairs to be stored in the\n        session-specific context from services.\n\n    \"\"\"\n</code></pre>"},{"location":"api_reference/interfaces/imappingstrategy/","title":"imappingstrategy","text":"<p>Mapping Strategy Interface</p>"},{"location":"api_reference/interfaces/imappingstrategy/#oteapi.interfaces.imappingstrategy.IMappingStrategy","title":"<code>IMappingStrategy</code>  <code>dataclass</code>","text":"<p>             Bases: <code>Protocol</code></p> <p>Mapping Strategy Interface.</p> Source code in <code>oteapi/interfaces/imappingstrategy.py</code> <pre><code>@dataclass  # type: ignore[misc]\nclass IMappingStrategy(Protocol):\n\"\"\"Mapping Strategy Interface.\"\"\"\n\n    mapping_config: \"MappingConfig\"\n\n    def get(self, session: \"Optional[Dict[str, Any]]\" = None) -&gt; \"SessionUpdate\":\n\"\"\"Execute the strategy.\n\n        Parameters:\n            session: A session-specific dictionary context.\n\n        Returns:\n            An update model of key/value-pairs to be stored in the\n            session-specific context from services.\n\n        \"\"\"\n\n    def initialize(self, session: \"Optional[Dict[str, Any]]\" = None) -&gt; \"SessionUpdate\":\n\"\"\"Initialize data class.\n\n        This method will be called through the `/initialize` endpoint of the OTE-API\n        Services.\n\n        Parameters:\n            session: A session-specific dictionary context.\n\n        Returns:\n            An update model of key/value-pairs to be stored in the\n            session-specific context from services.\n\n        \"\"\"\n</code></pre>"},{"location":"api_reference/interfaces/imappingstrategy/#oteapi.interfaces.imappingstrategy.IMappingStrategy.get","title":"<code>get(session=None)</code>","text":"<p>Execute the strategy.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>Optional[Dict[str, Any]]</code> <p>A session-specific dictionary context.</p> <code>None</code> <p>Returns:</p> Type Description <code>SessionUpdate</code> <p>An update model of key/value-pairs to be stored in the</p> <code>SessionUpdate</code> <p>session-specific context from services.</p> Source code in <code>oteapi/interfaces/imappingstrategy.py</code> <pre><code>def get(self, session: \"Optional[Dict[str, Any]]\" = None) -&gt; \"SessionUpdate\":\n\"\"\"Execute the strategy.\n\n    Parameters:\n        session: A session-specific dictionary context.\n\n    Returns:\n        An update model of key/value-pairs to be stored in the\n        session-specific context from services.\n\n    \"\"\"\n</code></pre>"},{"location":"api_reference/interfaces/imappingstrategy/#oteapi.interfaces.imappingstrategy.IMappingStrategy.initialize","title":"<code>initialize(session=None)</code>","text":"<p>Initialize data class.</p> <p>This method will be called through the <code>/initialize</code> endpoint of the OTE-API Services.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>Optional[Dict[str, Any]]</code> <p>A session-specific dictionary context.</p> <code>None</code> <p>Returns:</p> Type Description <code>SessionUpdate</code> <p>An update model of key/value-pairs to be stored in the</p> <code>SessionUpdate</code> <p>session-specific context from services.</p> Source code in <code>oteapi/interfaces/imappingstrategy.py</code> <pre><code>def initialize(self, session: \"Optional[Dict[str, Any]]\" = None) -&gt; \"SessionUpdate\":\n\"\"\"Initialize data class.\n\n    This method will be called through the `/initialize` endpoint of the OTE-API\n    Services.\n\n    Parameters:\n        session: A session-specific dictionary context.\n\n    Returns:\n        An update model of key/value-pairs to be stored in the\n        session-specific context from services.\n\n    \"\"\"\n</code></pre>"},{"location":"api_reference/interfaces/iparsestrategy/","title":"iparsestrategy","text":"<p>Parse Strategy Interface</p>"},{"location":"api_reference/interfaces/iparsestrategy/#oteapi.interfaces.iparsestrategy.IParseStrategy","title":"<code>IParseStrategy</code>  <code>dataclass</code>","text":"<p>             Bases: <code>Protocol</code></p> <p>Parse Strategy Interface.</p> Source code in <code>oteapi/interfaces/iparsestrategy.py</code> <pre><code>@dataclass  # type: ignore[misc]\nclass IParseStrategy(Protocol):\n\"\"\"Parse Strategy Interface.\"\"\"\n\n    parse_config: \"ParserConfig\"\n\n    def get(self, session: \"Optional[Dict[str, Any]]\" = None) -&gt; \"SessionUpdate\":\n\"\"\"Execute the strategy.\n\n        Parameters:\n            session: A session-specific dictionary context.\n\n        Returns:\n            An update model of key/value-pairs to be stored in the\n            session-specific context from services.\n\n        \"\"\"\n\n    def initialize(self, session: \"Optional[Dict[str, Any]]\" = None) -&gt; \"SessionUpdate\":\n\"\"\"Initialize data class.\n\n        This method will be called through the `/initialize` endpoint of the OTE-API\n        Services.\n\n        Parameters:\n            session: A session-specific dictionary context.\n\n        Returns:\n            An update model of key/value-pairs to be stored in the\n            session-specific context from services.\n\n        \"\"\"\n</code></pre>"},{"location":"api_reference/interfaces/iparsestrategy/#oteapi.interfaces.iparsestrategy.IParseStrategy.get","title":"<code>get(session=None)</code>","text":"<p>Execute the strategy.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>Optional[Dict[str, Any]]</code> <p>A session-specific dictionary context.</p> <code>None</code> <p>Returns:</p> Type Description <code>SessionUpdate</code> <p>An update model of key/value-pairs to be stored in the</p> <code>SessionUpdate</code> <p>session-specific context from services.</p> Source code in <code>oteapi/interfaces/iparsestrategy.py</code> <pre><code>def get(self, session: \"Optional[Dict[str, Any]]\" = None) -&gt; \"SessionUpdate\":\n\"\"\"Execute the strategy.\n\n    Parameters:\n        session: A session-specific dictionary context.\n\n    Returns:\n        An update model of key/value-pairs to be stored in the\n        session-specific context from services.\n\n    \"\"\"\n</code></pre>"},{"location":"api_reference/interfaces/iparsestrategy/#oteapi.interfaces.iparsestrategy.IParseStrategy.initialize","title":"<code>initialize(session=None)</code>","text":"<p>Initialize data class.</p> <p>This method will be called through the <code>/initialize</code> endpoint of the OTE-API Services.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>Optional[Dict[str, Any]]</code> <p>A session-specific dictionary context.</p> <code>None</code> <p>Returns:</p> Type Description <code>SessionUpdate</code> <p>An update model of key/value-pairs to be stored in the</p> <code>SessionUpdate</code> <p>session-specific context from services.</p> Source code in <code>oteapi/interfaces/iparsestrategy.py</code> <pre><code>def initialize(self, session: \"Optional[Dict[str, Any]]\" = None) -&gt; \"SessionUpdate\":\n\"\"\"Initialize data class.\n\n    This method will be called through the `/initialize` endpoint of the OTE-API\n    Services.\n\n    Parameters:\n        session: A session-specific dictionary context.\n\n    Returns:\n        An update model of key/value-pairs to be stored in the\n        session-specific context from services.\n\n    \"\"\"\n</code></pre>"},{"location":"api_reference/interfaces/iresourcestrategy/","title":"iresourcestrategy","text":"<p>Resource Strategy Interface</p>"},{"location":"api_reference/interfaces/iresourcestrategy/#oteapi.interfaces.iresourcestrategy.IResourceStrategy","title":"<code>IResourceStrategy</code>  <code>dataclass</code>","text":"<p>             Bases: <code>Protocol</code></p> <p>Resource Strategy Interface.</p> Source code in <code>oteapi/interfaces/iresourcestrategy.py</code> <pre><code>@dataclass  # type: ignore[misc]\nclass IResourceStrategy(Protocol):\n\"\"\"Resource Strategy Interface.\"\"\"\n\n    resource_config: \"ResourceConfig\"\n\n    def get(self, session: \"Optional[Dict[str, Any]]\" = None) -&gt; \"SessionUpdate\":\n\"\"\"Execute the strategy.\n\n        Parameters:\n            session: A session-specific dictionary context.\n\n        Returns:\n            An update model of key/value-pairs to be stored in the\n            session-specific context from services.\n\n        \"\"\"\n\n    def initialize(self, session: \"Optional[Dict[str, Any]]\" = None) -&gt; \"SessionUpdate\":\n\"\"\"Initialize data class.\n\n        This method will be called through the `/initialize` endpoint of the OTE-API\n        Services.\n\n        Parameters:\n            session: A session-specific dictionary context.\n\n        Returns:\n            An update model of key/value-pairs to be stored in the\n            session-specific context from services.\n\n        \"\"\"\n</code></pre>"},{"location":"api_reference/interfaces/iresourcestrategy/#oteapi.interfaces.iresourcestrategy.IResourceStrategy.get","title":"<code>get(session=None)</code>","text":"<p>Execute the strategy.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>Optional[Dict[str, Any]]</code> <p>A session-specific dictionary context.</p> <code>None</code> <p>Returns:</p> Type Description <code>SessionUpdate</code> <p>An update model of key/value-pairs to be stored in the</p> <code>SessionUpdate</code> <p>session-specific context from services.</p> Source code in <code>oteapi/interfaces/iresourcestrategy.py</code> <pre><code>def get(self, session: \"Optional[Dict[str, Any]]\" = None) -&gt; \"SessionUpdate\":\n\"\"\"Execute the strategy.\n\n    Parameters:\n        session: A session-specific dictionary context.\n\n    Returns:\n        An update model of key/value-pairs to be stored in the\n        session-specific context from services.\n\n    \"\"\"\n</code></pre>"},{"location":"api_reference/interfaces/iresourcestrategy/#oteapi.interfaces.iresourcestrategy.IResourceStrategy.initialize","title":"<code>initialize(session=None)</code>","text":"<p>Initialize data class.</p> <p>This method will be called through the <code>/initialize</code> endpoint of the OTE-API Services.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>Optional[Dict[str, Any]]</code> <p>A session-specific dictionary context.</p> <code>None</code> <p>Returns:</p> Type Description <code>SessionUpdate</code> <p>An update model of key/value-pairs to be stored in the</p> <code>SessionUpdate</code> <p>session-specific context from services.</p> Source code in <code>oteapi/interfaces/iresourcestrategy.py</code> <pre><code>def initialize(self, session: \"Optional[Dict[str, Any]]\" = None) -&gt; \"SessionUpdate\":\n\"\"\"Initialize data class.\n\n    This method will be called through the `/initialize` endpoint of the OTE-API\n    Services.\n\n    Parameters:\n        session: A session-specific dictionary context.\n\n    Returns:\n        An update model of key/value-pairs to be stored in the\n        session-specific context from services.\n\n    \"\"\"\n</code></pre>"},{"location":"api_reference/interfaces/itransformationstrategy/","title":"itransformationstrategy","text":"<p>Tranformation Strategy Interface</p>"},{"location":"api_reference/interfaces/itransformationstrategy/#oteapi.interfaces.itransformationstrategy.ITransformationStrategy","title":"<code>ITransformationStrategy</code>  <code>dataclass</code>","text":"<p>             Bases: <code>Protocol</code></p> <p>Transformation Strategy Interface.</p> Source code in <code>oteapi/interfaces/itransformationstrategy.py</code> <pre><code>@dataclass  # type: ignore[misc]\nclass ITransformationStrategy(Protocol):\n\"\"\"Transformation Strategy Interface.\"\"\"\n\n    transformation_config: \"TransformationConfig\"\n\n    def status(self, task_id: str) -&gt; \"TransformationStatus\":\n\"\"\"Get job status.\n\n        Parameters:\n            task_id: The transformation job ID.\n\n        Returns:\n            An overview of the transformation job's status, including relevant\n            metadata.\n\n        \"\"\"\n\n    def get(self, session: \"Optional[Dict[str, Any]]\" = None) -&gt; \"SessionUpdate\":\n\"\"\"Execute the strategy i.e. running a transformation job.\n\n        Parameters:\n            session: A session-specific dictionary context.\n\n        Returns:\n            An update model of key/value-pairs to be stored in the\n            session-specific context from services.\n\n        \"\"\"\n\n    def initialize(self, session: \"Optional[Dict[str, Any]]\" = None) -&gt; \"SessionUpdate\":\n\"\"\"Initialize data class.\n\n        This method will be called through the `/initialize` endpoint of the OTE-API\n        Services.\n\n        Parameters:\n            session: A session-specific dictionary context.\n\n        Returns:\n            An update model of key/value-pairs to be stored in the\n            session-specific context from services.\n\n        \"\"\"\n</code></pre>"},{"location":"api_reference/interfaces/itransformationstrategy/#oteapi.interfaces.itransformationstrategy.ITransformationStrategy.get","title":"<code>get(session=None)</code>","text":"<p>Execute the strategy i.e. running a transformation job.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>Optional[Dict[str, Any]]</code> <p>A session-specific dictionary context.</p> <code>None</code> <p>Returns:</p> Type Description <code>SessionUpdate</code> <p>An update model of key/value-pairs to be stored in the</p> <code>SessionUpdate</code> <p>session-specific context from services.</p> Source code in <code>oteapi/interfaces/itransformationstrategy.py</code> <pre><code>def get(self, session: \"Optional[Dict[str, Any]]\" = None) -&gt; \"SessionUpdate\":\n\"\"\"Execute the strategy i.e. running a transformation job.\n\n    Parameters:\n        session: A session-specific dictionary context.\n\n    Returns:\n        An update model of key/value-pairs to be stored in the\n        session-specific context from services.\n\n    \"\"\"\n</code></pre>"},{"location":"api_reference/interfaces/itransformationstrategy/#oteapi.interfaces.itransformationstrategy.ITransformationStrategy.initialize","title":"<code>initialize(session=None)</code>","text":"<p>Initialize data class.</p> <p>This method will be called through the <code>/initialize</code> endpoint of the OTE-API Services.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>Optional[Dict[str, Any]]</code> <p>A session-specific dictionary context.</p> <code>None</code> <p>Returns:</p> Type Description <code>SessionUpdate</code> <p>An update model of key/value-pairs to be stored in the</p> <code>SessionUpdate</code> <p>session-specific context from services.</p> Source code in <code>oteapi/interfaces/itransformationstrategy.py</code> <pre><code>def initialize(self, session: \"Optional[Dict[str, Any]]\" = None) -&gt; \"SessionUpdate\":\n\"\"\"Initialize data class.\n\n    This method will be called through the `/initialize` endpoint of the OTE-API\n    Services.\n\n    Parameters:\n        session: A session-specific dictionary context.\n\n    Returns:\n        An update model of key/value-pairs to be stored in the\n        session-specific context from services.\n\n    \"\"\"\n</code></pre>"},{"location":"api_reference/interfaces/itransformationstrategy/#oteapi.interfaces.itransformationstrategy.ITransformationStrategy.status","title":"<code>status(task_id)</code>","text":"<p>Get job status.</p> <p>Parameters:</p> Name Type Description Default <code>task_id</code> <code>str</code> <p>The transformation job ID.</p> required <p>Returns:</p> Type Description <code>TransformationStatus</code> <p>An overview of the transformation job's status, including relevant</p> <code>TransformationStatus</code> <p>metadata.</p> Source code in <code>oteapi/interfaces/itransformationstrategy.py</code> <pre><code>def status(self, task_id: str) -&gt; \"TransformationStatus\":\n\"\"\"Get job status.\n\n    Parameters:\n        task_id: The transformation job ID.\n\n    Returns:\n        An overview of the transformation job's status, including relevant\n        metadata.\n\n    \"\"\"\n</code></pre>"},{"location":"api_reference/models/datacacheconfig/","title":"datacacheconfig","text":"<p>Pydantic DataCache Configuration Data Model.</p>"},{"location":"api_reference/models/datacacheconfig/#oteapi.models.datacacheconfig.DataCacheConfig","title":"<code>DataCacheConfig</code>","text":"<p>             Bases: <code>AttrDict</code></p> <p>DataCache Configuration.</p> <p>This class should not be used directly as a configuration object for a strategy object, but only as a configuration field inside a configuration object.</p> Source code in <code>oteapi/models/datacacheconfig.py</code> <pre><code>class DataCacheConfig(AttrDict):\n\"\"\"DataCache Configuration.\n\n    This class should not be used directly as a configuration object\n    for a strategy object, but only as a configuration field inside\n    a configuration object.\n    \"\"\"\n\n    cacheDir: Path = Field(Path(\"oteapi\"), description=\"Cache directory.\")\n    accessKey: Optional[str] = Field(\n        None,\n        description=\"Key with which the downloaded content can be accessed. \"\n        \"Should preferable be the hash (corresponding to `hashType`) of the \"\n        \"content if it is known.\",\n    )\n    hashType: str = Field(\n        \"md5\",\n        description=\"Hash algorithm to use for creating hash keys for stored \"\n        \"data. Can be any algorithm supported by hashlib.\",\n    )\n    expireTime: int = Field(\n        3600 * 24 * 14,\n        description=\"Number of seconds before the cache entry expires. \"\n        \"Zero means no expiration. Default is two weeks.\",\n    )\n    tag: Optional[str] = Field(\n        None,\n        description=\"Tag assigned to the downloaded content, typically \"\n        \"identifying a session. Used with the `evict()` method to clean up a \"\n        \"all cache entries with a given tag.\",\n    )\n</code></pre>"},{"location":"api_reference/models/datacacheconfig/#oteapi.models.datacacheconfig.DataCacheConfig.accessKey","title":"<code>accessKey: Optional[str] = Field(None, description='Key with which the downloaded content can be accessed. Should preferable be the hash (corresponding to `hashType`) of the content if it is known.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/models/datacacheconfig/#oteapi.models.datacacheconfig.DataCacheConfig.cacheDir","title":"<code>cacheDir: Path = Field(Path('oteapi'), description='Cache directory.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/models/datacacheconfig/#oteapi.models.datacacheconfig.DataCacheConfig.expireTime","title":"<code>expireTime: int = Field(3600 * 24 * 14, description='Number of seconds before the cache entry expires. Zero means no expiration. Default is two weeks.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/models/datacacheconfig/#oteapi.models.datacacheconfig.DataCacheConfig.hashType","title":"<code>hashType: str = Field('md5', description='Hash algorithm to use for creating hash keys for stored data. Can be any algorithm supported by hashlib.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/models/datacacheconfig/#oteapi.models.datacacheconfig.DataCacheConfig.tag","title":"<code>tag: Optional[str] = Field(None, description='Tag assigned to the downloaded content, typically identifying a session. Used with the `evict()` method to clean up a all cache entries with a given tag.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/models/filterconfig/","title":"filterconfig","text":"<p>Pydantic Filter Configuration Data Model.</p>"},{"location":"api_reference/models/filterconfig/#oteapi.models.filterconfig.FilterConfig","title":"<code>FilterConfig</code>","text":"<p>             Bases: <code>GenericConfig</code></p> <p>Filter Strategy Data Configuration.</p> Source code in <code>oteapi/models/filterconfig.py</code> <pre><code>class FilterConfig(GenericConfig):\n\"\"\"Filter Strategy Data Configuration.\"\"\"\n\n    filterType: str = Field(\n        ..., description=\"Type of registered filter strategy. E.g., `filter/sql`.\"\n    )\n    query: Optional[str] = Field(None, description=\"Define a query operation.\")\n    condition: Optional[str] = Field(\n        None,\n        description=\"Logical statement indicating when a filter should be applied.\",\n    )\n    limit: Optional[int] = Field(\n        None, description=\"Number of items remaining after a filter expression.\"\n    )\n</code></pre>"},{"location":"api_reference/models/filterconfig/#oteapi.models.filterconfig.FilterConfig.condition","title":"<code>condition: Optional[str] = Field(None, description='Logical statement indicating when a filter should be applied.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/models/filterconfig/#oteapi.models.filterconfig.FilterConfig.filterType","title":"<code>filterType: str = Field(..., description='Type of registered filter strategy. E.g., `filter/sql`.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/models/filterconfig/#oteapi.models.filterconfig.FilterConfig.limit","title":"<code>limit: Optional[int] = Field(None, description='Number of items remaining after a filter expression.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/models/filterconfig/#oteapi.models.filterconfig.FilterConfig.query","title":"<code>query: Optional[str] = Field(None, description='Define a query operation.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/models/functionconfig/","title":"functionconfig","text":"<p>Pydantic Function Configuration Data Model.</p>"},{"location":"api_reference/models/functionconfig/#oteapi.models.functionconfig.FunctionConfig","title":"<code>FunctionConfig</code>","text":"<p>             Bases: <code>GenericConfig</code>, <code>SecretConfig</code></p> <p>Function Strategy Data Configuration.</p> Source code in <code>oteapi/models/functionconfig.py</code> <pre><code>class FunctionConfig(GenericConfig, SecretConfig):\n\"\"\"Function Strategy Data Configuration.\"\"\"\n\n    functionType: str = Field(\n        ...,\n        description=(\"Type of registered function strategy.\"),\n    )\n</code></pre>"},{"location":"api_reference/models/functionconfig/#oteapi.models.functionconfig.FunctionConfig.functionType","title":"<code>functionType: str = Field(..., description='Type of registered function strategy.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/models/genericconfig/","title":"genericconfig","text":"<p>Generic data model for configuration attributes.</p>"},{"location":"api_reference/models/genericconfig/#oteapi.models.genericconfig.AttrDict","title":"<code>AttrDict</code>","text":"<p>             Bases: <code>BaseModel</code>, <code>Mapping</code></p> <p>An object whose attributes can also be accessed through subscription, like with a dictionary.</p> Source code in <code>oteapi/models/genericconfig.py</code> <pre><code>class AttrDict(BaseModel, Mapping):\n\"\"\"An object whose attributes can also be accessed through\n    subscription, like with a dictionary.\"\"\"\n\n    def __contains__(self, name: \"Any\") -&gt; bool:\n\"\"\"Enable using the 'in' operator on this object.\"\"\"\n        return self.__dict__.__contains__(name)\n\n    def __delitem__(self, key: str) -&gt; None:\n\"\"\"Enable deletion access through subscription.\n\n        If the item is a pydantic field, reset it and remove it from the set of set\n        fields. Otherwise, delete the attribute.\n\n        \"\"\"\n        if key in self.__dict__:\n            if key in self.__fields__:\n                # Reset field to default and remove from set of set fields\n                setattr(self, key, self.__fields__[key].default)\n                self.__fields_set__.remove(key)\n            else:\n                self.__delattr__(key)\n        else:\n            raise KeyError(key)\n\n    def __getitem__(self, key: str) -&gt; \"Any\":\n\"\"\"Enable read access through subscription.\"\"\"\n        if key in self.__dict__:\n            return getattr(self, key)\n        raise KeyError(key)\n\n    def __setitem__(self, key: str, value: \"Any\") -&gt; None:\n\"\"\"Enable write access through subscription.\"\"\"\n        setattr(self, key, value)\n\n    def __len__(self):\n\"\"\"Return number of items.\"\"\"\n        return self.__dict__.__len__()\n\n    def __iter__(self):\n\"\"\"Enable **unpacking.\"\"\"\n        return self.__dict__.__iter__()\n\n    def items(self):\n\"\"\"Return a view of all (key, value) pairs.\"\"\"\n        return self.__dict__.items()\n\n    def keys(self):\n\"\"\"Return a view of all keys.\"\"\"\n        return self.__dict__.keys()\n\n    def values(self):\n\"\"\"Return a view of all values.\"\"\"\n        return self.__dict__.values()\n\n    def get(self, key: str, default: \"Optional[Any]\" = None) -&gt; \"Any\":\n\"\"\"Mapping `get`-method.\"\"\"\n        return self.__dict__.get(key, default)\n\n    def __ne__(self, other: \"Any\") -&gt; bool:\n\"\"\"Implement the != operator.\"\"\"\n        if isinstance(other, BaseModel):\n            return self.dict() != other.dict()\n        return self.dict() != other\n\n    def update(\n        self, other: \"Optional[Union[dict, AttrDict, Iterable[Any]]]\" = None, **kwargs\n    ) -&gt; None:\n\"\"\"MutableMapping `update`-method.\"\"\"\n        if other and isinstance(other, (dict, Mapping)):\n            for key, value in other.items():\n                setattr(self, key, value)\n        elif other and isinstance(other, BaseModel):\n            for key, value in other.dict().items():\n                setattr(self, key, value)\n        elif other and isinstance(other, Iterable):\n            for entry in other:\n                if not len(entry) == 2:\n                    raise ValueError(\n                        \"`other` must be an iterable of objects of length two.\"\n                    )\n            for key, value in other:\n                setattr(self, key, value)\n        if kwargs:\n            for key, value in kwargs.items():\n                setattr(self, key, value)\n\n    def pop(self, key: str, default: \"Optional[Any]\" = Undefined) -&gt; \"Any\":\n\"\"\"MutableMapping `pop`-method.\"\"\"\n        value = self.get(key, default)\n        if value == Undefined:\n            raise KeyError(key)\n        if key in self:\n            del self[key]\n        return value\n\n    def popitem(self) -&gt; \"Tuple[str, Any]\":\n\"\"\"MutableMapping `popitem`-method.\n\n        Important:\n            Unlike the regular `dict.popitem()` method, this one does _not_ respect\n            LIFO (last-in, first-out).\n            This is due to the fact that attributes are stored in a random order when\n            initializing the model.\n\n            However, it will respect LIFO with respect to the internal `__dict__`.\n\n        \"\"\"\n        if not self:\n            raise KeyError(f\"popitem(): {self.__class__.__name__} is empty\")\n\n        key = list(self.__dict__)[-1]\n        value = self.pop(key)\n        return key, value\n\n    class Config:\n\"\"\"Pydantic configuration for `AttrDict`.\n\n        * **`extra`**\n          Allow any attributes/fields to be defined - this is what makes this pydantic\n          model an attribute dictionary.\n        * **`validate_assignment`**\n          Validate and cast set values.\n          This is mainly relevant for sub-classes of `AttrDict`, where specific\n          attributes have been defined.\n        * **`arbitrary_types_allowed`**\n          If a custom type is used for an attribute that doesn't have a `validate()`\n          method, don't fail setting the attribute.\n\n        \"\"\"\n\n        extra = \"allow\"\n        validate_assignment = True\n        arbitrary_types_allowed = True\n</code></pre>"},{"location":"api_reference/models/genericconfig/#oteapi.models.genericconfig.AttrDict.Config","title":"<code>Config</code>","text":"<p>Pydantic configuration for <code>AttrDict</code>.</p> <ul> <li><code>extra</code>   Allow any attributes/fields to be defined - this is what makes this pydantic   model an attribute dictionary.</li> <li><code>validate_assignment</code>   Validate and cast set values.   This is mainly relevant for sub-classes of <code>AttrDict</code>, where specific   attributes have been defined.</li> <li><code>arbitrary_types_allowed</code>   If a custom type is used for an attribute that doesn't have a <code>validate()</code>   method, don't fail setting the attribute.</li> </ul> Source code in <code>oteapi/models/genericconfig.py</code> <pre><code>class Config:\n\"\"\"Pydantic configuration for `AttrDict`.\n\n    * **`extra`**\n      Allow any attributes/fields to be defined - this is what makes this pydantic\n      model an attribute dictionary.\n    * **`validate_assignment`**\n      Validate and cast set values.\n      This is mainly relevant for sub-classes of `AttrDict`, where specific\n      attributes have been defined.\n    * **`arbitrary_types_allowed`**\n      If a custom type is used for an attribute that doesn't have a `validate()`\n      method, don't fail setting the attribute.\n\n    \"\"\"\n\n    extra = \"allow\"\n    validate_assignment = True\n    arbitrary_types_allowed = True\n</code></pre>"},{"location":"api_reference/models/genericconfig/#oteapi.models.genericconfig.AttrDict.Config.arbitrary_types_allowed","title":"<code>arbitrary_types_allowed = True</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/models/genericconfig/#oteapi.models.genericconfig.AttrDict.Config.extra","title":"<code>extra = 'allow'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/models/genericconfig/#oteapi.models.genericconfig.AttrDict.Config.validate_assignment","title":"<code>validate_assignment = True</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/models/genericconfig/#oteapi.models.genericconfig.AttrDict.get","title":"<code>get(key, default=None)</code>","text":"<p>Mapping <code>get</code>-method.</p> Source code in <code>oteapi/models/genericconfig.py</code> <pre><code>def get(self, key: str, default: \"Optional[Any]\" = None) -&gt; \"Any\":\n\"\"\"Mapping `get`-method.\"\"\"\n    return self.__dict__.get(key, default)\n</code></pre>"},{"location":"api_reference/models/genericconfig/#oteapi.models.genericconfig.AttrDict.items","title":"<code>items()</code>","text":"<p>Return a view of all (key, value) pairs.</p> Source code in <code>oteapi/models/genericconfig.py</code> <pre><code>def items(self):\n\"\"\"Return a view of all (key, value) pairs.\"\"\"\n    return self.__dict__.items()\n</code></pre>"},{"location":"api_reference/models/genericconfig/#oteapi.models.genericconfig.AttrDict.keys","title":"<code>keys()</code>","text":"<p>Return a view of all keys.</p> Source code in <code>oteapi/models/genericconfig.py</code> <pre><code>def keys(self):\n\"\"\"Return a view of all keys.\"\"\"\n    return self.__dict__.keys()\n</code></pre>"},{"location":"api_reference/models/genericconfig/#oteapi.models.genericconfig.AttrDict.pop","title":"<code>pop(key, default=Undefined)</code>","text":"<p>MutableMapping <code>pop</code>-method.</p> Source code in <code>oteapi/models/genericconfig.py</code> <pre><code>def pop(self, key: str, default: \"Optional[Any]\" = Undefined) -&gt; \"Any\":\n\"\"\"MutableMapping `pop`-method.\"\"\"\n    value = self.get(key, default)\n    if value == Undefined:\n        raise KeyError(key)\n    if key in self:\n        del self[key]\n    return value\n</code></pre>"},{"location":"api_reference/models/genericconfig/#oteapi.models.genericconfig.AttrDict.popitem","title":"<code>popitem()</code>","text":"<p>MutableMapping <code>popitem</code>-method.</p> Important <p>Unlike the regular <code>dict.popitem()</code> method, this one does not respect LIFO (last-in, first-out). This is due to the fact that attributes are stored in a random order when initializing the model.</p> <p>However, it will respect LIFO with respect to the internal <code>__dict__</code>.</p> Source code in <code>oteapi/models/genericconfig.py</code> <pre><code>def popitem(self) -&gt; \"Tuple[str, Any]\":\n\"\"\"MutableMapping `popitem`-method.\n\n    Important:\n        Unlike the regular `dict.popitem()` method, this one does _not_ respect\n        LIFO (last-in, first-out).\n        This is due to the fact that attributes are stored in a random order when\n        initializing the model.\n\n        However, it will respect LIFO with respect to the internal `__dict__`.\n\n    \"\"\"\n    if not self:\n        raise KeyError(f\"popitem(): {self.__class__.__name__} is empty\")\n\n    key = list(self.__dict__)[-1]\n    value = self.pop(key)\n    return key, value\n</code></pre>"},{"location":"api_reference/models/genericconfig/#oteapi.models.genericconfig.AttrDict.update","title":"<code>update(other=None, **kwargs)</code>","text":"<p>MutableMapping <code>update</code>-method.</p> Source code in <code>oteapi/models/genericconfig.py</code> <pre><code>def update(\n    self, other: \"Optional[Union[dict, AttrDict, Iterable[Any]]]\" = None, **kwargs\n) -&gt; None:\n\"\"\"MutableMapping `update`-method.\"\"\"\n    if other and isinstance(other, (dict, Mapping)):\n        for key, value in other.items():\n            setattr(self, key, value)\n    elif other and isinstance(other, BaseModel):\n        for key, value in other.dict().items():\n            setattr(self, key, value)\n    elif other and isinstance(other, Iterable):\n        for entry in other:\n            if not len(entry) == 2:\n                raise ValueError(\n                    \"`other` must be an iterable of objects of length two.\"\n                )\n        for key, value in other:\n            setattr(self, key, value)\n    if kwargs:\n        for key, value in kwargs.items():\n            setattr(self, key, value)\n</code></pre>"},{"location":"api_reference/models/genericconfig/#oteapi.models.genericconfig.AttrDict.values","title":"<code>values()</code>","text":"<p>Return a view of all values.</p> Source code in <code>oteapi/models/genericconfig.py</code> <pre><code>def values(self):\n\"\"\"Return a view of all values.\"\"\"\n    return self.__dict__.values()\n</code></pre>"},{"location":"api_reference/models/genericconfig/#oteapi.models.genericconfig.GenericConfig","title":"<code>GenericConfig</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>Generic class for configuration objects.</p> Source code in <code>oteapi/models/genericconfig.py</code> <pre><code>class GenericConfig(BaseModel):\n\"\"\"Generic class for configuration objects.\"\"\"\n\n    configuration: AttrDict = Field(\n        AttrDict(),\n        description=\"Model-specific configuration options which can either \"\n        \"be given as key/value-pairs or set as attributes.\",\n    )\n\n    description: str = Field(\n        __doc__,\n        description=\"A description of the configuration model.\",\n    )\n\n    @classmethod\n    def __init_subclass__(cls) -&gt; None:\n\"\"\"Initialize subclass descriptions with their docstrings.\"\"\"\n        cls.__fields__[\"description\"].default = cls.__doc__\n\n    class Config:\n\"\"\"Pydantic configuration for `GenericConfig`.\n\n        * **`validate_assignment`**\n          Validate and cast set values.\n          This is mainly relevant for sub-classes of `AttrDict`, where specific\n          attributes have been defined.\n        * **`arbitrary_types_allowed`**\n          If a custom type is used for an attribute that doesn't have a `validate()`\n          method, don't fail setting the attribute.\n\n        \"\"\"\n\n        validate_assignment = True\n        arbitrary_types_allowed = True\n</code></pre>"},{"location":"api_reference/models/genericconfig/#oteapi.models.genericconfig.GenericConfig.configuration","title":"<code>configuration: AttrDict = Field(AttrDict(), description='Model-specific configuration options which can either be given as key/value-pairs or set as attributes.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/models/genericconfig/#oteapi.models.genericconfig.GenericConfig.description","title":"<code>description: str = Field(__doc__, description='A description of the configuration model.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/models/genericconfig/#oteapi.models.genericconfig.GenericConfig.Config","title":"<code>Config</code>","text":"<p>Pydantic configuration for <code>GenericConfig</code>.</p> <ul> <li><code>validate_assignment</code>   Validate and cast set values.   This is mainly relevant for sub-classes of <code>AttrDict</code>, where specific   attributes have been defined.</li> <li><code>arbitrary_types_allowed</code>   If a custom type is used for an attribute that doesn't have a <code>validate()</code>   method, don't fail setting the attribute.</li> </ul> Source code in <code>oteapi/models/genericconfig.py</code> <pre><code>class Config:\n\"\"\"Pydantic configuration for `GenericConfig`.\n\n    * **`validate_assignment`**\n      Validate and cast set values.\n      This is mainly relevant for sub-classes of `AttrDict`, where specific\n      attributes have been defined.\n    * **`arbitrary_types_allowed`**\n      If a custom type is used for an attribute that doesn't have a `validate()`\n      method, don't fail setting the attribute.\n\n    \"\"\"\n\n    validate_assignment = True\n    arbitrary_types_allowed = True\n</code></pre>"},{"location":"api_reference/models/genericconfig/#oteapi.models.genericconfig.GenericConfig.Config.arbitrary_types_allowed","title":"<code>arbitrary_types_allowed = True</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/models/genericconfig/#oteapi.models.genericconfig.GenericConfig.Config.validate_assignment","title":"<code>validate_assignment = True</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/models/mappingconfig/","title":"mappingconfig","text":"<p>Pydantic Mapping Configuration Data Model.</p>"},{"location":"api_reference/models/mappingconfig/#oteapi.models.mappingconfig.RDFTriple","title":"<code>RDFTriple = Tuple[str, str, str]</code>  <code>module-attribute</code>","text":""},{"location":"api_reference/models/mappingconfig/#oteapi.models.mappingconfig.MappingConfig","title":"<code>MappingConfig</code>","text":"<p>             Bases: <code>GenericConfig</code></p> <p>Mapping Strategy Data Configuration.</p> Source code in <code>oteapi/models/mappingconfig.py</code> <pre><code>class MappingConfig(GenericConfig):\n\"\"\"Mapping Strategy Data Configuration.\"\"\"\n\n    mappingType: str = Field(\n        ...,\n        description=\"Type of registered mapping strategy.\",\n    )\n    prefixes: Optional[Dict[str, str]] = Field(\n        None,\n        description=(\n            \"Dictionary of shortnames that expands to an IRI given as local \"\n            \"value/IRI-expansion-pairs.\"\n        ),\n    )\n    triples: Optional[Set[RDFTriple]] = Field(\n        None,\n        description=\"Set of RDF triples given as (subject, predicate, object).\",\n    )\n</code></pre>"},{"location":"api_reference/models/mappingconfig/#oteapi.models.mappingconfig.MappingConfig.mappingType","title":"<code>mappingType: str = Field(..., description='Type of registered mapping strategy.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/models/mappingconfig/#oteapi.models.mappingconfig.MappingConfig.prefixes","title":"<code>prefixes: Optional[Dict[str, str]] = Field(None, description='Dictionary of shortnames that expands to an IRI given as local value/IRI-expansion-pairs.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/models/mappingconfig/#oteapi.models.mappingconfig.MappingConfig.triples","title":"<code>triples: Optional[Set[RDFTriple]] = Field(None, description='Set of RDF triples given as (subject, predicate, object).')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/models/parserconfig/","title":"parserconfig","text":"<p>Pydantic Parser Configuration Data Model.</p>"},{"location":"api_reference/models/parserconfig/#oteapi.models.parserconfig.ParserConfig","title":"<code>ParserConfig</code>","text":"<p>             Bases: <code>GenericConfig</code></p> <p>Parser Strategy Data Configuration.</p> Source code in <code>oteapi/models/parserconfig.py</code> <pre><code>class ParserConfig(GenericConfig):\n\"\"\"Parser Strategy Data Configuration.\"\"\"\n\n    parserType: str = Field(..., description=\"Type of registered parser strategy.\")\n</code></pre>"},{"location":"api_reference/models/parserconfig/#oteapi.models.parserconfig.ParserConfig.parserType","title":"<code>parserType: str = Field(..., description='Type of registered parser strategy.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/models/resourceconfig/","title":"resourceconfig","text":"<p>Pydantic Resource Configuration Data Model.</p>"},{"location":"api_reference/models/resourceconfig/#oteapi.models.resourceconfig.HostlessAnyUrl","title":"<code>HostlessAnyUrl</code>","text":"<p>             Bases: <code>AnyUrl</code></p> <p>AnyUrl, but allow not having a host.</p> Source code in <code>oteapi/models/resourceconfig.py</code> <pre><code>class HostlessAnyUrl(AnyUrl):\n\"\"\"AnyUrl, but allow not having a host.\"\"\"\n\n    host_required = False\n</code></pre>"},{"location":"api_reference/models/resourceconfig/#oteapi.models.resourceconfig.HostlessAnyUrl.host_required","title":"<code>host_required = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/models/resourceconfig/#oteapi.models.resourceconfig.ResourceConfig","title":"<code>ResourceConfig</code>","text":"<p>             Bases: <code>GenericConfig</code>, <code>SecretConfig</code></p> <p>Resource Strategy Data Configuration.</p> Important <p>Either of the pairs of attributes <code>downloadUrl</code>/<code>mediaType</code> or <code>accessUrl</code>/<code>accessService</code> MUST be specified.</p> Source code in <code>oteapi/models/resourceconfig.py</code> <pre><code>class ResourceConfig(GenericConfig, SecretConfig):\n\"\"\"Resource Strategy Data Configuration.\n\n    Important:\n        Either of the pairs of attributes `downloadUrl`/`mediaType` or\n        `accessUrl`/`accessService` MUST be specified.\n\n    \"\"\"\n\n    downloadUrl: Optional[HostlessAnyUrl] = Field(\n        None,\n        description=(\n            \"Definition: The URL of the downloadable file in a given format. E.g. CSV \"\n            \"file or RDF file.\\n\\nUsage: `downloadURL` *SHOULD* be used for the URL at\"\n            \" which this distribution is available directly, typically through a HTTPS\"\n            \" GET request or SFTP.\"\n        ),\n    )\n    mediaType: Optional[str] = Field(\n        None,\n        description=(\n            \"The media type of the distribution as defined by IANA \"\n            \"[[IANA-MEDIA-TYPES](https://www.w3.org/TR/vocab-dcat-2/#bib-iana-media-types)]\"\n            \".\\n\\nUsage: This property *SHOULD* be used when the media\"\n            \" type of the distribution is defined in IANA \"\n            \"[[IANA-MEDIA-TYPES](https://www.w3.org/TR/vocab-dcat-2/#bib-iana-media-types)].\"\n        ),\n    )\n    accessUrl: Optional[HostlessAnyUrl] = Field(\n        None,\n        description=(\n            \"A URL of the resource that gives access to a distribution of \"\n            \"the dataset. E.g. landing page, feed, SPARQL endpoint.\\n\\nUsage: \"\n            \"`accessURL` *SHOULD* be used for the URL of a service or location that \"\n            \"can provide access to this distribution, typically through a Web form, \"\n            \"query or API call.\\n`downloadURL` is preferred for direct links to \"\n            \"downloadable resources.\"\n        ),\n    )\n    accessService: Optional[str] = Field(\n        None,\n        description=(\n            \"A data service that gives access to the distribution of the dataset.\"\n        ),\n    )\n    license: Optional[str] = Field(\n        None,\n        description=(\n            \"A legal document under which the distribution is made available.\"\n        ),\n    )\n    accessRights: Optional[str] = Field(\n        None,\n        description=(\n            \"A rights statement that concerns how the distribution is accessed.\"\n        ),\n    )\n    publisher: Optional[str] = Field(\n        None,\n        description=\"The entity responsible for making the resource/item available.\",\n    )\n\n    @root_validator\n    def ensure_unique_url_pairs(cls, values: \"Dict[str, Any]\") -&gt; \"Dict[str, Any]\":\n\"\"\"Ensure either downloadUrl/mediaType or accessUrl/accessService are defined.\n\n        It's fine to define them all, but at least one complete pair MUST be specified.\n        \"\"\"\n        if not (\n            all(values.get(_) for _ in [\"downloadUrl\", \"mediaType\"])\n            or all(values.get(_) for _ in [\"accessUrl\", \"accessService\"])\n        ):\n            raise ValueError(\n                \"Either of the pairs of attributes downloadUrl/mediaType or \"\n                \"accessUrl/accessService MUST be specified.\"\n            )\n        return values\n</code></pre>"},{"location":"api_reference/models/resourceconfig/#oteapi.models.resourceconfig.ResourceConfig.accessRights","title":"<code>accessRights: Optional[str] = Field(None, description='A rights statement that concerns how the distribution is accessed.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/models/resourceconfig/#oteapi.models.resourceconfig.ResourceConfig.accessService","title":"<code>accessService: Optional[str] = Field(None, description='A data service that gives access to the distribution of the dataset.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/models/resourceconfig/#oteapi.models.resourceconfig.ResourceConfig.accessUrl","title":"<code>accessUrl: Optional[HostlessAnyUrl] = Field(None, description='A URL of the resource that gives access to a distribution of the dataset. E.g. landing page, feed, SPARQL endpoint.\\n\\nUsage: `accessURL` *SHOULD* be used for the URL of a service or location that can provide access to this distribution, typically through a Web form, query or API call.\\n`downloadURL` is preferred for direct links to downloadable resources.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/models/resourceconfig/#oteapi.models.resourceconfig.ResourceConfig.downloadUrl","title":"<code>downloadUrl: Optional[HostlessAnyUrl] = Field(None, description='Definition: The URL of the downloadable file in a given format. E.g. CSV file or RDF file.\\n\\nUsage: `downloadURL` *SHOULD* be used for the URL at which this distribution is available directly, typically through a HTTPS GET request or SFTP.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/models/resourceconfig/#oteapi.models.resourceconfig.ResourceConfig.license","title":"<code>license: Optional[str] = Field(None, description='A legal document under which the distribution is made available.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/models/resourceconfig/#oteapi.models.resourceconfig.ResourceConfig.mediaType","title":"<code>mediaType: Optional[str] = Field(None, description='The media type of the distribution as defined by IANA [[IANA-MEDIA-TYPES](https://www.w3.org/TR/vocab-dcat-2/#bib-iana-media-types)].\\n\\nUsage: This property *SHOULD* be used when the media type of the distribution is defined in IANA [[IANA-MEDIA-TYPES](https://www.w3.org/TR/vocab-dcat-2/#bib-iana-media-types)].')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/models/resourceconfig/#oteapi.models.resourceconfig.ResourceConfig.publisher","title":"<code>publisher: Optional[str] = Field(None, description='The entity responsible for making the resource/item available.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/models/resourceconfig/#oteapi.models.resourceconfig.ResourceConfig.ensure_unique_url_pairs","title":"<code>ensure_unique_url_pairs(values)</code>","text":"<p>Ensure either downloadUrl/mediaType or accessUrl/accessService are defined.</p> <p>It's fine to define them all, but at least one complete pair MUST be specified.</p> Source code in <code>oteapi/models/resourceconfig.py</code> <pre><code>@root_validator\ndef ensure_unique_url_pairs(cls, values: \"Dict[str, Any]\") -&gt; \"Dict[str, Any]\":\n\"\"\"Ensure either downloadUrl/mediaType or accessUrl/accessService are defined.\n\n    It's fine to define them all, but at least one complete pair MUST be specified.\n    \"\"\"\n    if not (\n        all(values.get(_) for _ in [\"downloadUrl\", \"mediaType\"])\n        or all(values.get(_) for _ in [\"accessUrl\", \"accessService\"])\n    ):\n        raise ValueError(\n            \"Either of the pairs of attributes downloadUrl/mediaType or \"\n            \"accessUrl/accessService MUST be specified.\"\n        )\n    return values\n</code></pre>"},{"location":"api_reference/models/secretconfig/","title":"secretconfig","text":"<p>AttrDict for specifying user credentials or secrets.</p>"},{"location":"api_reference/models/secretconfig/#oteapi.models.secretconfig.SecretConfig","title":"<code>SecretConfig</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>Simple model for handling secret in other config-models.</p> Source code in <code>oteapi/models/secretconfig.py</code> <pre><code>class SecretConfig(BaseModel, json_dumps=json_dumps):\n\"\"\"Simple model for handling secret in other config-models.\"\"\"\n\n    user: Optional[SecretStr] = Field(None, description=\"User name for authentication.\")\n    password: Optional[SecretStr] = Field(\n        None, description=\"Password for authentication.\"\n    )\n    token: Optional[SecretStr] = Field(\n        None,\n        description=(\n            \"An access token for providing access and meta data to an application.\"\n        ),\n    )\n    client_id: Optional[SecretStr] = Field(\n        None, description=\"Client ID for an OAUTH2 client.\"\n    )\n    client_secret: Optional[SecretStr] = Field(\n        None, description=\"Client secret for an OAUTH2 client.\"\n    )\n</code></pre>"},{"location":"api_reference/models/secretconfig/#oteapi.models.secretconfig.SecretConfig.client_id","title":"<code>client_id: Optional[SecretStr] = Field(None, description='Client ID for an OAUTH2 client.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/models/secretconfig/#oteapi.models.secretconfig.SecretConfig.client_secret","title":"<code>client_secret: Optional[SecretStr] = Field(None, description='Client secret for an OAUTH2 client.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/models/secretconfig/#oteapi.models.secretconfig.SecretConfig.password","title":"<code>password: Optional[SecretStr] = Field(None, description='Password for authentication.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/models/secretconfig/#oteapi.models.secretconfig.SecretConfig.token","title":"<code>token: Optional[SecretStr] = Field(None, description='An access token for providing access and meta data to an application.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/models/secretconfig/#oteapi.models.secretconfig.SecretConfig.user","title":"<code>user: Optional[SecretStr] = Field(None, description='User name for authentication.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/models/secretconfig/#oteapi.models.secretconfig.json_dumps","title":"<code>json_dumps(model, default)</code>","text":"<p>Alternative function for dumping exposed secrets to json when model is serialized.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>dict</code> <p>The pydantic model to serialize.</p> required <code>default</code> <code>Callable[[Any], Any]</code> <p>A pass-through to the standard <code>json.dumps()</code>'s <code>default</code> parameter. From the <code>json.dumps()</code> doc-string: <code>default(obj)</code> is a function that should return a serializable version of <code>obj</code> or raise <code>TypeError</code>. The default simply raises <code>TypeError</code>.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The result of <code>json.dumps()</code> after handling possible secrets.</p> Source code in <code>oteapi/models/secretconfig.py</code> <pre><code>def json_dumps(model: dict, default: \"Callable[[Any], Any]\") -&gt; \"str\":\n\"\"\"Alternative function for dumping exposed\n    secrets to json when model is serialized.\n\n    Parameters:\n        model: The pydantic model to serialize.\n        default: A pass-through to the standard `json.dumps()`'s `default` parameter.\n            From the `json.dumps()` doc-string: `default(obj)` is a function that should\n            return a serializable version of `obj` or raise `TypeError`.\n            The default simply raises `TypeError`.\n\n    Returns:\n        The result of `json.dumps()` after handling possible secrets.\n\n    \"\"\"\n    return json.dumps(\n        {\n            key: (\n                value.get_secret_value()\n                if settings.expose_secrets and isinstance(value, SecretStr)\n                else value\n            )\n            for key, value in model.items()\n        },\n        default=default,\n    )\n</code></pre>"},{"location":"api_reference/models/sessionupdate/","title":"sessionupdate","text":"<p>Pydantic SessionUpdate Data Model.</p>"},{"location":"api_reference/models/sessionupdate/#oteapi.models.sessionupdate.SessionUpdate","title":"<code>SessionUpdate</code>","text":"<p>             Bases: <code>AttrDict</code></p> <p>Session Update Data Model for returning values.</p> Source code in <code>oteapi/models/sessionupdate.py</code> <pre><code>class SessionUpdate(AttrDict):\n\"\"\"Session Update Data Model for returning values.\"\"\"\n</code></pre>"},{"location":"api_reference/models/transformationconfig/","title":"transformationconfig","text":"<p>Pydantic Transformation Configuration Data Model.</p> <p>A transformation status data model is provided as well. This data model represents what should be returned from the strategy's <code>status()</code> method.</p>"},{"location":"api_reference/models/transformationconfig/#oteapi.models.transformationconfig.ProcessPriority","title":"<code>ProcessPriority</code>","text":"<p>             Bases: <code>str</code>, <code>Enum</code></p> <p>Defining process priority enumerators.</p> <p>Process priorities:</p> <ul> <li>Low</li> <li>Medium</li> <li>High</li> </ul> Source code in <code>oteapi/models/transformationconfig.py</code> <pre><code>class ProcessPriority(str, Enum):\n\"\"\"Defining process priority enumerators.\n\n    Process priorities:\n\n    - Low\n    - Medium\n    - High\n\n    \"\"\"\n\n    LOW = \"Low\"\n    MEDIUM = \"Medium\"\n    HIGH = \"High\"\n</code></pre>"},{"location":"api_reference/models/transformationconfig/#oteapi.models.transformationconfig.ProcessPriority.HIGH","title":"<code>HIGH = 'High'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/models/transformationconfig/#oteapi.models.transformationconfig.ProcessPriority.LOW","title":"<code>LOW = 'Low'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/models/transformationconfig/#oteapi.models.transformationconfig.ProcessPriority.MEDIUM","title":"<code>MEDIUM = 'Medium'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/models/transformationconfig/#oteapi.models.transformationconfig.TransformationConfig","title":"<code>TransformationConfig</code>","text":"<p>             Bases: <code>GenericConfig</code>, <code>SecretConfig</code></p> <p>Transformation Strategy Data Configuration.</p> Source code in <code>oteapi/models/transformationconfig.py</code> <pre><code>class TransformationConfig(GenericConfig, SecretConfig):\n\"\"\"Transformation Strategy Data Configuration.\"\"\"\n\n    transformationType: str = Field(\n        ...,\n        description=(\n            \"Type of registered transformation strategy. E.g., `celery/remote`.\"\n        ),\n    )\n    name: Optional[str] = Field(\n        None, description=\"Human-readable name of the transformation strategy.\"\n    )\n    due: Optional[datetime] = Field(\n        None,\n        description=(\n            \"Optional field to indicate a due data/time for when a transformation \"\n            \"should finish.\"\n        ),\n    )\n    priority: Optional[ProcessPriority] = Field(\n        ProcessPriority.MEDIUM,\n        description=\"Define the process priority of the transformation execution.\",\n    )\n</code></pre>"},{"location":"api_reference/models/transformationconfig/#oteapi.models.transformationconfig.TransformationConfig.due","title":"<code>due: Optional[datetime] = Field(None, description='Optional field to indicate a due data/time for when a transformation should finish.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/models/transformationconfig/#oteapi.models.transformationconfig.TransformationConfig.name","title":"<code>name: Optional[str] = Field(None, description='Human-readable name of the transformation strategy.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/models/transformationconfig/#oteapi.models.transformationconfig.TransformationConfig.priority","title":"<code>priority: Optional[ProcessPriority] = Field(ProcessPriority.MEDIUM, description='Define the process priority of the transformation execution.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/models/transformationconfig/#oteapi.models.transformationconfig.TransformationConfig.transformationType","title":"<code>transformationType: str = Field(..., description='Type of registered transformation strategy. E.g., `celery/remote`.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/models/transformationconfig/#oteapi.models.transformationconfig.TransformationStatus","title":"<code>TransformationStatus</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>Return from transformation status.</p> Source code in <code>oteapi/models/transformationconfig.py</code> <pre><code>class TransformationStatus(BaseModel):\n\"\"\"Return from transformation status.\"\"\"\n\n    id: str = Field(..., description=\"ID for the given transformation process.\")\n    status: Optional[str] = Field(\n        None, description=\"Status for the transformation process.\"\n    )\n    messages: Optional[List[str]] = Field(\n        None, description=\"Messages related to the transformation process.\"\n    )\n    created: Optional[datetime] = Field(\n        None,\n        description=\"Time of creation for the transformation process. Given in UTC.\",\n    )\n    startTime: Optional[datetime] = Field(\n        None, description=\"Time when the transformation process started. Given in UTC.\"\n    )\n    finishTime: Optional[datetime] = Field(\n        None, description=\"Time when the tranformation process finished. Given in UTC.\"\n    )\n</code></pre>"},{"location":"api_reference/models/transformationconfig/#oteapi.models.transformationconfig.TransformationStatus.created","title":"<code>created: Optional[datetime] = Field(None, description='Time of creation for the transformation process. Given in UTC.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/models/transformationconfig/#oteapi.models.transformationconfig.TransformationStatus.finishTime","title":"<code>finishTime: Optional[datetime] = Field(None, description='Time when the tranformation process finished. Given in UTC.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/models/transformationconfig/#oteapi.models.transformationconfig.TransformationStatus.id","title":"<code>id: str = Field(..., description='ID for the given transformation process.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/models/transformationconfig/#oteapi.models.transformationconfig.TransformationStatus.messages","title":"<code>messages: Optional[List[str]] = Field(None, description='Messages related to the transformation process.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/models/transformationconfig/#oteapi.models.transformationconfig.TransformationStatus.startTime","title":"<code>startTime: Optional[datetime] = Field(None, description='Time when the transformation process started. Given in UTC.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/models/transformationconfig/#oteapi.models.transformationconfig.TransformationStatus.status","title":"<code>status: Optional[str] = Field(None, description='Status for the transformation process.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/models/triplestoreconfig/","title":"triplestoreconfig","text":"<p>Pydantic TripleStore Configuration Data Model.</p>"},{"location":"api_reference/models/triplestoreconfig/#oteapi.models.triplestoreconfig.TripleStoreConfig","title":"<code>TripleStoreConfig</code>","text":"<p>             Bases: <code>GenericConfig</code>, <code>SecretConfig</code></p> <p>TripleStore Configuration.</p> <p>This is a configuration for the <code>TripleStore</code>.</p> <p>This class should not be used directly as a configuration object for a strategy object, but only as a configuration field inside a configuration object.</p> Source code in <code>oteapi/models/triplestoreconfig.py</code> <pre><code>class TripleStoreConfig(GenericConfig, SecretConfig):\n\"\"\"TripleStore Configuration.\n\n    This is a configuration for the\n    [`TripleStore`][oteapi.triplestore.triplestore.TripleStore].\n\n    This class should not be used directly as a configuration object\n    for a strategy object, but only as a configuration field inside\n    a configuration object.\n    \"\"\"\n\n    repositoryName: str = Field(\n        ..., description=\"The repository name, where the mappings are stored.\"\n    )\n    agraphHost: str = Field(\n        ...,\n        description=\"AllegroGraph host name.\",\n    )\n    agraphPort: int = Field(\n        ...,\n        description=\"AllegroGraph port number.\",\n    )\n\n    @root_validator\n    def ensure_user_pass(cls, values: \"Dict[str, Any]\") -&gt; \"Dict[str, Any]\":\n\"\"\"Ensure that user/password are set, since they are optional in the\n        SecretConfig.\"\"\"\n        if not all(values.get(_) for _ in [\"user\", \"password\"]):\n            raise ValueError(\"User and password must be defined.\")\n        return values\n\n    class Config:\n\"\"\"Pydantic configuration for TripleStoreConfig.\"\"\"\n\n        fields = {\n            \"token\": {\"exclude\": True},\n            \"client_id\": {\"exclude\": True},\n            \"client_secret\": {\"exclude\": True},\n        }\n\"\"\"The `fields`-config enables that `token`, `client_id` and `client_secret`\n        will be excluded, when the model is serialized.\"\"\"\n</code></pre>"},{"location":"api_reference/models/triplestoreconfig/#oteapi.models.triplestoreconfig.TripleStoreConfig.agraphHost","title":"<code>agraphHost: str = Field(..., description='AllegroGraph host name.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/models/triplestoreconfig/#oteapi.models.triplestoreconfig.TripleStoreConfig.agraphPort","title":"<code>agraphPort: int = Field(..., description='AllegroGraph port number.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/models/triplestoreconfig/#oteapi.models.triplestoreconfig.TripleStoreConfig.repositoryName","title":"<code>repositoryName: str = Field(..., description='The repository name, where the mappings are stored.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/models/triplestoreconfig/#oteapi.models.triplestoreconfig.TripleStoreConfig.Config","title":"<code>Config</code>","text":"<p>Pydantic configuration for TripleStoreConfig.</p> Source code in <code>oteapi/models/triplestoreconfig.py</code> <pre><code>class Config:\n\"\"\"Pydantic configuration for TripleStoreConfig.\"\"\"\n\n    fields = {\n        \"token\": {\"exclude\": True},\n        \"client_id\": {\"exclude\": True},\n        \"client_secret\": {\"exclude\": True},\n    }\n\"\"\"The `fields`-config enables that `token`, `client_id` and `client_secret`\n    will be excluded, when the model is serialized.\"\"\"\n</code></pre>"},{"location":"api_reference/models/triplestoreconfig/#oteapi.models.triplestoreconfig.TripleStoreConfig.Config.fields","title":"<code>fields = {'token': {'exclude': True}, 'client_id': {'exclude': True}, 'client_secret': {'exclude': True}}</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The <code>fields</code>-config enables that <code>token</code>, <code>client_id</code> and <code>client_secret</code> will be excluded, when the model is serialized.</p>"},{"location":"api_reference/models/triplestoreconfig/#oteapi.models.triplestoreconfig.TripleStoreConfig.ensure_user_pass","title":"<code>ensure_user_pass(values)</code>","text":"<p>Ensure that user/password are set, since they are optional in the SecretConfig.</p> Source code in <code>oteapi/models/triplestoreconfig.py</code> <pre><code>@root_validator\ndef ensure_user_pass(cls, values: \"Dict[str, Any]\") -&gt; \"Dict[str, Any]\":\n\"\"\"Ensure that user/password are set, since they are optional in the\n    SecretConfig.\"\"\"\n    if not all(values.get(_) for _ in [\"user\", \"password\"]):\n        raise ValueError(\"User and password must be defined.\")\n    return values\n</code></pre>"},{"location":"api_reference/plugins/entry_points/","title":"entry_points","text":"<p>Load plugins through entry points.</p> <p>This module deals with handling all plugged in strategies through the entry points API and importlib metadata API.</p> <p>Special functionality is put in place to handle the OTE-API-specific entry points.</p> <p>Since the entry points are information complete in and of themselves, there is no need to import actual strategy classes until they are truly needed. This therefore implements lazy loading of all plugin strategies.</p>"},{"location":"api_reference/plugins/entry_points/#oteapi.plugins.entry_points.EntryPointNotFound","title":"<code>EntryPointNotFound</code>","text":"<p>             Bases: <code>Exception</code></p> <p>A given strategy implementation (class) cannot be found from the given entry point value.</p> Source code in <code>oteapi/plugins/entry_points.py</code> <pre><code>class EntryPointNotFound(Exception):\n\"\"\"A given strategy implementation (class) cannot be found from the given entry\n    point value.\"\"\"\n</code></pre>"},{"location":"api_reference/plugins/entry_points/#oteapi.plugins.entry_points.EntryPointStrategy","title":"<code>EntryPointStrategy</code>","text":"<p>A strategy realized from an entry point.</p> <p>An entry point strategy is made unique by its \"strategy\", i.e., its (strategy type, strategy name)-tuple, e.g., <code>(\"download\", \"https\")</code>. This tuple can be retrieved from the <code>strategy</code> property, where the strategy type is represented by the <code>StrategyType</code> enumeration.</p> Note <p>It may be that in the future an entry points strategy is made unique by its \"full name\" instead, i.e., the entry point group + the entry points name, e.g., <code>oteapi.download:oteapi.https</code>. This value can be retrieved from the <code>full_name</code> property.</p> <p>This is a condition for uniqueness that is considered to be a superset of the current condition for uniqueness. It adds an extra package-specific uniqueness trait, allowing for different packages to implement the same strategies (which is currently not allowed according to the condition of uniqueness explained above).</p> <p>Currently there is no consensus on the API for handling this added strategy ambiguity.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the entry point name is not properly defined.</p> Source code in <code>oteapi/plugins/entry_points.py</code> <pre><code>class EntryPointStrategy:\n\"\"\"A strategy realized from an entry point.\n\n    An entry point strategy is made unique by its \"strategy\", i.e., its\n    (strategy type, strategy name)-tuple, e.g., `(\"download\", \"https\")`.\n    This tuple can be retrieved from the\n    [`strategy`][oteapi.plugins.entry_points.EntryPointStrategy.strategy] property,\n    where the strategy type is represented by the\n    [`StrategyType`][oteapi.plugins.entry_points.StrategyType] enumeration.\n\n    Note:\n        It may be that in the future an entry points strategy is made unique by\n        its \"full name\" instead, i.e., the entry point group + the entry points name,\n        e.g., `oteapi.download:oteapi.https`.\n        This value can be retrieved from the\n        [`full_name`][oteapi.plugins.entry_points.EntryPointStrategy.full_name]\n        property.\n\n        This is a condition for uniqueness that is considered to be a superset of the\n        current condition for uniqueness.\n        It adds an extra package-specific uniqueness trait, allowing for different\n        packages to implement the same strategies (which is currently not allowed\n        according to the condition of uniqueness explained above).\n\n        Currently there is no consensus on the API for handling this added strategy\n        ambiguity.\n\n    Raises:\n        ValueError: If the entry point name is not properly defined.\n\n    \"\"\"\n\n    ENTRY_POINT_NAME_REGEX = re.compile(\n        r\"^(?P&lt;package_name&gt;[a-z_]+)\\.(?P&lt;strategy_name&gt;.+)$\"\n    )\n    ENTRY_POINT_NAME_SEPARATOR = \":\"\n\n    def __init__(self, entry_point: \"EntryPoint\") -&gt; None:\n        self._entry_point = entry_point\n\n        match = self.ENTRY_POINT_NAME_REGEX.match(self._entry_point.name)\n        if match is None:\n            raise ValueError(\n                \"Could not determine package name and/or strategy name for entry \"\n                f\"point: {self.full_name}\"\n            )\n\n        self._match = match\n        self._type = StrategyType(self._entry_point.group[len(\"oteapi.\") :])\n        self._implementation: \"Optional[Type[IStrategy]]\" = None\n\n    @property\n    def type(self) -&gt; StrategyType:\n\"\"\"The strategy type.\n\n        One part of the (strategy type, strategy name)-tuple.\n        \"\"\"\n        return self._type\n\n    @property\n    def name(self) -&gt; str:\n\"\"\"The strategy name.\n\n        One part of the (strategy type, strategy name)-tuple.\n        \"\"\"\n        return self._match.group(\"strategy_name\")\n\n    @property\n    def strategy(self) -&gt; \"Tuple[StrategyType, str]\":\n\"\"\"The unique index identifier for the strategy.\"\"\"\n        return self.type, self.name\n\n    @property\n    def package(self) -&gt; str:\n\"\"\"The importable base package name for the strategy plugin.\"\"\"\n        return self._match.group(\"package_name\")\n\n    @property\n    def module(self) -&gt; str:\n\"\"\"The fully resolved importable module path.\"\"\"\n        return self._entry_point.module  # type: ignore[attr-defined]\n\n    @property\n    def full_name(self) -&gt; str:\n\"\"\"The full entry point name.\"\"\"\n        return (\n            f\"{self._entry_point.group}{self.ENTRY_POINT_NAME_SEPARATOR}\"\n            f\"{self._entry_point.name}\"\n        )\n\n    def __str__(self) -&gt; str:\n        return self.full_name\n\n    def __repr__(self) -&gt; str:\n        return f\"{self.__class__.__name__}(entry_point={self._entry_point!r})\"\n\n    @property\n    def implementation_name(self) -&gt; str:\n\"\"\"The EntryPoint attr, which should be the strategy implementation class\n        name.\"\"\"\n        return self._entry_point.attr  # type: ignore[attr-defined]\n\n    @property\n    def implementation(self) -&gt; \"Type[IStrategy]\":\n\"\"\"The actual strategy implementation.\"\"\"\n        if self._implementation is None:\n            self._implementation = self._load_implementation()\n        return self._implementation\n\n    def _load_implementation(self) -&gt; \"Type[IStrategy]\":\n\"\"\"Load the strategy implementation.\n\n        Because the actual importing of the module does not happen until this method is\n        called, we are lazily loading in the strategy implementation.\n\n        There is no need to check through the `globals()` built-in for whether the\n        module and class have already been imported, because this caching layer is\n        already implemented in the `importlib` API.\n\n        Raises:\n            EntryPointNotFound: If the strategy implementation (class) the entry point\n                is pointing to cannot be found in the module or if the module cannot be\n                imported.\n\n        Returns:\n            The imported strategy implementation (class).\n\n        \"\"\"\n        try:\n            module = importlib.import_module(self.module)\n        except ImportError as exc:\n            raise EntryPointNotFound(\n                f\"{self.module} cannot be imported. Did you install the \"\n                f\"{self.package!r} package?\"\n            ) from exc\n\n        if hasattr(module, self.implementation_name):\n            return getattr(module, self.implementation_name)\n        raise EntryPointNotFound(\n            f\"{self.implementation_name} cannot be found in {self.module}\"\n        )\n\n    def __eq__(self, other: \"Any\") -&gt; bool:\n        if isinstance(other, self.__class__):\n            return hash(self) == hash(other)\n        return False\n\n    def __hash__(self) -&gt; int:\n        return hash(self.strategy)\n\n    def __lt__(self, other: \"Any\") -&gt; bool:\n\"\"\"Whether or not `self` is less than (`&lt;`) `other`.\n\n        This is implemented to allow sorting (using `sorted()`).\n\n        The inequality is determined on the basis of the following properties:\n\n        1. [`type`][oteapi.plugins.entry_points.EntryPointStrategy.type]\n        2. [`package`][oteapi.plugins.entry_points.EntryPointStrategy.package]\n        3. [`name`][oteapi.plugins.entry_points.EntryPointStrategy.name]\n\n        Going from highest priority to lowest and in alphabetical ascending order.\n        \"\"\"\n        if isinstance(other, self.__class__):\n            if self.type == other.type:\n                if self.package == other.package:\n                    if self.name == other.name:\n                        # Considered equal, i.e., one can by definition not be unequal\n                        # with the other.\n                        return False\n                    return sorted([self.name, other.name])[0] == self.name\n                return sorted([self.package, other.package])[0] == self.package\n            return sorted([self.type.value, other.type.value])[0] == self.type.value\n        raise NotImplementedError(\n            f\"Less than comparison is not implemented for {type(other)} type objects.\"\n        )\n</code></pre>"},{"location":"api_reference/plugins/entry_points/#oteapi.plugins.entry_points.EntryPointStrategy.full_name","title":"<code>full_name: str</code>  <code>property</code>","text":"<p>The full entry point name.</p>"},{"location":"api_reference/plugins/entry_points/#oteapi.plugins.entry_points.EntryPointStrategy.implementation","title":"<code>implementation: Type[IStrategy]</code>  <code>property</code>","text":"<p>The actual strategy implementation.</p>"},{"location":"api_reference/plugins/entry_points/#oteapi.plugins.entry_points.EntryPointStrategy.implementation_name","title":"<code>implementation_name: str</code>  <code>property</code>","text":"<p>The EntryPoint attr, which should be the strategy implementation class name.</p>"},{"location":"api_reference/plugins/entry_points/#oteapi.plugins.entry_points.EntryPointStrategy.module","title":"<code>module: str</code>  <code>property</code>","text":"<p>The fully resolved importable module path.</p>"},{"location":"api_reference/plugins/entry_points/#oteapi.plugins.entry_points.EntryPointStrategy.name","title":"<code>name: str</code>  <code>property</code>","text":"<p>The strategy name.</p> <p>One part of the (strategy type, strategy name)-tuple.</p>"},{"location":"api_reference/plugins/entry_points/#oteapi.plugins.entry_points.EntryPointStrategy.package","title":"<code>package: str</code>  <code>property</code>","text":"<p>The importable base package name for the strategy plugin.</p>"},{"location":"api_reference/plugins/entry_points/#oteapi.plugins.entry_points.EntryPointStrategy.strategy","title":"<code>strategy: Tuple[StrategyType, str]</code>  <code>property</code>","text":"<p>The unique index identifier for the strategy.</p>"},{"location":"api_reference/plugins/entry_points/#oteapi.plugins.entry_points.EntryPointStrategy.type","title":"<code>type: StrategyType</code>  <code>property</code>","text":"<p>The strategy type.</p> <p>One part of the (strategy type, strategy name)-tuple.</p>"},{"location":"api_reference/plugins/entry_points/#oteapi.plugins.entry_points.EntryPointStrategyCollection","title":"<code>EntryPointStrategyCollection</code>","text":"<p>             Bases: <code>Collection</code></p> <p>A collection of <code>EntryPointStrategy</code>s.</p> Source code in <code>oteapi/plugins/entry_points.py</code> <pre><code>class EntryPointStrategyCollection(abc.Collection):\n\"\"\"A collection of\n    [`EntryPointStrategy`][oteapi.plugins.entry_points.EntryPointStrategy]s.\"\"\"\n\n    def __init__(self, *entry_points: \"EntryPointStrategy\") -&gt; None:\n        self._entry_points: \"Set[EntryPointStrategy]\" = (\n            set(entry_points) if entry_points else set()\n        )\n\n    def add(self, *entry_points: EntryPointStrategy) -&gt; None:\n\"\"\"Add entry points to the collection.\n\n        Parameters:\n            *entry_points (Iterable[EntryPointStrategy]): Entry points to add to the\n                collection.\n\n        \"\"\"\n        self._entry_points |= set(entry_points)\n\n    def remove(self, *entry_points: EntryPointStrategy) -&gt; None:\n\"\"\"Remove entry points from the collection.\n\n        Parameters:\n            *entry_points (Iterable[EntryPointStrategy]): Entry points to remove from\n                the collection.\n\n        \"\"\"\n        self._entry_points -= set(entry_points)\n\n    def exclusive_add(self, *entry_points: EntryPointStrategy) -&gt; None:\n\"\"\"Exclusively add entry points to the collection.\n\n        Parameters:\n            *entry_points (Iterable[EntryPointStrategy]): Entry points to add to the\n                collection.\n\n        Raises:\n            KeyError: If an entry point to be added already exists in the collection.\n\n        \"\"\"\n        for entry_point in entry_points:\n            if entry_point in self:\n                raise KeyError(\n                    f\"{entry_point.strategy} already exists in {self}. \"\n                    f\"(Tried adding {entry_point}.)\"\n                )\n            self.add(entry_point)\n\n    def __len__(self) -&gt; int:\n        return len(self._entry_points)\n\n    def __contains__(self, item: \"Any\") -&gt; bool:\n\"\"\"Whether or not `item` is contained in the collection.\n\n        One can test with an `EntryPointStrategy`, a string of an entry point\n        strategy's full name, or a tuple of an entry point's strategy type and name.\n\n        Parameters:\n            item: Item to test whether it is contained in the collection.\n\n        Returns:\n            Whether or not `item` is contained in the collection.\n            If the `item` is an unrecognized type, `False` will be returned.\n\n        \"\"\"\n        if isinstance(item, EntryPointStrategy):\n            return item in self._entry_points\n        if isinstance(item, str):\n            for entry_point in self._entry_points:\n                if item == entry_point.full_name:\n                    return True\n        if isinstance(item, tuple):\n            if len(item) != 2 or (\n                not isinstance(item[0], (StrategyType, str))\n                or not isinstance(item[1], str)\n            ):\n                # Only tuples of type (Union[StrategyType, str], str) are allowed.\n                return False\n            try:\n                item_ = (StrategyType.init(item[0]), item[1])\n            except ValueError:\n                # We only want to return True or False\n                return False\n            for entry_point in self._entry_points:\n                if item_ == entry_point.strategy:\n                    return True\n        # For any other type:\n        return False\n\n    def __iter__(self) -&gt; \"Iterator[EntryPointStrategy]\":\n        yield from self._entry_points\n\n    def __getitem__(self, key: \"Any\") -&gt; EntryPointStrategy:\n        return self.get_entry_point(key)\n\n    def get_entry_point(\n        self,\n        key: \"Union[EntryPointStrategy, str, Tuple[Union[StrategyType, str], str]]\",\n    ) -&gt; EntryPointStrategy:\n\"\"\"Retrieve an entry point from the collection.\n\n        Parameters:\n            key: The key to check for in the collection.\n\n        Raises:\n            KeyError: If an entry point cannot be found in the collection.\n            TypeError: If the `key` is not of an expected type. See the `key` parameter\n                above for the expected types.\n\n        Returns:\n            An entry point in the collection representing the key.\n\n        \"\"\"\n        if isinstance(key, (EntryPointStrategy, str, tuple)):\n            if key not in self:\n                raise KeyError(f\"{key} not found in {self}\")\n            return self._get_entry_point(key)\n        raise TypeError(\n            \"key should either be of type EntryPointStrategy, a string of the full \"\n            \"name or a strategy tuple.\"\n        )\n\n    def _get_entry_point(\n        self,\n        key: \"Union[EntryPointStrategy, str, Tuple[Union[StrategyType, str], str]]\",\n    ) -&gt; EntryPointStrategy:\n\"\"\"Helper method for retrieving an entry point from the collection.\n\n        Important:\n            It is expected that the entry point representing the key exists in the\n            collection. For example through a `key in self` test.\n\n        Parameters:\n            key: The key to check for in the collection.\n\n        Raises:\n            RuntimeError: If an entry point cannot be found in the collection, since\n                this is a requirement.\n\n        Returns:\n            An entry point in the collection representing the key.\n\n        \"\"\"\n        if isinstance(key, EntryPointStrategy):\n            return key\n        if isinstance(key, str):\n            for entry_point in self._entry_points:\n                if key == entry_point.full_name:\n                    return entry_point\n        if isinstance(key, tuple):\n            key_ = (StrategyType(key[0]), key[1])\n            for entry_point in self._entry_points:\n                if key_ == entry_point.strategy:\n                    return entry_point\n        raise RuntimeError(\n            f\"{key} not found in {self}, which is a requirement for the \"\n            \"_get_entry_point method.\"\n        )\n\n    def __eq__(self, other: \"Any\") -&gt; bool:\n        if isinstance(other, self.__class__):\n            return hash(self) == hash(other)\n        return False\n\n    def __hash__(self) -&gt; int:\n        return hash(tuple(_ for _ in sorted(self._entry_points)))\n\n    def __str__(self) -&gt; str:\n        number_of_strategies: \"Dict[str, int]\" = {}\n        for entry_point in self._entry_points:\n            if entry_point.type.value in number_of_strategies:\n                number_of_strategies[entry_point.type.value] += 1\n            else:\n                number_of_strategies[entry_point.type.value] = 1\n        sorted_list = sorted(\n            f\"{key} ({value})\" for key, value in number_of_strategies.items()\n        )\n        return f\"&lt;{self.__class__.__name__}: \" f\"Strategies={', '.join(sorted_list)}&gt;\"\n\n    def __repr__(self) -&gt; str:\n        return f\"{self.__class__.__name__}(*{tuple(sorted(self._entry_points))!r})\"\n</code></pre>"},{"location":"api_reference/plugins/entry_points/#oteapi.plugins.entry_points.EntryPointStrategyCollection.add","title":"<code>add(*entry_points)</code>","text":"<p>Add entry points to the collection.</p> <p>Parameters:</p> Name Type Description Default <code>*entry_points</code> <code>Iterable[EntryPointStrategy]</code> <p>Entry points to add to the collection.</p> <code>()</code> Source code in <code>oteapi/plugins/entry_points.py</code> <pre><code>def add(self, *entry_points: EntryPointStrategy) -&gt; None:\n\"\"\"Add entry points to the collection.\n\n    Parameters:\n        *entry_points (Iterable[EntryPointStrategy]): Entry points to add to the\n            collection.\n\n    \"\"\"\n    self._entry_points |= set(entry_points)\n</code></pre>"},{"location":"api_reference/plugins/entry_points/#oteapi.plugins.entry_points.EntryPointStrategyCollection.exclusive_add","title":"<code>exclusive_add(*entry_points)</code>","text":"<p>Exclusively add entry points to the collection.</p> <p>Parameters:</p> Name Type Description Default <code>*entry_points</code> <code>Iterable[EntryPointStrategy]</code> <p>Entry points to add to the collection.</p> <code>()</code> <p>Raises:</p> Type Description <code>KeyError</code> <p>If an entry point to be added already exists in the collection.</p> Source code in <code>oteapi/plugins/entry_points.py</code> <pre><code>def exclusive_add(self, *entry_points: EntryPointStrategy) -&gt; None:\n\"\"\"Exclusively add entry points to the collection.\n\n    Parameters:\n        *entry_points (Iterable[EntryPointStrategy]): Entry points to add to the\n            collection.\n\n    Raises:\n        KeyError: If an entry point to be added already exists in the collection.\n\n    \"\"\"\n    for entry_point in entry_points:\n        if entry_point in self:\n            raise KeyError(\n                f\"{entry_point.strategy} already exists in {self}. \"\n                f\"(Tried adding {entry_point}.)\"\n            )\n        self.add(entry_point)\n</code></pre>"},{"location":"api_reference/plugins/entry_points/#oteapi.plugins.entry_points.EntryPointStrategyCollection.get_entry_point","title":"<code>get_entry_point(key)</code>","text":"<p>Retrieve an entry point from the collection.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>Union[EntryPointStrategy, str, Tuple[Union[StrategyType, str], str]]</code> <p>The key to check for in the collection.</p> required <p>Raises:</p> Type Description <code>KeyError</code> <p>If an entry point cannot be found in the collection.</p> <code>TypeError</code> <p>If the <code>key</code> is not of an expected type. See the <code>key</code> parameter above for the expected types.</p> <p>Returns:</p> Type Description <code>EntryPointStrategy</code> <p>An entry point in the collection representing the key.</p> Source code in <code>oteapi/plugins/entry_points.py</code> <pre><code>def get_entry_point(\n    self,\n    key: \"Union[EntryPointStrategy, str, Tuple[Union[StrategyType, str], str]]\",\n) -&gt; EntryPointStrategy:\n\"\"\"Retrieve an entry point from the collection.\n\n    Parameters:\n        key: The key to check for in the collection.\n\n    Raises:\n        KeyError: If an entry point cannot be found in the collection.\n        TypeError: If the `key` is not of an expected type. See the `key` parameter\n            above for the expected types.\n\n    Returns:\n        An entry point in the collection representing the key.\n\n    \"\"\"\n    if isinstance(key, (EntryPointStrategy, str, tuple)):\n        if key not in self:\n            raise KeyError(f\"{key} not found in {self}\")\n        return self._get_entry_point(key)\n    raise TypeError(\n        \"key should either be of type EntryPointStrategy, a string of the full \"\n        \"name or a strategy tuple.\"\n    )\n</code></pre>"},{"location":"api_reference/plugins/entry_points/#oteapi.plugins.entry_points.EntryPointStrategyCollection.remove","title":"<code>remove(*entry_points)</code>","text":"<p>Remove entry points from the collection.</p> <p>Parameters:</p> Name Type Description Default <code>*entry_points</code> <code>Iterable[EntryPointStrategy]</code> <p>Entry points to remove from the collection.</p> <code>()</code> Source code in <code>oteapi/plugins/entry_points.py</code> <pre><code>def remove(self, *entry_points: EntryPointStrategy) -&gt; None:\n\"\"\"Remove entry points from the collection.\n\n    Parameters:\n        *entry_points (Iterable[EntryPointStrategy]): Entry points to remove from\n            the collection.\n\n    \"\"\"\n    self._entry_points -= set(entry_points)\n</code></pre>"},{"location":"api_reference/plugins/entry_points/#oteapi.plugins.entry_points.StrategyType","title":"<code>StrategyType</code>","text":"<p>             Bases: <code>Enum</code></p> <p>An enumeration of available strategy types.</p> <p>Available strategy types:</p> <ul> <li>download</li> <li>filter</li> <li>function</li> <li>mapping</li> <li>parse</li> <li>resource</li> <li>transformation</li> </ul> Source code in <code>oteapi/plugins/entry_points.py</code> <pre><code>class StrategyType(Enum):\n\"\"\"An enumeration of available strategy types.\n\n    Available strategy types:\n\n    - download\n    - filter\n    - function\n    - mapping\n    - parse\n    - resource\n    - transformation\n\n    \"\"\"\n\n    DOWNLOAD = \"download\"\n    FILTER = \"filter\"\n    FUNCTION = \"function\"\n    MAPPING = \"mapping\"\n    PARSE = \"parse\"\n    RESOURCE = \"resource\"\n    TRANSFORMATION = \"transformation\"\n\n    def map_to_field(self) -&gt; str:\n\"\"\"Map enumeration value to the strategy type's field.\"\"\"\n        return {\n            \"download\": \"scheme\",\n            \"filter\": \"filterType\",\n            \"function\": \"functionType\",\n            \"mapping\": \"mappingType\",\n            \"parse\": \"mediaType\",\n            \"resource\": \"accessService\",\n            \"transformation\": \"transformationType\",\n        }[self.value]\n\n    @classmethod\n    def map_from_field(cls, strategy_type_field: str) -&gt; \"StrategyType\":\n\"\"\"Map the strategy type's field to enumeration.\n\n        Parameters:\n            strategy_type_field: The strategy type's field. E.g., `scheme` for\n                `download`.\n\n        Raises:\n            KeyError: If the `strategy_type_field` is not valid.\n\n        Returns:\n            An enumeration instance representing the strategy type's field.\n\n        \"\"\"\n        return {\n            \"scheme\": cls.DOWNLOAD,\n            \"filterType\": cls.FILTER,\n            \"functionType\": cls.FUNCTION,\n            \"mappingType\": cls.MAPPING,\n            \"mediaType\": cls.PARSE,\n            \"accessService\": cls.RESOURCE,\n            \"transformationType\": cls.TRANSFORMATION,\n        }[strategy_type_field]\n\n    @classmethod\n    def init(cls, value: \"Union[str, StrategyType]\") -&gt; \"StrategyType\":\n\"\"\"Initialize a StrategyType with more than just the enumeration value.\n\n        This method allows one to also initialize a StrategyType with an actual\n        strategy type string, e.g., `scheme`, `mediaType`, etc.\n\n        Raises:\n            ValueError: As normal if the enumeration value is not valid.\n\n        \"\"\"\n        if isinstance(value, str):\n            try:\n                return cls.map_from_field(value)\n            except KeyError:\n                pass\n        return cls(value)\n\n    @classmethod\n    def all_values(cls) -&gt; \"Tuple[str, ...]\":\n\"\"\"Return all values.\"\"\"\n        return tuple(strategy_type.value for strategy_type in cls)\n\n    def __str__(self) -&gt; str:\n        return str(self.value)\n\n    def __repr__(self) -&gt; str:\n        return repr(str(self))\n\n    @property\n    def config_cls(self) -&gt; \"Type[StrategyConfig]\":\n\"\"\"Return the strategy-specific `*Config` class.\"\"\"\n        return {  # type: ignore[return-value]\n            \"download\": ResourceConfig,\n            \"filter\": FilterConfig,\n            \"function\": FunctionConfig,\n            \"mapping\": MappingConfig,\n            \"parse\": ResourceConfig,\n            \"resource\": ResourceConfig,\n            \"transformation\": TransformationConfig,\n        }[self.value]\n</code></pre>"},{"location":"api_reference/plugins/entry_points/#oteapi.plugins.entry_points.StrategyType.config_cls","title":"<code>config_cls: Type[StrategyConfig]</code>  <code>property</code>","text":"<p>Return the strategy-specific <code>*Config</code> class.</p>"},{"location":"api_reference/plugins/entry_points/#oteapi.plugins.entry_points.StrategyType.all_values","title":"<code>all_values()</code>  <code>classmethod</code>","text":"<p>Return all values.</p> Source code in <code>oteapi/plugins/entry_points.py</code> <pre><code>@classmethod\ndef all_values(cls) -&gt; \"Tuple[str, ...]\":\n\"\"\"Return all values.\"\"\"\n    return tuple(strategy_type.value for strategy_type in cls)\n</code></pre>"},{"location":"api_reference/plugins/entry_points/#oteapi.plugins.entry_points.StrategyType.init","title":"<code>init(value)</code>  <code>classmethod</code>","text":"<p>Initialize a StrategyType with more than just the enumeration value.</p> <p>This method allows one to also initialize a StrategyType with an actual strategy type string, e.g., <code>scheme</code>, <code>mediaType</code>, etc.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>As normal if the enumeration value is not valid.</p> Source code in <code>oteapi/plugins/entry_points.py</code> <pre><code>@classmethod\ndef init(cls, value: \"Union[str, StrategyType]\") -&gt; \"StrategyType\":\n\"\"\"Initialize a StrategyType with more than just the enumeration value.\n\n    This method allows one to also initialize a StrategyType with an actual\n    strategy type string, e.g., `scheme`, `mediaType`, etc.\n\n    Raises:\n        ValueError: As normal if the enumeration value is not valid.\n\n    \"\"\"\n    if isinstance(value, str):\n        try:\n            return cls.map_from_field(value)\n        except KeyError:\n            pass\n    return cls(value)\n</code></pre>"},{"location":"api_reference/plugins/entry_points/#oteapi.plugins.entry_points.StrategyType.map_from_field","title":"<code>map_from_field(strategy_type_field)</code>  <code>classmethod</code>","text":"<p>Map the strategy type's field to enumeration.</p> <p>Parameters:</p> Name Type Description Default <code>strategy_type_field</code> <code>str</code> <p>The strategy type's field. E.g., <code>scheme</code> for <code>download</code>.</p> required <p>Raises:</p> Type Description <code>KeyError</code> <p>If the <code>strategy_type_field</code> is not valid.</p> <p>Returns:</p> Type Description <code>StrategyType</code> <p>An enumeration instance representing the strategy type's field.</p> Source code in <code>oteapi/plugins/entry_points.py</code> <pre><code>@classmethod\ndef map_from_field(cls, strategy_type_field: str) -&gt; \"StrategyType\":\n\"\"\"Map the strategy type's field to enumeration.\n\n    Parameters:\n        strategy_type_field: The strategy type's field. E.g., `scheme` for\n            `download`.\n\n    Raises:\n        KeyError: If the `strategy_type_field` is not valid.\n\n    Returns:\n        An enumeration instance representing the strategy type's field.\n\n    \"\"\"\n    return {\n        \"scheme\": cls.DOWNLOAD,\n        \"filterType\": cls.FILTER,\n        \"functionType\": cls.FUNCTION,\n        \"mappingType\": cls.MAPPING,\n        \"mediaType\": cls.PARSE,\n        \"accessService\": cls.RESOURCE,\n        \"transformationType\": cls.TRANSFORMATION,\n    }[strategy_type_field]\n</code></pre>"},{"location":"api_reference/plugins/entry_points/#oteapi.plugins.entry_points.StrategyType.map_to_field","title":"<code>map_to_field()</code>","text":"<p>Map enumeration value to the strategy type's field.</p> Source code in <code>oteapi/plugins/entry_points.py</code> <pre><code>def map_to_field(self) -&gt; str:\n\"\"\"Map enumeration value to the strategy type's field.\"\"\"\n    return {\n        \"download\": \"scheme\",\n        \"filter\": \"filterType\",\n        \"function\": \"functionType\",\n        \"mapping\": \"mappingType\",\n        \"parse\": \"mediaType\",\n        \"resource\": \"accessService\",\n        \"transformation\": \"transformationType\",\n    }[self.value]\n</code></pre>"},{"location":"api_reference/plugins/entry_points/#oteapi.plugins.entry_points.get_strategy_entry_points","title":"<code>get_strategy_entry_points(strategy_type, enforce_uniqueness=True)</code>","text":"<p>Retrieve all entry points from a specific strategy type.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the strategy type is not supported.</p> <code>KeyError</code> <p>If <code>enforce_uniqueness</code> is <code>True</code> and an entry point strategy is duplicated.</p> <p>Parameters:</p> Name Type Description Default <code>strategy_type</code> <code>Union[StrategyType, str]</code> <p>A strategy type for which the entry points will be retrieved.</p> required <code>enforce_uniqueness</code> <code>bool</code> <p>Whether or not duplicate entry point strategies are allowed. Defaults to <code>True</code>, meaning duplicates are not allowed.</p> <code>True</code> <p>Returns:</p> Type Description <code>EntryPointStrategyCollection</code> <p>A collection of entry points for the specific strategy type.</p> Source code in <code>oteapi/plugins/entry_points.py</code> <pre><code>def get_strategy_entry_points(\n    strategy_type: \"Union[StrategyType, str]\",\n    enforce_uniqueness: bool = True,\n) -&gt; EntryPointStrategyCollection:\n\"\"\"Retrieve all entry points from a specific strategy type.\n\n    Raises:\n        ValueError: If the strategy type is not supported.\n        KeyError: If `enforce_uniqueness` is `True` and an entry point strategy is\n            duplicated.\n\n    Parameters:\n        strategy_type: A strategy type for which the entry points will be retrieved.\n        enforce_uniqueness: Whether or not duplicate entry point strategies are\n            allowed. Defaults to `True`, meaning duplicates are *not* allowed.\n\n    Returns:\n        A collection of entry points for the specific strategy type.\n\n    \"\"\"\n    try:\n        strategy_type = StrategyType(strategy_type)\n    except ValueError as exc:\n        str_strategy_type = (\n            strategy_type\n            if isinstance(strategy_type, str)\n            else str(strategy_type.value)\n        )\n        raise ValueError(\n            f\"Strategy type {str_strategy_type!r} is not supported.\"\n        ) from exc\n\n    collection = EntryPointStrategyCollection()\n    oteapi_entry_points = sorted(\n        set(get_entry_points().get(f\"oteapi.{strategy_type.value}\", []))\n    )\n\n    if enforce_uniqueness:\n        collection.exclusive_add(*(EntryPointStrategy(_) for _ in oteapi_entry_points))\n    else:\n        collection.add(*(EntryPointStrategy(_) for _ in oteapi_entry_points))\n\n    return collection\n</code></pre>"},{"location":"api_reference/plugins/factories/","title":"factories","text":"<p>Factory class for registering and creating strategy instances.</p> <p>Factory wrapper methods for creating the individual strategies.</p>"},{"location":"api_reference/plugins/factories/#oteapi.plugins.factories.StrategiesNotLoaded","title":"<code>StrategiesNotLoaded</code>","text":"<p>             Bases: <code>Exception</code></p> <p>Entry point strategies have not been loaded, run <code>load_strategies()</code>.</p> Source code in <code>oteapi/plugins/factories.py</code> <pre><code>class StrategiesNotLoaded(Exception):\n\"\"\"Entry point strategies have not been loaded, run\n    [`load_strategies()`][oteapi.plugins.factories.load_strategies].\"\"\"\n</code></pre>"},{"location":"api_reference/plugins/factories/#oteapi.plugins.factories.StrategyFactory","title":"<code>StrategyFactory</code>","text":"<p>Decorator-based Factory class.</p> <p>Attributes:</p> Name Type Description <code>strategy_create_func</code> <code>Dict[StrategyType, EntryPointStrategyCollection]</code> <p>An in-memory cache of all registered strategies.</p> Source code in <code>oteapi/plugins/factories.py</code> <pre><code>class StrategyFactory:\n\"\"\"Decorator-based Factory class.\n\n    Attributes:\n        strategy_create_func (Dict[StrategyType, EntryPointStrategyCollection]): An\n            in-memory cache of all registered strategies.\n\n    \"\"\"\n\n    strategy_create_func: \"Dict[StrategyType, EntryPointStrategyCollection]\"\n\n    @classmethod\n    def make_strategy(\n        cls,\n        config: \"Union[StrategyConfig, Dict[str, Any]]\",\n        strategy_type: \"Union[StrategyType, str]\",\n    ) -&gt; \"IStrategy\":\n\"\"\"Instantiate a strategy in a context class.\n\n        Parameters:\n            config: A strategy configuration.\n            strategy_type: The strategy type, e.g., `\"scheme\"`, `\"mediaType\"`, ... or\n                `\"download\"`, `\"parse\"`, ...\n                See the [`StrategyType`][oteapi.plugins.entry_points.StrategyType]\n                enumeration for a definition of valid strategy types.\n\n        Raises:\n            NotImplementedError: If the strategy cannot be found.\n            ValueError: If the `strategy_type` is not a valid strategy type.\n                See the [`StrategyType`][oteapi.plugins.entry_points.StrategyType]\n                enumeration for a definition of valid strategy types.\n            StrategiesNotLoaded: If the entry point strategies have not been loaded.\n\n        Returns:\n            An instantiated strategy. The strategy is instantiated with the provided\n            configuration, through the `config` parameter.\n\n        \"\"\"\n        if not hasattr(cls, \"strategy_create_func\"):\n            raise StrategiesNotLoaded(\n                \"Strategies have not been loaded, run `load_strategies()` or \"\n                \"`StrategyFactory.load_strategies()`.\"\n            )\n\n        if isinstance(strategy_type, str):\n            try:\n                strategy_type = StrategyType.init(strategy_type)\n            except ValueError as exc:\n                raise ValueError(\n                    f\"Strategy type {strategy_type!r} is not supported.\"\n                ) from exc\n        elif not isinstance(strategy_type, StrategyType):\n            raise TypeError(\n                \"strategy_type should be either of type StrategyType or a string.\"\n            )\n\n        if isinstance(config, dict):\n            config = strategy_type.config_cls(**config)  # type: ignore[call-arg]\n        elif not isinstance(config, get_args(StrategyConfig)):\n            raise TypeError(\"config should be either of type StrategyConfig or a dict.\")\n\n        strategy_name: str = cls._get_strategy_name(config, strategy_type)\n\n        if (strategy_type, strategy_name) in cls.strategy_create_func[strategy_type]:\n            return cls.strategy_create_func[strategy_type][\n                (strategy_type, strategy_name)\n            ].implementation(\n                config  # type: ignore[arg-type]\n            )\n        raise NotImplementedError(\n            f\"The {strategy_type.value} strategy {strategy_name!r} does not exist.\"\n        )\n\n    @classmethod\n    def _get_strategy_name(\n        cls,\n        config: \"StrategyConfig\",\n        strategy_type: StrategyType,\n    ) -&gt; str:\n\"\"\"Return the strategy name through the config.\n\n        This is a method to accommodate strategy type-specific quirks to retrieve the\n        strategy name.\n\n        Parameters:\n            config: A strategy configuration.\n            strategy_type: The strategy type as initialized in `make_strategy()`.\n\n        Returns:\n            The strategy name provided in the configuration.\n\n        \"\"\"\n        if strategy_type == StrategyType.DOWNLOAD:\n            return (\n                config.downloadUrl.scheme  # type: ignore[union-attr]\n                if config.downloadUrl is not None  # type: ignore[union-attr]\n                else \"\"\n            )\n        return getattr(config, strategy_type.map_to_field(), \"\")\n\n    @classmethod\n    def load_strategies(cls, test_for_uniqueness: bool = True) -&gt; None:\n\"\"\"Load strategies from entry points and store in class attribute.\n\n        Important:\n            This is not a cached method.\n            The importlib.metadata API will be re-requested to load the entry points\n            and strategies.\n\n        Note:\n            This does *not* import the actual strategy implementations (classes).\n            It only loads the strategies from the registerred OTE-API entry points.\n\n        Raises:\n            KeyError: If `test_for_uniqueness` is `True` and an entry point strategy is\n                duplicated.\n\n        Parameters:\n            test_for_uniqueness: If `True`, this will raise `KeyError` should an entry\n                point strategy be duplicated. Otherwise, the first loaded entry point\n                strategy will silently become the implementation of choice for the\n                duplicated strategy and the duplicates will be ignored.\n\n        \"\"\"\n        cls.strategy_create_func = {\n            strategy_type: get_strategy_entry_points(\n                strategy_type, enforce_uniqueness=test_for_uniqueness\n            )\n            for strategy_type in StrategyType\n        }\n</code></pre>"},{"location":"api_reference/plugins/factories/#oteapi.plugins.factories.StrategyFactory.load_strategies","title":"<code>load_strategies(test_for_uniqueness=True)</code>  <code>classmethod</code>","text":"<p>Load strategies from entry points and store in class attribute.</p> Important <p>This is not a cached method. The importlib.metadata API will be re-requested to load the entry points and strategies.</p> Note <p>This does not import the actual strategy implementations (classes). It only loads the strategies from the registerred OTE-API entry points.</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If <code>test_for_uniqueness</code> is <code>True</code> and an entry point strategy is duplicated.</p> <p>Parameters:</p> Name Type Description Default <code>test_for_uniqueness</code> <code>bool</code> <p>If <code>True</code>, this will raise <code>KeyError</code> should an entry point strategy be duplicated. Otherwise, the first loaded entry point strategy will silently become the implementation of choice for the duplicated strategy and the duplicates will be ignored.</p> <code>True</code> Source code in <code>oteapi/plugins/factories.py</code> <pre><code>@classmethod\ndef load_strategies(cls, test_for_uniqueness: bool = True) -&gt; None:\n\"\"\"Load strategies from entry points and store in class attribute.\n\n    Important:\n        This is not a cached method.\n        The importlib.metadata API will be re-requested to load the entry points\n        and strategies.\n\n    Note:\n        This does *not* import the actual strategy implementations (classes).\n        It only loads the strategies from the registerred OTE-API entry points.\n\n    Raises:\n        KeyError: If `test_for_uniqueness` is `True` and an entry point strategy is\n            duplicated.\n\n    Parameters:\n        test_for_uniqueness: If `True`, this will raise `KeyError` should an entry\n            point strategy be duplicated. Otherwise, the first loaded entry point\n            strategy will silently become the implementation of choice for the\n            duplicated strategy and the duplicates will be ignored.\n\n    \"\"\"\n    cls.strategy_create_func = {\n        strategy_type: get_strategy_entry_points(\n            strategy_type, enforce_uniqueness=test_for_uniqueness\n        )\n        for strategy_type in StrategyType\n    }\n</code></pre>"},{"location":"api_reference/plugins/factories/#oteapi.plugins.factories.StrategyFactory.make_strategy","title":"<code>make_strategy(config, strategy_type)</code>  <code>classmethod</code>","text":"<p>Instantiate a strategy in a context class.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>Union[StrategyConfig, Dict[str, Any]]</code> <p>A strategy configuration.</p> required <code>strategy_type</code> <code>Union[StrategyType, str]</code> <p>The strategy type, e.g., <code>\"scheme\"</code>, <code>\"mediaType\"</code>, ... or <code>\"download\"</code>, <code>\"parse\"</code>, ... See the <code>StrategyType</code> enumeration for a definition of valid strategy types.</p> required <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If the strategy cannot be found.</p> <code>ValueError</code> <p>If the <code>strategy_type</code> is not a valid strategy type. See the <code>StrategyType</code> enumeration for a definition of valid strategy types.</p> <code>StrategiesNotLoaded</code> <p>If the entry point strategies have not been loaded.</p> <p>Returns:</p> Type Description <code>IStrategy</code> <p>An instantiated strategy. The strategy is instantiated with the provided</p> <code>IStrategy</code> <p>configuration, through the <code>config</code> parameter.</p> Source code in <code>oteapi/plugins/factories.py</code> <pre><code>@classmethod\ndef make_strategy(\n    cls,\n    config: \"Union[StrategyConfig, Dict[str, Any]]\",\n    strategy_type: \"Union[StrategyType, str]\",\n) -&gt; \"IStrategy\":\n\"\"\"Instantiate a strategy in a context class.\n\n    Parameters:\n        config: A strategy configuration.\n        strategy_type: The strategy type, e.g., `\"scheme\"`, `\"mediaType\"`, ... or\n            `\"download\"`, `\"parse\"`, ...\n            See the [`StrategyType`][oteapi.plugins.entry_points.StrategyType]\n            enumeration for a definition of valid strategy types.\n\n    Raises:\n        NotImplementedError: If the strategy cannot be found.\n        ValueError: If the `strategy_type` is not a valid strategy type.\n            See the [`StrategyType`][oteapi.plugins.entry_points.StrategyType]\n            enumeration for a definition of valid strategy types.\n        StrategiesNotLoaded: If the entry point strategies have not been loaded.\n\n    Returns:\n        An instantiated strategy. The strategy is instantiated with the provided\n        configuration, through the `config` parameter.\n\n    \"\"\"\n    if not hasattr(cls, \"strategy_create_func\"):\n        raise StrategiesNotLoaded(\n            \"Strategies have not been loaded, run `load_strategies()` or \"\n            \"`StrategyFactory.load_strategies()`.\"\n        )\n\n    if isinstance(strategy_type, str):\n        try:\n            strategy_type = StrategyType.init(strategy_type)\n        except ValueError as exc:\n            raise ValueError(\n                f\"Strategy type {strategy_type!r} is not supported.\"\n            ) from exc\n    elif not isinstance(strategy_type, StrategyType):\n        raise TypeError(\n            \"strategy_type should be either of type StrategyType or a string.\"\n        )\n\n    if isinstance(config, dict):\n        config = strategy_type.config_cls(**config)  # type: ignore[call-arg]\n    elif not isinstance(config, get_args(StrategyConfig)):\n        raise TypeError(\"config should be either of type StrategyConfig or a dict.\")\n\n    strategy_name: str = cls._get_strategy_name(config, strategy_type)\n\n    if (strategy_type, strategy_name) in cls.strategy_create_func[strategy_type]:\n        return cls.strategy_create_func[strategy_type][\n            (strategy_type, strategy_name)\n        ].implementation(\n            config  # type: ignore[arg-type]\n        )\n    raise NotImplementedError(\n        f\"The {strategy_type.value} strategy {strategy_name!r} does not exist.\"\n    )\n</code></pre>"},{"location":"api_reference/plugins/factories/#oteapi.plugins.factories.create_strategy","title":"<code>create_strategy(strategy_type, config)</code>","text":"<p>Proxy function for <code>StrategyFactory.make_strategy()</code>.</p> <p>Parameters:</p> Name Type Description Default <code>strategy_type</code> <code>Union[StrategyType, str]</code> <p>A valid strategy type. See the <code>StrategyType</code> enumeration for a definition of valid strategy types.</p> required <code>config</code> <code>Union[StrategyConfig, Dict[str, Any]]</code> <p>A strategy configuration.</p> required <p>Returns:</p> Type Description <code>IStrategy</code> <p>The created strategy.</p> Source code in <code>oteapi/plugins/factories.py</code> <pre><code>def create_strategy(\n    strategy_type: \"Union[StrategyType, str]\",\n    config: \"Union[StrategyConfig, Dict[str, Any]]\",\n) -&gt; \"IStrategy\":\n\"\"\"Proxy function for\n    [`StrategyFactory.make_strategy()`][oteapi.plugins.factories.StrategyFactory.make_strategy].\n\n    Parameters:\n        strategy_type: A valid strategy type.\n            See the [`StrategyType`][oteapi.plugins.entry_points.StrategyType]\n            enumeration for a definition of valid strategy types.\n        config: A strategy configuration.\n\n    Returns:\n        The created strategy.\n\n    \"\"\"\n    return StrategyFactory.make_strategy(config, strategy_type)\n</code></pre>"},{"location":"api_reference/plugins/factories/#oteapi.plugins.factories.load_strategies","title":"<code>load_strategies(test_for_uniqueness=True)</code>","text":"<p>Proxy function for <code>StrategyFactory.load_strategies()</code>.</p> <p>Parameters:</p> Name Type Description Default <code>test_for_uniqueness</code> <code>bool</code> <p>If <code>True</code>, this will raise <code>KeyError</code> should an entry point strategy be duplicated. Otherwise, the first loaded entry point strategy will silently become the implementation of choice for the duplicated strategy and the duplicates will be ignored.</p> <code>True</code> Source code in <code>oteapi/plugins/factories.py</code> <pre><code>def load_strategies(test_for_uniqueness: bool = True) -&gt; None:\n\"\"\"Proxy function for\n    [`StrategyFactory.load_strategies()`][oteapi.plugins.factories.StrategyFactory.load_strategies].\n\n    Parameters:\n        test_for_uniqueness: If `True`, this will raise `KeyError` should an entry\n            point strategy be duplicated. Otherwise, the first loaded entry point\n            strategy will silently become the implementation of choice for the\n            duplicated strategy and the duplicates will be ignored.\n\n    \"\"\"\n    StrategyFactory.load_strategies(test_for_uniqueness)\n</code></pre>"},{"location":"api_reference/strategies/download/file/","title":"file","text":"<p>Download strategy class for the <code>file</code> scheme.</p>"},{"location":"api_reference/strategies/download/file/#oteapi.strategies.download.file.FileConfig","title":"<code>FileConfig</code>","text":"<p>             Bases: <code>AttrDict</code></p> <p>File-specific Configuration Data Model.</p> Source code in <code>oteapi/strategies/download/file.py</code> <pre><code>class FileConfig(AttrDict):\n\"\"\"File-specific Configuration Data Model.\"\"\"\n\n    text: bool = Field(\n        False,\n        description=(\n            \"Whether the file should be opened in text mode. If `False`, the file will\"\n            \" be opened in bytes mode.\"\n        ),\n    )\n    encoding: Optional[str] = Field(\n        None,\n        description=(\n            \"Encoding used when opening the file. The default is platform dependent.\"\n        ),\n    )\n    datacache_config: Optional[DataCacheConfig] = Field(\n        None,\n        description=(\n            \"Configurations for the data cache for storing the downloaded file \"\n            \"content.\"\n        ),\n    )\n</code></pre>"},{"location":"api_reference/strategies/download/file/#oteapi.strategies.download.file.FileConfig.datacache_config","title":"<code>datacache_config: Optional[DataCacheConfig] = Field(None, description='Configurations for the data cache for storing the downloaded file content.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/download/file/#oteapi.strategies.download.file.FileConfig.encoding","title":"<code>encoding: Optional[str] = Field(None, description='Encoding used when opening the file. The default is platform dependent.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/download/file/#oteapi.strategies.download.file.FileConfig.text","title":"<code>text: bool = Field(False, description='Whether the file should be opened in text mode. If `False`, the file will be opened in bytes mode.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/download/file/#oteapi.strategies.download.file.FileResourceConfig","title":"<code>FileResourceConfig</code>","text":"<p>             Bases: <code>ResourceConfig</code></p> <p>File download strategy filter config.</p> Source code in <code>oteapi/strategies/download/file.py</code> <pre><code>class FileResourceConfig(ResourceConfig):\n\"\"\"File download strategy filter config.\"\"\"\n\n    downloadUrl: FileUrl = Field(  # type: ignore[assignment]\n        ..., description=\"The file URL, which will be downloaded.\"\n    )\n    configuration: FileConfig = Field(\n        FileConfig(), description=\"File download strategy-specific configuration.\"\n    )\n\n    @validator(\"downloadUrl\")\n    def ensure_path_exists(cls, value: FileUrl) -&gt; FileUrl:\n\"\"\"Ensure `path` is defined in `downloadUrl`.\"\"\"\n        if not value.path:\n            raise ValueError(\"downloadUrl must contain a `path` part.\")\n        return value\n</code></pre>"},{"location":"api_reference/strategies/download/file/#oteapi.strategies.download.file.FileResourceConfig.configuration","title":"<code>configuration: FileConfig = Field(FileConfig(), description='File download strategy-specific configuration.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/download/file/#oteapi.strategies.download.file.FileResourceConfig.downloadUrl","title":"<code>downloadUrl: FileUrl = Field(..., description='The file URL, which will be downloaded.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/download/file/#oteapi.strategies.download.file.FileResourceConfig.ensure_path_exists","title":"<code>ensure_path_exists(value)</code>","text":"<p>Ensure <code>path</code> is defined in <code>downloadUrl</code>.</p> Source code in <code>oteapi/strategies/download/file.py</code> <pre><code>@validator(\"downloadUrl\")\ndef ensure_path_exists(cls, value: FileUrl) -&gt; FileUrl:\n\"\"\"Ensure `path` is defined in `downloadUrl`.\"\"\"\n    if not value.path:\n        raise ValueError(\"downloadUrl must contain a `path` part.\")\n    return value\n</code></pre>"},{"location":"api_reference/strategies/download/file/#oteapi.strategies.download.file.FileStrategy","title":"<code>FileStrategy</code>","text":"<p>Strategy for retrieving data from a local file.</p> <p>Registers strategies:</p> <ul> <li><code>(\"scheme\", \"file\")</code></li> </ul> Source code in <code>oteapi/strategies/download/file.py</code> <pre><code>@dataclass\nclass FileStrategy:\n\"\"\"Strategy for retrieving data from a local file.\n\n    **Registers strategies**:\n\n    - `(\"scheme\", \"file\")`\n\n    \"\"\"\n\n    download_config: FileResourceConfig\n\n    def initialize(self, session: \"Optional[Dict[str, Any]]\" = None) -&gt; SessionUpdate:\n\"\"\"Initialize.\"\"\"\n        return SessionUpdate()\n\n    def get(self, session: \"Optional[Dict[str, Any]]\" = None) -&gt; SessionUpdateFile:\n\"\"\"Read local file.\"\"\"\n        filename = uri_to_path(self.download_config.downloadUrl).resolve()\n\n        if not filename.exists():\n            raise FileNotFoundError(f\"File not found at {filename}\")\n\n        cache = DataCache(self.download_config.configuration.datacache_config)\n        if cache.config.accessKey and cache.config.accessKey in cache:\n            key = cache.config.accessKey\n        else:\n            key = cache.add(\n                filename.read_text(encoding=self.download_config.configuration.encoding)\n                if self.download_config.configuration.text\n                else filename.read_bytes()\n            )\n\n        return SessionUpdateFile(key=key)\n</code></pre>"},{"location":"api_reference/strategies/download/file/#oteapi.strategies.download.file.FileStrategy.download_config","title":"<code>download_config: FileResourceConfig</code>  <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/download/file/#oteapi.strategies.download.file.FileStrategy.get","title":"<code>get(session=None)</code>","text":"<p>Read local file.</p> Source code in <code>oteapi/strategies/download/file.py</code> <pre><code>def get(self, session: \"Optional[Dict[str, Any]]\" = None) -&gt; SessionUpdateFile:\n\"\"\"Read local file.\"\"\"\n    filename = uri_to_path(self.download_config.downloadUrl).resolve()\n\n    if not filename.exists():\n        raise FileNotFoundError(f\"File not found at {filename}\")\n\n    cache = DataCache(self.download_config.configuration.datacache_config)\n    if cache.config.accessKey and cache.config.accessKey in cache:\n        key = cache.config.accessKey\n    else:\n        key = cache.add(\n            filename.read_text(encoding=self.download_config.configuration.encoding)\n            if self.download_config.configuration.text\n            else filename.read_bytes()\n        )\n\n    return SessionUpdateFile(key=key)\n</code></pre>"},{"location":"api_reference/strategies/download/file/#oteapi.strategies.download.file.FileStrategy.initialize","title":"<code>initialize(session=None)</code>","text":"<p>Initialize.</p> Source code in <code>oteapi/strategies/download/file.py</code> <pre><code>def initialize(self, session: \"Optional[Dict[str, Any]]\" = None) -&gt; SessionUpdate:\n\"\"\"Initialize.\"\"\"\n    return SessionUpdate()\n</code></pre>"},{"location":"api_reference/strategies/download/file/#oteapi.strategies.download.file.SessionUpdateFile","title":"<code>SessionUpdateFile</code>","text":"<p>             Bases: <code>SessionUpdate</code></p> <p>Class for returning values from Download File strategy.</p> Source code in <code>oteapi/strategies/download/file.py</code> <pre><code>class SessionUpdateFile(SessionUpdate):\n\"\"\"Class for returning values from Download File strategy.\"\"\"\n\n    key: str = Field(..., description=\"Key to access the data in the cache.\")\n</code></pre>"},{"location":"api_reference/strategies/download/file/#oteapi.strategies.download.file.SessionUpdateFile.key","title":"<code>key: str = Field(..., description='Key to access the data in the cache.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/download/https/","title":"https","text":"<p>Download strategy class for http/https</p>"},{"location":"api_reference/strategies/download/https/#oteapi.strategies.download.https.HTTPSConfig","title":"<code>HTTPSConfig</code>","text":"<p>             Bases: <code>AttrDict</code></p> <p>HTTP(S)-specific Configuration Data Model.</p> Source code in <code>oteapi/strategies/download/https.py</code> <pre><code>class HTTPSConfig(AttrDict):\n\"\"\"HTTP(S)-specific Configuration Data Model.\"\"\"\n\n    datacache_config: Optional[DataCacheConfig] = Field(\n        None,\n        description=(\n            \"Configurations for the data cache for storing the downloaded file \"\n            \"content.\"\n        ),\n    )\n</code></pre>"},{"location":"api_reference/strategies/download/https/#oteapi.strategies.download.https.HTTPSConfig.datacache_config","title":"<code>datacache_config: Optional[DataCacheConfig] = Field(None, description='Configurations for the data cache for storing the downloaded file content.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/download/https/#oteapi.strategies.download.https.HTTPSResourceConfig","title":"<code>HTTPSResourceConfig</code>","text":"<p>             Bases: <code>ResourceConfig</code></p> <p>HTTP(S) download strategy filter config.</p> Source code in <code>oteapi/strategies/download/https.py</code> <pre><code>class HTTPSResourceConfig(ResourceConfig):\n\"\"\"HTTP(S) download strategy filter config.\"\"\"\n\n    downloadUrl: AnyHttpUrl = Field(  # type: ignore[assignment]\n        ..., description=\"The HTTP(S) URL, which will be downloaded.\"\n    )\n    configuration: HTTPSConfig = Field(\n        HTTPSConfig(), description=\"HTTP(S) download strategy-specific configuration.\"\n    )\n</code></pre>"},{"location":"api_reference/strategies/download/https/#oteapi.strategies.download.https.HTTPSResourceConfig.configuration","title":"<code>configuration: HTTPSConfig = Field(HTTPSConfig(), description='HTTP(S) download strategy-specific configuration.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/download/https/#oteapi.strategies.download.https.HTTPSResourceConfig.downloadUrl","title":"<code>downloadUrl: AnyHttpUrl = Field(..., description='The HTTP(S) URL, which will be downloaded.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/download/https/#oteapi.strategies.download.https.HTTPSStrategy","title":"<code>HTTPSStrategy</code>","text":"<p>Strategy for retrieving data via http.</p> <p>Registers strategies:</p> <ul> <li><code>(\"scheme\", \"http\")</code></li> <li><code>(\"scheme\", \"https\")</code></li> </ul> Source code in <code>oteapi/strategies/download/https.py</code> <pre><code>@dataclass\nclass HTTPSStrategy:\n\"\"\"Strategy for retrieving data via http.\n\n    **Registers strategies**:\n\n    - `(\"scheme\", \"http\")`\n    - `(\"scheme\", \"https\")`\n\n    \"\"\"\n\n    download_config: HTTPSResourceConfig\n\n    def initialize(self, session: \"Optional[Dict[str, Any]]\" = None) -&gt; SessionUpdate:\n\"\"\"Initialize.\"\"\"\n        return SessionUpdate()\n\n    def get(self, session: \"Optional[Dict[str, Any]]\" = None) -&gt; SessionUpdateHTTPS:\n\"\"\"Download via http/https and store on local cache.\"\"\"\n        cache = DataCache(self.download_config.configuration.datacache_config)\n        if cache.config.accessKey and cache.config.accessKey in cache:\n            key = cache.config.accessKey\n        else:\n            req = requests.get(\n                self.download_config.downloadUrl,\n                allow_redirects=True,\n                timeout=(3, 27),  # timeout: (connect, read) in seconds\n            )\n            key = cache.add(req.content)\n\n        return SessionUpdateHTTPS(key=key)\n</code></pre>"},{"location":"api_reference/strategies/download/https/#oteapi.strategies.download.https.HTTPSStrategy.download_config","title":"<code>download_config: HTTPSResourceConfig</code>  <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/download/https/#oteapi.strategies.download.https.HTTPSStrategy.get","title":"<code>get(session=None)</code>","text":"<p>Download via http/https and store on local cache.</p> Source code in <code>oteapi/strategies/download/https.py</code> <pre><code>def get(self, session: \"Optional[Dict[str, Any]]\" = None) -&gt; SessionUpdateHTTPS:\n\"\"\"Download via http/https and store on local cache.\"\"\"\n    cache = DataCache(self.download_config.configuration.datacache_config)\n    if cache.config.accessKey and cache.config.accessKey in cache:\n        key = cache.config.accessKey\n    else:\n        req = requests.get(\n            self.download_config.downloadUrl,\n            allow_redirects=True,\n            timeout=(3, 27),  # timeout: (connect, read) in seconds\n        )\n        key = cache.add(req.content)\n\n    return SessionUpdateHTTPS(key=key)\n</code></pre>"},{"location":"api_reference/strategies/download/https/#oteapi.strategies.download.https.HTTPSStrategy.initialize","title":"<code>initialize(session=None)</code>","text":"<p>Initialize.</p> Source code in <code>oteapi/strategies/download/https.py</code> <pre><code>def initialize(self, session: \"Optional[Dict[str, Any]]\" = None) -&gt; SessionUpdate:\n\"\"\"Initialize.\"\"\"\n    return SessionUpdate()\n</code></pre>"},{"location":"api_reference/strategies/download/https/#oteapi.strategies.download.https.SessionUpdateHTTPS","title":"<code>SessionUpdateHTTPS</code>","text":"<p>             Bases: <code>SessionUpdate</code></p> <p>Class for returning values from Download HTTPS strategy.</p> Source code in <code>oteapi/strategies/download/https.py</code> <pre><code>class SessionUpdateHTTPS(SessionUpdate):\n\"\"\"Class for returning values from Download HTTPS strategy.\"\"\"\n\n    key: str = Field(..., description=\"Key to access the data in the cache.\")\n</code></pre>"},{"location":"api_reference/strategies/download/https/#oteapi.strategies.download.https.SessionUpdateHTTPS.key","title":"<code>key: str = Field(..., description='Key to access the data in the cache.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/download/sftp/","title":"sftp","text":"<p>Strategy class for sftp/ftp</p>"},{"location":"api_reference/strategies/download/sftp/#oteapi.strategies.download.sftp.AnyFtpUrl","title":"<code>AnyFtpUrl</code>","text":"<p>             Bases: <code>AnyUrl</code></p> <p>A (S)FTP URL model.</p> Source code in <code>oteapi/strategies/download/sftp.py</code> <pre><code>class AnyFtpUrl(AnyUrl):\n\"\"\"A (S)FTP URL model.\"\"\"\n\n    allowed_schemes = {\"ftp\", \"sftp\"}\n</code></pre>"},{"location":"api_reference/strategies/download/sftp/#oteapi.strategies.download.sftp.AnyFtpUrl.allowed_schemes","title":"<code>allowed_schemes = {'ftp', 'sftp'}</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/download/sftp/#oteapi.strategies.download.sftp.SFTPConfig","title":"<code>SFTPConfig</code>","text":"<p>             Bases: <code>AttrDict</code></p> <p>(S)FTP-specific Configuration Data Model.</p> Source code in <code>oteapi/strategies/download/sftp.py</code> <pre><code>class SFTPConfig(AttrDict):\n\"\"\"(S)FTP-specific Configuration Data Model.\"\"\"\n\n    datacache_config: Optional[DataCacheConfig] = Field(\n        None,\n        description=(\n            \"Configurations for the data cache for storing the downloaded file \"\n            \"content.\"\n        ),\n    )\n</code></pre>"},{"location":"api_reference/strategies/download/sftp/#oteapi.strategies.download.sftp.SFTPConfig.datacache_config","title":"<code>datacache_config: Optional[DataCacheConfig] = Field(None, description='Configurations for the data cache for storing the downloaded file content.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/download/sftp/#oteapi.strategies.download.sftp.SFTPResourceConfig","title":"<code>SFTPResourceConfig</code>","text":"<p>             Bases: <code>ResourceConfig</code></p> <p>(S)FTP download strategy filter config.</p> Source code in <code>oteapi/strategies/download/sftp.py</code> <pre><code>class SFTPResourceConfig(ResourceConfig):\n\"\"\"(S)FTP download strategy filter config.\"\"\"\n\n    downloadUrl: AnyFtpUrl = Field(  # type: ignore[assignment]\n        ..., description=\"The (S)FTP URL, which will be downloaded.\"\n    )\n    configuration: SFTPConfig = Field(\n        SFTPConfig(), description=\"(S)FTP download strategy-specific configuration.\"\n    )\n</code></pre>"},{"location":"api_reference/strategies/download/sftp/#oteapi.strategies.download.sftp.SFTPResourceConfig.configuration","title":"<code>configuration: SFTPConfig = Field(SFTPConfig(), description='(S)FTP download strategy-specific configuration.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/download/sftp/#oteapi.strategies.download.sftp.SFTPResourceConfig.downloadUrl","title":"<code>downloadUrl: AnyFtpUrl = Field(..., description='The (S)FTP URL, which will be downloaded.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/download/sftp/#oteapi.strategies.download.sftp.SFTPStrategy","title":"<code>SFTPStrategy</code>","text":"<p>Strategy for retrieving data via sftp.</p> <p>Registers strategies:</p> <ul> <li><code>(\"scheme\", \"ftp\")</code></li> <li><code>(\"scheme\", \"sftp\")</code></li> </ul> Source code in <code>oteapi/strategies/download/sftp.py</code> <pre><code>@dataclass\nclass SFTPStrategy:\n\"\"\"Strategy for retrieving data via sftp.\n\n    **Registers strategies**:\n\n    - `(\"scheme\", \"ftp\")`\n    - `(\"scheme\", \"sftp\")`\n\n    \"\"\"\n\n    download_config: SFTPResourceConfig\n\n    def initialize(self, session: \"Optional[Dict[str, Any]]\" = None) -&gt; SessionUpdate:\n\"\"\"Initialize.\"\"\"\n        return SessionUpdate()\n\n    def get(self, session: \"Optional[Dict[str, Any]]\" = None) -&gt; SessionUpdateSFTP:\n\"\"\"Download via sftp\"\"\"\n        cache = DataCache(self.download_config.configuration.datacache_config)\n        if cache.config.accessKey and cache.config.accessKey in cache:\n            key = cache.config.accessKey\n        else:\n            # Setup connection options\n            cnopts = pysftp.CnOpts()\n            cnopts.hostkeys = None\n\n            # open connection and store data locally\n            with pysftp.Connection(\n                host=self.download_config.downloadUrl.host,\n                username=self.download_config.downloadUrl.user,\n                password=self.download_config.downloadUrl.password,\n                port=self.download_config.downloadUrl.port,\n                cnopts=cnopts,\n            ) as sftp:\n                # Because of insane locking on Windows, we have to close\n                # the downloaded file before adding it to the cache\n                with NamedTemporaryFile(prefix=\"oteapi-sftp-\", delete=False) as handle:\n                    localpath = Path(handle.name).resolve()\n                try:\n                    sftp.get(self.download_config.downloadUrl.path, localpath=localpath)\n                    key = cache.add(localpath.read_bytes())\n                finally:\n                    localpath.unlink()\n\n        return SessionUpdateSFTP(key=key)\n</code></pre>"},{"location":"api_reference/strategies/download/sftp/#oteapi.strategies.download.sftp.SFTPStrategy.download_config","title":"<code>download_config: SFTPResourceConfig</code>  <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/download/sftp/#oteapi.strategies.download.sftp.SFTPStrategy.get","title":"<code>get(session=None)</code>","text":"<p>Download via sftp</p> Source code in <code>oteapi/strategies/download/sftp.py</code> <pre><code>def get(self, session: \"Optional[Dict[str, Any]]\" = None) -&gt; SessionUpdateSFTP:\n\"\"\"Download via sftp\"\"\"\n    cache = DataCache(self.download_config.configuration.datacache_config)\n    if cache.config.accessKey and cache.config.accessKey in cache:\n        key = cache.config.accessKey\n    else:\n        # Setup connection options\n        cnopts = pysftp.CnOpts()\n        cnopts.hostkeys = None\n\n        # open connection and store data locally\n        with pysftp.Connection(\n            host=self.download_config.downloadUrl.host,\n            username=self.download_config.downloadUrl.user,\n            password=self.download_config.downloadUrl.password,\n            port=self.download_config.downloadUrl.port,\n            cnopts=cnopts,\n        ) as sftp:\n            # Because of insane locking on Windows, we have to close\n            # the downloaded file before adding it to the cache\n            with NamedTemporaryFile(prefix=\"oteapi-sftp-\", delete=False) as handle:\n                localpath = Path(handle.name).resolve()\n            try:\n                sftp.get(self.download_config.downloadUrl.path, localpath=localpath)\n                key = cache.add(localpath.read_bytes())\n            finally:\n                localpath.unlink()\n\n    return SessionUpdateSFTP(key=key)\n</code></pre>"},{"location":"api_reference/strategies/download/sftp/#oteapi.strategies.download.sftp.SFTPStrategy.initialize","title":"<code>initialize(session=None)</code>","text":"<p>Initialize.</p> Source code in <code>oteapi/strategies/download/sftp.py</code> <pre><code>def initialize(self, session: \"Optional[Dict[str, Any]]\" = None) -&gt; SessionUpdate:\n\"\"\"Initialize.\"\"\"\n    return SessionUpdate()\n</code></pre>"},{"location":"api_reference/strategies/download/sftp/#oteapi.strategies.download.sftp.SessionUpdateSFTP","title":"<code>SessionUpdateSFTP</code>","text":"<p>             Bases: <code>SessionUpdate</code></p> <p>Class for returning values from Download SFTP strategy.</p> Source code in <code>oteapi/strategies/download/sftp.py</code> <pre><code>class SessionUpdateSFTP(SessionUpdate):\n\"\"\"Class for returning values from Download SFTP strategy.\"\"\"\n\n    key: str = Field(..., description=\"Key to access the data in the cache.\")\n</code></pre>"},{"location":"api_reference/strategies/download/sftp/#oteapi.strategies.download.sftp.SessionUpdateSFTP.key","title":"<code>key: str = Field(..., description='Key to access the data in the cache.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/filter/crop_filter/","title":"crop_filter","text":"<p>Demo-filter strategy</p>"},{"location":"api_reference/strategies/filter/crop_filter/#oteapi.strategies.filter.crop_filter.CropImageConfig","title":"<code>CropImageConfig</code>","text":"<p>             Bases: <code>AttrDict</code></p> <p>Configuration model for crop data.</p> Source code in <code>oteapi/strategies/filter/crop_filter.py</code> <pre><code>class CropImageConfig(AttrDict):\n\"\"\"Configuration model for crop data.\"\"\"\n\n    crop: Tuple[int, int, int, int] = Field(\n        ..., description=\"Box cropping parameters (left, top, right, bottom).\"\n    )\n</code></pre>"},{"location":"api_reference/strategies/filter/crop_filter/#oteapi.strategies.filter.crop_filter.CropImageConfig.crop","title":"<code>crop: Tuple[int, int, int, int] = Field(..., description='Box cropping parameters (left, top, right, bottom).')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/filter/crop_filter/#oteapi.strategies.filter.crop_filter.CropImageFilter","title":"<code>CropImageFilter</code>","text":"<p>Strategy for cropping an image.</p> <p>Registers strategies:</p> <ul> <li><code>(\"filterType\", \"filter/crop\")</code></li> </ul> Source code in <code>oteapi/strategies/filter/crop_filter.py</code> <pre><code>@dataclass\nclass CropImageFilter:\n\"\"\"Strategy for cropping an image.\n\n    **Registers strategies**:\n\n    - `(\"filterType\", \"filter/crop\")`\n\n    \"\"\"\n\n    filter_config: CropImageFilterConfig\n\n    def initialize(\n        self,\n        session: \"Optional[Dict[str, Any]]\" = None,\n    ) -&gt; SessionUpdateCropFilter:\n\"\"\"Initialize strategy and return a dictionary.\"\"\"\n        return SessionUpdateCropFilter(\n            imagecrop=self.filter_config.configuration.crop,\n        )\n\n    def get(\n        self,\n        session: \"Optional[Dict[str, Any]]\" = None,\n    ) -&gt; SessionUpdate:\n\"\"\"Execute strategy and return a dictionary\"\"\"\n        return SessionUpdate()\n</code></pre>"},{"location":"api_reference/strategies/filter/crop_filter/#oteapi.strategies.filter.crop_filter.CropImageFilter.filter_config","title":"<code>filter_config: CropImageFilterConfig</code>  <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/filter/crop_filter/#oteapi.strategies.filter.crop_filter.CropImageFilter.get","title":"<code>get(session=None)</code>","text":"<p>Execute strategy and return a dictionary</p> Source code in <code>oteapi/strategies/filter/crop_filter.py</code> <pre><code>def get(\n    self,\n    session: \"Optional[Dict[str, Any]]\" = None,\n) -&gt; SessionUpdate:\n\"\"\"Execute strategy and return a dictionary\"\"\"\n    return SessionUpdate()\n</code></pre>"},{"location":"api_reference/strategies/filter/crop_filter/#oteapi.strategies.filter.crop_filter.CropImageFilter.initialize","title":"<code>initialize(session=None)</code>","text":"<p>Initialize strategy and return a dictionary.</p> Source code in <code>oteapi/strategies/filter/crop_filter.py</code> <pre><code>def initialize(\n    self,\n    session: \"Optional[Dict[str, Any]]\" = None,\n) -&gt; SessionUpdateCropFilter:\n\"\"\"Initialize strategy and return a dictionary.\"\"\"\n    return SessionUpdateCropFilter(\n        imagecrop=self.filter_config.configuration.crop,\n    )\n</code></pre>"},{"location":"api_reference/strategies/filter/crop_filter/#oteapi.strategies.filter.crop_filter.CropImageFilterConfig","title":"<code>CropImageFilterConfig</code>","text":"<p>             Bases: <code>FilterConfig</code></p> <p>Crop filter strategy filter config.</p> Source code in <code>oteapi/strategies/filter/crop_filter.py</code> <pre><code>class CropImageFilterConfig(FilterConfig):\n\"\"\"Crop filter strategy filter config.\"\"\"\n\n    filterType: str = Field(\n        \"filter/crop\",\n        const=True,\n        description=FilterConfig.__fields__[\"filterType\"].field_info.description,\n    )\n    configuration: CropImageConfig = Field(\n        ..., description=\"Image crop filter strategy-specific configuration.\"\n    )\n</code></pre>"},{"location":"api_reference/strategies/filter/crop_filter/#oteapi.strategies.filter.crop_filter.CropImageFilterConfig.configuration","title":"<code>configuration: CropImageConfig = Field(..., description='Image crop filter strategy-specific configuration.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/filter/crop_filter/#oteapi.strategies.filter.crop_filter.CropImageFilterConfig.filterType","title":"<code>filterType: str = Field('filter/crop', const=True, description=FilterConfig.__fields__['filterType'].field_info.description)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/filter/crop_filter/#oteapi.strategies.filter.crop_filter.SessionUpdateCropFilter","title":"<code>SessionUpdateCropFilter</code>","text":"<p>             Bases: <code>SessionUpdate</code></p> <p>Return model for <code>CropImageFilter</code>.</p> Source code in <code>oteapi/strategies/filter/crop_filter.py</code> <pre><code>class SessionUpdateCropFilter(SessionUpdate):\n\"\"\"Return model for `CropImageFilter`.\"\"\"\n\n    imagecrop: Tuple[int, int, int, int] = Field(\n        ..., description=\"Box cropping parameters (left, top, right, bottom).\"\n    )\n</code></pre>"},{"location":"api_reference/strategies/filter/crop_filter/#oteapi.strategies.filter.crop_filter.SessionUpdateCropFilter.imagecrop","title":"<code>imagecrop: Tuple[int, int, int, int] = Field(..., description='Box cropping parameters (left, top, right, bottom).')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/filter/sql_query_filter/","title":"sql_query_filter","text":"<p>SQL query filter strategy.</p>"},{"location":"api_reference/strategies/filter/sql_query_filter/#oteapi.strategies.filter.sql_query_filter.SQLQueryFilter","title":"<code>SQLQueryFilter</code>","text":"<p>Strategy for a SQL query filter.</p> <p>Registers strategies:</p> <ul> <li><code>(\"filterType\", \"filter/sql\")</code></li> </ul> Source code in <code>oteapi/strategies/filter/sql_query_filter.py</code> <pre><code>@dataclass\nclass SQLQueryFilter:\n\"\"\"Strategy for a SQL query filter.\n\n    **Registers strategies**:\n\n    - `(\"filterType\", \"filter/sql\")`\n\n    \"\"\"\n\n    filter_config: SqlQueryFilterConfig\n\n    def initialize(\n        self,\n        session: \"Optional[Dict[str, Any]]\" = None,\n    ) -&gt; SessionUpdateSqlQuery:\n\"\"\"Initialize strategy.\"\"\"\n        return SessionUpdateSqlQuery(sqlquery=self.filter_config.query)\n\n    def get(self, session: \"Optional[Dict[str, Any]]\" = None) -&gt; SessionUpdate:\n\"\"\"Execute strategy and return a dictionary.\"\"\"\n        return SessionUpdate()\n</code></pre>"},{"location":"api_reference/strategies/filter/sql_query_filter/#oteapi.strategies.filter.sql_query_filter.SQLQueryFilter.filter_config","title":"<code>filter_config: SqlQueryFilterConfig</code>  <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/filter/sql_query_filter/#oteapi.strategies.filter.sql_query_filter.SQLQueryFilter.get","title":"<code>get(session=None)</code>","text":"<p>Execute strategy and return a dictionary.</p> Source code in <code>oteapi/strategies/filter/sql_query_filter.py</code> <pre><code>def get(self, session: \"Optional[Dict[str, Any]]\" = None) -&gt; SessionUpdate:\n\"\"\"Execute strategy and return a dictionary.\"\"\"\n    return SessionUpdate()\n</code></pre>"},{"location":"api_reference/strategies/filter/sql_query_filter/#oteapi.strategies.filter.sql_query_filter.SQLQueryFilter.initialize","title":"<code>initialize(session=None)</code>","text":"<p>Initialize strategy.</p> Source code in <code>oteapi/strategies/filter/sql_query_filter.py</code> <pre><code>def initialize(\n    self,\n    session: \"Optional[Dict[str, Any]]\" = None,\n) -&gt; SessionUpdateSqlQuery:\n\"\"\"Initialize strategy.\"\"\"\n    return SessionUpdateSqlQuery(sqlquery=self.filter_config.query)\n</code></pre>"},{"location":"api_reference/strategies/filter/sql_query_filter/#oteapi.strategies.filter.sql_query_filter.SessionUpdateSqlQuery","title":"<code>SessionUpdateSqlQuery</code>","text":"<p>             Bases: <code>SessionUpdate</code></p> <p>Class for returning values from SQL Query data model.</p> Source code in <code>oteapi/strategies/filter/sql_query_filter.py</code> <pre><code>class SessionUpdateSqlQuery(SessionUpdate):\n\"\"\"Class for returning values from SQL Query data model.\"\"\"\n\n    sqlquery: str = Field(..., description=\"A SQL query string.\")\n</code></pre>"},{"location":"api_reference/strategies/filter/sql_query_filter/#oteapi.strategies.filter.sql_query_filter.SessionUpdateSqlQuery.sqlquery","title":"<code>sqlquery: str = Field(..., description='A SQL query string.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/filter/sql_query_filter/#oteapi.strategies.filter.sql_query_filter.SqlQueryFilterConfig","title":"<code>SqlQueryFilterConfig</code>","text":"<p>             Bases: <code>FilterConfig</code></p> <p>SQL query filter strategy filter config.</p> Source code in <code>oteapi/strategies/filter/sql_query_filter.py</code> <pre><code>class SqlQueryFilterConfig(FilterConfig):\n\"\"\"SQL query filter strategy filter config.\"\"\"\n\n    filterType: str = Field(\n        \"filter/sql\",\n        const=True,\n        description=FilterConfig.__fields__[\"filterType\"].field_info.description,\n    )\n    query: str = Field(..., description=\"A SQL query string.\")\n</code></pre>"},{"location":"api_reference/strategies/filter/sql_query_filter/#oteapi.strategies.filter.sql_query_filter.SqlQueryFilterConfig.filterType","title":"<code>filterType: str = Field('filter/sql', const=True, description=FilterConfig.__fields__['filterType'].field_info.description)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/filter/sql_query_filter/#oteapi.strategies.filter.sql_query_filter.SqlQueryFilterConfig.query","title":"<code>query: str = Field(..., description='A SQL query string.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/mapping/mapping/","title":"mapping","text":"<p>Mapping filter strategy.</p>"},{"location":"api_reference/strategies/mapping/mapping/#oteapi.strategies.mapping.mapping.MappingSessionUpdate","title":"<code>MappingSessionUpdate</code>","text":"<p>             Bases: <code>SessionUpdate</code></p> <p>SessionUpdate model for mappings.</p> Source code in <code>oteapi/strategies/mapping/mapping.py</code> <pre><code>class MappingSessionUpdate(SessionUpdate):\n\"\"\"SessionUpdate model for mappings.\"\"\"\n\n    prefixes: Dict[str, str] = Field(\n        ...,\n        description=(\n            \"Dictionary of shortnames that expands to an IRI \"\n            \"given as local value/IRI-expansion-pairs.\"\n        ),\n    )\n    triples: List[RDFTriple] = Field(\n        ...,\n        description=\"List of semantic triples given as (subject, predicate, object).\",\n    )\n</code></pre>"},{"location":"api_reference/strategies/mapping/mapping/#oteapi.strategies.mapping.mapping.MappingSessionUpdate.prefixes","title":"<code>prefixes: Dict[str, str] = Field(..., description='Dictionary of shortnames that expands to an IRI given as local value/IRI-expansion-pairs.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/mapping/mapping/#oteapi.strategies.mapping.mapping.MappingSessionUpdate.triples","title":"<code>triples: List[RDFTriple] = Field(..., description='List of semantic triples given as (subject, predicate, object).')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/mapping/mapping/#oteapi.strategies.mapping.mapping.MappingStrategy","title":"<code>MappingStrategy</code>","text":"<p>Strategy for a mapping.</p> <p>The mapping strategy simply adds more prefixes and triples to the <code>prefixes</code> and <code>triples</code> fields in the session such that they are available for other strategies, like function strategies that convert between data models.</p> <p>Nothing is returned to avoid deleting existing mappings.</p> <p>Registers strategies:</p> <ul> <li><code>(\"mappingType\", \"triples\")</code></li> </ul> Source code in <code>oteapi/strategies/mapping/mapping.py</code> <pre><code>@dataclass\nclass MappingStrategy:\n\"\"\"Strategy for a mapping.\n\n    The mapping strategy simply adds more prefixes and triples to the\n    `prefixes` and `triples` fields in the session such that they are\n    available for other strategies, like function strategies that convert\n    between data models.\n\n    Nothing is returned to avoid deleting existing mappings.\n\n    **Registers strategies**:\n\n    - `(\"mappingType\", \"triples\")`\n\n    \"\"\"\n\n    mapping_config: MappingConfig\n\n    def initialize(\n        self, session: \"Optional[Dict[str, Any]]\" = None\n    ) -&gt; MappingSessionUpdate:\n\"\"\"Initialize strategy.\"\"\"\n        prefixes = session.get(\"prefixes\", {}) if session else {}\n        triples = set(session.get(\"triples\", []) if session else [])\n\n        if self.mapping_config.prefixes:\n            prefixes.update(self.mapping_config.prefixes)\n        if self.mapping_config.triples:\n            triples.update(self.mapping_config.triples)\n\n        return MappingSessionUpdate(prefixes=prefixes, triples=triples)\n\n    def get(self, session: \"Optional[Dict[str, Any]]\" = None) -&gt; SessionUpdate:\n\"\"\"Execute strategy and return a dictionary.\"\"\"\n        return SessionUpdate()\n</code></pre>"},{"location":"api_reference/strategies/mapping/mapping/#oteapi.strategies.mapping.mapping.MappingStrategy.mapping_config","title":"<code>mapping_config: MappingConfig</code>  <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/mapping/mapping/#oteapi.strategies.mapping.mapping.MappingStrategy.get","title":"<code>get(session=None)</code>","text":"<p>Execute strategy and return a dictionary.</p> Source code in <code>oteapi/strategies/mapping/mapping.py</code> <pre><code>def get(self, session: \"Optional[Dict[str, Any]]\" = None) -&gt; SessionUpdate:\n\"\"\"Execute strategy and return a dictionary.\"\"\"\n    return SessionUpdate()\n</code></pre>"},{"location":"api_reference/strategies/mapping/mapping/#oteapi.strategies.mapping.mapping.MappingStrategy.initialize","title":"<code>initialize(session=None)</code>","text":"<p>Initialize strategy.</p> Source code in <code>oteapi/strategies/mapping/mapping.py</code> <pre><code>def initialize(\n    self, session: \"Optional[Dict[str, Any]]\" = None\n) -&gt; MappingSessionUpdate:\n\"\"\"Initialize strategy.\"\"\"\n    prefixes = session.get(\"prefixes\", {}) if session else {}\n    triples = set(session.get(\"triples\", []) if session else [])\n\n    if self.mapping_config.prefixes:\n        prefixes.update(self.mapping_config.prefixes)\n    if self.mapping_config.triples:\n        triples.update(self.mapping_config.triples)\n\n    return MappingSessionUpdate(prefixes=prefixes, triples=triples)\n</code></pre>"},{"location":"api_reference/strategies/parse/application_json/","title":"application_json","text":"<p>Strategy class for application/json.</p>"},{"location":"api_reference/strategies/parse/application_json/#oteapi.strategies.parse.application_json.JSONConfig","title":"<code>JSONConfig</code>","text":"<p>             Bases: <code>AttrDict</code></p> <p>JSON parse-specific Configuration Data Model.</p> Source code in <code>oteapi/strategies/parse/application_json.py</code> <pre><code>class JSONConfig(AttrDict):\n\"\"\"JSON parse-specific Configuration Data Model.\"\"\"\n\n    datacache_config: Optional[DataCacheConfig] = Field(\n        None,\n        description=(\n            \"Configurations for the data cache for storing the downloaded file \"\n            \"content.\"\n        ),\n    )\n</code></pre>"},{"location":"api_reference/strategies/parse/application_json/#oteapi.strategies.parse.application_json.JSONConfig.datacache_config","title":"<code>datacache_config: Optional[DataCacheConfig] = Field(None, description='Configurations for the data cache for storing the downloaded file content.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/parse/application_json/#oteapi.strategies.parse.application_json.JSONDataParseStrategy","title":"<code>JSONDataParseStrategy</code>","text":"<p>Parse strategy for JSON.</p> <p>Registers strategies:</p> <ul> <li><code>(\"mediaType\", \"application/json\")</code></li> </ul> Source code in <code>oteapi/strategies/parse/application_json.py</code> <pre><code>@dataclass\nclass JSONDataParseStrategy:\n\"\"\"Parse strategy for JSON.\n\n    **Registers strategies**:\n\n    - `(\"mediaType\", \"application/json\")`\n\n    \"\"\"\n\n    parse_config: JSONResourceConfig\n\n    def initialize(self, session: \"Optional[Dict[str, Any]]\" = None) -&gt; SessionUpdate:\n\"\"\"Initialize.\"\"\"\n        return SessionUpdate()\n\n    def get(self, session: \"Optional[Dict[str, Any]]\" = None) -&gt; SessionUpdateJSONParse:\n\"\"\"Parse json.\"\"\"\n        downloader = create_strategy(\"download\", self.parse_config)\n        output = downloader.get()\n        cache = DataCache(self.parse_config.configuration.datacache_config)\n        content = cache.get(output[\"key\"])\n\n        if isinstance(content, dict):\n            return SessionUpdateJSONParse(content=content)\n        return SessionUpdateJSONParse(content=json.loads(content))\n</code></pre>"},{"location":"api_reference/strategies/parse/application_json/#oteapi.strategies.parse.application_json.JSONDataParseStrategy.parse_config","title":"<code>parse_config: JSONResourceConfig</code>  <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/parse/application_json/#oteapi.strategies.parse.application_json.JSONDataParseStrategy.get","title":"<code>get(session=None)</code>","text":"<p>Parse json.</p> Source code in <code>oteapi/strategies/parse/application_json.py</code> <pre><code>def get(self, session: \"Optional[Dict[str, Any]]\" = None) -&gt; SessionUpdateJSONParse:\n\"\"\"Parse json.\"\"\"\n    downloader = create_strategy(\"download\", self.parse_config)\n    output = downloader.get()\n    cache = DataCache(self.parse_config.configuration.datacache_config)\n    content = cache.get(output[\"key\"])\n\n    if isinstance(content, dict):\n        return SessionUpdateJSONParse(content=content)\n    return SessionUpdateJSONParse(content=json.loads(content))\n</code></pre>"},{"location":"api_reference/strategies/parse/application_json/#oteapi.strategies.parse.application_json.JSONDataParseStrategy.initialize","title":"<code>initialize(session=None)</code>","text":"<p>Initialize.</p> Source code in <code>oteapi/strategies/parse/application_json.py</code> <pre><code>def initialize(self, session: \"Optional[Dict[str, Any]]\" = None) -&gt; SessionUpdate:\n\"\"\"Initialize.\"\"\"\n    return SessionUpdate()\n</code></pre>"},{"location":"api_reference/strategies/parse/application_json/#oteapi.strategies.parse.application_json.JSONResourceConfig","title":"<code>JSONResourceConfig</code>","text":"<p>             Bases: <code>ResourceConfig</code></p> <p>JSON parse strategy filter config.</p> Source code in <code>oteapi/strategies/parse/application_json.py</code> <pre><code>class JSONResourceConfig(ResourceConfig):\n\"\"\"JSON parse strategy filter config.\"\"\"\n\n    mediaType: str = Field(\n        \"application/json\",\n        const=True,\n        description=ResourceConfig.__fields__[\"mediaType\"].field_info.description,\n    )\n    configuration: JSONConfig = Field(\n        JSONConfig(), description=\"JSON parse strategy-specific configuration.\"\n    )\n</code></pre>"},{"location":"api_reference/strategies/parse/application_json/#oteapi.strategies.parse.application_json.JSONResourceConfig.configuration","title":"<code>configuration: JSONConfig = Field(JSONConfig(), description='JSON parse strategy-specific configuration.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/parse/application_json/#oteapi.strategies.parse.application_json.JSONResourceConfig.mediaType","title":"<code>mediaType: str = Field('application/json', const=True, description=ResourceConfig.__fields__['mediaType'].field_info.description)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/parse/application_json/#oteapi.strategies.parse.application_json.SessionUpdateJSONParse","title":"<code>SessionUpdateJSONParse</code>","text":"<p>             Bases: <code>SessionUpdate</code></p> <p>Class for returning values from JSON Parse.</p> Source code in <code>oteapi/strategies/parse/application_json.py</code> <pre><code>class SessionUpdateJSONParse(SessionUpdate):\n\"\"\"Class for returning values from JSON Parse.\"\"\"\n\n    content: dict = Field(..., description=\"Content of the JSON document.\")\n</code></pre>"},{"location":"api_reference/strategies/parse/application_json/#oteapi.strategies.parse.application_json.SessionUpdateJSONParse.content","title":"<code>content: dict = Field(..., description='Content of the JSON document.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/parse/application_vnd_sqlite/","title":"application_vnd_sqlite","text":"<p>Strategy class for application/vnd.sqlite3.</p>"},{"location":"api_reference/strategies/parse/application_vnd_sqlite/#oteapi.strategies.parse.application_vnd_sqlite.SessionUpdateSqLiteParse","title":"<code>SessionUpdateSqLiteParse</code>","text":"<p>             Bases: <code>SessionUpdate</code></p> <p>Configuration model for SqLiteParse.</p> Source code in <code>oteapi/strategies/parse/application_vnd_sqlite.py</code> <pre><code>class SessionUpdateSqLiteParse(SessionUpdate):\n\"\"\"Configuration model for SqLiteParse.\"\"\"\n\n    result: list = Field(..., description=\"List of results from the query.\")\n</code></pre>"},{"location":"api_reference/strategies/parse/application_vnd_sqlite/#oteapi.strategies.parse.application_vnd_sqlite.SessionUpdateSqLiteParse.result","title":"<code>result: list = Field(..., description='List of results from the query.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/parse/application_vnd_sqlite/#oteapi.strategies.parse.application_vnd_sqlite.SqliteParseConfig","title":"<code>SqliteParseConfig</code>","text":"<p>             Bases: <code>AttrDict</code></p> <p>Configuration data model for <code>SqliteParseStrategy</code>.</p> Source code in <code>oteapi/strategies/parse/application_vnd_sqlite.py</code> <pre><code>class SqliteParseConfig(AttrDict):\n\"\"\"Configuration data model for\n    [`SqliteParseStrategy`][oteapi.strategies.parse.application_vnd_sqlite.SqliteParseStrategy].\n    \"\"\"\n\n    sqlquery: str = Field(\"\", description=\"A SQL query string.\")\n    datacache_config: Optional[DataCacheConfig] = Field(\n        None,\n        description=\"Configuration options for the local data cache.\",\n    )\n</code></pre>"},{"location":"api_reference/strategies/parse/application_vnd_sqlite/#oteapi.strategies.parse.application_vnd_sqlite.SqliteParseConfig.datacache_config","title":"<code>datacache_config: Optional[DataCacheConfig] = Field(None, description='Configuration options for the local data cache.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/parse/application_vnd_sqlite/#oteapi.strategies.parse.application_vnd_sqlite.SqliteParseConfig.sqlquery","title":"<code>sqlquery: str = Field('', description='A SQL query string.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/parse/application_vnd_sqlite/#oteapi.strategies.parse.application_vnd_sqlite.SqliteParseStrategy","title":"<code>SqliteParseStrategy</code>","text":"<p>Parse strategy for SQLite.</p> <p>Registers strategies:</p> <ul> <li><code>(\"mediaType\", \"application/vnd.sqlite3\")</code></li> </ul> <p>Purpose of this strategy: Download a SQLite database using <code>downloadUrl</code> and run a SQL query on the database to return all relevant rows.</p> Source code in <code>oteapi/strategies/parse/application_vnd_sqlite.py</code> <pre><code>@dataclass\nclass SqliteParseStrategy:\n\"\"\"Parse strategy for SQLite.\n\n    **Registers strategies**:\n\n    - `(\"mediaType\", \"application/vnd.sqlite3\")`\n\n    Purpose of this strategy: Download a SQLite database using `downloadUrl` and run a\n    SQL query on the database to return all relevant rows.\n\n    \"\"\"\n\n    parse_config: SqliteParserResourceConfig\n\n    def initialize(self, session: \"Optional[Dict[str, Any]]\" = None) -&gt; SessionUpdate:\n\"\"\"Initialize strategy.\"\"\"\n        return SessionUpdate()\n\n    def get(\n        self, session: \"Optional[Dict[str, Any]]\" = None\n    ) -&gt; SessionUpdateSqLiteParse:\n\"\"\"Parse SQLite query responses.\"\"\"\n        if session:\n            self._use_filters(session)\n        session = session if session else {}\n\n        # Retrieve SQLite file\n        download_config = self.parse_config.copy()\n        del download_config.configuration\n        downloader = create_strategy(\"download\", download_config)\n        session.update(downloader.initialize(session))\n        cache_key = downloader.get(session).get(\"key\", \"\")\n\n        cache = DataCache(self.parse_config.configuration.datacache_config)\n        with cache.getfile(cache_key, suffix=\"db\") as filename:\n            connection = create_connection(filename)\n            cursor = connection.cursor()\n            result = cursor.execute(self.parse_config.configuration.sqlquery).fetchall()\n            connection.close()\n        return SessionUpdateSqLiteParse(result=result)\n\n    def _use_filters(self, session: \"Dict[str, Any]\") -&gt; None:\n\"\"\"Update `config` according to filter values found in the session.\"\"\"\n        if \"sqlquery\" in session and not self.parse_config.configuration.sqlquery:\n            # Use SQL query available in session\n            self.parse_config.configuration.sqlquery = session[\"sqlquery\"]\n</code></pre>"},{"location":"api_reference/strategies/parse/application_vnd_sqlite/#oteapi.strategies.parse.application_vnd_sqlite.SqliteParseStrategy.parse_config","title":"<code>parse_config: SqliteParserResourceConfig</code>  <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/parse/application_vnd_sqlite/#oteapi.strategies.parse.application_vnd_sqlite.SqliteParseStrategy.get","title":"<code>get(session=None)</code>","text":"<p>Parse SQLite query responses.</p> Source code in <code>oteapi/strategies/parse/application_vnd_sqlite.py</code> <pre><code>def get(\n    self, session: \"Optional[Dict[str, Any]]\" = None\n) -&gt; SessionUpdateSqLiteParse:\n\"\"\"Parse SQLite query responses.\"\"\"\n    if session:\n        self._use_filters(session)\n    session = session if session else {}\n\n    # Retrieve SQLite file\n    download_config = self.parse_config.copy()\n    del download_config.configuration\n    downloader = create_strategy(\"download\", download_config)\n    session.update(downloader.initialize(session))\n    cache_key = downloader.get(session).get(\"key\", \"\")\n\n    cache = DataCache(self.parse_config.configuration.datacache_config)\n    with cache.getfile(cache_key, suffix=\"db\") as filename:\n        connection = create_connection(filename)\n        cursor = connection.cursor()\n        result = cursor.execute(self.parse_config.configuration.sqlquery).fetchall()\n        connection.close()\n    return SessionUpdateSqLiteParse(result=result)\n</code></pre>"},{"location":"api_reference/strategies/parse/application_vnd_sqlite/#oteapi.strategies.parse.application_vnd_sqlite.SqliteParseStrategy.initialize","title":"<code>initialize(session=None)</code>","text":"<p>Initialize strategy.</p> Source code in <code>oteapi/strategies/parse/application_vnd_sqlite.py</code> <pre><code>def initialize(self, session: \"Optional[Dict[str, Any]]\" = None) -&gt; SessionUpdate:\n\"\"\"Initialize strategy.\"\"\"\n    return SessionUpdate()\n</code></pre>"},{"location":"api_reference/strategies/parse/application_vnd_sqlite/#oteapi.strategies.parse.application_vnd_sqlite.SqliteParserResourceConfig","title":"<code>SqliteParserResourceConfig</code>","text":"<p>             Bases: <code>ResourceConfig</code></p> <p>SQLite parse strategy resource config.</p> Source code in <code>oteapi/strategies/parse/application_vnd_sqlite.py</code> <pre><code>class SqliteParserResourceConfig(ResourceConfig):\n\"\"\"SQLite parse strategy resource config.\"\"\"\n\n    mediaType: str = Field(\n        \"application/vnd.sqlite3\",\n        const=True,\n        description=ResourceConfig.__fields__[\"mediaType\"].field_info.description,\n    )\n    configuration: SqliteParseConfig = Field(\n        SqliteParseConfig(), description=\"SQLite parse strategy-specific configuration.\"\n    )\n</code></pre>"},{"location":"api_reference/strategies/parse/application_vnd_sqlite/#oteapi.strategies.parse.application_vnd_sqlite.SqliteParserResourceConfig.configuration","title":"<code>configuration: SqliteParseConfig = Field(SqliteParseConfig(), description='SQLite parse strategy-specific configuration.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/parse/application_vnd_sqlite/#oteapi.strategies.parse.application_vnd_sqlite.SqliteParserResourceConfig.mediaType","title":"<code>mediaType: str = Field('application/vnd.sqlite3', const=True, description=ResourceConfig.__fields__['mediaType'].field_info.description)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/parse/application_vnd_sqlite/#oteapi.strategies.parse.application_vnd_sqlite.create_connection","title":"<code>create_connection(db_file)</code>","text":"<p>Create a database connection to SQLite database.</p> <p>Parameters:</p> Name Type Description Default <code>db_file</code> <code>Path</code> <p>Full path to SQLite database file.</p> required <p>Raises:</p> Type Description <code>Error</code> <p>If a DB connection cannot be made.</p> <p>Returns:</p> Type Description <code>Connection</code> <p>Connection object.</p> Source code in <code>oteapi/strategies/parse/application_vnd_sqlite.py</code> <pre><code>def create_connection(db_file: Path) -&gt; sqlite3.Connection:\n\"\"\"Create a database connection to SQLite database.\n\n    Parameters:\n        db_file: Full path to SQLite database file.\n\n    Raises:\n        sqlite3.Error: If a DB connection cannot be made.\n\n    Returns:\n        Connection object.\n\n    \"\"\"\n    try:\n        return sqlite3.connect(db_file)\n    except sqlite3.Error as exc:\n        raise sqlite3.Error(\"Could not connect to given SQLite DB.\") from exc\n</code></pre>"},{"location":"api_reference/strategies/parse/excel_xlsx/","title":"excel_xlsx","text":"<p>Strategy class for workbook/xlsx.</p>"},{"location":"api_reference/strategies/parse/excel_xlsx/#oteapi.strategies.parse.excel_xlsx.SessionUpdateXLSXParse","title":"<code>SessionUpdateXLSXParse</code>","text":"<p>             Bases: <code>SessionUpdate</code></p> <p>Class for returning values from XLSXParse.</p> Source code in <code>oteapi/strategies/parse/excel_xlsx.py</code> <pre><code>class SessionUpdateXLSXParse(SessionUpdate):\n\"\"\"Class for returning values from XLSXParse.\"\"\"\n\n    data: Dict[str, list] = Field(\n        ...,\n        description=\"A dict with column-name/column-value pairs. The values are lists.\",\n    )\n</code></pre>"},{"location":"api_reference/strategies/parse/excel_xlsx/#oteapi.strategies.parse.excel_xlsx.SessionUpdateXLSXParse.data","title":"<code>data: Dict[str, list] = Field(..., description='A dict with column-name/column-value pairs. The values are lists.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/parse/excel_xlsx/#oteapi.strategies.parse.excel_xlsx.XLSXParseConfig","title":"<code>XLSXParseConfig</code>","text":"<p>             Bases: <code>AttrDict</code></p> <p>Data model for retrieving a rectangular section of an Excel sheet.</p> Source code in <code>oteapi/strategies/parse/excel_xlsx.py</code> <pre><code>class XLSXParseConfig(AttrDict):\n\"\"\"Data model for retrieving a rectangular section of an Excel sheet.\"\"\"\n\n    worksheet: str = Field(..., description=\"Name of worksheet to load.\")\n    row_from: Optional[int] = Field(\n        None,\n        description=\"Excel row number of first row. Defaults to first assigned row.\",\n    )\n    col_from: Optional[Union[int, str]] = Field(\n        None,\n        description=(\n            \"Excel column number or label of first column. Defaults to first assigned \"\n            \"column.\"\n        ),\n    )\n    row_to: Optional[int] = Field(\n        None, description=\"Excel row number of last row. Defaults to last assigned row.\"\n    )\n    col_to: Optional[Union[int, str]] = Field(\n        None,\n        description=(\n            \"Excel column number or label of last column. Defaults to last assigned \"\n            \"column.\"\n        ),\n    )\n    header_row: Optional[int] = Field(\n        None,\n        description=(\n            \"Row number with the headers. Defaults to `1` if header is given, \"\n            \"otherwise `None`.\"\n        ),\n    )\n    header: Optional[List[str]] = Field(\n        None,\n        description=(\n            \"Optional list of column names, specifying the columns to return. \"\n            \"These names they should match cells in `header_row`.\"\n        ),\n    )\n    new_header: Optional[List[str]] = Field(\n        None,\n        description=(\n            \"Optional list of new column names replacing `header` in the output.\"\n        ),\n    )\n    download_config: AttrDict = Field(\n        AttrDict(),\n        description=\"Configurations provided to a download strategy.\",\n    )\n    datacache_config: Optional[DataCacheConfig] = Field(\n        None,\n        description=(\n            \"Configurations for the data cache for retrieving the downloaded file \"\n            \"content.\"\n        ),\n    )\n</code></pre>"},{"location":"api_reference/strategies/parse/excel_xlsx/#oteapi.strategies.parse.excel_xlsx.XLSXParseConfig.col_from","title":"<code>col_from: Optional[Union[int, str]] = Field(None, description='Excel column number or label of first column. Defaults to first assigned column.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/parse/excel_xlsx/#oteapi.strategies.parse.excel_xlsx.XLSXParseConfig.col_to","title":"<code>col_to: Optional[Union[int, str]] = Field(None, description='Excel column number or label of last column. Defaults to last assigned column.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/parse/excel_xlsx/#oteapi.strategies.parse.excel_xlsx.XLSXParseConfig.datacache_config","title":"<code>datacache_config: Optional[DataCacheConfig] = Field(None, description='Configurations for the data cache for retrieving the downloaded file content.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/parse/excel_xlsx/#oteapi.strategies.parse.excel_xlsx.XLSXParseConfig.download_config","title":"<code>download_config: AttrDict = Field(AttrDict(), description='Configurations provided to a download strategy.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/parse/excel_xlsx/#oteapi.strategies.parse.excel_xlsx.XLSXParseConfig.header","title":"<code>header: Optional[List[str]] = Field(None, description='Optional list of column names, specifying the columns to return. These names they should match cells in `header_row`.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/parse/excel_xlsx/#oteapi.strategies.parse.excel_xlsx.XLSXParseConfig.header_row","title":"<code>header_row: Optional[int] = Field(None, description='Row number with the headers. Defaults to `1` if header is given, otherwise `None`.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/parse/excel_xlsx/#oteapi.strategies.parse.excel_xlsx.XLSXParseConfig.new_header","title":"<code>new_header: Optional[List[str]] = Field(None, description='Optional list of new column names replacing `header` in the output.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/parse/excel_xlsx/#oteapi.strategies.parse.excel_xlsx.XLSXParseConfig.row_from","title":"<code>row_from: Optional[int] = Field(None, description='Excel row number of first row. Defaults to first assigned row.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/parse/excel_xlsx/#oteapi.strategies.parse.excel_xlsx.XLSXParseConfig.row_to","title":"<code>row_to: Optional[int] = Field(None, description='Excel row number of last row. Defaults to last assigned row.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/parse/excel_xlsx/#oteapi.strategies.parse.excel_xlsx.XLSXParseConfig.worksheet","title":"<code>worksheet: str = Field(..., description='Name of worksheet to load.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/parse/excel_xlsx/#oteapi.strategies.parse.excel_xlsx.XLSXParseParserConfig","title":"<code>XLSXParseParserConfig</code>","text":"<p>             Bases: <code>ParserConfig</code></p> <p>XLSX parse strategy resource config.</p> Source code in <code>oteapi/strategies/parse/excel_xlsx.py</code> <pre><code>class XLSXParseParserConfig(ParserConfig):\n\"\"\"XLSX parse strategy resource config.\"\"\"\n\n    parserType: str = Field(\n        \"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\",\n        const=True,\n        description=ParserConfig.__fields__[\"parserType\"].field_info.description,\n    )\n    configuration: XLSXParseConfig = Field(\n        ..., description=\"SQLite parse strategy-specific configuration.\"\n    )\n</code></pre>"},{"location":"api_reference/strategies/parse/excel_xlsx/#oteapi.strategies.parse.excel_xlsx.XLSXParseParserConfig.configuration","title":"<code>configuration: XLSXParseConfig = Field(..., description='SQLite parse strategy-specific configuration.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/parse/excel_xlsx/#oteapi.strategies.parse.excel_xlsx.XLSXParseParserConfig.parserType","title":"<code>parserType: str = Field('application/vnd.openxmlformats-officedocument.spreadsheetml.sheet', const=True, description=ParserConfig.__fields__['parserType'].field_info.description)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/parse/excel_xlsx/#oteapi.strategies.parse.excel_xlsx.XLSXParseStrategy","title":"<code>XLSXParseStrategy</code>","text":"<p>Parse strategy for Excel XLSX files.</p> <p>Registers strategies:</p> <ul> <li><code>(\"parserType\", \"excel_xlsx\")</code></li> </ul> Source code in <code>oteapi/strategies/parse/excel_xlsx.py</code> <pre><code>@dataclass\nclass XLSXParseStrategy:\n\"\"\"Parse strategy for Excel XLSX files.\n\n    **Registers strategies**:\n\n    - `(\"parserType\", \"excel_xlsx\")`\n\n    \"\"\"\n\n    parse_config: XLSXParseParserConfig\n\n    def initialize(self, session: \"Optional[Dict[str, Any]]\" = None) -&gt; SessionUpdate:\n\"\"\"Initialize.\"\"\"\n        return SessionUpdate()\n\n    def get(self, session: \"Optional[Dict[str, Any]]\" = None) -&gt; SessionUpdateXLSXParse:\n\"\"\"Parses selected region of an excel file.\n\n        Returns:\n            A dict with column-name/column-value pairs. The values are lists.\n\n        \"\"\"\n\n        cache = DataCache(self.parse_config.configuration.datacache_config)\n        if session is None:\n            raise ValueError(\"Missing session\")\n        with cache.getfile(key=session[\"key\"], suffix=\".xlsx\") as filename:\n            # Note that we have to set read_only=False to ensure that\n            # load_workbook() properly closes the xlsx file after reading.\n            # Otherwise Windows will fail when the temporary file is removed\n            # when leaving the with statement.\n            workbook = load_workbook(filename=filename, read_only=False, data_only=True)\n\n        worksheet = workbook[self.parse_config.configuration.worksheet]\n        set_model_defaults(self.parse_config.configuration, worksheet)\n        columns = get_column_indices(self.parse_config.configuration, worksheet)\n\n        data = []\n        for row in worksheet.iter_rows(\n            min_row=self.parse_config.configuration.row_from,\n            max_row=self.parse_config.configuration.row_to,\n            min_col=min(columns),\n            max_col=max(columns),\n        ):\n            data.append([row[c - 1].value for c in columns])\n\n        if self.parse_config.configuration.header_row:\n            row = worksheet.iter_rows(\n                min_row=self.parse_config.configuration.header_row,\n                max_row=self.parse_config.configuration.header_row,\n                min_col=min(columns),\n                max_col=max(columns),\n            ).__next__()\n            header = [row[c - 1].value for c in columns]\n        else:\n            header = None\n\n        if self.parse_config.configuration.new_header:\n            nhead = len(header) if header else len(data[0]) if data else 0\n            if len(self.parse_config.configuration.new_header) != nhead:\n                raise TypeError(\n                    \"length of `new_header` \"\n                    f\"(={len(self.parse_config.configuration.new_header)}) \"\n                    f\"doesn't match number of columns (={len(header) if header else 0})\"\n                )\n            if header:\n                for i, val in enumerate(self.parse_config.configuration.new_header):\n                    if val is not None:\n                        header[i] = val\n            elif data:\n                header = self.parse_config.configuration.new_header\n\n        if header is None:\n            header = [get_column_letter(col + 1) for col in range(len(data))]\n\n        transposed = [list(datum) for datum in zip(*data)]\n        return SessionUpdateXLSXParse(\n            data={key: value for key, value in zip(header, transposed)}\n        )\n</code></pre>"},{"location":"api_reference/strategies/parse/excel_xlsx/#oteapi.strategies.parse.excel_xlsx.XLSXParseStrategy.parse_config","title":"<code>parse_config: XLSXParseParserConfig</code>  <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/parse/excel_xlsx/#oteapi.strategies.parse.excel_xlsx.XLSXParseStrategy.get","title":"<code>get(session=None)</code>","text":"<p>Parses selected region of an excel file.</p> <p>Returns:</p> Type Description <code>SessionUpdateXLSXParse</code> <p>A dict with column-name/column-value pairs. The values are lists.</p> Source code in <code>oteapi/strategies/parse/excel_xlsx.py</code> <pre><code>def get(self, session: \"Optional[Dict[str, Any]]\" = None) -&gt; SessionUpdateXLSXParse:\n\"\"\"Parses selected region of an excel file.\n\n    Returns:\n        A dict with column-name/column-value pairs. The values are lists.\n\n    \"\"\"\n\n    cache = DataCache(self.parse_config.configuration.datacache_config)\n    if session is None:\n        raise ValueError(\"Missing session\")\n    with cache.getfile(key=session[\"key\"], suffix=\".xlsx\") as filename:\n        # Note that we have to set read_only=False to ensure that\n        # load_workbook() properly closes the xlsx file after reading.\n        # Otherwise Windows will fail when the temporary file is removed\n        # when leaving the with statement.\n        workbook = load_workbook(filename=filename, read_only=False, data_only=True)\n\n    worksheet = workbook[self.parse_config.configuration.worksheet]\n    set_model_defaults(self.parse_config.configuration, worksheet)\n    columns = get_column_indices(self.parse_config.configuration, worksheet)\n\n    data = []\n    for row in worksheet.iter_rows(\n        min_row=self.parse_config.configuration.row_from,\n        max_row=self.parse_config.configuration.row_to,\n        min_col=min(columns),\n        max_col=max(columns),\n    ):\n        data.append([row[c - 1].value for c in columns])\n\n    if self.parse_config.configuration.header_row:\n        row = worksheet.iter_rows(\n            min_row=self.parse_config.configuration.header_row,\n            max_row=self.parse_config.configuration.header_row,\n            min_col=min(columns),\n            max_col=max(columns),\n        ).__next__()\n        header = [row[c - 1].value for c in columns]\n    else:\n        header = None\n\n    if self.parse_config.configuration.new_header:\n        nhead = len(header) if header else len(data[0]) if data else 0\n        if len(self.parse_config.configuration.new_header) != nhead:\n            raise TypeError(\n                \"length of `new_header` \"\n                f\"(={len(self.parse_config.configuration.new_header)}) \"\n                f\"doesn't match number of columns (={len(header) if header else 0})\"\n            )\n        if header:\n            for i, val in enumerate(self.parse_config.configuration.new_header):\n                if val is not None:\n                    header[i] = val\n        elif data:\n            header = self.parse_config.configuration.new_header\n\n    if header is None:\n        header = [get_column_letter(col + 1) for col in range(len(data))]\n\n    transposed = [list(datum) for datum in zip(*data)]\n    return SessionUpdateXLSXParse(\n        data={key: value for key, value in zip(header, transposed)}\n    )\n</code></pre>"},{"location":"api_reference/strategies/parse/excel_xlsx/#oteapi.strategies.parse.excel_xlsx.XLSXParseStrategy.initialize","title":"<code>initialize(session=None)</code>","text":"<p>Initialize.</p> Source code in <code>oteapi/strategies/parse/excel_xlsx.py</code> <pre><code>def initialize(self, session: \"Optional[Dict[str, Any]]\" = None) -&gt; SessionUpdate:\n\"\"\"Initialize.\"\"\"\n    return SessionUpdate()\n</code></pre>"},{"location":"api_reference/strategies/parse/excel_xlsx/#oteapi.strategies.parse.excel_xlsx.get_column_indices","title":"<code>get_column_indices(model, worksheet)</code>","text":"<p>Helper function returning a list of column indices.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>XLSXParseConfig</code> <p>The parsed data model.</p> required <code>worksheet</code> <code>Worksheet</code> <p>Excel worksheet, from which the header values will be retrieved.</p> required <p>Returns:</p> Type Description <code>Iterable[int]</code> <p>A list of column indices.</p> Source code in <code>oteapi/strategies/parse/excel_xlsx.py</code> <pre><code>def get_column_indices(\n    model: XLSXParseConfig, worksheet: \"Worksheet\"\n) -&gt; \"Iterable[int]\":\n\"\"\"Helper function returning a list of column indices.\n\n    Parameters:\n        model: The parsed data model.\n        worksheet: Excel worksheet, from which the header values will be retrieved.\n\n    Returns:\n        A list of column indices.\n\n    \"\"\"\n    if not isinstance(model.col_from, int) or not isinstance(model.col_to, int):\n        raise TypeError(\"Expected `model.col_from` and `model.col_to` to be integers.\")\n\n    if model.header:\n        header_dict = {\n            worksheet.cell(model.header_row, col).value: col\n            for col in range(model.col_from, model.col_to + 1)\n        }\n        return [header_dict[h] for h in model.header]\n    return range(model.col_from, model.col_to + 1)\n</code></pre>"},{"location":"api_reference/strategies/parse/excel_xlsx/#oteapi.strategies.parse.excel_xlsx.set_model_defaults","title":"<code>set_model_defaults(model, worksheet)</code>","text":"<p>Update data model <code>model</code> with default values obtained from <code>worksheet</code>.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>XLSXParseConfig</code> <p>The parsed data model.</p> required <code>worksheet</code> <code>Worksheet</code> <p>Excel worksheet, from which the default values will be obtained.</p> required Source code in <code>oteapi/strategies/parse/excel_xlsx.py</code> <pre><code>def set_model_defaults(model: XLSXParseConfig, worksheet: \"Worksheet\") -&gt; None:\n\"\"\"Update data model `model` with default values obtained from `worksheet`.\n\n    Parameters:\n        model: The parsed data model.\n        worksheet: Excel worksheet, from which the default values will be obtained.\n\n    \"\"\"\n    if model.row_from is None:\n        if model.header:\n            # assume that data starts on the first row after the header\n            model.row_from = model.header_row + 1 if model.header_row else 1\n        else:\n            model.row_from = worksheet.min_row\n\n    if model.row_to is None:\n        model.row_to = worksheet.max_row\n\n    if model.col_from is None:\n        model.col_from = worksheet.min_column\n    elif isinstance(model.col_from, str):\n        model.col_from = column_index_from_string(model.col_from)\n\n    if model.col_to is None:\n        model.col_to = worksheet.max_column\n    elif isinstance(model.col_to, str):\n        model.col_to = column_index_from_string(model.col_to)\n\n    if model.header and not model.header_row:\n        model.header_row = 1\n</code></pre>"},{"location":"api_reference/strategies/parse/image/","title":"image","text":"<p>Strategy class for image/jpg.</p>"},{"location":"api_reference/strategies/parse/image/#oteapi.strategies.parse.image.ImageDataParseStrategy","title":"<code>ImageDataParseStrategy</code>","text":"<p>Parse strategy for images.</p> <p>This strategy uses Pillow to read a raw image from the data cache, converts it into a NumPy array and stores the new array in the data cache.</p> <p>It also supports simple cropping and image conversions.</p> <p>The key to the new array and other metadata is stored in the session. See <code>SessionUpdateImageParse</code> for more info.</p> <p>Registers strategies:</p> <ul> <li><code>(\"mediaType\", \"image/jpg\")</code></li> <li><code>(\"mediaType\", \"image/jpeg\")</code></li> <li><code>(\"mediaType\", \"image/jp2\")</code></li> <li><code>(\"mediaType\", \"image/png\")</code></li> <li><code>(\"mediaType\", \"image/gif\")</code></li> <li><code>(\"mediaType\", \"image/tiff\")</code></li> <li><code>(\"mediaType\", \"image/eps\")</code></li> </ul> Source code in <code>oteapi/strategies/parse/image.py</code> <pre><code>@dataclass\nclass ImageDataParseStrategy:\n\"\"\"Parse strategy for images.\n\n    This strategy uses Pillow to read a raw image from the data cache,\n    converts it into a NumPy array and stores the new array in the\n    data cache.\n\n    It also supports simple cropping and image conversions.\n\n    The key to the new array and other metadata is stored in the session. See\n    [`SessionUpdateImageParse`][oteapi.strategies.parse.image.SessionUpdateImageParse]\n    for more info.\n\n    **Registers strategies**:\n\n    - `(\"mediaType\", \"image/jpg\")`\n    - `(\"mediaType\", \"image/jpeg\")`\n    - `(\"mediaType\", \"image/jp2\")`\n    - `(\"mediaType\", \"image/png\")`\n    - `(\"mediaType\", \"image/gif\")`\n    - `(\"mediaType\", \"image/tiff\")`\n    - `(\"mediaType\", \"image/eps\")`\n\n    \"\"\"\n\n    parse_config: ImageParserResourceConfig\n\n    def initialize(self, session: \"Optional[Dict[str, Any]]\" = None) -&gt; SessionUpdate:\n\"\"\"Initialize strategy.\"\"\"\n        return SessionUpdate()\n\n    def get(\n        self, session: \"Optional[Dict[str, Any]]\" = None\n    ) -&gt; SessionUpdateImageParse:\n\"\"\"Execute the strategy.\"\"\"\n        if not session:\n            session = {}\n\n        config = self.parse_config.configuration\n        crop = config.crop if config.crop else session.get(\"imagecrop\")\n\n        mime_format = self.parse_config.mediaType.split(\"/\")[1]\n        image_format = SupportedFormat[mime_format].value\n\n        # Proper download configurations\n        conf = self.parse_config.dict()\n        conf[\"configuration\"] = config.download_config or {}\n        download_config = ResourceConfig(**conf)\n\n        downloader = create_strategy(\"download\", download_config)\n        session.update(downloader.initialize(session))\n\n        downloader = create_strategy(\"download\", download_config)\n        output = downloader.get(session)\n        session.update(output)\n\n        if config.datacache_config and config.datacache_config.accessKey:\n            cache_key = config.datacache_config.accessKey\n        elif \"key\" in output:\n            cache_key = output[\"key\"]\n        else:\n            raise RuntimeError(\"No data cache key provided to the downloaded content\")\n\n        cache = DataCache(config.datacache_config)\n\n        # Treat image according to filter values\n        with cache.getfile(cache_key, suffix=mime_format) as filename:\n            image = Image.open(filename, formats=[image_format])\n            if crop:\n                image = image.crop(crop)\n            if config.image_mode:\n                image = image.convert(mode=config.image_mode)\n\n            if image_format == \"GIF\":\n                if image.info.get(\"version\", b\"\").startswith(b\"GIF\"):\n                    image.info.update(\n                        {\"version\": image.info.get(\"version\", b\"\")[len(b\"GIF\") :]}\n                    )\n\n            # Use the buffer protocol to store the image in the datacache\n            data = np.asarray(image)\n            image_key = cache.add(\n                data,\n                key=config.image_key,\n                tag=str(id(session)),\n            )\n\n            if image.mode == \"P\":\n                image_palette_key = cache.add(\n                    np.asarray(image.getpalette()), tag=str(id(session))\n                )\n            else:\n                image_palette_key = None\n\n            # The session must be json serialisable - filter out all\n            # non-json serialisable fields in image.info\n            if image.info:\n                image_info = {\n                    key: val\n                    for key, val in image.info.items()\n                    if isinstance(val, (str, int, float, type(None), bool, tuple, list))\n                }\n            else:\n                image_info = {}\n\n            session_update = SessionUpdateImageParse(\n                image_key=image_key,\n                image_size=image.size,\n                image_mode=image.mode,\n                image_palette_key=image_palette_key,\n                image_info=image_info,\n            )\n\n            # Explicitly close the image to avoid crashes on Windows\n            image.close()\n\n        return session_update\n</code></pre>"},{"location":"api_reference/strategies/parse/image/#oteapi.strategies.parse.image.ImageDataParseStrategy.parse_config","title":"<code>parse_config: ImageParserResourceConfig</code>  <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/parse/image/#oteapi.strategies.parse.image.ImageDataParseStrategy.get","title":"<code>get(session=None)</code>","text":"<p>Execute the strategy.</p> Source code in <code>oteapi/strategies/parse/image.py</code> <pre><code>def get(\n    self, session: \"Optional[Dict[str, Any]]\" = None\n) -&gt; SessionUpdateImageParse:\n\"\"\"Execute the strategy.\"\"\"\n    if not session:\n        session = {}\n\n    config = self.parse_config.configuration\n    crop = config.crop if config.crop else session.get(\"imagecrop\")\n\n    mime_format = self.parse_config.mediaType.split(\"/\")[1]\n    image_format = SupportedFormat[mime_format].value\n\n    # Proper download configurations\n    conf = self.parse_config.dict()\n    conf[\"configuration\"] = config.download_config or {}\n    download_config = ResourceConfig(**conf)\n\n    downloader = create_strategy(\"download\", download_config)\n    session.update(downloader.initialize(session))\n\n    downloader = create_strategy(\"download\", download_config)\n    output = downloader.get(session)\n    session.update(output)\n\n    if config.datacache_config and config.datacache_config.accessKey:\n        cache_key = config.datacache_config.accessKey\n    elif \"key\" in output:\n        cache_key = output[\"key\"]\n    else:\n        raise RuntimeError(\"No data cache key provided to the downloaded content\")\n\n    cache = DataCache(config.datacache_config)\n\n    # Treat image according to filter values\n    with cache.getfile(cache_key, suffix=mime_format) as filename:\n        image = Image.open(filename, formats=[image_format])\n        if crop:\n            image = image.crop(crop)\n        if config.image_mode:\n            image = image.convert(mode=config.image_mode)\n\n        if image_format == \"GIF\":\n            if image.info.get(\"version\", b\"\").startswith(b\"GIF\"):\n                image.info.update(\n                    {\"version\": image.info.get(\"version\", b\"\")[len(b\"GIF\") :]}\n                )\n\n        # Use the buffer protocol to store the image in the datacache\n        data = np.asarray(image)\n        image_key = cache.add(\n            data,\n            key=config.image_key,\n            tag=str(id(session)),\n        )\n\n        if image.mode == \"P\":\n            image_palette_key = cache.add(\n                np.asarray(image.getpalette()), tag=str(id(session))\n            )\n        else:\n            image_palette_key = None\n\n        # The session must be json serialisable - filter out all\n        # non-json serialisable fields in image.info\n        if image.info:\n            image_info = {\n                key: val\n                for key, val in image.info.items()\n                if isinstance(val, (str, int, float, type(None), bool, tuple, list))\n            }\n        else:\n            image_info = {}\n\n        session_update = SessionUpdateImageParse(\n            image_key=image_key,\n            image_size=image.size,\n            image_mode=image.mode,\n            image_palette_key=image_palette_key,\n            image_info=image_info,\n        )\n\n        # Explicitly close the image to avoid crashes on Windows\n        image.close()\n\n    return session_update\n</code></pre>"},{"location":"api_reference/strategies/parse/image/#oteapi.strategies.parse.image.ImageDataParseStrategy.initialize","title":"<code>initialize(session=None)</code>","text":"<p>Initialize strategy.</p> Source code in <code>oteapi/strategies/parse/image.py</code> <pre><code>def initialize(self, session: \"Optional[Dict[str, Any]]\" = None) -&gt; SessionUpdate:\n\"\"\"Initialize strategy.\"\"\"\n    return SessionUpdate()\n</code></pre>"},{"location":"api_reference/strategies/parse/image/#oteapi.strategies.parse.image.ImageParserConfig","title":"<code>ImageParserConfig</code>","text":"<p>             Bases: <code>AttrDict</code></p> <p>Configuration data model for <code>ImageDataParseStrategy</code>.</p> Source code in <code>oteapi/strategies/parse/image.py</code> <pre><code>class ImageParserConfig(AttrDict):\n\"\"\"Configuration data model for\n    [`ImageDataParseStrategy`][oteapi.strategies.parse.image.ImageDataParseStrategy].\"\"\"\n\n    crop: Optional[Tuple[int, int, int, int]] = Field(\n        None,\n        description=\"Box cropping parameters (left, top, right, bottom).\",\n    )\n    datacache_config: Optional[DataCacheConfig] = Field(\n        None,\n        description=\"Configuration options for the local data cache.\",\n    )\n    download_config: AttrDict = Field(\n        AttrDict(),\n        description=\"Configurations passed to the downloader.\",\n    )\n    image_key: Optional[str] = Field(\n        None,\n        description=\"Key to use when storing the image data in datacache.\",\n    )\n    image_mode: Optional[str] = Field(\n        None,\n        description=(\n            \"Pillow mode to convert image into. See \"\n            \"https://pillow.readthedocs.io/en/stable/handbook/concepts.html \"\n            \"for details.\"\n        ),\n    )\n</code></pre>"},{"location":"api_reference/strategies/parse/image/#oteapi.strategies.parse.image.ImageParserConfig.crop","title":"<code>crop: Optional[Tuple[int, int, int, int]] = Field(None, description='Box cropping parameters (left, top, right, bottom).')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/parse/image/#oteapi.strategies.parse.image.ImageParserConfig.datacache_config","title":"<code>datacache_config: Optional[DataCacheConfig] = Field(None, description='Configuration options for the local data cache.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/parse/image/#oteapi.strategies.parse.image.ImageParserConfig.download_config","title":"<code>download_config: AttrDict = Field(AttrDict(), description='Configurations passed to the downloader.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/parse/image/#oteapi.strategies.parse.image.ImageParserConfig.image_key","title":"<code>image_key: Optional[str] = Field(None, description='Key to use when storing the image data in datacache.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/parse/image/#oteapi.strategies.parse.image.ImageParserConfig.image_mode","title":"<code>image_mode: Optional[str] = Field(None, description='Pillow mode to convert image into. See https://pillow.readthedocs.io/en/stable/handbook/concepts.html for details.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/parse/image/#oteapi.strategies.parse.image.ImageParserResourceConfig","title":"<code>ImageParserResourceConfig</code>","text":"<p>             Bases: <code>ResourceConfig</code></p> <p>Image parse strategy resource config.</p> Source code in <code>oteapi/strategies/parse/image.py</code> <pre><code>class ImageParserResourceConfig(ResourceConfig):\n\"\"\"Image parse strategy resource config.\"\"\"\n\n    mediaType: Literal[\n        \"image/jpg\",\n        \"image/jpeg\",\n        \"image/jp2\",\n        \"image/png\",\n        \"image/gif\",\n        \"image/tiff\",\n        \"image/eps\",\n    ] = Field(\n        ...,\n        description=ResourceConfig.__fields__[\"mediaType\"].field_info.description,\n    )\n    configuration: ImageParserConfig = Field(\n        ImageParserConfig(),\n        description=\"Image parse strategy-specific configuration.\",\n    )\n</code></pre>"},{"location":"api_reference/strategies/parse/image/#oteapi.strategies.parse.image.ImageParserResourceConfig.configuration","title":"<code>configuration: ImageParserConfig = Field(ImageParserConfig(), description='Image parse strategy-specific configuration.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/parse/image/#oteapi.strategies.parse.image.ImageParserResourceConfig.mediaType","title":"<code>mediaType: Literal['image/jpg', 'image/jpeg', 'image/jp2', 'image/png', 'image/gif', 'image/tiff', 'image/eps'] = Field(..., description=ResourceConfig.__fields__['mediaType'].field_info.description)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/parse/image/#oteapi.strategies.parse.image.SessionUpdateImageParse","title":"<code>SessionUpdateImageParse</code>","text":"<p>             Bases: <code>SessionUpdate</code></p> <p>Configuration model for ImageParse.</p> <p>See Pillow handbook for more details on <code>image_mode</code>, <code>image_palette</code>, and <code>image_info</code>.</p> Source code in <code>oteapi/strategies/parse/image.py</code> <pre><code>class SessionUpdateImageParse(SessionUpdate):\n\"\"\"Configuration model for ImageParse.\n\n    See\n    [Pillow handbook](https://pillow.readthedocs.io/en/stable/handbook/concepts.html)\n    for more details on `image_mode`, `image_palette`, and `image_info`.\n    \"\"\"\n\n    image_key: str = Field(\n        ...,\n        description=\"Key with which the image content is stored in the data cache.\",\n    )\n    image_size: Tuple[int, int] = Field(\n        ...,\n        description=\"Image size (width, height).\",\n    )\n    image_mode: str = Field(\n        ...,\n        description=\"Image mode. Examples: 'L', 'P', 'RGB', 'RGBA'...\",\n    )\n    image_palette_key: Optional[str] = Field(\n        None,\n        description=\"Datacache key for colour palette if mode is 'P'.\",\n    )\n    image_info: dict = Field(\n        {},\n        description=\"Additional information about the image.\",\n    )\n</code></pre>"},{"location":"api_reference/strategies/parse/image/#oteapi.strategies.parse.image.SessionUpdateImageParse.image_info","title":"<code>image_info: dict = Field({}, description='Additional information about the image.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/parse/image/#oteapi.strategies.parse.image.SessionUpdateImageParse.image_key","title":"<code>image_key: str = Field(..., description='Key with which the image content is stored in the data cache.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/parse/image/#oteapi.strategies.parse.image.SessionUpdateImageParse.image_mode","title":"<code>image_mode: str = Field(..., description=\"Image mode. Examples: 'L', 'P', 'RGB', 'RGBA'...\")</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/parse/image/#oteapi.strategies.parse.image.SessionUpdateImageParse.image_palette_key","title":"<code>image_palette_key: Optional[str] = Field(None, description=\"Datacache key for colour palette if mode is 'P'.\")</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/parse/image/#oteapi.strategies.parse.image.SessionUpdateImageParse.image_size","title":"<code>image_size: Tuple[int, int] = Field(..., description='Image size (width, height).')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/parse/image/#oteapi.strategies.parse.image.SupportedFormat","title":"<code>SupportedFormat</code>","text":"<p>             Bases: <code>Enum</code></p> <p>Supported formats for <code>ImageDataParseStrategy</code>.</p> Source code in <code>oteapi/strategies/parse/image.py</code> <pre><code>class SupportedFormat(Enum):\n\"\"\"Supported formats for `ImageDataParseStrategy`.\"\"\"\n\n    jpeg = \"JPEG\"\n    jpg = \"JPEG\"\n    jp2 = \"JPEG2000\"\n    png = \"PNG\"\n    gif = \"GIF\"\n    tiff = \"TIFF\"\n    eps = \"EPS\"\n</code></pre>"},{"location":"api_reference/strategies/parse/image/#oteapi.strategies.parse.image.SupportedFormat.eps","title":"<code>eps = 'EPS'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/parse/image/#oteapi.strategies.parse.image.SupportedFormat.gif","title":"<code>gif = 'GIF'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/parse/image/#oteapi.strategies.parse.image.SupportedFormat.jp2","title":"<code>jp2 = 'JPEG2000'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/parse/image/#oteapi.strategies.parse.image.SupportedFormat.jpeg","title":"<code>jpeg = 'JPEG'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/parse/image/#oteapi.strategies.parse.image.SupportedFormat.jpg","title":"<code>jpg = 'JPEG'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/parse/image/#oteapi.strategies.parse.image.SupportedFormat.png","title":"<code>png = 'PNG'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/parse/image/#oteapi.strategies.parse.image.SupportedFormat.tiff","title":"<code>tiff = 'TIFF'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/parse/postgres/","title":"postgres","text":"<p>Strategy class for application/vnd.postgresql</p>"},{"location":"api_reference/strategies/parse/postgres/#oteapi.strategies.parse.postgres.PostgresConfig","title":"<code>PostgresConfig</code>","text":"<p>             Bases: <code>AttrDict</code></p> <p>Configuration data model for <code>PostgresResourceStrategy</code>.</p> Source code in <code>oteapi/strategies/parse/postgres.py</code> <pre><code>class PostgresConfig(AttrDict):\n\"\"\"Configuration data model for\n    [`PostgresResourceStrategy`][oteapi.strategies.parse.postgres.PostgresResourceConfig].\n    \"\"\"\n\n    user: Optional[str] = Field(None, description=\"postgres server username\")\n    dbname: Optional[str] = Field(None, description=\"postgres dbname name\")\n    password: Optional[str] = Field(None, description=\"postgres password\")\n\n    sqlquery: Optional[str] = Field(\"\", description=\"A SQL query string.\")\n</code></pre>"},{"location":"api_reference/strategies/parse/postgres/#oteapi.strategies.parse.postgres.PostgresConfig.dbname","title":"<code>dbname: Optional[str] = Field(None, description='postgres dbname name')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/parse/postgres/#oteapi.strategies.parse.postgres.PostgresConfig.password","title":"<code>password: Optional[str] = Field(None, description='postgres password')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/parse/postgres/#oteapi.strategies.parse.postgres.PostgresConfig.sqlquery","title":"<code>sqlquery: Optional[str] = Field('', description='A SQL query string.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/parse/postgres/#oteapi.strategies.parse.postgres.PostgresConfig.user","title":"<code>user: Optional[str] = Field(None, description='postgres server username')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/parse/postgres/#oteapi.strategies.parse.postgres.PostgresResourceConfig","title":"<code>PostgresResourceConfig</code>","text":"<p>             Bases: <code>ResourceConfig</code></p> <p>Postgresql parse strategy config</p> Source code in <code>oteapi/strategies/parse/postgres.py</code> <pre><code>class PostgresResourceConfig(ResourceConfig):\n\"\"\"Postgresql parse strategy config\"\"\"\n\n    configuration: PostgresConfig = Field(\n        PostgresConfig(),\n        description=(\n            \"Configuration for resource. \" \"Values in the accessURL take precedence.\"\n        ),\n    )\n    datacache_config: Optional[DataCacheConfig] = Field(\n        None,\n        description=\"Configuration options for the local data cache.\",\n    )\n\n    @classmethod\n    def _urlconstruct(\n        cls,  # PEP8 - Always use cls for the first argument to class methods.\n        scheme: Optional[str] = \"\",  # Schema defining link format\n        user: Optional[str] = None,  # Username\n        password: Optional[str] = None,  # Password\n        host: Optional[str] = None,\n        port: Optional[int] = None,\n        path: Optional[str] = \"\",\n        params: Optional[str] = \"\",\n        query: Optional[str] = \"\",\n        fragment: Optional[str] = \"\",\n    ):\n\"\"\"Construct a pydantic AnyUrl based on the given URL properties\"\"\"\n\n        # Hostname should always be given\n        if not host:\n            raise ValueError(\"hostname must be specified\")\n\n        # Update netloc of username or username|password pair is defined\n        netloc = host\n        if user and not password:  # Only username is provided. OK\n            netloc = f\"{user}@{host}\"\n        elif user and password:  # Username and password is provided. OK\n            netloc = f\"{user}:{password}@{host}\"\n        else:  # Password and no username is provided. ERROR\n            raise ValueError(\"username not provided\")\n\n        # Append port if port is defined\n        netloc = netloc if not port else f\"{netloc}:{port}\"\n\n        # Construct a URL from a tuple of URL-properties\n        unparsed = urlunparse([scheme, netloc, path, params, query, fragment])\n\n        # Populate and return a Pydantic URL\n        return parse_obj_as(AnyUrl, unparsed)\n\n    @root_validator\n    def adjust_url(cls, values):\n\"\"\"Root Validator\n        Verifies configuration consistency, merge configurations\n        and update the accessUrl property.\n        \"\"\"\n\n        # Copy model-state into placeholders\n        config = values.get(\"configuration\")\n        accessUrl = values[\"accessUrl\"]\n\n        # Check and merge user configuration\n        user = accessUrl.user if accessUrl.user else config[\"user\"]\n        if config[\"user\"] and user != config[\"user\"]:\n            raise ValueError(\"mismatching username in accessUrl and configuration\")\n\n        # Check and merge password configuration\n        password = accessUrl.password if accessUrl.password else config[\"password\"]\n        if config[\"password\"] and password != config[\"password\"]:\n            raise ValueError(\"mismatching password in accessUrl and configuration\")\n\n        # Check and merge database name configuration\n        dbname = accessUrl.path if accessUrl.path else config[\"dbname\"]\n        if config[\"dbname\"] and dbname != config[\"dbname\"]:\n            raise ValueError(\"mismatching dbname in accessUrl and configuration\")\n\n        # Reconstruct accessUrl from the updated properties\n        values[\"accessUrl\"] = cls._urlconstruct(\n            scheme=accessUrl.scheme,\n            host=accessUrl.host,\n            port=accessUrl.port,\n            user=user,\n            password=password,\n        )\n        return values\n</code></pre>"},{"location":"api_reference/strategies/parse/postgres/#oteapi.strategies.parse.postgres.PostgresResourceConfig.configuration","title":"<code>configuration: PostgresConfig = Field(PostgresConfig(), description='Configuration for resource. Values in the accessURL take precedence.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/parse/postgres/#oteapi.strategies.parse.postgres.PostgresResourceConfig.datacache_config","title":"<code>datacache_config: Optional[DataCacheConfig] = Field(None, description='Configuration options for the local data cache.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/parse/postgres/#oteapi.strategies.parse.postgres.PostgresResourceConfig.adjust_url","title":"<code>adjust_url(values)</code>","text":"<p>Root Validator Verifies configuration consistency, merge configurations and update the accessUrl property.</p> Source code in <code>oteapi/strategies/parse/postgres.py</code> <pre><code>@root_validator\ndef adjust_url(cls, values):\n\"\"\"Root Validator\n    Verifies configuration consistency, merge configurations\n    and update the accessUrl property.\n    \"\"\"\n\n    # Copy model-state into placeholders\n    config = values.get(\"configuration\")\n    accessUrl = values[\"accessUrl\"]\n\n    # Check and merge user configuration\n    user = accessUrl.user if accessUrl.user else config[\"user\"]\n    if config[\"user\"] and user != config[\"user\"]:\n        raise ValueError(\"mismatching username in accessUrl and configuration\")\n\n    # Check and merge password configuration\n    password = accessUrl.password if accessUrl.password else config[\"password\"]\n    if config[\"password\"] and password != config[\"password\"]:\n        raise ValueError(\"mismatching password in accessUrl and configuration\")\n\n    # Check and merge database name configuration\n    dbname = accessUrl.path if accessUrl.path else config[\"dbname\"]\n    if config[\"dbname\"] and dbname != config[\"dbname\"]:\n        raise ValueError(\"mismatching dbname in accessUrl and configuration\")\n\n    # Reconstruct accessUrl from the updated properties\n    values[\"accessUrl\"] = cls._urlconstruct(\n        scheme=accessUrl.scheme,\n        host=accessUrl.host,\n        port=accessUrl.port,\n        user=user,\n        password=password,\n    )\n    return values\n</code></pre>"},{"location":"api_reference/strategies/parse/postgres/#oteapi.strategies.parse.postgres.PostgresResourceStrategy","title":"<code>PostgresResourceStrategy</code>","text":"<p>Resource strategy for Postgres.</p> <p>Registers strategies:</p> <ul> <li><code>(\"accessService\", \"postgres\")</code></li> </ul> <p>Purpose of this strategy: Connect to a postgres DB and run a SQL query on the dbname to return all relevant rows.</p> Source code in <code>oteapi/strategies/parse/postgres.py</code> <pre><code>@dataclass\nclass PostgresResourceStrategy:\n\"\"\"Resource strategy for Postgres.\n\n    **Registers strategies**:\n\n    - `(\"accessService\", \"postgres\")`\n\n    Purpose of this strategy: Connect to a postgres DB and run a\n    SQL query on the dbname to return all relevant rows.\n\n    \"\"\"\n\n    resource_config: PostgresResourceConfig\n\n    def initialize(self, session: \"Optional[Dict[str, Any]]\" = None) -&gt; SessionUpdate:\n\"\"\"Initialize strategy.\"\"\"\n        return SessionUpdate()\n\n    def get(\n        self, session: \"Optional[Dict[str, Any]]\" = None\n    ) -&gt; SessionUpdatePostgresResource:\n\"\"\"Resource Postgres query responses.\"\"\"\n        if session:\n            self._use_filters(session)\n        session = session if session else {}\n\n        connection = create_connection(self.resource_config)\n        cursor = connection.cursor()\n        result = cursor.execute(self.resource_config.configuration.sqlquery).fetchall()\n        connection.close()\n        return SessionUpdatePostgresResource(result=result)\n\n    def _use_filters(self, session: \"Dict[str, Any]\") -&gt; None:\n\"\"\"Update `config` according to filter values found in the session.\"\"\"\n        if \"sqlquery\" in session and not self.resource_config.configuration.sqlquery:\n            # Use SQL query available in session\n            self.resource_config.configuration.sqlquery = session[\"sqlquery\"]\n</code></pre>"},{"location":"api_reference/strategies/parse/postgres/#oteapi.strategies.parse.postgres.PostgresResourceStrategy.resource_config","title":"<code>resource_config: PostgresResourceConfig</code>  <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/parse/postgres/#oteapi.strategies.parse.postgres.PostgresResourceStrategy.get","title":"<code>get(session=None)</code>","text":"<p>Resource Postgres query responses.</p> Source code in <code>oteapi/strategies/parse/postgres.py</code> <pre><code>def get(\n    self, session: \"Optional[Dict[str, Any]]\" = None\n) -&gt; SessionUpdatePostgresResource:\n\"\"\"Resource Postgres query responses.\"\"\"\n    if session:\n        self._use_filters(session)\n    session = session if session else {}\n\n    connection = create_connection(self.resource_config)\n    cursor = connection.cursor()\n    result = cursor.execute(self.resource_config.configuration.sqlquery).fetchall()\n    connection.close()\n    return SessionUpdatePostgresResource(result=result)\n</code></pre>"},{"location":"api_reference/strategies/parse/postgres/#oteapi.strategies.parse.postgres.PostgresResourceStrategy.initialize","title":"<code>initialize(session=None)</code>","text":"<p>Initialize strategy.</p> Source code in <code>oteapi/strategies/parse/postgres.py</code> <pre><code>def initialize(self, session: \"Optional[Dict[str, Any]]\" = None) -&gt; SessionUpdate:\n\"\"\"Initialize strategy.\"\"\"\n    return SessionUpdate()\n</code></pre>"},{"location":"api_reference/strategies/parse/postgres/#oteapi.strategies.parse.postgres.SessionUpdatePostgresResource","title":"<code>SessionUpdatePostgresResource</code>","text":"<p>             Bases: <code>SessionUpdate</code></p> <p>Configuration model for PostgresResource.</p> Source code in <code>oteapi/strategies/parse/postgres.py</code> <pre><code>class SessionUpdatePostgresResource(SessionUpdate):\n\"\"\"Configuration model for PostgresResource.\"\"\"\n\n    result: list = Field(..., description=\"List of results from the query.\")\n</code></pre>"},{"location":"api_reference/strategies/parse/postgres/#oteapi.strategies.parse.postgres.SessionUpdatePostgresResource.result","title":"<code>result: list = Field(..., description='List of results from the query.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/parse/postgres/#oteapi.strategies.parse.postgres.create_connection","title":"<code>create_connection(resource_config)</code>","text":"<p>Create a dbname connection to Postgres dbname.</p> <p>Parameters:</p> Name Type Description Default <code>resource_config</code> <code>PostgresResourceConfig</code> <p>A dictionary providing everything needed for a psycopg          connection configuration</p> required <p>Raises:</p> Type Description <code>Error</code> <p>If a DB connection cannot be made.</p> <p>Returns:</p> Type Description <code>Connection</code> <p>Connection object.</p> Source code in <code>oteapi/strategies/parse/postgres.py</code> <pre><code>def create_connection(resource_config: PostgresResourceConfig) -&gt; psycopg.Connection:\n\"\"\"Create a dbname connection to Postgres dbname.\n\n    Parameters:\n        resource_config: A dictionary providing everything needed for a psycopg\n                     connection configuration\n\n    Raises:\n        psycopg.Error: If a DB connection cannot be made.\n\n    Returns:\n        Connection object.\n\n    \"\"\"\n    try:\n        return psycopg.connect(resource_config.accessUrl)\n    except psycopg.Error as exc:\n        raise psycopg.Error(\"Could not connect to given Postgres DB.\") from exc\n</code></pre>"},{"location":"api_reference/strategies/parse/text_csv/","title":"text_csv","text":"<p>Strategy class for text/csv.</p>"},{"location":"api_reference/strategies/parse/text_csv/#oteapi.strategies.parse.text_csv.CSVDialect","title":"<code>CSVDialect: Type[Enum] = Enum(value='CSVDialect', names={dialect.upper(): dialectfor dialect in csv.list_dialects()}, module=__name__, type=str)</code>  <code>module-attribute</code>","text":"<p>CSV dialects.</p> <p>All available dialects are retrieved through the <code>csv.list_dialects()</code> function, and will thus depend on the currently loaded and used Python interpreter.</p>"},{"location":"api_reference/strategies/parse/text_csv/#oteapi.strategies.parse.text_csv.CSVConfig","title":"<code>CSVConfig</code>","text":"<p>             Bases: <code>AttrDict</code></p> <p>CSV parse-specific Configuration Data Model.</p> Source code in <code>oteapi/strategies/parse/text_csv.py</code> <pre><code>class CSVConfig(AttrDict):\n\"\"\"CSV parse-specific Configuration Data Model.\"\"\"\n\n    datacache_config: Optional[DataCacheConfig] = Field(\n        None,\n        description=(\n            \"Configurations for the data cache for storing the downloaded file \"\n            \"content.\"\n        ),\n    )\n    dialect: DialectFormatting = Field(\n        DialectFormatting(),\n        description=(\n            \"Dialect and formatting parameters. See [the Python docs]\"\n            \"(https://docs.python.org/3/library/csv.html#csv-fmt-params) for more \"\n            \"information.\"\n        ),\n    )\n    reader: ReaderConfig = Field(\n        ReaderConfig(),\n        description=(\n            \"CSV DictReader configuration parameters. See [the Python docs]\"\n            \"(https://docs.python.org/3/library/csv.html#csv.DictReader) for more \"\n            \"information.\"\n        ),\n    )\n</code></pre>"},{"location":"api_reference/strategies/parse/text_csv/#oteapi.strategies.parse.text_csv.CSVConfig.datacache_config","title":"<code>datacache_config: Optional[DataCacheConfig] = Field(None, description='Configurations for the data cache for storing the downloaded file content.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/parse/text_csv/#oteapi.strategies.parse.text_csv.CSVConfig.dialect","title":"<code>dialect: DialectFormatting = Field(DialectFormatting(), description='Dialect and formatting parameters. See [the Python docs](https://docs.python.org/3/library/csv.html#csv-fmt-params) for more information.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/parse/text_csv/#oteapi.strategies.parse.text_csv.CSVConfig.reader","title":"<code>reader: ReaderConfig = Field(ReaderConfig(), description='CSV DictReader configuration parameters. See [the Python docs](https://docs.python.org/3/library/csv.html#csv.DictReader) for more information.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/parse/text_csv/#oteapi.strategies.parse.text_csv.CSVParseStrategy","title":"<code>CSVParseStrategy</code>","text":"<p>Parse strategy for CSV files.</p> <p>Registers strategies:</p> <ul> <li><code>(\"mediaType\", \"text/csv\")</code></li> </ul> Source code in <code>oteapi/strategies/parse/text_csv.py</code> <pre><code>@dataclass\nclass CSVParseStrategy:\n\"\"\"Parse strategy for CSV files.\n\n    **Registers strategies**:\n\n    - `(\"mediaType\", \"text/csv\")`\n\n    \"\"\"\n\n    parse_config: CSVResourceConfig\n\n    def initialize(self, session: \"Optional[dict[str, Any]]\" = None) -&gt; SessionUpdate:\n\"\"\"Initialize.\"\"\"\n        return SessionUpdate()\n\n    def get(self, session: \"Optional[dict[str, Any]]\" = None) -&gt; SessionUpdateCSVParse:\n\"\"\"Parse CSV.\"\"\"\n        downloader = create_strategy(\"download\", self.parse_config)\n        output = downloader.get()\n        cache = DataCache(self.parse_config.configuration.datacache_config)\n\n        with cache.getfile(output[\"key\"]) as csvfile_path:\n            kwargs = self.parse_config.configuration.dialect.dict(\n                exclude={\"base\", \"quoting\"}, exclude_unset=True\n            )\n\n            dialect = self.parse_config.configuration.dialect.base\n            if dialect:\n                kwargs[\"dialect\"] = dialect.value\n            quoting = self.parse_config.configuration.dialect.quoting\n            if quoting:\n                kwargs[\"quoting\"] = quoting.csv_constant()\n\n            kwargs.update(\n                self.parse_config.configuration.reader.dict(exclude_unset=True)\n            )\n\n            with open(\n                csvfile_path,\n                newline=\"\",\n                encoding=self.parse_config.configuration.reader.encoding,\n            ) as csvfile:\n                csvreader = csv.DictReader(csvfile, **kwargs)\n                content: dict[Union[str, None], list[Any]] = defaultdict(list)\n                for row in csvreader:\n                    for field, value in row.items():\n                        if (\n                            csvreader.reader.dialect.quoting == csv.QUOTE_NONNUMERIC\n                            and isinstance(value, float)\n                            and value.is_integer()\n                        ):\n                            value = int(value)\n                        content[field].append(value)\n            for key in list(content):\n                if any(isinstance(value, float) for value in content[key]):\n                    content[key] = [\n                        float(value)\n                        if (value or value == 0.0 or value == 0)\n                        and value != csvreader.restval\n                        else float(\"nan\")\n                        for value in content[key]\n                    ]\n                    continue\n                if any(isinstance(value, int) for value in content[key]):\n                    content[key] = [\n                        int(value)\n                        if (value or value == 0) and value != csvreader.restval\n                        else csvreader.restval\n                        for value in content[key]\n                    ]\n\n            return SessionUpdateCSVParse(content=content)\n</code></pre>"},{"location":"api_reference/strategies/parse/text_csv/#oteapi.strategies.parse.text_csv.CSVParseStrategy.parse_config","title":"<code>parse_config: CSVResourceConfig</code>  <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/parse/text_csv/#oteapi.strategies.parse.text_csv.CSVParseStrategy.get","title":"<code>get(session=None)</code>","text":"<p>Parse CSV.</p> Source code in <code>oteapi/strategies/parse/text_csv.py</code> <pre><code>def get(self, session: \"Optional[dict[str, Any]]\" = None) -&gt; SessionUpdateCSVParse:\n\"\"\"Parse CSV.\"\"\"\n    downloader = create_strategy(\"download\", self.parse_config)\n    output = downloader.get()\n    cache = DataCache(self.parse_config.configuration.datacache_config)\n\n    with cache.getfile(output[\"key\"]) as csvfile_path:\n        kwargs = self.parse_config.configuration.dialect.dict(\n            exclude={\"base\", \"quoting\"}, exclude_unset=True\n        )\n\n        dialect = self.parse_config.configuration.dialect.base\n        if dialect:\n            kwargs[\"dialect\"] = dialect.value\n        quoting = self.parse_config.configuration.dialect.quoting\n        if quoting:\n            kwargs[\"quoting\"] = quoting.csv_constant()\n\n        kwargs.update(\n            self.parse_config.configuration.reader.dict(exclude_unset=True)\n        )\n\n        with open(\n            csvfile_path,\n            newline=\"\",\n            encoding=self.parse_config.configuration.reader.encoding,\n        ) as csvfile:\n            csvreader = csv.DictReader(csvfile, **kwargs)\n            content: dict[Union[str, None], list[Any]] = defaultdict(list)\n            for row in csvreader:\n                for field, value in row.items():\n                    if (\n                        csvreader.reader.dialect.quoting == csv.QUOTE_NONNUMERIC\n                        and isinstance(value, float)\n                        and value.is_integer()\n                    ):\n                        value = int(value)\n                    content[field].append(value)\n        for key in list(content):\n            if any(isinstance(value, float) for value in content[key]):\n                content[key] = [\n                    float(value)\n                    if (value or value == 0.0 or value == 0)\n                    and value != csvreader.restval\n                    else float(\"nan\")\n                    for value in content[key]\n                ]\n                continue\n            if any(isinstance(value, int) for value in content[key]):\n                content[key] = [\n                    int(value)\n                    if (value or value == 0) and value != csvreader.restval\n                    else csvreader.restval\n                    for value in content[key]\n                ]\n\n        return SessionUpdateCSVParse(content=content)\n</code></pre>"},{"location":"api_reference/strategies/parse/text_csv/#oteapi.strategies.parse.text_csv.CSVParseStrategy.initialize","title":"<code>initialize(session=None)</code>","text":"<p>Initialize.</p> Source code in <code>oteapi/strategies/parse/text_csv.py</code> <pre><code>def initialize(self, session: \"Optional[dict[str, Any]]\" = None) -&gt; SessionUpdate:\n\"\"\"Initialize.\"\"\"\n    return SessionUpdate()\n</code></pre>"},{"location":"api_reference/strategies/parse/text_csv/#oteapi.strategies.parse.text_csv.CSVResourceConfig","title":"<code>CSVResourceConfig</code>","text":"<p>             Bases: <code>ResourceConfig</code></p> <p>CSV parse strategy filter config.</p> Source code in <code>oteapi/strategies/parse/text_csv.py</code> <pre><code>class CSVResourceConfig(ResourceConfig):\n\"\"\"CSV parse strategy filter config.\"\"\"\n\n    mediaType: str = Field(\n        \"text/csv\",\n        const=True,\n        description=ResourceConfig.__fields__[\"mediaType\"].field_info.description,\n    )\n    configuration: CSVConfig = Field(\n        CSVConfig(), description=\"CSV parse strategy-specific configuration.\"\n    )\n</code></pre>"},{"location":"api_reference/strategies/parse/text_csv/#oteapi.strategies.parse.text_csv.CSVResourceConfig.configuration","title":"<code>configuration: CSVConfig = Field(CSVConfig(), description='CSV parse strategy-specific configuration.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/parse/text_csv/#oteapi.strategies.parse.text_csv.CSVResourceConfig.mediaType","title":"<code>mediaType: str = Field('text/csv', const=True, description=ResourceConfig.__fields__['mediaType'].field_info.description)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/parse/text_csv/#oteapi.strategies.parse.text_csv.DialectFormatting","title":"<code>DialectFormatting</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>Dialect and formatting parameters for CSV.</p> <p>See the Python docs for more information.</p> Note <p>As <code>Dialect.lineterminator</code> is hardcoded in <code>csv.reader</code>, it is left out of this model.</p> Source code in <code>oteapi/strategies/parse/text_csv.py</code> <pre><code>class DialectFormatting(BaseModel):\n\"\"\"Dialect and formatting parameters for CSV.\n\n    See [the Python docs](https://docs.python.org/3/library/csv.html#csv-fmt-params)\n    for more information.\n\n    Note:\n        As `Dialect.lineterminator` is hardcoded in `csv.reader`, it is left out of\n        this model.\n\n    \"\"\"\n\n    base: Optional[CSVDialect] = Field(\n        None,\n        description=(\n            \"A specific CSV dialect, e.g., 'excel'. Any other parameters here will \"\n            \"overwrite the preset dialect parameters for the specified dialect.\"\n        ),\n    )\n    delimiter: Optional[str] = Field(\n        None,\n        description=(\n            \"A one-character string used to separate fields. \"\n            \"See [the Python docs entry](https://docs.python.org/3/library/csv.html\"\n            \"#csv.Dialect.delimiter) for more information.\"\n        ),\n        min_length=1,\n        max_length=1,\n    )\n    doublequote: Optional[bool] = Field(\n        None,\n        description=(\n            \"Controls how instances of [`quotechar`]\"\n            \"[oteapi.strategies.parse.text_csv.DialectFormatting.quotechar] \"\n            \"appearing inside a field should themselves be quoted. When `True`, the \"\n            \"character is doubled. When `False`, the [`escapechar`]\"\n            \"[oteapi.strategies.parse.text_csv.DialectFormatting.escapechar] \"\n            \"is used as a prefix to the [`quotechar`]\"\n            \"[oteapi.strategies.parse.text_csv.DialectFormatting.quotechar]. \"\n            \"See [the Python docs entry]\"\n            \"(https://docs.python.org/3/library/csv.html#csv.Dialect.doublequote) \"\n            \"for more information.\"\n        ),\n    )\n    escapechar: Optional[str] = Field(\n        None,\n        description=(\n            \"A one-character string used by the writer to escape the [`delimiter`]\"\n            \"[oteapi.strategies.parse.text_csv.DialectFormatting.delimiter] if \"\n            \"[`quoting`][oteapi.strategies.parse.text_csv.DialectFormatting.quoting] \"\n            \"is set to [`QUOTE_NONE`]\"\n            \"[oteapi.strategies.parse.text_csv.QuoteConstants.QUOTE_NONE] and the \"\n            \"[`quotechar`][oteapi.strategies.parse.text_csv.DialectFormatting.\"\n            \"quotechar] if [`doublequote`][oteapi.strategies.parse.text_csv.\"\n            \"DialectFormatting.doublequote] is `False`. On reading, the \"\n            \"[`escapechar`][oteapi.strategies.parse.text_csv.DialectFormatting.\"\n            \"escapechar] removes any special meaning from the following character. \"\n            \"See [the Python docs entry]\"\n            \"(https://docs.python.org/3/library/csv.html#csv.Dialect.escapechar) \"\n            \"for more information.\"\n        ),\n        min_length=1,\n        max_length=1,\n    )\n    quotechar: Optional[str] = Field(\n        None,\n        description=(\n            \"A one-character string used to quote fields containing special \"\n            \"characters, such as the [`delimiter`]\"\n            \"[oteapi.strategies.parse.text_csv.DialectFormatting.delimiter] or \"\n            \"[`quotechar`][oteapi.strategies.parse.text_csv.DialectFormatting.\"\n            \"quotechar], or which contain new-line characters. See \"\n            \"[the Python docs entry](https://docs.python.org/3/library/csv.html\"\n            \"#csv.Dialect.quotechar) for more information.\"\n        ),\n        min_length=1,\n        max_length=1,\n    )\n    quoting: Optional[QuoteConstants] = Field(\n        None,\n        description=(\n            \"Controls when quotes should be generated by the writer and recognised by \"\n            \"the reader. It can take on any of the `QUOTE_*` constants (see section \"\n            \"[Module Contents](https://docs.python.org/3/library/csv.html\"\n            \"#csv-contents)). See [the Python docs entry]\"\n            \"(https://docs.python.org/3/library/csv.html#csv.Dialect.quoting) \"\n            \"for more information.\"\n        ),\n    )\n    skipinitialspace: Optional[bool] = Field(\n        None,\n        description=(\n            \"When `True`, whitespace immediately following the [`delimiter`]\"\n            \"[oteapi.strategies.parse.text_csv.DialectFormatting.delimiter] is \"\n            \"ignored. See [the Python docs entry]\"\n            \"(https://docs.python.org/3/library/csv.html#csv.Dialect.skipinitialspace)\"\n            \" for more information.\"\n        ),\n    )\n    strict: Optional[bool] = Field(\n        None,\n        description=(\n            \"When `True`, raise exception [Error]\"\n            \"(https://docs.python.org/3/library/csv.html#csv.Error) on bad CSV input. \"\n            \"See [the Python docs entry](https://docs.python.org/3/library/csv.html\"\n            \"#csv.Dialect.strict) for more information.\"\n        ),\n    )\n\n    @validator(\"base\")\n    def validate_dialect_base(cls, value: str) -&gt; str:\n\"\"\"Ensure the given `base` dialect is registered locally.\"\"\"\n        if value not in csv.list_dialects():\n            raise ValueError(\n                f\"{value!r} is not a known registered CSV dialect. \"\n                f\"Registered dialects: {', '.join(csv.list_dialects())}.\"\n            )\n        return value\n</code></pre>"},{"location":"api_reference/strategies/parse/text_csv/#oteapi.strategies.parse.text_csv.DialectFormatting.base","title":"<code>base: Optional[CSVDialect] = Field(None, description=\"A specific CSV dialect, e.g., 'excel'. Any other parameters here will overwrite the preset dialect parameters for the specified dialect.\")</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/parse/text_csv/#oteapi.strategies.parse.text_csv.DialectFormatting.delimiter","title":"<code>delimiter: Optional[str] = Field(None, description='A one-character string used to separate fields. See [the Python docs entry](https://docs.python.org/3/library/csv.html#csv.Dialect.delimiter) for more information.', min_length=1, max_length=1)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/parse/text_csv/#oteapi.strategies.parse.text_csv.DialectFormatting.doublequote","title":"<code>doublequote: Optional[bool] = Field(None, description='Controls how instances of [`quotechar`][oteapi.strategies.parse.text_csv.DialectFormatting.quotechar] appearing inside a field should themselves be quoted. When `True`, the character is doubled. When `False`, the [`escapechar`][oteapi.strategies.parse.text_csv.DialectFormatting.escapechar] is used as a prefix to the [`quotechar`][oteapi.strategies.parse.text_csv.DialectFormatting.quotechar]. See [the Python docs entry](https://docs.python.org/3/library/csv.html#csv.Dialect.doublequote) for more information.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/parse/text_csv/#oteapi.strategies.parse.text_csv.DialectFormatting.escapechar","title":"<code>escapechar: Optional[str] = Field(None, description='A one-character string used by the writer to escape the [`delimiter`][oteapi.strategies.parse.text_csv.DialectFormatting.delimiter] if [`quoting`][oteapi.strategies.parse.text_csv.DialectFormatting.quoting] is set to [`QUOTE_NONE`][oteapi.strategies.parse.text_csv.QuoteConstants.QUOTE_NONE] and the [`quotechar`][oteapi.strategies.parse.text_csv.DialectFormatting.quotechar] if [`doublequote`][oteapi.strategies.parse.text_csv.DialectFormatting.doublequote] is `False`. On reading, the [`escapechar`][oteapi.strategies.parse.text_csv.DialectFormatting.escapechar] removes any special meaning from the following character. See [the Python docs entry](https://docs.python.org/3/library/csv.html#csv.Dialect.escapechar) for more information.', min_length=1, max_length=1)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/parse/text_csv/#oteapi.strategies.parse.text_csv.DialectFormatting.quotechar","title":"<code>quotechar: Optional[str] = Field(None, description='A one-character string used to quote fields containing special characters, such as the [`delimiter`][oteapi.strategies.parse.text_csv.DialectFormatting.delimiter] or [`quotechar`][oteapi.strategies.parse.text_csv.DialectFormatting.quotechar], or which contain new-line characters. See [the Python docs entry](https://docs.python.org/3/library/csv.html#csv.Dialect.quotechar) for more information.', min_length=1, max_length=1)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/parse/text_csv/#oteapi.strategies.parse.text_csv.DialectFormatting.quoting","title":"<code>quoting: Optional[QuoteConstants] = Field(None, description='Controls when quotes should be generated by the writer and recognised by the reader. It can take on any of the `QUOTE_*` constants (see section [Module Contents](https://docs.python.org/3/library/csv.html#csv-contents)). See [the Python docs entry](https://docs.python.org/3/library/csv.html#csv.Dialect.quoting) for more information.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/parse/text_csv/#oteapi.strategies.parse.text_csv.DialectFormatting.skipinitialspace","title":"<code>skipinitialspace: Optional[bool] = Field(None, description='When `True`, whitespace immediately following the [`delimiter`][oteapi.strategies.parse.text_csv.DialectFormatting.delimiter] is ignored. See [the Python docs entry](https://docs.python.org/3/library/csv.html#csv.Dialect.skipinitialspace) for more information.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/parse/text_csv/#oteapi.strategies.parse.text_csv.DialectFormatting.strict","title":"<code>strict: Optional[bool] = Field(None, description='When `True`, raise exception [Error](https://docs.python.org/3/library/csv.html#csv.Error) on bad CSV input. See [the Python docs entry](https://docs.python.org/3/library/csv.html#csv.Dialect.strict) for more information.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/parse/text_csv/#oteapi.strategies.parse.text_csv.DialectFormatting.validate_dialect_base","title":"<code>validate_dialect_base(value)</code>","text":"<p>Ensure the given <code>base</code> dialect is registered locally.</p> Source code in <code>oteapi/strategies/parse/text_csv.py</code> <pre><code>@validator(\"base\")\ndef validate_dialect_base(cls, value: str) -&gt; str:\n\"\"\"Ensure the given `base` dialect is registered locally.\"\"\"\n    if value not in csv.list_dialects():\n        raise ValueError(\n            f\"{value!r} is not a known registered CSV dialect. \"\n            f\"Registered dialects: {', '.join(csv.list_dialects())}.\"\n        )\n    return value\n</code></pre>"},{"location":"api_reference/strategies/parse/text_csv/#oteapi.strategies.parse.text_csv.QuoteConstants","title":"<code>QuoteConstants</code>","text":"<p>             Bases: <code>str</code>, <code>Enum</code></p> <p>CSV module <code>QUOTE_*</code> constants.</p> Source code in <code>oteapi/strategies/parse/text_csv.py</code> <pre><code>class QuoteConstants(str, Enum):\n\"\"\"CSV module `QUOTE_*` constants.\"\"\"\n\n    QUOTE_ALL = \"QUOTE_ALL\"\n    QUOTE_MINIMAL = \"QUOTE_MINIMAL\"\n    QUOTE_NONUMERIC = \"QUOTE_NONNUMERIC\"\n    QUOTE_NONE = \"QUOTE_NONE\"\n\n    def csv_constant(self) -&gt; int:\n\"\"\"Return the CSV lib equivalent constant.\"\"\"\n        return {\n            self.QUOTE_ALL: csv.QUOTE_ALL,\n            self.QUOTE_MINIMAL: csv.QUOTE_MINIMAL,\n            self.QUOTE_NONUMERIC: csv.QUOTE_NONNUMERIC,\n            self.QUOTE_NONE: csv.QUOTE_NONE,\n        }[self]\n</code></pre>"},{"location":"api_reference/strategies/parse/text_csv/#oteapi.strategies.parse.text_csv.QuoteConstants.QUOTE_ALL","title":"<code>QUOTE_ALL = 'QUOTE_ALL'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/parse/text_csv/#oteapi.strategies.parse.text_csv.QuoteConstants.QUOTE_MINIMAL","title":"<code>QUOTE_MINIMAL = 'QUOTE_MINIMAL'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/parse/text_csv/#oteapi.strategies.parse.text_csv.QuoteConstants.QUOTE_NONE","title":"<code>QUOTE_NONE = 'QUOTE_NONE'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/parse/text_csv/#oteapi.strategies.parse.text_csv.QuoteConstants.QUOTE_NONUMERIC","title":"<code>QUOTE_NONUMERIC = 'QUOTE_NONNUMERIC'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/parse/text_csv/#oteapi.strategies.parse.text_csv.QuoteConstants.csv_constant","title":"<code>csv_constant()</code>","text":"<p>Return the CSV lib equivalent constant.</p> Source code in <code>oteapi/strategies/parse/text_csv.py</code> <pre><code>def csv_constant(self) -&gt; int:\n\"\"\"Return the CSV lib equivalent constant.\"\"\"\n    return {\n        self.QUOTE_ALL: csv.QUOTE_ALL,\n        self.QUOTE_MINIMAL: csv.QUOTE_MINIMAL,\n        self.QUOTE_NONUMERIC: csv.QUOTE_NONNUMERIC,\n        self.QUOTE_NONE: csv.QUOTE_NONE,\n    }[self]\n</code></pre>"},{"location":"api_reference/strategies/parse/text_csv/#oteapi.strategies.parse.text_csv.ReaderConfig","title":"<code>ReaderConfig</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>CSV DictReader configuration parameters.</p> <p>See the Python docs for more information.</p> Source code in <code>oteapi/strategies/parse/text_csv.py</code> <pre><code>class ReaderConfig(BaseModel):\n\"\"\"CSV DictReader configuration parameters.\n\n    See [the Python docs](https://docs.python.org/3/library/csv.html#csv.DictReader)\n    for more information.\n    \"\"\"\n\n    fieldnames: Optional[list[str]] = Field(\n        None,\n        description=(\n            \"List of headers. If not set, the values in the first row of the CSV file \"\n            \"will be used as the field names.\"\n        ),\n    )\n    restkey: Optional[Hashable] = Field(\n        None,\n        description=(\n            \"If a row has more fields than [`fieldnames`]\"\n            \"[oteapi.strategies.parse.text_csv.ReaderConfig.fieldnames], the \"\n            \"remaining data is put in a list and stored with the field name specified \"\n            \"by [`restkey`][oteapi.strategies.parse.text_csv.ReaderConfig.restkey].\"\n        ),\n    )\n    restval: Optional[Any] = Field(\n        None,\n        description=(\n            \"If a non-blank row has fewer fields than the length of [`fieldnames`]\"\n            \"[oteapi.strategies.parse.text_csv.ReaderConfig.fieldnames], the missing \"\n            \"values are filled-in with the value of [`restval`]\"\n            \"[oteapi.strategies.parse.text_csv.ReaderConfig.restval].\"\n        ),\n    )\n    encoding: str = Field(\n        \"utf8\",\n        description=\"The file encoding.\",\n    )\n</code></pre>"},{"location":"api_reference/strategies/parse/text_csv/#oteapi.strategies.parse.text_csv.ReaderConfig.encoding","title":"<code>encoding: str = Field('utf8', description='The file encoding.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/parse/text_csv/#oteapi.strategies.parse.text_csv.ReaderConfig.fieldnames","title":"<code>fieldnames: Optional[list[str]] = Field(None, description='List of headers. If not set, the values in the first row of the CSV file will be used as the field names.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/parse/text_csv/#oteapi.strategies.parse.text_csv.ReaderConfig.restkey","title":"<code>restkey: Optional[Hashable] = Field(None, description='If a row has more fields than [`fieldnames`][oteapi.strategies.parse.text_csv.ReaderConfig.fieldnames], the remaining data is put in a list and stored with the field name specified by [`restkey`][oteapi.strategies.parse.text_csv.ReaderConfig.restkey].')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/parse/text_csv/#oteapi.strategies.parse.text_csv.ReaderConfig.restval","title":"<code>restval: Optional[Any] = Field(None, description='If a non-blank row has fewer fields than the length of [`fieldnames`][oteapi.strategies.parse.text_csv.ReaderConfig.fieldnames], the missing values are filled-in with the value of [`restval`][oteapi.strategies.parse.text_csv.ReaderConfig.restval].')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/parse/text_csv/#oteapi.strategies.parse.text_csv.SessionUpdateCSVParse","title":"<code>SessionUpdateCSVParse</code>","text":"<p>             Bases: <code>SessionUpdate</code></p> <p>Class for returning values from CSV Parse.</p> Source code in <code>oteapi/strategies/parse/text_csv.py</code> <pre><code>class SessionUpdateCSVParse(SessionUpdate):\n\"\"\"Class for returning values from CSV Parse.\"\"\"\n\n    content: dict[Union[str, None], list[Any]] = Field(\n        ..., description=\"Content of the CSV document.\"\n    )\n</code></pre>"},{"location":"api_reference/strategies/parse/text_csv/#oteapi.strategies.parse.text_csv.SessionUpdateCSVParse.content","title":"<code>content: dict[Union[str, None], list[Any]] = Field(..., description='Content of the CSV document.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/transformation/celery_remote/","title":"celery_remote","text":"<p>Transformation Plugin that uses the Celery framework to call remote workers.</p>"},{"location":"api_reference/strategies/transformation/celery_remote/#oteapi.strategies.transformation.celery_remote.CELERY_APP","title":"<code>CELERY_APP = Celery(broker=f'redis://{REDIS_HOST}:{REDIS_PORT}', backend=f'redis://{REDIS_HOST}:{REDIS_PORT}')</code>  <code>module-attribute</code>","text":""},{"location":"api_reference/strategies/transformation/celery_remote/#oteapi.strategies.transformation.celery_remote.REDIS_HOST","title":"<code>REDIS_HOST = os.getenv('OTEAPI_REDIS_HOST', 'redis')</code>  <code>module-attribute</code>","text":""},{"location":"api_reference/strategies/transformation/celery_remote/#oteapi.strategies.transformation.celery_remote.REDIS_PORT","title":"<code>REDIS_PORT = int(os.getenv('OTEAPI_REDIS_PORT', '6379'))</code>  <code>module-attribute</code>","text":""},{"location":"api_reference/strategies/transformation/celery_remote/#oteapi.strategies.transformation.celery_remote.CeleryConfig","title":"<code>CeleryConfig</code>","text":"<p>             Bases: <code>AttrDict</code></p> <p>Celery configuration.</p> <p>All fields here (including those added from the session through the <code>get()</code> method, as well as those added \"anonymously\") will be used as keyword arguments to the <code>send_task()</code> method for the Celery App.</p> Note <p>Using <code>alias</code> for the <code>name</code> field to favor populating it with <code>task_name</code> arguments, since this is the \"original\" field name. I.e., this is done for backwards compatibility.</p> <p>Setting <code>allow_population_by_field_name=True</code> as pydantic model configuration in order to allow populating it using <code>name</code> as well as <code>task_name</code>.</p> Source code in <code>oteapi/strategies/transformation/celery_remote.py</code> <pre><code>class CeleryConfig(AttrDict, allow_population_by_field_name=True):\n\"\"\"Celery configuration.\n\n    All fields here (including those added from the session through the `get()` method,\n    as well as those added \"anonymously\") will be used as keyword arguments to the\n    `send_task()` method for the Celery App.\n\n    Note:\n        Using `alias` for the `name` field to favor populating it with `task_name`\n        arguments, since this is the \"original\" field name. I.e., this is done for\n        backwards compatibility.\n\n    Setting `allow_population_by_field_name=True` as pydantic model configuration in\n    order to allow populating it using `name` as well as `task_name`.\n\n    \"\"\"\n\n    name: str = Field(..., description=\"A task name.\", alias=\"task_name\")\n    args: list = Field(..., description=\"List of arguments for the task.\")\n</code></pre>"},{"location":"api_reference/strategies/transformation/celery_remote/#oteapi.strategies.transformation.celery_remote.CeleryConfig.args","title":"<code>args: list = Field(..., description='List of arguments for the task.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/transformation/celery_remote/#oteapi.strategies.transformation.celery_remote.CeleryConfig.name","title":"<code>name: str = Field(..., description='A task name.', alias='task_name')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/transformation/celery_remote/#oteapi.strategies.transformation.celery_remote.CeleryRemoteStrategy","title":"<code>CeleryRemoteStrategy</code>","text":"<p>Submit job to remote Celery runner.</p> <p>Registers strategies:</p> <ul> <li><code>(\"transformationType\", \"celery/remote\")</code></li> </ul> Source code in <code>oteapi/strategies/transformation/celery_remote.py</code> <pre><code>@dataclass\nclass CeleryRemoteStrategy:\n\"\"\"Submit job to remote Celery runner.\n\n    **Registers strategies**:\n\n    - `(\"transformationType\", \"celery/remote\")`\n\n    \"\"\"\n\n    transformation_config: CeleryStrategyConfig\n\n    def get(self, session: \"Optional[Dict[str, Any]]\" = None) -&gt; SessionUpdateCelery:\n\"\"\"Run a job, return a job ID.\"\"\"\n        if session:\n            self._use_session(session)\n\n        result: \"Union[AsyncResult, Any]\" = CELERY_APP.send_task(\n            **self.transformation_config.configuration\n        )\n        return SessionUpdateCelery(celery_task_id=result.task_id)\n\n    def initialize(self, session: \"Optional[Dict[str, Any]]\" = None) -&gt; SessionUpdate:\n\"\"\"Initialize a job.\"\"\"\n        return SessionUpdate()\n\n    def status(self, task_id: str) -&gt; TransformationStatus:\n\"\"\"Get job status.\"\"\"\n        result = AsyncResult(id=task_id, app=CELERY_APP)\n        return TransformationStatus(id=task_id, status=result.state)\n\n    def _use_session(self, session: \"Dict[str, Any]\") -&gt; None:\n\"\"\"Update the configuration with values from the sesssion.\n\n        Check all fields (non-aliased and aliased) in `CeleryConfig` if they exist in\n        the session. Override the given field values in the current strategy-specific\n        configuration (the `CeleryConfig` instance) with the values found in the\n        session.\n\n        Parameters:\n            session: The current OTE session.\n\n        \"\"\"\n        alias_mapping: dict[str, str] = {\n            field.alias: field_name\n            for field_name, field in CeleryConfig.__fields__.items()\n        }\n\n        fields = set(CeleryConfig.__fields__)\n        fields |= {_.alias for _ in CeleryConfig.__fields__.values()}\n\n        for field in fields:\n            if field in session:\n                setattr(\n                    self.transformation_config.configuration,\n                    alias_mapping[field],\n                    session[field],\n                )\n</code></pre>"},{"location":"api_reference/strategies/transformation/celery_remote/#oteapi.strategies.transformation.celery_remote.CeleryRemoteStrategy.transformation_config","title":"<code>transformation_config: CeleryStrategyConfig</code>  <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/transformation/celery_remote/#oteapi.strategies.transformation.celery_remote.CeleryRemoteStrategy.get","title":"<code>get(session=None)</code>","text":"<p>Run a job, return a job ID.</p> Source code in <code>oteapi/strategies/transformation/celery_remote.py</code> <pre><code>def get(self, session: \"Optional[Dict[str, Any]]\" = None) -&gt; SessionUpdateCelery:\n\"\"\"Run a job, return a job ID.\"\"\"\n    if session:\n        self._use_session(session)\n\n    result: \"Union[AsyncResult, Any]\" = CELERY_APP.send_task(\n        **self.transformation_config.configuration\n    )\n    return SessionUpdateCelery(celery_task_id=result.task_id)\n</code></pre>"},{"location":"api_reference/strategies/transformation/celery_remote/#oteapi.strategies.transformation.celery_remote.CeleryRemoteStrategy.initialize","title":"<code>initialize(session=None)</code>","text":"<p>Initialize a job.</p> Source code in <code>oteapi/strategies/transformation/celery_remote.py</code> <pre><code>def initialize(self, session: \"Optional[Dict[str, Any]]\" = None) -&gt; SessionUpdate:\n\"\"\"Initialize a job.\"\"\"\n    return SessionUpdate()\n</code></pre>"},{"location":"api_reference/strategies/transformation/celery_remote/#oteapi.strategies.transformation.celery_remote.CeleryRemoteStrategy.status","title":"<code>status(task_id)</code>","text":"<p>Get job status.</p> Source code in <code>oteapi/strategies/transformation/celery_remote.py</code> <pre><code>def status(self, task_id: str) -&gt; TransformationStatus:\n\"\"\"Get job status.\"\"\"\n    result = AsyncResult(id=task_id, app=CELERY_APP)\n    return TransformationStatus(id=task_id, status=result.state)\n</code></pre>"},{"location":"api_reference/strategies/transformation/celery_remote/#oteapi.strategies.transformation.celery_remote.CeleryStrategyConfig","title":"<code>CeleryStrategyConfig</code>","text":"<p>             Bases: <code>TransformationConfig</code></p> <p>Celery strategy-specific configuration.</p> Source code in <code>oteapi/strategies/transformation/celery_remote.py</code> <pre><code>class CeleryStrategyConfig(TransformationConfig):\n\"\"\"Celery strategy-specific configuration.\"\"\"\n\n    transformationType: str = Field(\n        \"celery/remote\",\n        const=True,\n        description=TransformationConfig.__fields__[\n            \"transformationType\"\n        ].field_info.description,\n    )\n    configuration: CeleryConfig = Field(\n        ..., description=\"Celery transformation strategy-specific configuration.\"\n    )\n</code></pre>"},{"location":"api_reference/strategies/transformation/celery_remote/#oteapi.strategies.transformation.celery_remote.CeleryStrategyConfig.configuration","title":"<code>configuration: CeleryConfig = Field(..., description='Celery transformation strategy-specific configuration.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/transformation/celery_remote/#oteapi.strategies.transformation.celery_remote.CeleryStrategyConfig.transformationType","title":"<code>transformationType: str = Field('celery/remote', const=True, description=TransformationConfig.__fields__['transformationType'].field_info.description)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/transformation/celery_remote/#oteapi.strategies.transformation.celery_remote.SessionUpdateCelery","title":"<code>SessionUpdateCelery</code>","text":"<p>             Bases: <code>SessionUpdate</code></p> <p>Class for returning values from a Celery task.</p> Source code in <code>oteapi/strategies/transformation/celery_remote.py</code> <pre><code>class SessionUpdateCelery(SessionUpdate):\n\"\"\"Class for returning values from a Celery task.\"\"\"\n\n    celery_task_id: str = Field(..., description=\"A Celery task identifier.\")\n</code></pre>"},{"location":"api_reference/strategies/transformation/celery_remote/#oteapi.strategies.transformation.celery_remote.SessionUpdateCelery.celery_task_id","title":"<code>celery_task_id: str = Field(..., description='A Celery task identifier.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/triplestore/triplestore/","title":"triplestore","text":"<p>An RDF triplestore using Allegrograph https://franz.com/agraph/support/documentation/current/python/api.html https://franz.com/agraph/support/documentation/current/agraph-introduction.html</p> <p>Features:</p> <ul> <li>Store mapping data (triple format)</li> <li>AllegroGraph has a well documented python API package</li> </ul>"},{"location":"api_reference/triplestore/triplestore/#oteapi.triplestore.triplestore.TripleStore","title":"<code>TripleStore</code>","text":"<p>This class is available to import from <code>oteapi.triplestore</code>, e.g.:</p> <p><pre><code>from oteapi.triplestore import TripleStore\n</code></pre> Init must initialize the triple store connection</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>Union[TripleStoreConfig, Dict[str, Any]]</code> <p>RDF triple-store configuration.</p> required <p>Attributes:</p> Name Type Description <code>config</code> <code>TripleStoreConfig</code> <p>The RDF triple-store configuration.</p> Source code in <code>oteapi/triplestore/triplestore.py</code> <pre><code>class TripleStore:\n\"\"\"\n    This class is available to import from `oteapi.triplestore`, e.g.:\n\n    ```python\n    from oteapi.triplestore import TripleStore\n    ```\n    Init must initialize the triple store connection\n\n    Args:\n        config (Union[TripleStoreConfig, Dict[str, Any]]): RDF triple-store\n            configuration.\n\n    Attributes:\n        config (TripleStoreConfig): The RDF triple-store configuration.\n\n    \"\"\"\n\n    def __init__(\n        self,\n        config: \"Union[TripleStoreConfig, Dict[str, Any]]\",\n    ) -&gt; None:\n        if isinstance(config, (dict, AttrDict)):\n            self.config = TripleStoreConfig(**config)\n        elif isinstance(config, TripleStoreConfig):\n            self.config = config\n        else:\n            raise TypeError(\n                \"config should be either a `TripleStoreConfig` data model or a \"\n                \"dictionary.\"\n            )\n        self.server = AllegroGraphServer(\n            self.config.agraphHost,\n            self.config.agraphPort,\n            self.config.user.get_secret_value(),  # type: ignore [union-attr]\n            self.config.password.get_secret_value(),  # type: ignore [union-attr]\n        )\n\n    def add(self, triples: RDFTriple) -&gt; None:\n\"\"\"\n        Add triples to the triplestore.\n\n        Args:\n            triples: triples turtle format(&lt;s&gt; &lt;o&gt; &lt;p&gt;.).\n\n        \"\"\"\n        with ag_connect(\n            self.config.repositoryName,\n            host=self.config.agraphHost,\n            port=self.config.agraphPort,\n            user=self.config.user.get_secret_value(),  # type: ignore [union-attr]\n            password=self.config.password.get_secret_value(),  # type: ignore [union-attr]  # noqa: E501\n        ) as connection:\n            connection.addData(triples)\n            connection.close()\n\n    def get(self, sparql_query: str) -&gt; \"Any\":\n\"\"\"Return the query result.\n\n        Args:\n            sparql_query: The SPARQL search query.\n\n        Returns:\n            The output of the search query in the form of a list of RDF triples.\n\n        \"\"\"\n        connection = self.server.openSession(\n            reason(\"&lt;\" + str(self.config.repositoryName) + \"&gt;\")\n        )\n        try:\n            tuple_query = connection.prepareTupleQuery(query=sparql_query)\n            response = []\n\n            with tuple_query.evaluate(output_format=TupleFormat.JSON) as results:\n                for result in results:\n                    triple = {}\n                    if \"'s': \" in str(result):\n                        triple[\"s\"] = str(result.getValue(\"s\"))\n                    if \"'p': \" in str(result):\n                        triple[\"p\"] = str(result.getValue(\"p\"))\n                    if \"'o': \" in str(result):\n                        triple[\"o\"] = str(result.getValue(\"o\"))\n                    response.append(triple)\n            connection.close()\n            return response\n        except RequestError as error:\n            return {\"Error\": error}\n\n    def update_delete(self, sparql_query: str) -&gt; None:\n\"\"\"Remove and update triples.\n\n        Useful for modifying and cleaning up mappings.\n\n        Args:\n            sparql_query: The sparql update/delete query.\n        Returns:\n            True if update was successful.\n\n        \"\"\"\n        with ag_connect(\n            self.config.repositoryName,\n            host=self.config.agraphHost,\n            port=self.config.agraphPort,\n            user=self.config.user.get_secret_value(),  # type: ignore [union-attr]\n            password=self.config.password.get_secret_value(),  # type: ignore [union-attr]  # noqa: E501\n        ) as connection:\n            update_query = connection.prepareUpdate(query=sparql_query)\n            update_query.evaluate()\n            connection.close()\n</code></pre>"},{"location":"api_reference/triplestore/triplestore/#oteapi.triplestore.triplestore.TripleStore.add","title":"<code>add(triples)</code>","text":"<p>Add triples to the triplestore.</p> <p>Parameters:</p> Name Type Description Default <code>triples</code> <code>RDFTriple</code> <p>triples turtle format( <p>.).</p> required Source code in <code>oteapi/triplestore/triplestore.py</code> <pre><code>def add(self, triples: RDFTriple) -&gt; None:\n\"\"\"\n    Add triples to the triplestore.\n\n    Args:\n        triples: triples turtle format(&lt;s&gt; &lt;o&gt; &lt;p&gt;.).\n\n    \"\"\"\n    with ag_connect(\n        self.config.repositoryName,\n        host=self.config.agraphHost,\n        port=self.config.agraphPort,\n        user=self.config.user.get_secret_value(),  # type: ignore [union-attr]\n        password=self.config.password.get_secret_value(),  # type: ignore [union-attr]  # noqa: E501\n    ) as connection:\n        connection.addData(triples)\n        connection.close()\n</code></pre>"},{"location":"api_reference/triplestore/triplestore/#oteapi.triplestore.triplestore.TripleStore.get","title":"<code>get(sparql_query)</code>","text":"<p>Return the query result.</p> <p>Parameters:</p> Name Type Description Default <code>sparql_query</code> <code>str</code> <p>The SPARQL search query.</p> required <p>Returns:</p> Type Description <code>Any</code> <p>The output of the search query in the form of a list of RDF triples.</p> Source code in <code>oteapi/triplestore/triplestore.py</code> <pre><code>def get(self, sparql_query: str) -&gt; \"Any\":\n\"\"\"Return the query result.\n\n    Args:\n        sparql_query: The SPARQL search query.\n\n    Returns:\n        The output of the search query in the form of a list of RDF triples.\n\n    \"\"\"\n    connection = self.server.openSession(\n        reason(\"&lt;\" + str(self.config.repositoryName) + \"&gt;\")\n    )\n    try:\n        tuple_query = connection.prepareTupleQuery(query=sparql_query)\n        response = []\n\n        with tuple_query.evaluate(output_format=TupleFormat.JSON) as results:\n            for result in results:\n                triple = {}\n                if \"'s': \" in str(result):\n                    triple[\"s\"] = str(result.getValue(\"s\"))\n                if \"'p': \" in str(result):\n                    triple[\"p\"] = str(result.getValue(\"p\"))\n                if \"'o': \" in str(result):\n                    triple[\"o\"] = str(result.getValue(\"o\"))\n                response.append(triple)\n        connection.close()\n        return response\n    except RequestError as error:\n        return {\"Error\": error}\n</code></pre>"},{"location":"api_reference/triplestore/triplestore/#oteapi.triplestore.triplestore.TripleStore.update_delete","title":"<code>update_delete(sparql_query)</code>","text":"<p>Remove and update triples.</p> <p>Useful for modifying and cleaning up mappings.</p> <p>Parameters:</p> Name Type Description Default <code>sparql_query</code> <code>str</code> <p>The sparql update/delete query.</p> required <p>Returns:     True if update was successful.</p> Source code in <code>oteapi/triplestore/triplestore.py</code> <pre><code>def update_delete(self, sparql_query: str) -&gt; None:\n\"\"\"Remove and update triples.\n\n    Useful for modifying and cleaning up mappings.\n\n    Args:\n        sparql_query: The sparql update/delete query.\n    Returns:\n        True if update was successful.\n\n    \"\"\"\n    with ag_connect(\n        self.config.repositoryName,\n        host=self.config.agraphHost,\n        port=self.config.agraphPort,\n        user=self.config.user.get_secret_value(),  # type: ignore [union-attr]\n        password=self.config.password.get_secret_value(),  # type: ignore [union-attr]  # noqa: E501\n    ) as connection:\n        update_query = connection.prepareUpdate(query=sparql_query)\n        update_query.evaluate()\n        connection.close()\n</code></pre>"},{"location":"api_reference/utils/config_updater/","title":"config_updater","text":"<p>Utility functions for updating GenericConfig instances.</p>"},{"location":"api_reference/utils/config_updater/#oteapi.utils.config_updater.populate_config_from_session","title":"<code>populate_config_from_session(session, config)</code>","text":"<p>Update the configuration attributes of a GenericConfig object using values from a session. If a key already exists in the config's configuration and has a different value from the session, an exception will be raised.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>Dict</code> <p>A session containing configuration attributes.</p> required <code>config</code> <code>GenericConfig</code> <p>A GenericConfig object to be updated.</p> required Source code in <code>oteapi/utils/config_updater.py</code> <pre><code>def populate_config_from_session(\n    session: \"Dict[str, Any]\",\n    config: GenericConfig,\n) -&gt; None:\n\"\"\"\n    Update the configuration attributes of a GenericConfig object\n    using values from a session. If a key already exists in the\n    config's configuration and has a different value from the session,\n    an exception will be raised.\n\n    Args:\n        session (Dict): A session containing configuration attributes.\n        config (GenericConfig): A GenericConfig object to be updated.\n    \"\"\"\n    # Determine which keys to update\n    keys_to_update = list(session.keys())\n\n    for key in keys_to_update:\n        if key in config.configuration and session[key] != config.configuration[key]:\n            raise ValueError(\n                f\"Key '{key}' in config has different value than in session.\"\n            )\n\n        try:\n            config.configuration[key] = session[key]\n        except Exception as error:\n            raise RuntimeError(\n                f\"Failed to update key '{key}' in the config. Reason: {str(error)}\"\n            ) from error\n</code></pre>"},{"location":"api_reference/utils/paths/","title":"paths","text":"<p>Utility functions for handling paths.</p>"},{"location":"api_reference/utils/paths/#oteapi.utils.paths.uri_to_path","title":"<code>uri_to_path(uri)</code>","text":"<p>Convert URI to pathlib.Path.</p> <p>Support both Windows and Posix path types.</p> Information <p><code>urllib.parse.urlparse()</code> leaves an initial slash in front of the drive letter when parsing a file URL for an absolute path on Windows.</p> <p>Example: <code>urlparse(\"file:///C:/Windows\").path</code> -&gt; <code>\"/C:/Windows\"</code></p> <p>To solve this, the initial forward slash is removed prior to casting to <code>pathlib.Path</code>.</p> <p>Parameters:</p> Name Type Description Default <code>uri</code> <code>Union[str, AnyUrl, ParseResult]</code> <p>The URI/IRI/URL. Either as a string or a parsed URL.</p> required <p>Returns:</p> Type Description <code>Path</code> <p>A properly converted URI/IRI/URL to <code>pathlib.Path</code>.</p> Source code in <code>oteapi/utils/paths.py</code> <pre><code>def uri_to_path(uri: \"Union[str, AnyUrl, ParseResult]\") -&gt; Path:\n\"\"\"Convert URI to pathlib.Path.\n\n    Support both Windows and Posix path types.\n\n    Information:\n        `urllib.parse.urlparse()` leaves an initial slash in front of the drive letter\n        when parsing a file URL for an absolute path on Windows.\n\n        Example: `urlparse(\"file:///C:/Windows\").path` -&gt; `\"/C:/Windows\"`\n\n        To solve this, the initial forward slash is removed prior to casting to\n        `pathlib.Path`.\n\n    Parameters:\n        uri: The URI/IRI/URL. Either as a string or a parsed URL.\n\n    Returns:\n        A properly converted URI/IRI/URL to `pathlib.Path`.\n\n    \"\"\"\n    if not isinstance(uri, ParseResult):\n        uri = urlparse(uri)  # type: ignore\n\n    uri_path = (uri.netloc + uri.path) if uri.scheme == \"file\" else uri.path\n\n    if uri.scheme != \"file\":\n        warnings.warn(\n            \"A 'file'-scheme was expected for the 'uri' in 'uri_to_path()', instead a \"\n            f\"{uri.scheme!r} was received. Still converting to `pathlib.Path` using \"\n            \"the 'path' of the URI.\"\n        )\n\n    path = Path(uri_path)\n    if isinstance(path, PureWindowsPath):\n        path = Path(uri_path.lstrip(\"/\"))\n    return path\n</code></pre>"}]}