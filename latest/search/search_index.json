{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Open Translation Environment (OTE) API Core","text":"<p>Framework for accessing data resources, mapping data models, describing the data to ontologies and perform data transformations</p> <p> </p> <p>We highly recommend reading this page in the official documentation.</p> <p>Important: As of v0.6.0, OTEAPI Core is no longer compatible with pydantic v1, but only with pydantic v2. For more information about migrating your plugin repository to pydantic v2, see the pydantic documentation's migration guide. Until the end of 2023, pydantic v1 will still be supported with security updates, but no new features will be added. To keep using pydantic v1, one should use the v0.5.x versions of OTEAPI Core.</p>"},{"location":"#about-oteapi-core","title":"About OTEAPI Core","text":"<p>OTEAPI Core provides the core functionality of OTEAPI, which stands for the Open Translation Environment API.</p> <p>It uses the strategy software design pattern to implement a simple and easy to extend access to a large range of data resources. Semantic interoperability is supported via mapping of data models describing the data to ontologies. A set of strategy interfaces that can be considered abstract classes for the implementation of strategies, and data models used in their configuration, are provided. This repo also contains implementations for several standard strategies, e.g., downloading files, parsing Excel documents. Transformations, mainly intended to transform data between representations, are also supported, but transformations can also be used for running simulations in a simple workflow.</p> <p>OTEAPI Core includes:</p> <ul> <li>A set of standard strategies;</li> <li>A plugin system for loading the standard strategies, as well as third party strategies;</li> <li>Data models for configuring the strategies;</li> <li>A Python library, through which the data can be accessed; and</li> <li>An efficient data cache module that avoids downloading the same content several times.</li> </ul>"},{"location":"#types-of-strategies","title":"Types of strategies","text":""},{"location":"#download-strategy","title":"Download strategy","text":"<p>Download strategy patterns use a given protocol to download content into the data cache. They are configured with the <code>ResourceConfig</code> data model, using the scheme of the <code>downloadUrl</code> field for strategy selection. The <code>configuration</code> field can be used to configure how the downloaded content is stored in the cache using the <code>DownloadConfig</code> data model.</p> <p>Standard downloaded strategies: file, https, http, sftp, ftp</p>"},{"location":"#parse-strategy","title":"Parse strategy","text":"<p>Parse strategy patterns convert content from the data cache to a Python dict. Like download strategies, they are configured with the <code>ResourceConfig</code> data model, using the <code>mediaType</code> field for strategy selection. Additional strategy-specific configurations can be provided via the <code>configuration</code> field.</p> <p>Standard parse strategies: application/json, image/jpg, image/jpeg, image/jp2, image/png, image/gif, image/tiff, image/eps, application/vnd.openxmlformats-officedocument.spreadsheetml.sheet, application/vnd.sqlite3</p>"},{"location":"#resource-strategy","title":"Resource strategy","text":"<p>Resource strategy patterns can retrieve/upload data to external data services. They are configured with the <code>ResourceConfig</code> data model, using the scheme of the <code>accessUrl</code> and <code>accessService</code> fields. The scheme of the <code>accessUrl</code> is used for strategy selection.</p>"},{"location":"#mapping-strategy","title":"Mapping strategy","text":"<p>Strategies for mapping fields/properties in data models to ontological concepts.</p>"},{"location":"#filter-strategy","title":"Filter strategy","text":"<p>Filter strategies can update the configuration of other strategies. They can also update values in the data cache.</p> <p>Standard filter strategies: filter/crop, filter/sql</p>"},{"location":"#function-strategy","title":"Function strategy","text":"<p>Function strategies are synchronous transformations that (normally) run directly on the server hosting the OTE service.</p>"},{"location":"#transformation-strategy","title":"Transformation strategy","text":"<p>Transformation strategies are a special form of a function strategy intended for long-running transformations. In this sense, they represent asynchronous functions running in the background or on external resources.</p> <p>Standard transformation strategies: celery/remote</p> <p>The transformation strategy has consolidated the execution of the transformation with the <code>get()</code> method to unify the strategy interfaces. <code>get()</code> is intended to start an asynchronous process and return a task_id which can be queried using the <code>status()</code> method (outside of a pipeline).</p>"},{"location":"#entry-points-for-plugins","title":"Entry points for plugins","text":"<p>The way strategies are registered and found is through entry points.</p> <p>Special group names allow understanding the strategy type and the entry point values allow understanding of what kind of strategy a specific class implements. A full overview of recognized entry point group names can be seen in Table of entry point strategies.</p>"},{"location":"#defining-entry-points","title":"Defining entry points","text":"<p>In the following examples, let's imagine we have a package importable in Python through <code>my_plugin</code> and contains two download strategies and a single parse strategy:</p> <ol> <li>A peer-2-peer download strategy, implemented in a class named <code>Peer2PeerDownload</code> importable from <code>my_plugin.strategies.download.peer_2_peer</code>.</li> <li>A MongoDB download strategy, implemented in a class named <code>MongoRetrieve</code> importable from <code>my_plugin.strategies.mongo</code>.</li> <li>A MongoDB parse strategy, implemented in a class named <code>MongoParse</code> importable from <code>my_plugin.strategies.mongo</code>.</li> </ol> <p>There are now various different ways to let the Python environment know of these strategies through entry points.</p>"},{"location":"#setuppy","title":"<code>setup.py</code>","text":"<p>In the package's <code>setup.py</code> file, one can specify entry points. Here, an example snippet is shown using setuptools:</p> <pre><code># setup.py\nfrom setuptools import setup\n\nsetup(\n    # ...,\n    entry_points={\n        \"oteapi.download\": [\n            \"my_plugin.p2p = my_plugin.strategies.download.peer_2_peer:Peer2PeerDownload\",\n            \"my_plugin.mongo = my_plugin.strategies.mongo:MongoRetrieve\",\n        ],\n        \"oteapi.parse\": [\n            \"my_plugin.application/vnd.mongo+json = my_plugin.strategies.mongo:MongoParse\",\n        ]\n    },\n)\n</code></pre>"},{"location":"#yamljson-custom-files","title":"YAML/JSON custom files","text":"<p>Use custom files that are later parsed and used in a <code>setup.py</code> file.</p> <pre><code>entry_points:\n  oteapi.download:\n  - \"my_plugin.p2p = my_plugin.strategies.download.peer_2_peer:Peer2PeerDownload\"\n  - \"my_plugin.mongo = my_plugin.strategies.mongo:MongoRetrieve\"\n  oteapi.parse:\n  - \"my_plugin.application/vnd.mongo+json = my_plugin.strategies.mongo:MongoParse\"\n</code></pre> <pre><code>{\n  \"entry_points\": {\n    \"oteapi.download\": [\n      \"my_plugin.p2p = my_plugin.strategies.download.peer_2_peer:Peer2PeerDownload\",\n      \"my_plugin.mongo = my_plugin.strategies.mongo:MongoRetrieve\"\n    ],\n    \"oteapi.parse\": [\n      \"my_plugin.application/vnd.mongo+json = my_plugin.strategies.mongo:MongoParse\"\n    ]\n  }\n}\n</code></pre>"},{"location":"#setupcfgpyprojecttoml","title":"<code>setup.cfg</code>/<code>pyproject.toml</code>","text":"<p>A more modern approach is to use <code>setup.cfg</code> or <code>pyproject.toml</code>.</p> <pre><code>[options.entry_points]\noteapi.download =\n    my_plugin.p2p = my_plugin.strategies.download.peer_2_peer:Peer2PeerDownload\n    my_plugin.mongo = my_plugin.strategies.mongo:MongoRetrieve\noteapi.parse =\n    my_plugin.application/vnd.mongo+json = my_plugin.strategies.mongo:MongoParse\n</code></pre>"},{"location":"#syntax-and-semantics","title":"Syntax and semantics","text":"<p>As seen above, there are a few different syntactical flavors of how to list the entry points. However, the \"value\" stays the same throughout.</p>"},{"location":"#general-python-entry-points","title":"General Python entry points","text":"<p>The general syntax for entry points is based on <code>ini</code> files and parsed using the built-in <code>configparser</code> module described here. Specifically for entry points the nomenclature is the following:</p> <pre><code>[options.entry_points]\nGROUP =\n    NAME = VALUE\n</code></pre> <p>The <code>VALUE</code> is then further split into: <code>PACKAGE.MODULE:OBJECT.ATTRIBUTE [EXTRA1, EXTRA2]</code>.</p>"},{"location":"#oteapi-strategy-entry-points","title":"OTEAPI strategy entry points","text":"<p>From the general syntax outlined above, OTEAPI Core then implements rules and requirements regarding the syntax for strategies.</p> <ol> <li>A class MUST be specified (as an <code>OBJECT</code>).</li> <li>The <code>NAME</code> MUST consist of exactly two parts: <code>PACKAGE</code> and strategy type value in the form of <code>PACKAGE.STRATEGY_TYPE_VALUE</code>.</li> <li>The <code>GROUP</code> MUST be a valid OTEAPI entry point group, see Table of entry point strategies for a full list of valid OTEAPI entry point group values.</li> </ol> <p>To understand what the strategy type value should be, see Table of entry point strategies.</p>"},{"location":"#table-of-entry-point-strategies","title":"Table of entry point strategies","text":"Strategy Type Name Strategy Type Value Entry Point Group Documentation Reference Download <code>scheme</code> <code>oteapi.download</code> Download strategy Filter <code>filterType</code> <code>oteapi.filter</code> Filter strategy Function <code>functionType</code> <code>oteapi.function</code> Function strategy Mapping <code>mappingType</code> <code>oteapi.mapping</code> Mapping strategy Parse <code>mediaType</code> <code>oteapi.parse</code> Parse strategy Resource <code>accessService</code> <code>oteapi.resource</code> Resource strategy Transformation <code>transformationType</code> <code>oteapi.transformation</code> Transformation strategy"},{"location":"#other-oteapi-related-repositories","title":"Other OTEAPI-related repositories","text":"<ul> <li>OTEAPI Services - a RESTful interface to OTEAPI Core</li> <li>OTELib - a Python interface to OTEAPI Services</li> <li>OTEAPI Plugin Template - a cookiecutter template for OTEAPI Plugins</li> </ul>"},{"location":"#installation","title":"Installation","text":"<p>OTEAPI Core can be installed with:</p> <pre><code>pip install oteapi-core\n</code></pre>"},{"location":"#for-developers","title":"For developers","text":"<p>If you want to install OTEAPI Core to have a developer environment, please clone down the repository from GitHub and install:</p> <pre><code>git clone https://github.com/EMMC-ASBL/oteapi-core /path/to/oteapi-core\npip install -U --upgrade-strategy=eager -e /path/to/oteapi-core[dev]\n</code></pre> <p>Note, <code>/path/to/oteapi-core</code> can be left out of the first line, but then it must be updated in the second line, either to <code>./oteapi-core</code>/<code>oteapi-core</code> or <code>.</code> if you <code>cd</code> into the generated folder wherein the repository has been cloned.</p> <p>The <code>--upgrade-strategy=eager</code> part can be left out. We recommend installing within a dedicated virtual environment.</p> <p>To test the installation, you can run:</p> <pre><code>cd /path/to/oteapi-core\npytest\n</code></pre> <p>If you run into issues at this stage, please open an issue.</p>"},{"location":"#using-docker-with-postgresql","title":"Using Docker with PostgreSQL","text":"<p>Docker is an effective tool for creating portable, isolated environments for your applications. Here's an example of setting up a PostgreSQL instance using Docker:</p> <ol> <li>Create a Docker volume: Docker volumes enable data to persist across uses of Docker containers.    In this context, we create a volume called pgdata to store database data.</li> </ol> <pre><code>docker volume create pgdata\n</code></pre> <ol> <li>Start a Docker container: Use the <code>docker run</code> command to initiate a new Docker container using the postgres image.    Here's a breakdown of the options used in the command:</li> </ol> <p><code>-d</code>: Runs the container in the background (detached mode), freeing up your terminal.</p> <p><code>--name postgres</code>: Names the container postgres, allowing it to be referenced in future Docker commands.</p> <p><code>-e POSTGRES_PASSWORD=postgres</code>: Sets an environment variable in the container to specify the PostgreSQL database password as postgres.</p> <p><code>-p 5432:5432</code>: Maps port 5432 of the container to port 5432 of the host machine, letting applications on the host connect to the PostgreSQL database in the container.</p> <p><code>-v pgdata:/var/lib/postgresql/data</code>: Mounts the pgdata volume at the path /var/lib/postgresql/data inside the container, which is the storage location for PostgreSQL data files.</p> <p><code>--restart always</code>: Ensures the container restarts whenever it stops, unless it is manually stopped, in which case it only restarts when the Docker daemon starts, usually on system boot.</p> <pre><code>docker run  -d --name postgres \\\n    -e POSTGRES_PASSWORD=postgres \\\n    -p 5432:5432 \\\n    -v pgdata:/var/lib/postgresql/data \\\n    --restart always postgres\n</code></pre>"},{"location":"#license","title":"License","text":"<p>OTEAPI Core is released under the MIT license with copyright \u00a9 SINTEF.</p>"},{"location":"#acknowledgment","title":"Acknowledgment","text":"<p>OTEAPI Core has been supported by the following projects:</p> <ul> <li> <p>OntoTrans (2020-2024) that receives funding from the European Union\u2019s Horizon 2020 Research and Innovation Programme, under Grant Agreement no. 862136.</p> </li> <li> <p>VIPCOAT (2021-2025) receives funding from the European Union\u2019s Horizon 2020 Research and Innovation Programme - DT-NMBP-11-2020 Open Innovation Platform for Materials Modelling, under Grant Agreement no: 952903.</p> </li> <li> <p>OpenModel (2021-2025) receives funding from the European Union\u2019s Horizon 2020 Research and Innovation Programme - DT-NMBP-11-2020 Open Innovation Platform for Materials Modelling, under Grant Agreement no: 953167.</p> </li> </ul>"},{"location":"CHANGELOG/","title":"Changelog","text":""},{"location":"CHANGELOG/#unreleased-changes-2024-09-05","title":"Unreleased changes (2024-09-05)","text":"<p>Full Changelog</p> <p>Merged pull requests:</p> <ul> <li>[Auto-generated] Update dependencies #521 (TEAM4-0)</li> <li>[Auto-generated] Update dependencies #512 (TEAM4-0)</li> <li>[Auto-generated] Update dependencies #511 (TEAM4-0)</li> <li>[Auto-generated] Update dependencies #508 (TEAM4-0)</li> <li>[Auto-generated] Update dependencies #506 (TEAM4-0)</li> <li>[Auto-generated] Update dependencies #500 (TEAM4-0)</li> <li>[Auto-generated] Update dependencies #499 (TEAM4-0)</li> </ul>"},{"location":"CHANGELOG/#v070dev2-2024-07-05","title":"v0.7.0.dev2 (2024-07-05)","text":"<p>Full Changelog</p> <p>Closed issues:</p> <ul> <li>Update use of <code>importlib.metadata.entry_points</code> #395</li> </ul> <p>Merged pull requests:</p> <ul> <li>Expect <code>EntryPoints</code> from <code>importlib.metadata</code> #496 (CasperWA)</li> <li>[Auto-generated] Update dependencies #495 (TEAM4-0)</li> <li>[Auto-generated] Update dependencies #491 (TEAM4-0)</li> <li>[Auto-generated] Update dependencies #490 (TEAM4-0)</li> <li>[Auto-generated] Update dependencies #487 (TEAM4-0)</li> <li>[Auto-generated] Update dependencies #485 (TEAM4-0)</li> <li>[Auto-generated] Update dependencies #480 (TEAM4-0)</li> <li>[Auto-generated] Update dependencies #477 (TEAM4-0)</li> <li>[Auto-generated] Update dependencies #474 (TEAM4-0)</li> <li>[Auto-generated] Update dependencies #470 (TEAM4-0)</li> <li>[pre-commit.ci] pre-commit autoupdate #468 (pre-commit-ci[bot])</li> <li>[Auto-generated] Update dependencies #463 (TEAM4-0)</li> <li>[Auto-generated] Update dependencies #460 (TEAM4-0)</li> <li>[Auto-generated] Update dependencies #457 (TEAM4-0)</li> <li>[Auto-generated] Update dependencies #454 (TEAM4-0)</li> <li>[Auto-generated] Update dependencies #452 (TEAM4-0)</li> <li>[Auto-generated] Update dependencies #447 (TEAM4-0)</li> <li>[Auto-generated] Update dependencies #446 (TEAM4-0)</li> </ul>"},{"location":"CHANGELOG/#v070dev1-2024-03-08","title":"v0.7.0.dev1 (2024-03-08)","text":"<p>Full Changelog</p> <p>Merged pull requests:</p> <ul> <li>[Auto-generated] Update dependencies #444 (TEAM4-0)</li> <li>Ensure config models are dumped safely #443 (CasperWA)</li> <li>Update resource/url strategy #440 (CasperWA)</li> </ul>"},{"location":"CHANGELOG/#v070dev0-2024-02-29","title":"v0.7.0.dev0 (2024-02-29)","text":"<p>Full Changelog</p> <p>Merged pull requests:</p> <ul> <li>[Auto-generated] Update dependencies #439 (TEAM4-0)</li> <li>[Auto-generated] Update dependencies #435 (TEAM4-0)</li> <li>[Auto-generated] Update dependencies #431 (TEAM4-0)</li> <li>Major/410 session removal #429 (Treesarj)</li> <li>[Auto-generated] Update dependencies #422 (TEAM4-0)</li> <li>[Auto-generated] Update dependencies #417 (TEAM4-0)</li> <li>[Auto-generated] Update dependencies #414 (TEAM4-0)</li> <li>[Auto-generated] Update dependencies #413 (TEAM4-0)</li> <li>[Auto-generated] Update dependencies #409 (TEAM4-0)</li> <li>[Auto-generated] Update dependencies #407 (TEAM4-0)</li> <li>[Auto-generated] Update dependencies #405 (TEAM4-0)</li> <li>[Auto-generated] Update dependencies #403 (TEAM4-0)</li> <li>[Auto-generated] Update dependencies #394 (TEAM4-0)</li> <li>[Auto-generated] Update dependencies #392 (TEAM4-0)</li> <li>[Auto-generated] Update dependencies #391 (TEAM4-0)</li> </ul>"},{"location":"CHANGELOG/#v061-2023-11-14","title":"v0.6.1 (2023-11-14)","text":"<p>Full Changelog</p> <p>Implemented enhancements:</p> <ul> <li>Implement split development #346</li> </ul> <p>Fixed bugs:</p> <ul> <li>Extend branch name for \"normal\" CI - Check dependencies job #371</li> <li>PRs for updating dependencies not opened #365</li> <li>Wrong key name used in CI workflow #363</li> <li>Update package name format check #361</li> </ul> <p>Merged pull requests:</p> <ul> <li>[Auto-generated] Update dependencies #385 (TEAM4-0)</li> <li>[Auto-generated] Update dependencies #381 (TEAM4-0)</li> <li>Add branch name extension for CI workflow #376 (CasperWA)</li> <li>[Auto-generated] Update dependencies #374 (TEAM4-0)</li> <li>Use <code>branch_name_extension</code> and auto-merge dependency PRs #369 (CasperWA)</li> <li>[Auto-generated] Update dependencies #366 (TEAM4-0)</li> <li>Fix workflow ignore rules key name #364 (CasperWA)</li> <li>Implement PEP 508 regex for package_name #362 (CasperWA)</li> <li>[Auto-generated] Update dependencies #360 (TEAM4-0)</li> </ul>"},{"location":"CHANGELOG/#v060-2023-10-12","title":"v0.6.0 (2023-10-12)","text":"<p>Full Changelog</p> <p>Implemented enhancements:</p> <ul> <li>Upgrade to support only Pydantic v2 #339</li> </ul> <p>Closed issues:</p> <ul> <li>Update dependency automation to include pydantic v1 support branch #349</li> <li>Update README in both branches to highlight the development/pydantic split #348</li> <li>Update release CD workflow to support releasing from <code>release/pydantic-v1-support</code> branch #347</li> </ul> <p>Merged pull requests:</p> <ul> <li>[Auto-generated] Update dependencies #358 (TEAM4-0)</li> <li>Update README to include info about pydantic v1 vs v2 #353 (CasperWA)</li> <li>[Auto-generated] Update dependencies #352 (TEAM4-0)</li> <li>Update CI/CD workflows for updating dependencies #351 (CasperWA)</li> <li>Upgrade to pydantic v2 #330 (CasperWA)</li> </ul>"},{"location":"CHANGELOG/#v052-2023-09-29","title":"v0.5.2 (2023-09-29)","text":"<p>Full Changelog</p> <p>Fixed bugs:</p> <ul> <li>Integrated support for pydantic v1 and v2 is wrong #341</li> </ul> <p>Merged pull requests:</p> <ul> <li>Revert pydantic 2 false support #343 (CasperWA)</li> <li>[Auto-generated] Update dependencies #342 (TEAM4-0)</li> </ul>"},{"location":"CHANGELOG/#v051-2023-09-22","title":"v0.5.1 (2023-09-22)","text":"<p>Full Changelog</p> <p>Implemented enhancements:</p> <ul> <li>Use ruff instead of pylint #331</li> <li>Consider using <code>flit</code> #267</li> </ul> <p>Fixed bugs:</p> <ul> <li>Update <code>full_docs_dirs</code> input for CI/CD #322</li> </ul> <p>Closed issues:</p> <ul> <li>Revert update of codecov-action from v4 to v3 #328</li> <li>Make the code-base compatible with pydantic version 2 and above #308</li> <li>Document that oteapi-core must be installed editable in order to test with pytest #62</li> </ul> <p>Merged pull requests:</p> <ul> <li>Sort dependencies #337 (CasperWA)</li> <li>Support pydantic v1 &amp; v2 #336 (CasperWA)</li> <li>Extend codecov uploads with strategies-specific flag #335 (CasperWA)</li> <li>Use flit instead of setuptools #334 (CasperWA)</li> <li>[Auto-generated] Update dependencies #333 (TEAM4-0)</li> <li>Use ruff instead of pylint #332 (CasperWA)</li> <li>[Auto-generated] Update dependencies #324 (TEAM4-0)</li> <li>Add strategies folders to CI/CD workflows docs update #323 (CasperWA)</li> </ul>"},{"location":"CHANGELOG/#v050-2023-09-12","title":"v0.5.0 (2023-09-12)","text":"<p>Full Changelog</p> <p>Fixed bugs:</p> <ul> <li>datacache:  the hash is not updated if the value is a string #298</li> </ul> <p>Closed issues:</p> <ul> <li>Ensure all strategy models are fully expressed #312</li> <li>Importing oteapi.strategies.parse.image fails for Python 3.9 #269</li> </ul> <p>Merged pull requests:</p> <ul> <li>Added support for relative file paths #318 (jesper-friis)</li> <li>[Auto-generated] Update dependencies #315 (TEAM4-0)</li> <li>Fully document strategies #313 (CasperWA)</li> <li>Update .pre-commit-config.yaml #307 (Treesarj)</li> <li>Introduce ParserConfig Model  #306 (daniel-sintef)</li> <li>[Auto-generated] Update dependencies #282 (TEAM4-0)</li> </ul>"},{"location":"CHANGELOG/#v045-2023-08-11","title":"v0.4.5 (2023-08-11)","text":"<p>Full Changelog</p> <p>Merged pull requests:</p> <ul> <li>update key in datacachewhen value is added as string #299 (francescalb)</li> <li>[Auto-generated] Update dependencies #280 (TEAM4-0)</li> <li>[Auto-generated] Update dependencies #278 (TEAM4-0)</li> <li>Added DOI badge to readme #273 (jesper-friis)</li> </ul>"},{"location":"CHANGELOG/#v044-2023-05-24","title":"v0.4.4 (2023-05-24)","text":"<p>Full Changelog</p> <p>Closed issues:</p> <ul> <li>psycopg2/PostgreSQL datasource strategy #191</li> </ul> <p>Merged pull requests:</p> <ul> <li>191 psycopg2postgresql datasource strategy #196 (daniel-sintef)</li> </ul>"},{"location":"CHANGELOG/#v043-2023-05-23","title":"v0.4.3 (2023-05-23)","text":"<p>Full Changelog</p> <p>Merged pull requests:</p> <ul> <li>[Auto-generated] Update dependencies #272 (TEAM4-0)</li> <li>Use typing-extensions for Python \\&lt;= 3.9 #270 (CasperWA)</li> </ul>"},{"location":"CHANGELOG/#v042-2023-05-12","title":"v0.4.2 (2023-05-12)","text":"<p>Full Changelog</p> <p>Implemented enhancements:</p> <ul> <li>Update SINTEF/ci-cd #265</li> </ul> <p>Fixed bugs:</p> <ul> <li>Pin to using urllib3 v1.x #261</li> </ul> <p>Closed issues:</p> <ul> <li>Rename the pipeline get() method to execute() #250</li> <li>Clean up requirements #248</li> <li>Activate auto-merging for CI workflow to update dependencies #247</li> </ul> <p>Merged pull requests:</p> <ul> <li>Update to SINTEF/ci-cd v2 #266 (CasperWA)</li> <li>[Auto-generated] Update dependencies #264 (TEAM4-0)</li> <li>Pin urllib3 to v1.x #262 (CasperWA)</li> <li>[Auto-generated] Update dependencies #260 (TEAM4-0)</li> <li>[Auto-generated] Update dependencies #258 (TEAM4-0)</li> <li>[Auto-generated] Update dependencies #256 (TEAM4-0)</li> <li>[Auto-generated] Update dependencies #252 (TEAM4-0)</li> <li>[Auto-generated] Update dependencies #246 (TEAM4-0)</li> <li>[Auto-generated] Update dependencies #244 (TEAM4-0)</li> </ul>"},{"location":"CHANGELOG/#v041-2023-03-10","title":"v0.4.1 (2023-03-10)","text":"<p>Full Changelog</p> <p>Merged pull requests:</p> <ul> <li>[Auto-generated] Update dependencies #242 (TEAM4-0)</li> <li>Polish <code>celery/remote</code> transformation strategy #240 (CasperWA)</li> <li>[Auto-generated] Update dependencies #239 (TEAM4-0)</li> <li>[Auto-generated] Update dependencies #235 (TEAM4-0)</li> <li>[Auto-generated] Update dependencies #234 (TEAM4-0)</li> </ul>"},{"location":"CHANGELOG/#v040-2023-02-07","title":"v0.4.0 (2023-02-07)","text":"<p>Full Changelog</p> <p>Fixed bugs:</p> <ul> <li>pylint compliance #229</li> </ul> <p>Closed issues:</p> <ul> <li>Use get in transformation datamodels and celery_remote #232</li> </ul> <p>Merged pull requests:</p> <ul> <li>Updated the interfaces and implementation of the transformation strat\u2026 #233 (quaat)</li> <li>Move pylint config file to pyproject.toml #230 (CasperWA)</li> <li>[Auto-generated] Update dependencies #228 (TEAM4-0)</li> <li>[Auto-generated] Update dependencies #226 (TEAM4-0)</li> </ul>"},{"location":"CHANGELOG/#v030-2023-01-24","title":"v0.3.0 (2023-01-24)","text":"<p>Full Changelog</p> <p>Implemented enhancements:</p> <ul> <li>Add json-encoders for SecretStr/SecretByte #218</li> <li>Use SINTEF/ci-cd callable workflows and pre-commit hooks #205</li> </ul> <p>Fixed bugs:</p> <ul> <li>Update configuration files for MkDocs #203</li> </ul> <p>Closed issues:</p> <ul> <li>Reenable documentation CI/CD disabled in PR #200 #201</li> <li>Error in description of MappingConfig.prefixes #197</li> <li>Update pylint options #193</li> </ul> <p>Merged pull requests:</p> <ul> <li>[Auto-generated] Update dependencies #223 (TEAM4-0)</li> <li>Enh/secrets json encoders #222 (MBueschelberger)</li> <li>[Auto-generated] Update dependencies #220 (TEAM4-0)</li> <li>[Auto-generated] Update dependencies #217 (TEAM4-0)</li> <li>[Auto-generated] Update dependencies #215 (TEAM4-0)</li> <li>[Auto-generated] Update dependencies #214 (TEAM4-0)</li> <li>[Auto-generated] Update dependencies #213 (TEAM4-0)</li> <li>add optional secret to functionconfig and resourceconfig #212 (MBueschelberger)</li> <li>Updated documentation of prefixes in MappingConfig #209 (jesper-friis)</li> <li>Use SINTEF/ci-cd #206 (CasperWA)</li> <li>Revert removing <code>--strict</code> and fix docs build #204 (CasperWA)</li> <li>removed --strict option #202 (daniel-sintef)</li> <li>[Auto-generated] Update dependencies #199 (TEAM4-0)</li> <li>added a small clarification to the docs #198 (daniel-sintef)</li> <li>Use recursive option for pylint-tests CI #194 (CasperWA)</li> <li>[Auto-generated] Update dependencies #190 (TEAM4-0)</li> <li>[Auto-generated] Update dependencies #189 (TEAM4-0)</li> <li>[Auto-generated] Update dependencies #186 (TEAM4-0)</li> <li>[Auto-generated] Update dependencies #184 (TEAM4-0)</li> <li>[Auto-generated] Update dependencies #182 (TEAM4-0)</li> <li>[Auto-generated] Update dependencies #174 (TEAM4-0)</li> </ul>"},{"location":"CHANGELOG/#v021-2022-07-20","title":"v0.2.1 (2022-07-20)","text":"<p>Full Changelog</p> <p>Fixed bugs:</p> <ul> <li><code>filter/crop</code> not loading properly #170</li> </ul> <p>Merged pull requests:</p> <ul> <li>Test and fix registered strategies #171 (CasperWA)</li> <li>[Auto-generated] Update dependencies #169 (TEAM4-0)</li> </ul>"},{"location":"CHANGELOG/#v020-2022-07-11","title":"v0.2.0 (2022-07-11)","text":"<p>Full Changelog</p> <p>Implemented enhancements:</p> <ul> <li>Implement the CSV parse strategy #159</li> </ul> <p>Fixed bugs:</p> <ul> <li>Problems accessing configurations' fields #113</li> </ul> <p>Closed issues:</p> <ul> <li>Add VIPCOAT and OpenModel to acknowledgements on all repositories. #133</li> </ul> <p>Merged pull requests:</p> <ul> <li>[Auto-generated] Update dependencies #165 (TEAM4-0)</li> <li>[Auto-generated] Update dependencies #163 (TEAM4-0)</li> <li>CSV parse strategy #160 (CasperWA)</li> <li>[Auto-generated] Update dependencies #155 (TEAM4-0)</li> <li>[Auto-generated] Update dependencies #152 (TEAM4-0)</li> <li>[Auto-generated] Update dependencies #150 (TEAM4-0)</li> </ul>"},{"location":"CHANGELOG/#v016-2022-04-20","title":"v0.1.6 (2022-04-20)","text":"<p>Full Changelog</p> <p>Fixed bugs:</p> <ul> <li>Setting attributes in <code>AttrDict</code> should be handled by pydantic #143</li> </ul> <p>Closed issues:</p> <ul> <li>Add checklist for reviewers to all repositories. #137</li> </ul> <p>Merged pull requests:</p> <ul> <li>[Auto-generated] Update dependencies #149 (TEAM4-0)</li> <li>Modify excel parse #148 (daniel-sintef)</li> <li>[Auto-generated] Update dependencies #147 (TEAM4-0)</li> <li>Fix deleting entries in AttrDict #144 (CasperWA)</li> <li>[Auto-generated] Update dependencies #142 (TEAM4-0)</li> <li>Added PR template with checklist for reviewers. #139 (francescalb)</li> <li>[Auto-generated] Update dependencies #136 (TEAM4-0)</li> </ul>"},{"location":"CHANGELOG/#v015-2022-03-23","title":"v0.1.5 (2022-03-23)","text":"<p>Full Changelog</p> <p>Implemented enhancements:</p> <ul> <li>Create a triple store class #120</li> <li>Fix pydantic model types according to default values #117</li> </ul> <p>Closed issues:</p> <ul> <li>Fix badge links in README #122</li> </ul> <p>Merged pull requests:</p> <ul> <li>Update README.md #134 (quaat)</li> <li>[Auto-generated] Update dependencies #130 (TEAM4-0)</li> <li>triplestore class which does add, delete/update and get mappings/triples #128 (Treesarj)</li> <li>Add links to badges in README #126 (CasperWA)</li> <li>Fix pydantic model type and default values #125 (CasperWA)</li> </ul>"},{"location":"CHANGELOG/#v014-2022-03-11","title":"v0.1.4 (2022-03-11)","text":"<p>Full Changelog</p> <p>Implemented enhancements:</p> <ul> <li>Support passing a dictionary as config to <code>create_strategy()</code> #123</li> </ul> <p>Merged pull requests:</p> <ul> <li>Using the <code>StrategyType</code> to deliver the <code>*Config</code> cls #124 (CasperWA)</li> </ul>"},{"location":"CHANGELOG/#v013-2022-03-10","title":"v0.1.3 (2022-03-10)","text":"<p>Full Changelog</p> <p>Implemented enhancements:</p> <ul> <li>Move pytest fixtures into <code>oteapi</code> package #121</li> <li>Add <code>pop()</code> (and possibly <code>popitem()</code>) to <code>AttrDict</code> #118</li> <li>Allow to bind values added to the data cache to an object, such that they automatically will be remove when the object goes out of scope #114</li> <li>Add some badges to the README #91</li> </ul> <p>Fixed bugs:</p> <ul> <li>The image strategy puts binary data in the session #107</li> </ul> <p>Merged pull requests:</p> <ul> <li>Implement and test <code>pop()</code> and <code>popitem()</code> for AttrDict #119 (CasperWA)</li> <li>[Auto-generated] Update dependencies #116 (TEAM4-0)</li> <li>Allow to bind the lifetime of datacache values to the lifetime of the session #115 (jesper-friis)</li> <li>Added mapping strategy #112 (jesper-friis)</li> <li>Corrected the sql_query_filter. #110 (jesper-friis)</li> <li>Store image data in datacache instead of session #108 (jesper-friis)</li> <li>Update README #106 (CasperWA)</li> </ul>"},{"location":"CHANGELOG/#v012-2022-03-03","title":"v0.1.2 (2022-03-03)","text":"<p>Full Changelog</p> <p>Implemented enhancements:</p> <ul> <li>Go through ignored dev tools comments #76</li> </ul> <p>Fixed bugs:</p> <ul> <li>Issue with <code>AttrDict.update()</code> for <code>AttrDict</code> subclasses #101</li> <li>GH GraphQL type issue in auto-merge workflow #96</li> </ul> <p>Merged pull requests:</p> <ul> <li>Update \"ignore\" statements #103 (CasperWA)</li> <li>Add test for AttrDict.update() method #102 (CasperWA)</li> <li>[Auto-generated] Update dependencies #100 (TEAM4-0)</li> <li>Use <code>ID!</code> type instead of <code>String!</code> #97 (CasperWA)</li> </ul>"},{"location":"CHANGELOG/#v011-2022-02-24","title":"v0.1.1 (2022-02-24)","text":"<p>Full Changelog</p> <p>Implemented enhancements:</p> <ul> <li>Avoid registerring the incomplete <code>text/csv</code> parse strategy #95</li> <li>Use special <code>*Config</code> classes where necessary #93</li> </ul> <p>Closed issues:</p> <ul> <li>Clean up the handling of paths in the file download strategy #84</li> </ul> <p>Merged pull requests:</p> <ul> <li>Update data cache invocation #94 (CasperWA)</li> <li>[Auto-generated] Update dependencies #92 (TEAM4-0)</li> </ul>"},{"location":"CHANGELOG/#v010-2022-02-22","title":"v0.1.0 (2022-02-22)","text":"<p>Full Changelog</p> <p>Implemented enhancements:</p> <ul> <li>Clean up tests #75</li> <li>Image parser: Use datacache #63</li> </ul> <p>Fixed bugs:</p> <ul> <li>Entrypoint does not seem to be updated during rebuild #86</li> <li>Use proper file scheme URLs in tests #74</li> <li>xlsx parse strategy fails parsing file on Windows #23</li> </ul> <p>Closed issues:</p> <ul> <li>Use standard library functions instead of homemade code for handling file:// URIs #88</li> <li>Remove image/eps as supported image format #68</li> </ul> <p>Merged pull requests:</p> <ul> <li>EntryPoint duplicity #87 (CasperWA)</li> <li>Added support for dumping numpy arrays to the datacache #83 (jesper-friis)</li> <li>[Auto-generated] Update dependencies #82 (TEAM4-0)</li> <li>Pydantic dataclasses #81 (CasperWA)</li> <li>Made datacache accepting AttrDict configuration #70 (jesper-friis)</li> </ul>"},{"location":"CHANGELOG/#v006-2022-02-14","title":"v0.0.6 (2022-02-14)","text":"<p>Full Changelog</p> <p>Implemented enhancements:</p> <ul> <li>New Function strategy #19</li> </ul> <p>Fixed bugs:</p> <ul> <li>ResourceConfig.configuration should be a dict #65</li> <li>Configuration bug #34</li> <li>Change mediaType for json to application/json #24</li> </ul> <p>Closed issues:</p> <ul> <li>AttrDict cannot be **unpacked #69</li> <li>Add tests of configuration object subscripting functionality #61</li> <li>Tests require installation #50</li> <li>Rename image_jpeg.py #48</li> <li>Write unit tests #11</li> </ul> <p>Merged pull requests:</p> <ul> <li>Sg/session update model #78 (sygout)</li> <li>New Function strategy #73 (CasperWA)</li> <li>Made ResourceConfig.configuration a dict #67 (jesper-friis)</li> <li>[Auto-generated] Update dependencies #66 (TEAM4-0)</li> <li>Add some dictionary functionality to configuration models #53 (TorgeirUstad)</li> <li>All new tests #35 (TorgeirUstad)</li> </ul>"},{"location":"CHANGELOG/#v005-2022-02-04","title":"v0.0.5 (2022-02-04)","text":"<p>Full Changelog</p> <p>Implemented enhancements:</p> <ul> <li>Consider removing the <code>create_*_strategy()</code> functions #57</li> <li>Lazy strategy loading #21</li> <li>Extend and \"safeguard\" plugin loading through entry points #10</li> </ul> <p>Fixed bugs:</p> <ul> <li>Out-of-scope CVE from NumPy makes safety cry #54</li> <li>pyproject.toml addopts line doesn't work on Windows #51</li> <li>Ignore ID 44715 for safety #55 (CasperWA)</li> </ul> <p>Merged pull requests:</p> <ul> <li>[Auto-generated] Update dependencies #56 (TEAM4-0)</li> <li>Add Windows pytest CI job #52 (CasperWA)</li> <li>Start implementing entry point logic #47 (CasperWA)</li> </ul>"},{"location":"CHANGELOG/#v004-2022-01-26","title":"v0.0.4 (2022-01-26)","text":"<p>Full Changelog</p> <p>Implemented enhancements:</p> <ul> <li>Setup dependency handling via dependabot #31</li> <li>Attempt simplifying strategy factory function #13</li> </ul> <p>Fixed bugs:</p> <ul> <li>Update pytest command in CI to fix codecov #42</li> <li>Publish workflow failing - invoke not installed #40</li> </ul> <p>Closed issues:</p> <ul> <li>Use new TEAM 4.0[bot] email throughout #38</li> <li>Make datacache safe to call from within a running asyncio event loop #26</li> <li>Setup documentation framework #9</li> </ul> <p>Merged pull requests:</p> <ul> <li>[Auto-generated] Update dependencies #45 (TEAM4-0)</li> <li>Add pytest options to pyproject.toml #43 (CasperWA)</li> <li>Install the <code>dev</code> extra in publish workflow #41 (CasperWA)</li> <li>Use the updated @TEAM4-0 email address #39 (CasperWA)</li> <li>Implement CI/CD for dependabot #33 (CasperWA)</li> <li>Remove asyncio from datacache #32 (jesper-friis)</li> <li>Setup docs framework and implement creating any strategy function #29 (CasperWA)</li> </ul>"},{"location":"CHANGELOG/#v003-2022-01-21","title":"v0.0.3 (2022-01-21)","text":"<p>Full Changelog</p> <p>Implemented enhancements:</p> <ul> <li>Remove non-\"standard\" strategies #14</li> <li>Clean up the API #12</li> </ul> <p>Fixed bugs:</p> <ul> <li>Update CI/CD to only use Python 3.9 #25</li> <li>References in README are wrong #18</li> </ul> <p>Closed issues:</p> <ul> <li>Bring back <code>pre-commit</code> #16</li> <li>Publish docker image #15</li> </ul> <p>Merged pull requests:</p> <ul> <li>Updated cd_release.yml to python 3.9 #28 (kriwiik)</li> <li>Add back <code>pre-commit</code> #22 (CasperWA)</li> <li>Fixed README.md References #20 (anasayb)</li> <li>Clean up Python API #17 (CasperWA)</li> </ul>"},{"location":"CHANGELOG/#v002-2022-01-14","title":"v0.0.2 (2022-01-14)","text":"<p>Full Changelog</p> <p>Implemented enhancements:</p> <ul> <li>Release and tests CD/CI #1 (CasperWA)</li> </ul> <p>Fixed bugs:</p> <ul> <li>CD publish release workflow not working #4</li> <li>CD release not working - wrong utils path #2</li> </ul> <p>Merged pull requests:</p> <ul> <li>Cleanup #8 (jesper-friis)</li> <li>Renamed oteapi/strategy-interfaces to oteapi/interfaces and updated paths in all Python modules #6 (jesper-friis)</li> <li>Update workflows to make CD work #5 (CasperWA)</li> <li>Fix location of utility files for GH Actions #3 (CasperWA)</li> </ul> <p>* This Changelog was automatically generated by github_changelog_generator</p>"},{"location":"LICENSE/","title":"License","text":"<p>MIT License</p> <p>Copyright (c) 2020-2022 SINTEF</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"all_models/","title":"OTE-API Configuration Models","text":"<p>This page provides documentation for the <code>oteapi.models</code> submodule, where all the OTE-API strategy configuration data models are located.</p> <p>When creating instances of these models, the data types are automatically validated.</p> <p><code>oteapi.models</code> module.</p> <p>This module contains all the <code>pydantic</code> configuration models.</p>"},{"location":"all_models/#oteapi.models.HostlessAnyUrl","title":"<code>HostlessAnyUrl = Annotated[Url, UrlConstraints(host_required=False)]</code>  <code>module-attribute</code>","text":""},{"location":"all_models/#oteapi.models.RDFTriple","title":"<code>RDFTriple = Tuple[str, str, str]</code>  <code>module-attribute</code>","text":""},{"location":"all_models/#oteapi.models.StrategyConfig","title":"<code>StrategyConfig = Union[FilterConfig, FunctionConfig, MappingConfig, ParserConfig, ResourceConfig, TransformationConfig]</code>  <code>module-attribute</code>","text":""},{"location":"all_models/#oteapi.models.AttrDict","title":"<code>AttrDict</code>","text":"<p>               Bases: <code>BaseModel</code>, <code>MutableMapping</code></p> <p>An object whose attributes can also be accessed through subscription, like with a dictionary.</p> <p>Special pydantic configuration settings:</p> <ul> <li><code>extra</code>   Allow any attributes/fields to be defined - this is what makes this pydantic   model an attribute dictionary.</li> <li><code>validate_assignment</code>   Validate and cast set values.   This is mainly relevant for sub-classes of <code>AttrDict</code>, where specific   attributes have been defined.</li> <li><code>arbitrary_types_allowed</code>   If a custom type is used for an attribute that doesn't have a <code>validate()</code>   method, don't fail setting the attribute.</li> </ul> Source code in <code>oteapi/models/genericconfig.py</code> <pre><code>class AttrDict(BaseModel, MutableMapping):\n    \"\"\"An object whose attributes can also be accessed through\n    subscription, like with a dictionary.\n\n    Special pydantic configuration settings:\n\n    - **`extra`**\n      Allow any attributes/fields to be defined - this is what makes this pydantic\n      model an attribute dictionary.\n    - **`validate_assignment`**\n      Validate and cast set values.\n      This is mainly relevant for sub-classes of `AttrDict`, where specific\n      attributes have been defined.\n    - **`arbitrary_types_allowed`**\n      If a custom type is used for an attribute that doesn't have a `validate()`\n      method, don't fail setting the attribute.\n\n    \"\"\"\n\n    model_config = ConfigDict(\n        extra=\"allow\", validate_assignment=True, arbitrary_types_allowed=True\n    )\n\n    # Collection methods\n    def __contains__(self, key: object) -&gt; bool:\n        if not isinstance(key, str):\n            raise TypeError(f\"Keys must be of type `str`, not `{type(key).__name__}`.\")\n        return hasattr(self, key)\n\n    def __len__(self) -&gt; int:\n        return len(self.model_dump())\n\n    # Mapping methods\n    def __getitem__(self, key: \"Any\") -&gt; \"Any\":\n        if not isinstance(key, str):\n            raise TypeError(f\"Keys must be of type `str`, not `{type(key).__name__}`.\")\n        try:\n            return getattr(self, key)\n        except AttributeError as exc:\n            raise KeyError(key) from exc\n\n    def items(self):\n        return self.model_dump().items()\n\n    def keys(self):\n        return self.model_dump().keys()\n\n    def values(self):\n        return self.model_dump().values()\n\n    def get(self, key: str, default: \"Optional[Any]\" = None) -&gt; \"Any\":\n        return getattr(self, key, default)\n\n    def __eq__(self, value: object) -&gt; bool:\n        if isinstance(value, Mapping):\n            return self.model_dump() == value\n        if isinstance(value, BaseModel):\n            return BaseModel.__eq__(self, value)\n        return False\n\n    # MutableMapping methods\n    def __setitem__(self, key: \"Any\", value: \"Any\") -&gt; None:\n        if not isinstance(key, str):\n            raise TypeError(f\"Keys must be of type `str`, not `{type(key).__name__}`.\")\n        try:\n            return self.__setattr__(key, value)\n        except AttributeError as exc:\n            raise KeyError(key) from exc\n\n    def __delitem__(self, key: \"Any\") -&gt; None:\n        warnings.warn(\n            \"Item deletion used to reset fields to their default values. To keep using\"\n            \" this functionality, use the `reset_field()` method.\",\n            DeprecationWarning,\n        )\n\n        if not isinstance(key, str):\n            raise TypeError(f\"Keys must be of type `str`, not `{type(key).__name__}`.\")\n        try:\n            self.__delattr__(key)\n        except AttributeError as exc:\n            raise KeyError(key) from exc\n        else:\n            if key in self.model_fields_set:\n                self.model_fields_set.remove(key)\n\n    def clear(self) -&gt; None:\n        # Ignore the deprecation warning from `__delitem__`\n        with warnings.catch_warnings():\n            warnings.simplefilter(\"ignore\", DeprecationWarning)\n\n            for field in self.model_dump():\n                del self[field]\n\n    def update(  # type: ignore[override]\n        self,\n        other: \"Optional[Union[Mapping[str, Any], Iterable[tuple[str, Any]]]]\" = None,\n        **kwargs,\n    ) -&gt; None:\n        if other and isinstance(other, Mapping):\n            for key, value in other.items():\n                setattr(self, key, value)\n        elif other and isinstance(other, BaseModel):\n            for key, value in other:\n                setattr(self, key, value)\n        elif other and isinstance(other, Iterable):\n            for entry in other:\n                if not isinstance(entry, tuple):\n                    raise TypeError(\n                        \"`other` must be an iterable of tuples of length two.\"\n                    )\n                if not len(entry) == 2:\n                    raise ValueError(\n                        \"`other` must be an iterable of objects of length two.\"\n                    )\n            for key, value in other:  # type: ignore[misc]\n                setattr(self, key, value)\n        elif other:\n            raise TypeError(\n                \"`other` must be of type `dict`, `Mapping`, `BaseModel` or \"\n                \"`Iterable`, not `{type(other).__name__}`.\"\n            )\n        if kwargs:\n            for key, value in kwargs.items():\n                setattr(self, key, value)\n\n    def pop(self, key: str, default: \"Optional[Any]\" = PydanticUndefined) -&gt; \"Any\":\n        value = self.get(key, default)\n        if value == PydanticUndefined:\n            raise KeyError(key)\n        if key in self:\n            # Ignore the deprecation warning from `__delitem__`\n            with warnings.catch_warnings():\n                warnings.simplefilter(\"ignore\", DeprecationWarning)\n\n                del self[key]\n        return value\n\n    def popitem(self) -&gt; \"Tuple[str, Any]\":\n        \"\"\"MutableMapping `popitem`-method.\n\n        Important:\n            Unlike the regular `dict.popitem()` method, this one does _not_ respect\n            LIFO (last-in, first-out).\n            This is due to the fact that attributes are stored in a random order when\n            initializing the model.\n\n            However, it will respect LIFO with respect to the internal `model_fields`.\n\n        \"\"\"\n        if not self:\n            raise KeyError(f\"popitem(): {self.__class__.__name__} is empty\")\n\n        key = list(self.keys())[-1]\n        value = self.pop(key)\n        return key, value\n\n    def reset_field(self, field: str) -&gt; None:\n        \"\"\"Reset a field to its default value.\n\n        Warning:\n            This will remove/delete a field that is not part of the model schema.\n\n        Parameters:\n            field: The field to reset.\n\n        \"\"\"\n        if field not in self:\n            raise KeyError(f\"Field {field!r} does not exist.\")\n\n        if field in self.model_fields:\n            # Part of the model schema\n            schema_field = True\n\n            # Set the field to its default value\n            setattr(self, field, self.model_fields[field].default)\n        else:\n            # Not part of the model schema, but part of the extras\n            schema_field = False\n\n            # Remove the field altogether\n            if self.model_extra is None:\n                raise RuntimeError(\"Model has no extra fields.\")\n\n            try:\n                self.model_extra.pop(field)\n            except KeyError as exc:\n                raise RuntimeError(\n                    f\"Field {field!r} can not be found in the model fields or extras.\"\n                ) from exc\n\n        # Remove it from fields set by the user\n        if field in self.model_fields_set:\n            self.model_fields_set.remove(field)\n\n        # Check the field has been properly reset\n        if schema_field:\n            if field not in self:\n                raise RuntimeError(f\"Field {field!r} was not reset as expected.\")\n            if self[field] != self.model_fields[field].default:\n                raise RuntimeError(\n                    f\"Field {field!r} was not reset to its default value as expected.\"\n                )\n        else:\n            if field in self:\n                raise RuntimeError(f\"Field {field!r} was not removed as expected.\")\n        if field in self.model_fields_set:\n            raise RuntimeError(\n                f\"Field {field!r} was not removed from the set of user-set fields as \"\n                \"expected.\"\n            )\n</code></pre>"},{"location":"all_models/#oteapi.models.AttrDict.model_config","title":"<code>model_config = ConfigDict(extra='allow', validate_assignment=True, arbitrary_types_allowed=True)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_models/#oteapi.models.AttrDict.clear","title":"<code>clear()</code>","text":"Source code in <code>oteapi/models/genericconfig.py</code> <pre><code>def clear(self) -&gt; None:\n    # Ignore the deprecation warning from `__delitem__`\n    with warnings.catch_warnings():\n        warnings.simplefilter(\"ignore\", DeprecationWarning)\n\n        for field in self.model_dump():\n            del self[field]\n</code></pre>"},{"location":"all_models/#oteapi.models.AttrDict.get","title":"<code>get(key, default=None)</code>","text":"Source code in <code>oteapi/models/genericconfig.py</code> <pre><code>def get(self, key: str, default: \"Optional[Any]\" = None) -&gt; \"Any\":\n    return getattr(self, key, default)\n</code></pre>"},{"location":"all_models/#oteapi.models.AttrDict.items","title":"<code>items()</code>","text":"Source code in <code>oteapi/models/genericconfig.py</code> <pre><code>def items(self):\n    return self.model_dump().items()\n</code></pre>"},{"location":"all_models/#oteapi.models.AttrDict.keys","title":"<code>keys()</code>","text":"Source code in <code>oteapi/models/genericconfig.py</code> <pre><code>def keys(self):\n    return self.model_dump().keys()\n</code></pre>"},{"location":"all_models/#oteapi.models.AttrDict.pop","title":"<code>pop(key, default=PydanticUndefined)</code>","text":"Source code in <code>oteapi/models/genericconfig.py</code> <pre><code>def pop(self, key: str, default: \"Optional[Any]\" = PydanticUndefined) -&gt; \"Any\":\n    value = self.get(key, default)\n    if value == PydanticUndefined:\n        raise KeyError(key)\n    if key in self:\n        # Ignore the deprecation warning from `__delitem__`\n        with warnings.catch_warnings():\n            warnings.simplefilter(\"ignore\", DeprecationWarning)\n\n            del self[key]\n    return value\n</code></pre>"},{"location":"all_models/#oteapi.models.AttrDict.popitem","title":"<code>popitem()</code>","text":"<p>MutableMapping <code>popitem</code>-method.</p> Important <p>Unlike the regular <code>dict.popitem()</code> method, this one does not respect LIFO (last-in, first-out). This is due to the fact that attributes are stored in a random order when initializing the model.</p> <p>However, it will respect LIFO with respect to the internal <code>model_fields</code>.</p> Source code in <code>oteapi/models/genericconfig.py</code> <pre><code>def popitem(self) -&gt; \"Tuple[str, Any]\":\n    \"\"\"MutableMapping `popitem`-method.\n\n    Important:\n        Unlike the regular `dict.popitem()` method, this one does _not_ respect\n        LIFO (last-in, first-out).\n        This is due to the fact that attributes are stored in a random order when\n        initializing the model.\n\n        However, it will respect LIFO with respect to the internal `model_fields`.\n\n    \"\"\"\n    if not self:\n        raise KeyError(f\"popitem(): {self.__class__.__name__} is empty\")\n\n    key = list(self.keys())[-1]\n    value = self.pop(key)\n    return key, value\n</code></pre>"},{"location":"all_models/#oteapi.models.AttrDict.reset_field","title":"<code>reset_field(field)</code>","text":"<p>Reset a field to its default value.</p> Warning <p>This will remove/delete a field that is not part of the model schema.</p> <p>Parameters:</p> Name Type Description Default <code>field</code> <code>str</code> <p>The field to reset.</p> required Source code in <code>oteapi/models/genericconfig.py</code> <pre><code>def reset_field(self, field: str) -&gt; None:\n    \"\"\"Reset a field to its default value.\n\n    Warning:\n        This will remove/delete a field that is not part of the model schema.\n\n    Parameters:\n        field: The field to reset.\n\n    \"\"\"\n    if field not in self:\n        raise KeyError(f\"Field {field!r} does not exist.\")\n\n    if field in self.model_fields:\n        # Part of the model schema\n        schema_field = True\n\n        # Set the field to its default value\n        setattr(self, field, self.model_fields[field].default)\n    else:\n        # Not part of the model schema, but part of the extras\n        schema_field = False\n\n        # Remove the field altogether\n        if self.model_extra is None:\n            raise RuntimeError(\"Model has no extra fields.\")\n\n        try:\n            self.model_extra.pop(field)\n        except KeyError as exc:\n            raise RuntimeError(\n                f\"Field {field!r} can not be found in the model fields or extras.\"\n            ) from exc\n\n    # Remove it from fields set by the user\n    if field in self.model_fields_set:\n        self.model_fields_set.remove(field)\n\n    # Check the field has been properly reset\n    if schema_field:\n        if field not in self:\n            raise RuntimeError(f\"Field {field!r} was not reset as expected.\")\n        if self[field] != self.model_fields[field].default:\n            raise RuntimeError(\n                f\"Field {field!r} was not reset to its default value as expected.\"\n            )\n    else:\n        if field in self:\n            raise RuntimeError(f\"Field {field!r} was not removed as expected.\")\n    if field in self.model_fields_set:\n        raise RuntimeError(\n            f\"Field {field!r} was not removed from the set of user-set fields as \"\n            \"expected.\"\n        )\n</code></pre>"},{"location":"all_models/#oteapi.models.AttrDict.update","title":"<code>update(other=None, **kwargs)</code>","text":"Source code in <code>oteapi/models/genericconfig.py</code> <pre><code>def update(  # type: ignore[override]\n    self,\n    other: \"Optional[Union[Mapping[str, Any], Iterable[tuple[str, Any]]]]\" = None,\n    **kwargs,\n) -&gt; None:\n    if other and isinstance(other, Mapping):\n        for key, value in other.items():\n            setattr(self, key, value)\n    elif other and isinstance(other, BaseModel):\n        for key, value in other:\n            setattr(self, key, value)\n    elif other and isinstance(other, Iterable):\n        for entry in other:\n            if not isinstance(entry, tuple):\n                raise TypeError(\n                    \"`other` must be an iterable of tuples of length two.\"\n                )\n            if not len(entry) == 2:\n                raise ValueError(\n                    \"`other` must be an iterable of objects of length two.\"\n                )\n        for key, value in other:  # type: ignore[misc]\n            setattr(self, key, value)\n    elif other:\n        raise TypeError(\n            \"`other` must be of type `dict`, `Mapping`, `BaseModel` or \"\n            \"`Iterable`, not `{type(other).__name__}`.\"\n        )\n    if kwargs:\n        for key, value in kwargs.items():\n            setattr(self, key, value)\n</code></pre>"},{"location":"all_models/#oteapi.models.AttrDict.values","title":"<code>values()</code>","text":"Source code in <code>oteapi/models/genericconfig.py</code> <pre><code>def values(self):\n    return self.model_dump().values()\n</code></pre>"},{"location":"all_models/#oteapi.models.DataCacheConfig","title":"<code>DataCacheConfig</code>","text":"<p>               Bases: <code>AttrDict</code></p> <p>DataCache Configuration.</p> <p>This class should not be used directly as a configuration object for a strategy object, but only as a configuration field inside a configuration object.</p> Source code in <code>oteapi/models/datacacheconfig.py</code> <pre><code>class DataCacheConfig(AttrDict):\n    \"\"\"DataCache Configuration.\n\n    This class should not be used directly as a configuration object\n    for a strategy object, but only as a configuration field inside\n    a configuration object.\n    \"\"\"\n\n    cacheDir: Path = Field(Path(\"oteapi\"), description=\"Cache directory.\")\n    accessKey: Optional[str] = Field(\n        None,\n        description=\"Key with which the downloaded content can be accessed. \"\n        \"Should preferable be the hash (corresponding to `hashType`) of the \"\n        \"content if it is known.\",\n    )\n    hashType: str = Field(\n        \"md5\",\n        description=\"Hash algorithm to use for creating hash keys for stored \"\n        \"data. Can be any algorithm supported by hashlib.\",\n    )\n    expireTime: int = Field(\n        3600 * 24 * 14,\n        description=\"Number of seconds before the cache entry expires. \"\n        \"Zero means no expiration. Default is two weeks.\",\n    )\n    tag: Optional[str] = Field(\n        None,\n        description=\"Tag assigned to the downloaded content, typically \"\n        \"identifying a session. Used with the `evict()` method to clean up a \"\n        \"all cache entries with a given tag.\",\n    )\n</code></pre>"},{"location":"all_models/#oteapi.models.DataCacheConfig.accessKey","title":"<code>accessKey: Optional[str] = Field(None, description='Key with which the downloaded content can be accessed. Should preferable be the hash (corresponding to `hashType`) of the content if it is known.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_models/#oteapi.models.DataCacheConfig.cacheDir","title":"<code>cacheDir: Path = Field(Path('oteapi'), description='Cache directory.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_models/#oteapi.models.DataCacheConfig.expireTime","title":"<code>expireTime: int = Field(3600 * 24 * 14, description='Number of seconds before the cache entry expires. Zero means no expiration. Default is two weeks.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_models/#oteapi.models.DataCacheConfig.hashType","title":"<code>hashType: str = Field('md5', description='Hash algorithm to use for creating hash keys for stored data. Can be any algorithm supported by hashlib.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_models/#oteapi.models.DataCacheConfig.tag","title":"<code>tag: Optional[str] = Field(None, description='Tag assigned to the downloaded content, typically identifying a session. Used with the `evict()` method to clean up a all cache entries with a given tag.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_models/#oteapi.models.FilterConfig","title":"<code>FilterConfig</code>","text":"<p>               Bases: <code>GenericConfig</code></p> <p>Filter Strategy Data Configuration.</p> Source code in <code>oteapi/models/filterconfig.py</code> <pre><code>class FilterConfig(GenericConfig):\n    \"\"\"Filter Strategy Data Configuration.\"\"\"\n\n    filterType: str = Field(\n        ..., description=\"Type of registered filter strategy. E.g., `filter/sql`.\"\n    )\n    query: Optional[str] = Field(None, description=\"Define a query operation.\")\n    condition: Optional[str] = Field(\n        None,\n        description=\"Logical statement indicating when a filter should be applied.\",\n    )\n    limit: Optional[int] = Field(\n        None, description=\"Number of items remaining after a filter expression.\"\n    )\n</code></pre>"},{"location":"all_models/#oteapi.models.FilterConfig.condition","title":"<code>condition: Optional[str] = Field(None, description='Logical statement indicating when a filter should be applied.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_models/#oteapi.models.FilterConfig.filterType","title":"<code>filterType: str = Field(..., description='Type of registered filter strategy. E.g., `filter/sql`.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_models/#oteapi.models.FilterConfig.limit","title":"<code>limit: Optional[int] = Field(None, description='Number of items remaining after a filter expression.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_models/#oteapi.models.FilterConfig.query","title":"<code>query: Optional[str] = Field(None, description='Define a query operation.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_models/#oteapi.models.FunctionConfig","title":"<code>FunctionConfig</code>","text":"<p>               Bases: <code>GenericConfig</code>, <code>SecretConfig</code></p> <p>Function Strategy Data Configuration.</p> Source code in <code>oteapi/models/functionconfig.py</code> <pre><code>class FunctionConfig(GenericConfig, SecretConfig):\n    \"\"\"Function Strategy Data Configuration.\"\"\"\n\n    functionType: str = Field(\n        ...,\n        description=(\"Type of registered function strategy.\"),\n    )\n</code></pre>"},{"location":"all_models/#oteapi.models.FunctionConfig.functionType","title":"<code>functionType: str = Field(..., description='Type of registered function strategy.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_models/#oteapi.models.GenericConfig","title":"<code>GenericConfig</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Generic class for configuration objects.</p> <p>Special pydantic configuration settings:</p> <ul> <li><code>validate_assignment</code>   Validate and cast set values.   This is mainly relevant for sub-classes of <code>AttrDict</code>, where specific   attributes have been defined.</li> <li><code>arbitrary_types_allowed</code>   If a custom type is used for an attribute that doesn't have a <code>validate()</code>   method, don't fail setting the attribute.</li> </ul> Source code in <code>oteapi/models/genericconfig.py</code> <pre><code>class GenericConfig(BaseModel):\n    \"\"\"Generic class for configuration objects.\n\n    Special pydantic configuration settings:\n\n    - **`validate_assignment`**\n      Validate and cast set values.\n      This is mainly relevant for sub-classes of `AttrDict`, where specific\n      attributes have been defined.\n    - **`arbitrary_types_allowed`**\n      If a custom type is used for an attribute that doesn't have a `validate()`\n      method, don't fail setting the attribute.\n\n    \"\"\"\n\n    configuration: AttrDict = Field(\n        AttrDict(),\n        description=\"Model-specific configuration options which can either \"\n        \"be given as key/value-pairs or set as attributes.\",\n    )\n\n    description: str = Field(\n        __doc__,\n        description=\"A description of the configuration model.\",\n    )\n\n    @classmethod\n    def __init_subclass__(cls, **kwargs) -&gt; None:\n        \"\"\"Initialize subclass descriptions with their docstrings.\"\"\"\n        cls.model_fields[\"description\"].default = cls.__doc__\n\n    model_config = ConfigDict(validate_assignment=True, arbitrary_types_allowed=True)\n</code></pre>"},{"location":"all_models/#oteapi.models.GenericConfig.configuration","title":"<code>configuration: AttrDict = Field(AttrDict(), description='Model-specific configuration options which can either be given as key/value-pairs or set as attributes.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_models/#oteapi.models.GenericConfig.description","title":"<code>description: str = Field(__doc__, description='A description of the configuration model.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_models/#oteapi.models.GenericConfig.model_config","title":"<code>model_config = ConfigDict(validate_assignment=True, arbitrary_types_allowed=True)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_models/#oteapi.models.MappingConfig","title":"<code>MappingConfig</code>","text":"<p>               Bases: <code>GenericConfig</code></p> <p>Mapping Strategy Data Configuration.</p> Source code in <code>oteapi/models/mappingconfig.py</code> <pre><code>class MappingConfig(GenericConfig):\n    \"\"\"Mapping Strategy Data Configuration.\"\"\"\n\n    mappingType: str = Field(\n        ...,\n        description=\"Type of registered mapping strategy.\",\n    )\n    prefixes: Optional[Dict[str, str]] = Field(\n        None,\n        description=(\n            \"Dictionary of shortnames that expands to an IRI given as local \"\n            \"value/IRI-expansion-pairs.\"\n        ),\n    )\n    triples: Optional[Set[RDFTriple]] = Field(\n        None,\n        description=\"Set of RDF triples given as (subject, predicate, object).\",\n    )\n</code></pre>"},{"location":"all_models/#oteapi.models.MappingConfig.mappingType","title":"<code>mappingType: str = Field(..., description='Type of registered mapping strategy.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_models/#oteapi.models.MappingConfig.prefixes","title":"<code>prefixes: Optional[Dict[str, str]] = Field(None, description='Dictionary of shortnames that expands to an IRI given as local value/IRI-expansion-pairs.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_models/#oteapi.models.MappingConfig.triples","title":"<code>triples: Optional[Set[RDFTriple]] = Field(None, description='Set of RDF triples given as (subject, predicate, object).')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_models/#oteapi.models.ParserConfig","title":"<code>ParserConfig</code>","text":"<p>               Bases: <code>GenericConfig</code></p> <p>Parser Strategy Data Configuration.</p> Source code in <code>oteapi/models/parserconfig.py</code> <pre><code>class ParserConfig(GenericConfig):\n    \"\"\"Parser Strategy Data Configuration.\"\"\"\n\n    parserType: str = Field(..., description=\"Type of registered parser strategy.\")\n    entity: AnyHttpUrl = Field(..., description=\"IRI to the entity or collection.\")\n</code></pre>"},{"location":"all_models/#oteapi.models.ParserConfig.entity","title":"<code>entity: AnyHttpUrl = Field(..., description='IRI to the entity or collection.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_models/#oteapi.models.ParserConfig.parserType","title":"<code>parserType: str = Field(..., description='Type of registered parser strategy.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_models/#oteapi.models.ResourceConfig","title":"<code>ResourceConfig</code>","text":"<p>               Bases: <code>GenericConfig</code>, <code>SecretConfig</code></p> <p>Resource Strategy Data Configuration.</p> Important <p>Either of the pairs of attributes <code>downloadUrl</code>/<code>mediaType</code> or <code>accessUrl</code>/<code>accessService</code> MUST be specified.</p> Source code in <code>oteapi/models/resourceconfig.py</code> <pre><code>class ResourceConfig(GenericConfig, SecretConfig):\n    \"\"\"Resource Strategy Data Configuration.\n\n    Important:\n        Either of the pairs of attributes `downloadUrl`/`mediaType` or\n        `accessUrl`/`accessService` MUST be specified.\n\n    \"\"\"\n\n    resourceType: Optional[str] = Field(\n        None, description=\"Type of registered resource strategy.\"\n    )\n\n    downloadUrl: Optional[HostlessAnyUrl] = Field(\n        None,\n        description=(\n            \"Definition: The URL of the downloadable file in a given format. E.g. CSV \"\n            \"file or RDF file.\\n\\nUsage: `downloadURL` *SHOULD* be used for the URL at\"\n            \" which this distribution is available directly, typically through a HTTPS\"\n            \" GET request or SFTP.\"\n        ),\n    )\n    mediaType: Optional[str] = Field(\n        None,\n        description=(\n            \"The media type of the distribution as defined by IANA \"\n            \"[[IANA-MEDIA-TYPES](https://www.w3.org/TR/vocab-dcat-2/#bib-iana-media-types)]\"\n            \".\\n\\nUsage: This property *SHOULD* be used when the media\"\n            \" type of the distribution is defined in IANA \"\n            \"[[IANA-MEDIA-TYPES](https://www.w3.org/TR/vocab-dcat-2/#bib-iana-media-types)].\"\n        ),\n    )\n    accessUrl: Optional[HostlessAnyUrl] = Field(\n        None,\n        description=(\n            \"A URL of the resource that gives access to a distribution of \"\n            \"the dataset. E.g. landing page, feed, SPARQL endpoint.\\n\\nUsage: \"\n            \"`accessURL` *SHOULD* be used for the URL of a service or location that \"\n            \"can provide access to this distribution, typically through a Web form, \"\n            \"query or API call.\\n`downloadURL` is preferred for direct links to \"\n            \"downloadable resources.\"\n        ),\n    )\n    accessService: Optional[str] = Field(\n        None,\n        description=(\n            \"A data service that gives access to the distribution of the dataset.\"\n        ),\n    )\n    license: Optional[str] = Field(\n        None,\n        description=(\n            \"A legal document under which the distribution is made available.\"\n        ),\n    )\n    accessRights: Optional[str] = Field(\n        None,\n        description=(\n            \"A rights statement that concerns how the distribution is accessed.\"\n        ),\n    )\n    publisher: Optional[str] = Field(\n        None,\n        description=\"The entity responsible for making the resource/item available.\",\n    )\n\n    @model_validator(mode=\"after\")\n    def ensure_unique_url_pairs(self) -&gt; \"ResourceConfig\":\n        \"\"\"Ensure either downloadUrl/mediaType or accessUrl/accessService are defined.\n\n        It's fine to define them all, but at least one complete pair MUST be specified.\n        \"\"\"\n        if not (\n            all(getattr(self, _) for _ in [\"downloadUrl\", \"mediaType\"])\n            or all(getattr(self, _) for _ in [\"accessUrl\", \"accessService\"])\n        ):\n            raise ValueError(\n                \"Either of the pairs of attributes downloadUrl/mediaType or \"\n                \"accessUrl/accessService MUST be specified.\"\n            )\n        return self\n</code></pre>"},{"location":"all_models/#oteapi.models.ResourceConfig.accessRights","title":"<code>accessRights: Optional[str] = Field(None, description='A rights statement that concerns how the distribution is accessed.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_models/#oteapi.models.ResourceConfig.accessService","title":"<code>accessService: Optional[str] = Field(None, description='A data service that gives access to the distribution of the dataset.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_models/#oteapi.models.ResourceConfig.accessUrl","title":"<code>accessUrl: Optional[HostlessAnyUrl] = Field(None, description='A URL of the resource that gives access to a distribution of the dataset. E.g. landing page, feed, SPARQL endpoint.\\n\\nUsage: `accessURL` *SHOULD* be used for the URL of a service or location that can provide access to this distribution, typically through a Web form, query or API call.\\n`downloadURL` is preferred for direct links to downloadable resources.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_models/#oteapi.models.ResourceConfig.downloadUrl","title":"<code>downloadUrl: Optional[HostlessAnyUrl] = Field(None, description='Definition: The URL of the downloadable file in a given format. E.g. CSV file or RDF file.\\n\\nUsage: `downloadURL` *SHOULD* be used for the URL at which this distribution is available directly, typically through a HTTPS GET request or SFTP.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_models/#oteapi.models.ResourceConfig.license","title":"<code>license: Optional[str] = Field(None, description='A legal document under which the distribution is made available.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_models/#oteapi.models.ResourceConfig.mediaType","title":"<code>mediaType: Optional[str] = Field(None, description='The media type of the distribution as defined by IANA [[IANA-MEDIA-TYPES](https://www.w3.org/TR/vocab-dcat-2/#bib-iana-media-types)].\\n\\nUsage: This property *SHOULD* be used when the media type of the distribution is defined in IANA [[IANA-MEDIA-TYPES](https://www.w3.org/TR/vocab-dcat-2/#bib-iana-media-types)].')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_models/#oteapi.models.ResourceConfig.publisher","title":"<code>publisher: Optional[str] = Field(None, description='The entity responsible for making the resource/item available.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_models/#oteapi.models.ResourceConfig.resourceType","title":"<code>resourceType: Optional[str] = Field(None, description='Type of registered resource strategy.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_models/#oteapi.models.ResourceConfig.ensure_unique_url_pairs","title":"<code>ensure_unique_url_pairs()</code>","text":"<p>Ensure either downloadUrl/mediaType or accessUrl/accessService are defined.</p> <p>It's fine to define them all, but at least one complete pair MUST be specified.</p> Source code in <code>oteapi/models/resourceconfig.py</code> <pre><code>@model_validator(mode=\"after\")\ndef ensure_unique_url_pairs(self) -&gt; \"ResourceConfig\":\n    \"\"\"Ensure either downloadUrl/mediaType or accessUrl/accessService are defined.\n\n    It's fine to define them all, but at least one complete pair MUST be specified.\n    \"\"\"\n    if not (\n        all(getattr(self, _) for _ in [\"downloadUrl\", \"mediaType\"])\n        or all(getattr(self, _) for _ in [\"accessUrl\", \"accessService\"])\n    ):\n        raise ValueError(\n            \"Either of the pairs of attributes downloadUrl/mediaType or \"\n            \"accessUrl/accessService MUST be specified.\"\n        )\n    return self\n</code></pre>"},{"location":"all_models/#oteapi.models.SecretConfig","title":"<code>SecretConfig</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Simple model for handling secret in other config-models.</p> Source code in <code>oteapi/models/secretconfig.py</code> <pre><code>class SecretConfig(BaseModel):\n    \"\"\"Simple model for handling secret in other config-models.\"\"\"\n\n    user: Optional[TogglableSecretStr] = Field(\n        None, description=\"User name for authentication.\"\n    )\n    password: Optional[TogglableSecretStr] = Field(\n        None, description=\"Password for authentication.\"\n    )\n    token: Optional[TogglableSecretStr] = Field(\n        None,\n        description=(\n            \"An access token for providing access and meta data to an application.\"\n        ),\n    )\n    client_id: Optional[TogglableSecretStr] = Field(\n        None, description=\"Client ID for an OAUTH2 client.\"\n    )\n    client_secret: Optional[TogglableSecretStr] = Field(\n        None, description=\"Client secret for an OAUTH2 client.\"\n    )\n</code></pre>"},{"location":"all_models/#oteapi.models.SecretConfig.client_id","title":"<code>client_id: Optional[TogglableSecretStr] = Field(None, description='Client ID for an OAUTH2 client.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_models/#oteapi.models.SecretConfig.client_secret","title":"<code>client_secret: Optional[TogglableSecretStr] = Field(None, description='Client secret for an OAUTH2 client.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_models/#oteapi.models.SecretConfig.password","title":"<code>password: Optional[TogglableSecretStr] = Field(None, description='Password for authentication.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_models/#oteapi.models.SecretConfig.token","title":"<code>token: Optional[TogglableSecretStr] = Field(None, description='An access token for providing access and meta data to an application.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_models/#oteapi.models.SecretConfig.user","title":"<code>user: Optional[TogglableSecretStr] = Field(None, description='User name for authentication.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_models/#oteapi.models.TransformationConfig","title":"<code>TransformationConfig</code>","text":"<p>               Bases: <code>GenericConfig</code>, <code>SecretConfig</code></p> <p>Transformation Strategy Data Configuration.</p> Source code in <code>oteapi/models/transformationconfig.py</code> <pre><code>class TransformationConfig(GenericConfig, SecretConfig):\n    \"\"\"Transformation Strategy Data Configuration.\"\"\"\n\n    transformationType: str = Field(\n        ...,\n        description=(\n            \"Type of registered transformation strategy. E.g., `celery/remote`.\"\n        ),\n    )\n    name: Optional[str] = Field(\n        None, description=\"Human-readable name of the transformation strategy.\"\n    )\n    due: Optional[datetime] = Field(\n        None,\n        description=(\n            \"Optional field to indicate a due data/time for when a transformation \"\n            \"should finish.\"\n        ),\n    )\n    priority: Optional[ProcessPriority] = Field(\n        ProcessPriority.MEDIUM,\n        description=\"Define the process priority of the transformation execution.\",\n    )\n</code></pre>"},{"location":"all_models/#oteapi.models.TransformationConfig.due","title":"<code>due: Optional[datetime] = Field(None, description='Optional field to indicate a due data/time for when a transformation should finish.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_models/#oteapi.models.TransformationConfig.name","title":"<code>name: Optional[str] = Field(None, description='Human-readable name of the transformation strategy.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_models/#oteapi.models.TransformationConfig.priority","title":"<code>priority: Optional[ProcessPriority] = Field(ProcessPriority.MEDIUM, description='Define the process priority of the transformation execution.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_models/#oteapi.models.TransformationConfig.transformationType","title":"<code>transformationType: str = Field(..., description='Type of registered transformation strategy. E.g., `celery/remote`.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_models/#oteapi.models.TransformationStatus","title":"<code>TransformationStatus</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Return from transformation status.</p> Source code in <code>oteapi/models/transformationconfig.py</code> <pre><code>class TransformationStatus(BaseModel):\n    \"\"\"Return from transformation status.\"\"\"\n\n    id: str = Field(..., description=\"ID for the given transformation process.\")\n    status: Optional[str] = Field(\n        None, description=\"Status for the transformation process.\"\n    )\n    messages: Optional[List[str]] = Field(\n        None, description=\"Messages related to the transformation process.\"\n    )\n    created: Optional[datetime] = Field(\n        None,\n        description=\"Time of creation for the transformation process. Given in UTC.\",\n    )\n    startTime: Optional[datetime] = Field(\n        None, description=\"Time when the transformation process started. Given in UTC.\"\n    )\n    finishTime: Optional[datetime] = Field(\n        None, description=\"Time when the tranformation process finished. Given in UTC.\"\n    )\n</code></pre>"},{"location":"all_models/#oteapi.models.TransformationStatus.created","title":"<code>created: Optional[datetime] = Field(None, description='Time of creation for the transformation process. Given in UTC.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_models/#oteapi.models.TransformationStatus.finishTime","title":"<code>finishTime: Optional[datetime] = Field(None, description='Time when the tranformation process finished. Given in UTC.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_models/#oteapi.models.TransformationStatus.id","title":"<code>id: str = Field(..., description='ID for the given transformation process.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_models/#oteapi.models.TransformationStatus.messages","title":"<code>messages: Optional[List[str]] = Field(None, description='Messages related to the transformation process.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_models/#oteapi.models.TransformationStatus.startTime","title":"<code>startTime: Optional[datetime] = Field(None, description='Time when the transformation process started. Given in UTC.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_models/#oteapi.models.TransformationStatus.status","title":"<code>status: Optional[str] = Field(None, description='Status for the transformation process.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_models/#oteapi.models.TripleStoreConfig","title":"<code>TripleStoreConfig</code>","text":"<p>               Bases: <code>GenericConfig</code>, <code>SecretConfig</code></p> <p>TripleStore Configuration.</p> <p>This is a configuration for the <code>TripleStore</code>.</p> <p>This class should not be used directly as a configuration object for a strategy object, but only as a configuration field inside a configuration object.</p> Source code in <code>oteapi/models/triplestoreconfig.py</code> <pre><code>class TripleStoreConfig(GenericConfig, SecretConfig):\n    \"\"\"TripleStore Configuration.\n\n    This is a configuration for the\n    [`TripleStore`][oteapi.triplestore.triplestore.TripleStore].\n\n    This class should not be used directly as a configuration object\n    for a strategy object, but only as a configuration field inside\n    a configuration object.\n    \"\"\"\n\n    repositoryName: str = Field(\n        ..., description=\"The repository name, where the mappings are stored.\"\n    )\n    agraphHost: str = Field(..., description=\"AllegroGraph host name.\")\n    agraphPort: int = Field(..., description=\"AllegroGraph port number.\")\n\n    # Exclude these inherited fields from serialization\n    token: Annotated[ExcludeTogglableSecretStr, SecretConfig.model_fields[\"token\"]] = (\n        SecretConfig.model_fields[\"token\"].default\n    )\n    client_id: Annotated[\n        ExcludeTogglableSecretStr, SecretConfig.model_fields[\"client_id\"]\n    ] = SecretConfig.model_fields[\"client_id\"].default\n    client_secret: Annotated[\n        ExcludeTogglableSecretStr, SecretConfig.model_fields[\"client_secret\"]\n    ] = SecretConfig.model_fields[\"client_secret\"].default\n\n    @model_validator(mode=\"after\")\n    def ensure_user_pass(self) -&gt; \"TripleStoreConfig\":\n        \"\"\"Ensure that user/password are set, since they are optional in the\n        SecretConfig.\"\"\"\n        if not all(getattr(self, _) for _ in [\"user\", \"password\"]):\n            raise ValueError(\"User and password must be defined.\")\n        return self\n</code></pre>"},{"location":"all_models/#oteapi.models.TripleStoreConfig.agraphHost","title":"<code>agraphHost: str = Field(..., description='AllegroGraph host name.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_models/#oteapi.models.TripleStoreConfig.agraphPort","title":"<code>agraphPort: int = Field(..., description='AllegroGraph port number.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_models/#oteapi.models.TripleStoreConfig.client_id","title":"<code>client_id: Annotated[ExcludeTogglableSecretStr, SecretConfig.model_fields[client_id]] = SecretConfig.model_fields['client_id'].default</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_models/#oteapi.models.TripleStoreConfig.client_secret","title":"<code>client_secret: Annotated[ExcludeTogglableSecretStr, SecretConfig.model_fields[client_secret]] = SecretConfig.model_fields['client_secret'].default</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_models/#oteapi.models.TripleStoreConfig.repositoryName","title":"<code>repositoryName: str = Field(..., description='The repository name, where the mappings are stored.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_models/#oteapi.models.TripleStoreConfig.token","title":"<code>token: Annotated[ExcludeTogglableSecretStr, SecretConfig.model_fields[token]] = SecretConfig.model_fields['token'].default</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_models/#oteapi.models.TripleStoreConfig.ensure_user_pass","title":"<code>ensure_user_pass()</code>","text":"<p>Ensure that user/password are set, since they are optional in the SecretConfig.</p> Source code in <code>oteapi/models/triplestoreconfig.py</code> <pre><code>@model_validator(mode=\"after\")\ndef ensure_user_pass(self) -&gt; \"TripleStoreConfig\":\n    \"\"\"Ensure that user/password are set, since they are optional in the\n    SecretConfig.\"\"\"\n    if not all(getattr(self, _) for _ in [\"user\", \"password\"]):\n        raise ValueError(\"User and password must be defined.\")\n    return self\n</code></pre>"},{"location":"all_models/#oteapi.models.datacacheconfig","title":"<code>datacacheconfig</code>","text":"<p>Pydantic DataCache Configuration Data Model.</p>"},{"location":"all_models/#oteapi.models.datacacheconfig.DataCacheConfig","title":"<code>DataCacheConfig</code>","text":"<p>               Bases: <code>AttrDict</code></p> <p>DataCache Configuration.</p> <p>This class should not be used directly as a configuration object for a strategy object, but only as a configuration field inside a configuration object.</p> Source code in <code>oteapi/models/datacacheconfig.py</code> <pre><code>class DataCacheConfig(AttrDict):\n    \"\"\"DataCache Configuration.\n\n    This class should not be used directly as a configuration object\n    for a strategy object, but only as a configuration field inside\n    a configuration object.\n    \"\"\"\n\n    cacheDir: Path = Field(Path(\"oteapi\"), description=\"Cache directory.\")\n    accessKey: Optional[str] = Field(\n        None,\n        description=\"Key with which the downloaded content can be accessed. \"\n        \"Should preferable be the hash (corresponding to `hashType`) of the \"\n        \"content if it is known.\",\n    )\n    hashType: str = Field(\n        \"md5\",\n        description=\"Hash algorithm to use for creating hash keys for stored \"\n        \"data. Can be any algorithm supported by hashlib.\",\n    )\n    expireTime: int = Field(\n        3600 * 24 * 14,\n        description=\"Number of seconds before the cache entry expires. \"\n        \"Zero means no expiration. Default is two weeks.\",\n    )\n    tag: Optional[str] = Field(\n        None,\n        description=\"Tag assigned to the downloaded content, typically \"\n        \"identifying a session. Used with the `evict()` method to clean up a \"\n        \"all cache entries with a given tag.\",\n    )\n</code></pre>"},{"location":"all_models/#oteapi.models.datacacheconfig.DataCacheConfig.accessKey","title":"<code>accessKey: Optional[str] = Field(None, description='Key with which the downloaded content can be accessed. Should preferable be the hash (corresponding to `hashType`) of the content if it is known.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_models/#oteapi.models.datacacheconfig.DataCacheConfig.cacheDir","title":"<code>cacheDir: Path = Field(Path('oteapi'), description='Cache directory.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_models/#oteapi.models.datacacheconfig.DataCacheConfig.expireTime","title":"<code>expireTime: int = Field(3600 * 24 * 14, description='Number of seconds before the cache entry expires. Zero means no expiration. Default is two weeks.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_models/#oteapi.models.datacacheconfig.DataCacheConfig.hashType","title":"<code>hashType: str = Field('md5', description='Hash algorithm to use for creating hash keys for stored data. Can be any algorithm supported by hashlib.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_models/#oteapi.models.datacacheconfig.DataCacheConfig.tag","title":"<code>tag: Optional[str] = Field(None, description='Tag assigned to the downloaded content, typically identifying a session. Used with the `evict()` method to clean up a all cache entries with a given tag.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_models/#oteapi.models.filterconfig","title":"<code>filterconfig</code>","text":"<p>Pydantic Filter Configuration Data Model.</p>"},{"location":"all_models/#oteapi.models.filterconfig.FilterConfig","title":"<code>FilterConfig</code>","text":"<p>               Bases: <code>GenericConfig</code></p> <p>Filter Strategy Data Configuration.</p> Source code in <code>oteapi/models/filterconfig.py</code> <pre><code>class FilterConfig(GenericConfig):\n    \"\"\"Filter Strategy Data Configuration.\"\"\"\n\n    filterType: str = Field(\n        ..., description=\"Type of registered filter strategy. E.g., `filter/sql`.\"\n    )\n    query: Optional[str] = Field(None, description=\"Define a query operation.\")\n    condition: Optional[str] = Field(\n        None,\n        description=\"Logical statement indicating when a filter should be applied.\",\n    )\n    limit: Optional[int] = Field(\n        None, description=\"Number of items remaining after a filter expression.\"\n    )\n</code></pre>"},{"location":"all_models/#oteapi.models.filterconfig.FilterConfig.condition","title":"<code>condition: Optional[str] = Field(None, description='Logical statement indicating when a filter should be applied.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_models/#oteapi.models.filterconfig.FilterConfig.filterType","title":"<code>filterType: str = Field(..., description='Type of registered filter strategy. E.g., `filter/sql`.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_models/#oteapi.models.filterconfig.FilterConfig.limit","title":"<code>limit: Optional[int] = Field(None, description='Number of items remaining after a filter expression.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_models/#oteapi.models.filterconfig.FilterConfig.query","title":"<code>query: Optional[str] = Field(None, description='Define a query operation.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_models/#oteapi.models.functionconfig","title":"<code>functionconfig</code>","text":"<p>Pydantic Function Configuration Data Model.</p>"},{"location":"all_models/#oteapi.models.functionconfig.FunctionConfig","title":"<code>FunctionConfig</code>","text":"<p>               Bases: <code>GenericConfig</code>, <code>SecretConfig</code></p> <p>Function Strategy Data Configuration.</p> Source code in <code>oteapi/models/functionconfig.py</code> <pre><code>class FunctionConfig(GenericConfig, SecretConfig):\n    \"\"\"Function Strategy Data Configuration.\"\"\"\n\n    functionType: str = Field(\n        ...,\n        description=(\"Type of registered function strategy.\"),\n    )\n</code></pre>"},{"location":"all_models/#oteapi.models.functionconfig.FunctionConfig.functionType","title":"<code>functionType: str = Field(..., description='Type of registered function strategy.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_models/#oteapi.models.genericconfig","title":"<code>genericconfig</code>","text":"<p>Generic data model for configuration attributes.</p>"},{"location":"all_models/#oteapi.models.genericconfig.AttrDict","title":"<code>AttrDict</code>","text":"<p>               Bases: <code>BaseModel</code>, <code>MutableMapping</code></p> <p>An object whose attributes can also be accessed through subscription, like with a dictionary.</p> <p>Special pydantic configuration settings:</p> <ul> <li><code>extra</code>   Allow any attributes/fields to be defined - this is what makes this pydantic   model an attribute dictionary.</li> <li><code>validate_assignment</code>   Validate and cast set values.   This is mainly relevant for sub-classes of <code>AttrDict</code>, where specific   attributes have been defined.</li> <li><code>arbitrary_types_allowed</code>   If a custom type is used for an attribute that doesn't have a <code>validate()</code>   method, don't fail setting the attribute.</li> </ul> Source code in <code>oteapi/models/genericconfig.py</code> <pre><code>class AttrDict(BaseModel, MutableMapping):\n    \"\"\"An object whose attributes can also be accessed through\n    subscription, like with a dictionary.\n\n    Special pydantic configuration settings:\n\n    - **`extra`**\n      Allow any attributes/fields to be defined - this is what makes this pydantic\n      model an attribute dictionary.\n    - **`validate_assignment`**\n      Validate and cast set values.\n      This is mainly relevant for sub-classes of `AttrDict`, where specific\n      attributes have been defined.\n    - **`arbitrary_types_allowed`**\n      If a custom type is used for an attribute that doesn't have a `validate()`\n      method, don't fail setting the attribute.\n\n    \"\"\"\n\n    model_config = ConfigDict(\n        extra=\"allow\", validate_assignment=True, arbitrary_types_allowed=True\n    )\n\n    # Collection methods\n    def __contains__(self, key: object) -&gt; bool:\n        if not isinstance(key, str):\n            raise TypeError(f\"Keys must be of type `str`, not `{type(key).__name__}`.\")\n        return hasattr(self, key)\n\n    def __len__(self) -&gt; int:\n        return len(self.model_dump())\n\n    # Mapping methods\n    def __getitem__(self, key: \"Any\") -&gt; \"Any\":\n        if not isinstance(key, str):\n            raise TypeError(f\"Keys must be of type `str`, not `{type(key).__name__}`.\")\n        try:\n            return getattr(self, key)\n        except AttributeError as exc:\n            raise KeyError(key) from exc\n\n    def items(self):\n        return self.model_dump().items()\n\n    def keys(self):\n        return self.model_dump().keys()\n\n    def values(self):\n        return self.model_dump().values()\n\n    def get(self, key: str, default: \"Optional[Any]\" = None) -&gt; \"Any\":\n        return getattr(self, key, default)\n\n    def __eq__(self, value: object) -&gt; bool:\n        if isinstance(value, Mapping):\n            return self.model_dump() == value\n        if isinstance(value, BaseModel):\n            return BaseModel.__eq__(self, value)\n        return False\n\n    # MutableMapping methods\n    def __setitem__(self, key: \"Any\", value: \"Any\") -&gt; None:\n        if not isinstance(key, str):\n            raise TypeError(f\"Keys must be of type `str`, not `{type(key).__name__}`.\")\n        try:\n            return self.__setattr__(key, value)\n        except AttributeError as exc:\n            raise KeyError(key) from exc\n\n    def __delitem__(self, key: \"Any\") -&gt; None:\n        warnings.warn(\n            \"Item deletion used to reset fields to their default values. To keep using\"\n            \" this functionality, use the `reset_field()` method.\",\n            DeprecationWarning,\n        )\n\n        if not isinstance(key, str):\n            raise TypeError(f\"Keys must be of type `str`, not `{type(key).__name__}`.\")\n        try:\n            self.__delattr__(key)\n        except AttributeError as exc:\n            raise KeyError(key) from exc\n        else:\n            if key in self.model_fields_set:\n                self.model_fields_set.remove(key)\n\n    def clear(self) -&gt; None:\n        # Ignore the deprecation warning from `__delitem__`\n        with warnings.catch_warnings():\n            warnings.simplefilter(\"ignore\", DeprecationWarning)\n\n            for field in self.model_dump():\n                del self[field]\n\n    def update(  # type: ignore[override]\n        self,\n        other: \"Optional[Union[Mapping[str, Any], Iterable[tuple[str, Any]]]]\" = None,\n        **kwargs,\n    ) -&gt; None:\n        if other and isinstance(other, Mapping):\n            for key, value in other.items():\n                setattr(self, key, value)\n        elif other and isinstance(other, BaseModel):\n            for key, value in other:\n                setattr(self, key, value)\n        elif other and isinstance(other, Iterable):\n            for entry in other:\n                if not isinstance(entry, tuple):\n                    raise TypeError(\n                        \"`other` must be an iterable of tuples of length two.\"\n                    )\n                if not len(entry) == 2:\n                    raise ValueError(\n                        \"`other` must be an iterable of objects of length two.\"\n                    )\n            for key, value in other:  # type: ignore[misc]\n                setattr(self, key, value)\n        elif other:\n            raise TypeError(\n                \"`other` must be of type `dict`, `Mapping`, `BaseModel` or \"\n                \"`Iterable`, not `{type(other).__name__}`.\"\n            )\n        if kwargs:\n            for key, value in kwargs.items():\n                setattr(self, key, value)\n\n    def pop(self, key: str, default: \"Optional[Any]\" = PydanticUndefined) -&gt; \"Any\":\n        value = self.get(key, default)\n        if value == PydanticUndefined:\n            raise KeyError(key)\n        if key in self:\n            # Ignore the deprecation warning from `__delitem__`\n            with warnings.catch_warnings():\n                warnings.simplefilter(\"ignore\", DeprecationWarning)\n\n                del self[key]\n        return value\n\n    def popitem(self) -&gt; \"Tuple[str, Any]\":\n        \"\"\"MutableMapping `popitem`-method.\n\n        Important:\n            Unlike the regular `dict.popitem()` method, this one does _not_ respect\n            LIFO (last-in, first-out).\n            This is due to the fact that attributes are stored in a random order when\n            initializing the model.\n\n            However, it will respect LIFO with respect to the internal `model_fields`.\n\n        \"\"\"\n        if not self:\n            raise KeyError(f\"popitem(): {self.__class__.__name__} is empty\")\n\n        key = list(self.keys())[-1]\n        value = self.pop(key)\n        return key, value\n\n    def reset_field(self, field: str) -&gt; None:\n        \"\"\"Reset a field to its default value.\n\n        Warning:\n            This will remove/delete a field that is not part of the model schema.\n\n        Parameters:\n            field: The field to reset.\n\n        \"\"\"\n        if field not in self:\n            raise KeyError(f\"Field {field!r} does not exist.\")\n\n        if field in self.model_fields:\n            # Part of the model schema\n            schema_field = True\n\n            # Set the field to its default value\n            setattr(self, field, self.model_fields[field].default)\n        else:\n            # Not part of the model schema, but part of the extras\n            schema_field = False\n\n            # Remove the field altogether\n            if self.model_extra is None:\n                raise RuntimeError(\"Model has no extra fields.\")\n\n            try:\n                self.model_extra.pop(field)\n            except KeyError as exc:\n                raise RuntimeError(\n                    f\"Field {field!r} can not be found in the model fields or extras.\"\n                ) from exc\n\n        # Remove it from fields set by the user\n        if field in self.model_fields_set:\n            self.model_fields_set.remove(field)\n\n        # Check the field has been properly reset\n        if schema_field:\n            if field not in self:\n                raise RuntimeError(f\"Field {field!r} was not reset as expected.\")\n            if self[field] != self.model_fields[field].default:\n                raise RuntimeError(\n                    f\"Field {field!r} was not reset to its default value as expected.\"\n                )\n        else:\n            if field in self:\n                raise RuntimeError(f\"Field {field!r} was not removed as expected.\")\n        if field in self.model_fields_set:\n            raise RuntimeError(\n                f\"Field {field!r} was not removed from the set of user-set fields as \"\n                \"expected.\"\n            )\n</code></pre>"},{"location":"all_models/#oteapi.models.genericconfig.AttrDict.model_config","title":"<code>model_config = ConfigDict(extra='allow', validate_assignment=True, arbitrary_types_allowed=True)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_models/#oteapi.models.genericconfig.AttrDict.clear","title":"<code>clear()</code>","text":"Source code in <code>oteapi/models/genericconfig.py</code> <pre><code>def clear(self) -&gt; None:\n    # Ignore the deprecation warning from `__delitem__`\n    with warnings.catch_warnings():\n        warnings.simplefilter(\"ignore\", DeprecationWarning)\n\n        for field in self.model_dump():\n            del self[field]\n</code></pre>"},{"location":"all_models/#oteapi.models.genericconfig.AttrDict.get","title":"<code>get(key, default=None)</code>","text":"Source code in <code>oteapi/models/genericconfig.py</code> <pre><code>def get(self, key: str, default: \"Optional[Any]\" = None) -&gt; \"Any\":\n    return getattr(self, key, default)\n</code></pre>"},{"location":"all_models/#oteapi.models.genericconfig.AttrDict.items","title":"<code>items()</code>","text":"Source code in <code>oteapi/models/genericconfig.py</code> <pre><code>def items(self):\n    return self.model_dump().items()\n</code></pre>"},{"location":"all_models/#oteapi.models.genericconfig.AttrDict.keys","title":"<code>keys()</code>","text":"Source code in <code>oteapi/models/genericconfig.py</code> <pre><code>def keys(self):\n    return self.model_dump().keys()\n</code></pre>"},{"location":"all_models/#oteapi.models.genericconfig.AttrDict.pop","title":"<code>pop(key, default=PydanticUndefined)</code>","text":"Source code in <code>oteapi/models/genericconfig.py</code> <pre><code>def pop(self, key: str, default: \"Optional[Any]\" = PydanticUndefined) -&gt; \"Any\":\n    value = self.get(key, default)\n    if value == PydanticUndefined:\n        raise KeyError(key)\n    if key in self:\n        # Ignore the deprecation warning from `__delitem__`\n        with warnings.catch_warnings():\n            warnings.simplefilter(\"ignore\", DeprecationWarning)\n\n            del self[key]\n    return value\n</code></pre>"},{"location":"all_models/#oteapi.models.genericconfig.AttrDict.popitem","title":"<code>popitem()</code>","text":"<p>MutableMapping <code>popitem</code>-method.</p> Important <p>Unlike the regular <code>dict.popitem()</code> method, this one does not respect LIFO (last-in, first-out). This is due to the fact that attributes are stored in a random order when initializing the model.</p> <p>However, it will respect LIFO with respect to the internal <code>model_fields</code>.</p> Source code in <code>oteapi/models/genericconfig.py</code> <pre><code>def popitem(self) -&gt; \"Tuple[str, Any]\":\n    \"\"\"MutableMapping `popitem`-method.\n\n    Important:\n        Unlike the regular `dict.popitem()` method, this one does _not_ respect\n        LIFO (last-in, first-out).\n        This is due to the fact that attributes are stored in a random order when\n        initializing the model.\n\n        However, it will respect LIFO with respect to the internal `model_fields`.\n\n    \"\"\"\n    if not self:\n        raise KeyError(f\"popitem(): {self.__class__.__name__} is empty\")\n\n    key = list(self.keys())[-1]\n    value = self.pop(key)\n    return key, value\n</code></pre>"},{"location":"all_models/#oteapi.models.genericconfig.AttrDict.reset_field","title":"<code>reset_field(field)</code>","text":"<p>Reset a field to its default value.</p> Warning <p>This will remove/delete a field that is not part of the model schema.</p> <p>Parameters:</p> Name Type Description Default <code>field</code> <code>str</code> <p>The field to reset.</p> required Source code in <code>oteapi/models/genericconfig.py</code> <pre><code>def reset_field(self, field: str) -&gt; None:\n    \"\"\"Reset a field to its default value.\n\n    Warning:\n        This will remove/delete a field that is not part of the model schema.\n\n    Parameters:\n        field: The field to reset.\n\n    \"\"\"\n    if field not in self:\n        raise KeyError(f\"Field {field!r} does not exist.\")\n\n    if field in self.model_fields:\n        # Part of the model schema\n        schema_field = True\n\n        # Set the field to its default value\n        setattr(self, field, self.model_fields[field].default)\n    else:\n        # Not part of the model schema, but part of the extras\n        schema_field = False\n\n        # Remove the field altogether\n        if self.model_extra is None:\n            raise RuntimeError(\"Model has no extra fields.\")\n\n        try:\n            self.model_extra.pop(field)\n        except KeyError as exc:\n            raise RuntimeError(\n                f\"Field {field!r} can not be found in the model fields or extras.\"\n            ) from exc\n\n    # Remove it from fields set by the user\n    if field in self.model_fields_set:\n        self.model_fields_set.remove(field)\n\n    # Check the field has been properly reset\n    if schema_field:\n        if field not in self:\n            raise RuntimeError(f\"Field {field!r} was not reset as expected.\")\n        if self[field] != self.model_fields[field].default:\n            raise RuntimeError(\n                f\"Field {field!r} was not reset to its default value as expected.\"\n            )\n    else:\n        if field in self:\n            raise RuntimeError(f\"Field {field!r} was not removed as expected.\")\n    if field in self.model_fields_set:\n        raise RuntimeError(\n            f\"Field {field!r} was not removed from the set of user-set fields as \"\n            \"expected.\"\n        )\n</code></pre>"},{"location":"all_models/#oteapi.models.genericconfig.AttrDict.update","title":"<code>update(other=None, **kwargs)</code>","text":"Source code in <code>oteapi/models/genericconfig.py</code> <pre><code>def update(  # type: ignore[override]\n    self,\n    other: \"Optional[Union[Mapping[str, Any], Iterable[tuple[str, Any]]]]\" = None,\n    **kwargs,\n) -&gt; None:\n    if other and isinstance(other, Mapping):\n        for key, value in other.items():\n            setattr(self, key, value)\n    elif other and isinstance(other, BaseModel):\n        for key, value in other:\n            setattr(self, key, value)\n    elif other and isinstance(other, Iterable):\n        for entry in other:\n            if not isinstance(entry, tuple):\n                raise TypeError(\n                    \"`other` must be an iterable of tuples of length two.\"\n                )\n            if not len(entry) == 2:\n                raise ValueError(\n                    \"`other` must be an iterable of objects of length two.\"\n                )\n        for key, value in other:  # type: ignore[misc]\n            setattr(self, key, value)\n    elif other:\n        raise TypeError(\n            \"`other` must be of type `dict`, `Mapping`, `BaseModel` or \"\n            \"`Iterable`, not `{type(other).__name__}`.\"\n        )\n    if kwargs:\n        for key, value in kwargs.items():\n            setattr(self, key, value)\n</code></pre>"},{"location":"all_models/#oteapi.models.genericconfig.AttrDict.values","title":"<code>values()</code>","text":"Source code in <code>oteapi/models/genericconfig.py</code> <pre><code>def values(self):\n    return self.model_dump().values()\n</code></pre>"},{"location":"all_models/#oteapi.models.genericconfig.GenericConfig","title":"<code>GenericConfig</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Generic class for configuration objects.</p> <p>Special pydantic configuration settings:</p> <ul> <li><code>validate_assignment</code>   Validate and cast set values.   This is mainly relevant for sub-classes of <code>AttrDict</code>, where specific   attributes have been defined.</li> <li><code>arbitrary_types_allowed</code>   If a custom type is used for an attribute that doesn't have a <code>validate()</code>   method, don't fail setting the attribute.</li> </ul> Source code in <code>oteapi/models/genericconfig.py</code> <pre><code>class GenericConfig(BaseModel):\n    \"\"\"Generic class for configuration objects.\n\n    Special pydantic configuration settings:\n\n    - **`validate_assignment`**\n      Validate and cast set values.\n      This is mainly relevant for sub-classes of `AttrDict`, where specific\n      attributes have been defined.\n    - **`arbitrary_types_allowed`**\n      If a custom type is used for an attribute that doesn't have a `validate()`\n      method, don't fail setting the attribute.\n\n    \"\"\"\n\n    configuration: AttrDict = Field(\n        AttrDict(),\n        description=\"Model-specific configuration options which can either \"\n        \"be given as key/value-pairs or set as attributes.\",\n    )\n\n    description: str = Field(\n        __doc__,\n        description=\"A description of the configuration model.\",\n    )\n\n    @classmethod\n    def __init_subclass__(cls, **kwargs) -&gt; None:\n        \"\"\"Initialize subclass descriptions with their docstrings.\"\"\"\n        cls.model_fields[\"description\"].default = cls.__doc__\n\n    model_config = ConfigDict(validate_assignment=True, arbitrary_types_allowed=True)\n</code></pre>"},{"location":"all_models/#oteapi.models.genericconfig.GenericConfig.configuration","title":"<code>configuration: AttrDict = Field(AttrDict(), description='Model-specific configuration options which can either be given as key/value-pairs or set as attributes.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_models/#oteapi.models.genericconfig.GenericConfig.description","title":"<code>description: str = Field(__doc__, description='A description of the configuration model.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_models/#oteapi.models.genericconfig.GenericConfig.model_config","title":"<code>model_config = ConfigDict(validate_assignment=True, arbitrary_types_allowed=True)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_models/#oteapi.models.mappingconfig","title":"<code>mappingconfig</code>","text":"<p>Pydantic Mapping Configuration Data Model.</p>"},{"location":"all_models/#oteapi.models.mappingconfig.RDFTriple","title":"<code>RDFTriple = Tuple[str, str, str]</code>  <code>module-attribute</code>","text":""},{"location":"all_models/#oteapi.models.mappingconfig.MappingConfig","title":"<code>MappingConfig</code>","text":"<p>               Bases: <code>GenericConfig</code></p> <p>Mapping Strategy Data Configuration.</p> Source code in <code>oteapi/models/mappingconfig.py</code> <pre><code>class MappingConfig(GenericConfig):\n    \"\"\"Mapping Strategy Data Configuration.\"\"\"\n\n    mappingType: str = Field(\n        ...,\n        description=\"Type of registered mapping strategy.\",\n    )\n    prefixes: Optional[Dict[str, str]] = Field(\n        None,\n        description=(\n            \"Dictionary of shortnames that expands to an IRI given as local \"\n            \"value/IRI-expansion-pairs.\"\n        ),\n    )\n    triples: Optional[Set[RDFTriple]] = Field(\n        None,\n        description=\"Set of RDF triples given as (subject, predicate, object).\",\n    )\n</code></pre>"},{"location":"all_models/#oteapi.models.mappingconfig.MappingConfig.mappingType","title":"<code>mappingType: str = Field(..., description='Type of registered mapping strategy.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_models/#oteapi.models.mappingconfig.MappingConfig.prefixes","title":"<code>prefixes: Optional[Dict[str, str]] = Field(None, description='Dictionary of shortnames that expands to an IRI given as local value/IRI-expansion-pairs.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_models/#oteapi.models.mappingconfig.MappingConfig.triples","title":"<code>triples: Optional[Set[RDFTriple]] = Field(None, description='Set of RDF triples given as (subject, predicate, object).')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_models/#oteapi.models.parserconfig","title":"<code>parserconfig</code>","text":"<p>Pydantic Parser Configuration Data Model.</p>"},{"location":"all_models/#oteapi.models.parserconfig.ParserConfig","title":"<code>ParserConfig</code>","text":"<p>               Bases: <code>GenericConfig</code></p> <p>Parser Strategy Data Configuration.</p> Source code in <code>oteapi/models/parserconfig.py</code> <pre><code>class ParserConfig(GenericConfig):\n    \"\"\"Parser Strategy Data Configuration.\"\"\"\n\n    parserType: str = Field(..., description=\"Type of registered parser strategy.\")\n    entity: AnyHttpUrl = Field(..., description=\"IRI to the entity or collection.\")\n</code></pre>"},{"location":"all_models/#oteapi.models.parserconfig.ParserConfig.entity","title":"<code>entity: AnyHttpUrl = Field(..., description='IRI to the entity or collection.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_models/#oteapi.models.parserconfig.ParserConfig.parserType","title":"<code>parserType: str = Field(..., description='Type of registered parser strategy.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_models/#oteapi.models.resourceconfig","title":"<code>resourceconfig</code>","text":"<p>Pydantic Resource Configuration Data Model.</p>"},{"location":"all_models/#oteapi.models.resourceconfig.HostlessAnyUrl","title":"<code>HostlessAnyUrl = Annotated[Url, UrlConstraints(host_required=False)]</code>  <code>module-attribute</code>","text":""},{"location":"all_models/#oteapi.models.resourceconfig.ResourceConfig","title":"<code>ResourceConfig</code>","text":"<p>               Bases: <code>GenericConfig</code>, <code>SecretConfig</code></p> <p>Resource Strategy Data Configuration.</p> Important <p>Either of the pairs of attributes <code>downloadUrl</code>/<code>mediaType</code> or <code>accessUrl</code>/<code>accessService</code> MUST be specified.</p> Source code in <code>oteapi/models/resourceconfig.py</code> <pre><code>class ResourceConfig(GenericConfig, SecretConfig):\n    \"\"\"Resource Strategy Data Configuration.\n\n    Important:\n        Either of the pairs of attributes `downloadUrl`/`mediaType` or\n        `accessUrl`/`accessService` MUST be specified.\n\n    \"\"\"\n\n    resourceType: Optional[str] = Field(\n        None, description=\"Type of registered resource strategy.\"\n    )\n\n    downloadUrl: Optional[HostlessAnyUrl] = Field(\n        None,\n        description=(\n            \"Definition: The URL of the downloadable file in a given format. E.g. CSV \"\n            \"file or RDF file.\\n\\nUsage: `downloadURL` *SHOULD* be used for the URL at\"\n            \" which this distribution is available directly, typically through a HTTPS\"\n            \" GET request or SFTP.\"\n        ),\n    )\n    mediaType: Optional[str] = Field(\n        None,\n        description=(\n            \"The media type of the distribution as defined by IANA \"\n            \"[[IANA-MEDIA-TYPES](https://www.w3.org/TR/vocab-dcat-2/#bib-iana-media-types)]\"\n            \".\\n\\nUsage: This property *SHOULD* be used when the media\"\n            \" type of the distribution is defined in IANA \"\n            \"[[IANA-MEDIA-TYPES](https://www.w3.org/TR/vocab-dcat-2/#bib-iana-media-types)].\"\n        ),\n    )\n    accessUrl: Optional[HostlessAnyUrl] = Field(\n        None,\n        description=(\n            \"A URL of the resource that gives access to a distribution of \"\n            \"the dataset. E.g. landing page, feed, SPARQL endpoint.\\n\\nUsage: \"\n            \"`accessURL` *SHOULD* be used for the URL of a service or location that \"\n            \"can provide access to this distribution, typically through a Web form, \"\n            \"query or API call.\\n`downloadURL` is preferred for direct links to \"\n            \"downloadable resources.\"\n        ),\n    )\n    accessService: Optional[str] = Field(\n        None,\n        description=(\n            \"A data service that gives access to the distribution of the dataset.\"\n        ),\n    )\n    license: Optional[str] = Field(\n        None,\n        description=(\n            \"A legal document under which the distribution is made available.\"\n        ),\n    )\n    accessRights: Optional[str] = Field(\n        None,\n        description=(\n            \"A rights statement that concerns how the distribution is accessed.\"\n        ),\n    )\n    publisher: Optional[str] = Field(\n        None,\n        description=\"The entity responsible for making the resource/item available.\",\n    )\n\n    @model_validator(mode=\"after\")\n    def ensure_unique_url_pairs(self) -&gt; \"ResourceConfig\":\n        \"\"\"Ensure either downloadUrl/mediaType or accessUrl/accessService are defined.\n\n        It's fine to define them all, but at least one complete pair MUST be specified.\n        \"\"\"\n        if not (\n            all(getattr(self, _) for _ in [\"downloadUrl\", \"mediaType\"])\n            or all(getattr(self, _) for _ in [\"accessUrl\", \"accessService\"])\n        ):\n            raise ValueError(\n                \"Either of the pairs of attributes downloadUrl/mediaType or \"\n                \"accessUrl/accessService MUST be specified.\"\n            )\n        return self\n</code></pre>"},{"location":"all_models/#oteapi.models.resourceconfig.ResourceConfig.accessRights","title":"<code>accessRights: Optional[str] = Field(None, description='A rights statement that concerns how the distribution is accessed.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_models/#oteapi.models.resourceconfig.ResourceConfig.accessService","title":"<code>accessService: Optional[str] = Field(None, description='A data service that gives access to the distribution of the dataset.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_models/#oteapi.models.resourceconfig.ResourceConfig.accessUrl","title":"<code>accessUrl: Optional[HostlessAnyUrl] = Field(None, description='A URL of the resource that gives access to a distribution of the dataset. E.g. landing page, feed, SPARQL endpoint.\\n\\nUsage: `accessURL` *SHOULD* be used for the URL of a service or location that can provide access to this distribution, typically through a Web form, query or API call.\\n`downloadURL` is preferred for direct links to downloadable resources.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_models/#oteapi.models.resourceconfig.ResourceConfig.downloadUrl","title":"<code>downloadUrl: Optional[HostlessAnyUrl] = Field(None, description='Definition: The URL of the downloadable file in a given format. E.g. CSV file or RDF file.\\n\\nUsage: `downloadURL` *SHOULD* be used for the URL at which this distribution is available directly, typically through a HTTPS GET request or SFTP.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_models/#oteapi.models.resourceconfig.ResourceConfig.license","title":"<code>license: Optional[str] = Field(None, description='A legal document under which the distribution is made available.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_models/#oteapi.models.resourceconfig.ResourceConfig.mediaType","title":"<code>mediaType: Optional[str] = Field(None, description='The media type of the distribution as defined by IANA [[IANA-MEDIA-TYPES](https://www.w3.org/TR/vocab-dcat-2/#bib-iana-media-types)].\\n\\nUsage: This property *SHOULD* be used when the media type of the distribution is defined in IANA [[IANA-MEDIA-TYPES](https://www.w3.org/TR/vocab-dcat-2/#bib-iana-media-types)].')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_models/#oteapi.models.resourceconfig.ResourceConfig.publisher","title":"<code>publisher: Optional[str] = Field(None, description='The entity responsible for making the resource/item available.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_models/#oteapi.models.resourceconfig.ResourceConfig.resourceType","title":"<code>resourceType: Optional[str] = Field(None, description='Type of registered resource strategy.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_models/#oteapi.models.resourceconfig.ResourceConfig.ensure_unique_url_pairs","title":"<code>ensure_unique_url_pairs()</code>","text":"<p>Ensure either downloadUrl/mediaType or accessUrl/accessService are defined.</p> <p>It's fine to define them all, but at least one complete pair MUST be specified.</p> Source code in <code>oteapi/models/resourceconfig.py</code> <pre><code>@model_validator(mode=\"after\")\ndef ensure_unique_url_pairs(self) -&gt; \"ResourceConfig\":\n    \"\"\"Ensure either downloadUrl/mediaType or accessUrl/accessService are defined.\n\n    It's fine to define them all, but at least one complete pair MUST be specified.\n    \"\"\"\n    if not (\n        all(getattr(self, _) for _ in [\"downloadUrl\", \"mediaType\"])\n        or all(getattr(self, _) for _ in [\"accessUrl\", \"accessService\"])\n    ):\n        raise ValueError(\n            \"Either of the pairs of attributes downloadUrl/mediaType or \"\n            \"accessUrl/accessService MUST be specified.\"\n        )\n    return self\n</code></pre>"},{"location":"all_models/#oteapi.models.secretconfig","title":"<code>secretconfig</code>","text":"<p>AttrDict for specifying user credentials or secrets.</p>"},{"location":"all_models/#oteapi.models.secretconfig.TogglableSecretStr","title":"<code>TogglableSecretStr = Annotated[SecretStr, PlainSerializer(lambda value: value.get_secret_value() if settings.expose_secrets else str(value), return_type=str, when_used='json-unless-none')]</code>  <code>module-attribute</code>","text":"<p>Annotated type alias for a secret string that can be toggled to be exposed or not.</p>"},{"location":"all_models/#oteapi.models.secretconfig.SecretConfig","title":"<code>SecretConfig</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Simple model for handling secret in other config-models.</p> Source code in <code>oteapi/models/secretconfig.py</code> <pre><code>class SecretConfig(BaseModel):\n    \"\"\"Simple model for handling secret in other config-models.\"\"\"\n\n    user: Optional[TogglableSecretStr] = Field(\n        None, description=\"User name for authentication.\"\n    )\n    password: Optional[TogglableSecretStr] = Field(\n        None, description=\"Password for authentication.\"\n    )\n    token: Optional[TogglableSecretStr] = Field(\n        None,\n        description=(\n            \"An access token for providing access and meta data to an application.\"\n        ),\n    )\n    client_id: Optional[TogglableSecretStr] = Field(\n        None, description=\"Client ID for an OAUTH2 client.\"\n    )\n    client_secret: Optional[TogglableSecretStr] = Field(\n        None, description=\"Client secret for an OAUTH2 client.\"\n    )\n</code></pre>"},{"location":"all_models/#oteapi.models.secretconfig.SecretConfig.client_id","title":"<code>client_id: Optional[TogglableSecretStr] = Field(None, description='Client ID for an OAUTH2 client.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_models/#oteapi.models.secretconfig.SecretConfig.client_secret","title":"<code>client_secret: Optional[TogglableSecretStr] = Field(None, description='Client secret for an OAUTH2 client.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_models/#oteapi.models.secretconfig.SecretConfig.password","title":"<code>password: Optional[TogglableSecretStr] = Field(None, description='Password for authentication.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_models/#oteapi.models.secretconfig.SecretConfig.token","title":"<code>token: Optional[TogglableSecretStr] = Field(None, description='An access token for providing access and meta data to an application.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_models/#oteapi.models.secretconfig.SecretConfig.user","title":"<code>user: Optional[TogglableSecretStr] = Field(None, description='User name for authentication.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_models/#oteapi.models.transformationconfig","title":"<code>transformationconfig</code>","text":"<p>Pydantic Transformation Configuration Data Model.</p> <p>A transformation status data model is provided as well. This data model represents what should be returned from the strategy's <code>status()</code> method.</p>"},{"location":"all_models/#oteapi.models.transformationconfig.ProcessPriority","title":"<code>ProcessPriority</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Defining process priority enumerators.</p> <p>Process priorities:</p> <ul> <li>Low</li> <li>Medium</li> <li>High</li> </ul> Source code in <code>oteapi/models/transformationconfig.py</code> <pre><code>class ProcessPriority(str, Enum):\n    \"\"\"Defining process priority enumerators.\n\n    Process priorities:\n\n    - Low\n    - Medium\n    - High\n\n    \"\"\"\n\n    LOW = \"Low\"\n    MEDIUM = \"Medium\"\n    HIGH = \"High\"\n</code></pre>"},{"location":"all_models/#oteapi.models.transformationconfig.ProcessPriority.HIGH","title":"<code>HIGH = 'High'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_models/#oteapi.models.transformationconfig.ProcessPriority.LOW","title":"<code>LOW = 'Low'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_models/#oteapi.models.transformationconfig.ProcessPriority.MEDIUM","title":"<code>MEDIUM = 'Medium'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_models/#oteapi.models.transformationconfig.TransformationConfig","title":"<code>TransformationConfig</code>","text":"<p>               Bases: <code>GenericConfig</code>, <code>SecretConfig</code></p> <p>Transformation Strategy Data Configuration.</p> Source code in <code>oteapi/models/transformationconfig.py</code> <pre><code>class TransformationConfig(GenericConfig, SecretConfig):\n    \"\"\"Transformation Strategy Data Configuration.\"\"\"\n\n    transformationType: str = Field(\n        ...,\n        description=(\n            \"Type of registered transformation strategy. E.g., `celery/remote`.\"\n        ),\n    )\n    name: Optional[str] = Field(\n        None, description=\"Human-readable name of the transformation strategy.\"\n    )\n    due: Optional[datetime] = Field(\n        None,\n        description=(\n            \"Optional field to indicate a due data/time for when a transformation \"\n            \"should finish.\"\n        ),\n    )\n    priority: Optional[ProcessPriority] = Field(\n        ProcessPriority.MEDIUM,\n        description=\"Define the process priority of the transformation execution.\",\n    )\n</code></pre>"},{"location":"all_models/#oteapi.models.transformationconfig.TransformationConfig.due","title":"<code>due: Optional[datetime] = Field(None, description='Optional field to indicate a due data/time for when a transformation should finish.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_models/#oteapi.models.transformationconfig.TransformationConfig.name","title":"<code>name: Optional[str] = Field(None, description='Human-readable name of the transformation strategy.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_models/#oteapi.models.transformationconfig.TransformationConfig.priority","title":"<code>priority: Optional[ProcessPriority] = Field(ProcessPriority.MEDIUM, description='Define the process priority of the transformation execution.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_models/#oteapi.models.transformationconfig.TransformationConfig.transformationType","title":"<code>transformationType: str = Field(..., description='Type of registered transformation strategy. E.g., `celery/remote`.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_models/#oteapi.models.transformationconfig.TransformationStatus","title":"<code>TransformationStatus</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Return from transformation status.</p> Source code in <code>oteapi/models/transformationconfig.py</code> <pre><code>class TransformationStatus(BaseModel):\n    \"\"\"Return from transformation status.\"\"\"\n\n    id: str = Field(..., description=\"ID for the given transformation process.\")\n    status: Optional[str] = Field(\n        None, description=\"Status for the transformation process.\"\n    )\n    messages: Optional[List[str]] = Field(\n        None, description=\"Messages related to the transformation process.\"\n    )\n    created: Optional[datetime] = Field(\n        None,\n        description=\"Time of creation for the transformation process. Given in UTC.\",\n    )\n    startTime: Optional[datetime] = Field(\n        None, description=\"Time when the transformation process started. Given in UTC.\"\n    )\n    finishTime: Optional[datetime] = Field(\n        None, description=\"Time when the tranformation process finished. Given in UTC.\"\n    )\n</code></pre>"},{"location":"all_models/#oteapi.models.transformationconfig.TransformationStatus.created","title":"<code>created: Optional[datetime] = Field(None, description='Time of creation for the transformation process. Given in UTC.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_models/#oteapi.models.transformationconfig.TransformationStatus.finishTime","title":"<code>finishTime: Optional[datetime] = Field(None, description='Time when the tranformation process finished. Given in UTC.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_models/#oteapi.models.transformationconfig.TransformationStatus.id","title":"<code>id: str = Field(..., description='ID for the given transformation process.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_models/#oteapi.models.transformationconfig.TransformationStatus.messages","title":"<code>messages: Optional[List[str]] = Field(None, description='Messages related to the transformation process.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_models/#oteapi.models.transformationconfig.TransformationStatus.startTime","title":"<code>startTime: Optional[datetime] = Field(None, description='Time when the transformation process started. Given in UTC.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_models/#oteapi.models.transformationconfig.TransformationStatus.status","title":"<code>status: Optional[str] = Field(None, description='Status for the transformation process.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_models/#oteapi.models.triplestoreconfig","title":"<code>triplestoreconfig</code>","text":"<p>Pydantic TripleStore Configuration Data Model.</p>"},{"location":"all_models/#oteapi.models.triplestoreconfig.ExcludeTogglableSecretStr","title":"<code>ExcludeTogglableSecretStr = Annotated[Optional[TogglableSecretStr], Field(exclude=True)]</code>  <code>module-attribute</code>","text":"<p>Annotated type alias for excluding a togglable secret from serialization.</p>"},{"location":"all_models/#oteapi.models.triplestoreconfig.TripleStoreConfig","title":"<code>TripleStoreConfig</code>","text":"<p>               Bases: <code>GenericConfig</code>, <code>SecretConfig</code></p> <p>TripleStore Configuration.</p> <p>This is a configuration for the <code>TripleStore</code>.</p> <p>This class should not be used directly as a configuration object for a strategy object, but only as a configuration field inside a configuration object.</p> Source code in <code>oteapi/models/triplestoreconfig.py</code> <pre><code>class TripleStoreConfig(GenericConfig, SecretConfig):\n    \"\"\"TripleStore Configuration.\n\n    This is a configuration for the\n    [`TripleStore`][oteapi.triplestore.triplestore.TripleStore].\n\n    This class should not be used directly as a configuration object\n    for a strategy object, but only as a configuration field inside\n    a configuration object.\n    \"\"\"\n\n    repositoryName: str = Field(\n        ..., description=\"The repository name, where the mappings are stored.\"\n    )\n    agraphHost: str = Field(..., description=\"AllegroGraph host name.\")\n    agraphPort: int = Field(..., description=\"AllegroGraph port number.\")\n\n    # Exclude these inherited fields from serialization\n    token: Annotated[ExcludeTogglableSecretStr, SecretConfig.model_fields[\"token\"]] = (\n        SecretConfig.model_fields[\"token\"].default\n    )\n    client_id: Annotated[\n        ExcludeTogglableSecretStr, SecretConfig.model_fields[\"client_id\"]\n    ] = SecretConfig.model_fields[\"client_id\"].default\n    client_secret: Annotated[\n        ExcludeTogglableSecretStr, SecretConfig.model_fields[\"client_secret\"]\n    ] = SecretConfig.model_fields[\"client_secret\"].default\n\n    @model_validator(mode=\"after\")\n    def ensure_user_pass(self) -&gt; \"TripleStoreConfig\":\n        \"\"\"Ensure that user/password are set, since they are optional in the\n        SecretConfig.\"\"\"\n        if not all(getattr(self, _) for _ in [\"user\", \"password\"]):\n            raise ValueError(\"User and password must be defined.\")\n        return self\n</code></pre>"},{"location":"all_models/#oteapi.models.triplestoreconfig.TripleStoreConfig.agraphHost","title":"<code>agraphHost: str = Field(..., description='AllegroGraph host name.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_models/#oteapi.models.triplestoreconfig.TripleStoreConfig.agraphPort","title":"<code>agraphPort: int = Field(..., description='AllegroGraph port number.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_models/#oteapi.models.triplestoreconfig.TripleStoreConfig.client_id","title":"<code>client_id: Annotated[ExcludeTogglableSecretStr, SecretConfig.model_fields[client_id]] = SecretConfig.model_fields['client_id'].default</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_models/#oteapi.models.triplestoreconfig.TripleStoreConfig.client_secret","title":"<code>client_secret: Annotated[ExcludeTogglableSecretStr, SecretConfig.model_fields[client_secret]] = SecretConfig.model_fields['client_secret'].default</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_models/#oteapi.models.triplestoreconfig.TripleStoreConfig.repositoryName","title":"<code>repositoryName: str = Field(..., description='The repository name, where the mappings are stored.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_models/#oteapi.models.triplestoreconfig.TripleStoreConfig.token","title":"<code>token: Annotated[ExcludeTogglableSecretStr, SecretConfig.model_fields[token]] = SecretConfig.model_fields['token'].default</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_models/#oteapi.models.triplestoreconfig.TripleStoreConfig.ensure_user_pass","title":"<code>ensure_user_pass()</code>","text":"<p>Ensure that user/password are set, since they are optional in the SecretConfig.</p> Source code in <code>oteapi/models/triplestoreconfig.py</code> <pre><code>@model_validator(mode=\"after\")\ndef ensure_user_pass(self) -&gt; \"TripleStoreConfig\":\n    \"\"\"Ensure that user/password are set, since they are optional in the\n    SecretConfig.\"\"\"\n    if not all(getattr(self, _) for _ in [\"user\", \"password\"]):\n        raise ValueError(\"User and password must be defined.\")\n    return self\n</code></pre>"},{"location":"all_strategies/","title":"OTE-API Core Strategies","text":"<p>This page provides documentation for the <code>oteapi.strategies</code> submodule, where all the core OTE-API strategies are located.</p> <p>These strategies will always be available when setting up a server based on the OTE-API Core package.</p>"},{"location":"all_strategies/#oteapi.strategies.download","title":"<code>download</code>","text":""},{"location":"all_strategies/#oteapi.strategies.download.file","title":"<code>file</code>","text":"<p>Download strategy class for the <code>file</code> scheme.</p>"},{"location":"all_strategies/#oteapi.strategies.download.file.DownloadFileContent","title":"<code>DownloadFileContent</code>","text":"<p>               Bases: <code>AttrDict</code></p> <p>Class for returning values from Download File strategy.</p> Source code in <code>oteapi/strategies/download/file.py</code> <pre><code>class DownloadFileContent(AttrDict):\n    \"\"\"Class for returning values from Download File strategy.\"\"\"\n\n    key: str = Field(..., description=\"Key to access the data in the cache.\")\n</code></pre>"},{"location":"all_strategies/#oteapi.strategies.download.file.DownloadFileContent.key","title":"<code>key: str = Field(..., description='Key to access the data in the cache.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.download.file.FileConfig","title":"<code>FileConfig</code>","text":"<p>               Bases: <code>AttrDict</code></p> <p>File-specific Configuration Data Model.</p> Source code in <code>oteapi/strategies/download/file.py</code> <pre><code>class FileConfig(AttrDict):\n    \"\"\"File-specific Configuration Data Model.\"\"\"\n\n    text: bool = Field(\n        False,\n        description=(\n            \"Whether the file should be opened in text mode. If `False`, the file will\"\n            \" be opened in bytes mode.\"\n        ),\n    )\n    encoding: Optional[str] = Field(\n        None,\n        description=(\n            \"Encoding used when opening the file. The default is platform dependent.\"\n        ),\n    )\n    datacache_config: Optional[DataCacheConfig] = Field(\n        None,\n        description=(\n            \"Configurations for the data cache for storing the downloaded file \"\n            \"content.\"\n        ),\n    )\n</code></pre>"},{"location":"all_strategies/#oteapi.strategies.download.file.FileConfig.datacache_config","title":"<code>datacache_config: Optional[DataCacheConfig] = Field(None, description='Configurations for the data cache for storing the downloaded file content.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.download.file.FileConfig.encoding","title":"<code>encoding: Optional[str] = Field(None, description='Encoding used when opening the file. The default is platform dependent.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.download.file.FileConfig.text","title":"<code>text: bool = Field(False, description='Whether the file should be opened in text mode. If `False`, the file will be opened in bytes mode.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.download.file.FileResourceConfig","title":"<code>FileResourceConfig</code>","text":"<p>               Bases: <code>ResourceConfig</code></p> <p>File download strategy filter config.</p> Source code in <code>oteapi/strategies/download/file.py</code> <pre><code>class FileResourceConfig(ResourceConfig):\n    \"\"\"File download strategy filter config.\"\"\"\n\n    downloadUrl: FileUrl = Field(  # type: ignore[assignment]\n        ..., description=\"The file URL, which will be downloaded.\"\n    )\n    configuration: FileConfig = Field(\n        FileConfig(), description=\"File download strategy-specific configuration.\"\n    )\n\n    @field_validator(\"downloadUrl\")\n    @classmethod\n    def ensure_path_exists(cls, value: FileUrl) -&gt; FileUrl:\n        \"\"\"Ensure `path` is defined in `downloadUrl`.\"\"\"\n        if not value.path:\n            raise ValueError(\"downloadUrl must contain a `path` part.\")\n        return value\n</code></pre>"},{"location":"all_strategies/#oteapi.strategies.download.file.FileResourceConfig.configuration","title":"<code>configuration: FileConfig = Field(FileConfig(), description='File download strategy-specific configuration.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.download.file.FileResourceConfig.downloadUrl","title":"<code>downloadUrl: FileUrl = Field(..., description='The file URL, which will be downloaded.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.download.file.FileResourceConfig.ensure_path_exists","title":"<code>ensure_path_exists(value)</code>  <code>classmethod</code>","text":"<p>Ensure <code>path</code> is defined in <code>downloadUrl</code>.</p> Source code in <code>oteapi/strategies/download/file.py</code> <pre><code>@field_validator(\"downloadUrl\")\n@classmethod\ndef ensure_path_exists(cls, value: FileUrl) -&gt; FileUrl:\n    \"\"\"Ensure `path` is defined in `downloadUrl`.\"\"\"\n    if not value.path:\n        raise ValueError(\"downloadUrl must contain a `path` part.\")\n    return value\n</code></pre>"},{"location":"all_strategies/#oteapi.strategies.download.file.FileStrategy","title":"<code>FileStrategy</code>","text":"<p>Strategy for retrieving data from a local file.</p> <p>Registers strategies:</p> <ul> <li><code>(\"scheme\", \"file\")</code></li> </ul> Source code in <code>oteapi/strategies/download/file.py</code> <pre><code>@dataclass\nclass FileStrategy:\n    \"\"\"Strategy for retrieving data from a local file.\n\n    **Registers strategies**:\n\n    - `(\"scheme\", \"file\")`\n\n    \"\"\"\n\n    download_config: FileResourceConfig\n\n    def initialize(self) -&gt; AttrDict:\n        \"\"\"Initialize.\"\"\"\n        return AttrDict()\n\n    def get(self) -&gt; DownloadFileContent:\n        \"\"\"Read local file.\"\"\"\n        filename = uri_to_path(self.download_config.downloadUrl).resolve()\n\n        if not filename.exists():\n            raise FileNotFoundError(f\"File not found at {filename}\")\n\n        cache = DataCache(self.download_config.configuration.datacache_config)\n        if cache.config.accessKey and cache.config.accessKey in cache:\n            key = cache.config.accessKey\n        else:\n            key = cache.add(\n                filename.read_text(encoding=self.download_config.configuration.encoding)\n                if self.download_config.configuration.text\n                else filename.read_bytes()\n            )\n\n        return DownloadFileContent(key=key)\n</code></pre>"},{"location":"all_strategies/#oteapi.strategies.download.file.FileStrategy.download_config","title":"<code>download_config: FileResourceConfig</code>  <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.download.file.FileStrategy.get","title":"<code>get()</code>","text":"<p>Read local file.</p> Source code in <code>oteapi/strategies/download/file.py</code> <pre><code>def get(self) -&gt; DownloadFileContent:\n    \"\"\"Read local file.\"\"\"\n    filename = uri_to_path(self.download_config.downloadUrl).resolve()\n\n    if not filename.exists():\n        raise FileNotFoundError(f\"File not found at {filename}\")\n\n    cache = DataCache(self.download_config.configuration.datacache_config)\n    if cache.config.accessKey and cache.config.accessKey in cache:\n        key = cache.config.accessKey\n    else:\n        key = cache.add(\n            filename.read_text(encoding=self.download_config.configuration.encoding)\n            if self.download_config.configuration.text\n            else filename.read_bytes()\n        )\n\n    return DownloadFileContent(key=key)\n</code></pre>"},{"location":"all_strategies/#oteapi.strategies.download.file.FileStrategy.initialize","title":"<code>initialize()</code>","text":"<p>Initialize.</p> Source code in <code>oteapi/strategies/download/file.py</code> <pre><code>def initialize(self) -&gt; AttrDict:\n    \"\"\"Initialize.\"\"\"\n    return AttrDict()\n</code></pre>"},{"location":"all_strategies/#oteapi.strategies.download.https","title":"<code>https</code>","text":"<p>Download strategy class for http/https</p>"},{"location":"all_strategies/#oteapi.strategies.download.https.HTTPDownloadContent","title":"<code>HTTPDownloadContent</code>","text":"<p>               Bases: <code>AttrDict</code></p> <p>Class for returning values from Download HTTPS strategy.</p> Source code in <code>oteapi/strategies/download/https.py</code> <pre><code>class HTTPDownloadContent(AttrDict):\n    \"\"\"Class for returning values from Download HTTPS strategy.\"\"\"\n\n    key: str = Field(..., description=\"Key to access the data in the cache.\")\n</code></pre>"},{"location":"all_strategies/#oteapi.strategies.download.https.HTTPDownloadContent.key","title":"<code>key: str = Field(..., description='Key to access the data in the cache.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.download.https.HTTPSConfig","title":"<code>HTTPSConfig</code>","text":"<p>               Bases: <code>AttrDict</code></p> <p>HTTP(S)-specific Configuration Data Model.</p> Source code in <code>oteapi/strategies/download/https.py</code> <pre><code>class HTTPSConfig(AttrDict):\n    \"\"\"HTTP(S)-specific Configuration Data Model.\"\"\"\n\n    datacache_config: Optional[DataCacheConfig] = Field(\n        None,\n        description=(\n            \"Configurations for the data cache for storing the downloaded file \"\n            \"content.\"\n        ),\n    )\n</code></pre>"},{"location":"all_strategies/#oteapi.strategies.download.https.HTTPSConfig.datacache_config","title":"<code>datacache_config: Optional[DataCacheConfig] = Field(None, description='Configurations for the data cache for storing the downloaded file content.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.download.https.HTTPSResourceConfig","title":"<code>HTTPSResourceConfig</code>","text":"<p>               Bases: <code>ResourceConfig</code></p> <p>HTTP(S) download strategy filter config.</p> Source code in <code>oteapi/strategies/download/https.py</code> <pre><code>class HTTPSResourceConfig(ResourceConfig):\n    \"\"\"HTTP(S) download strategy filter config.\"\"\"\n\n    downloadUrl: AnyHttpUrl = Field(  # type: ignore[assignment]\n        ..., description=\"The HTTP(S) URL, which will be downloaded.\"\n    )\n    configuration: HTTPSConfig = Field(\n        HTTPSConfig(), description=\"HTTP(S) download strategy-specific configuration.\"\n    )\n</code></pre>"},{"location":"all_strategies/#oteapi.strategies.download.https.HTTPSResourceConfig.configuration","title":"<code>configuration: HTTPSConfig = Field(HTTPSConfig(), description='HTTP(S) download strategy-specific configuration.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.download.https.HTTPSResourceConfig.downloadUrl","title":"<code>downloadUrl: AnyHttpUrl = Field(..., description='The HTTP(S) URL, which will be downloaded.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.download.https.HTTPSStrategy","title":"<code>HTTPSStrategy</code>","text":"<p>Strategy for retrieving data via http.</p> <p>Registers strategies:</p> <ul> <li><code>(\"scheme\", \"http\")</code></li> <li><code>(\"scheme\", \"https\")</code></li> </ul> Source code in <code>oteapi/strategies/download/https.py</code> <pre><code>@dataclass\nclass HTTPSStrategy:\n    \"\"\"Strategy for retrieving data via http.\n\n    **Registers strategies**:\n\n    - `(\"scheme\", \"http\")`\n    - `(\"scheme\", \"https\")`\n\n    \"\"\"\n\n    download_config: HTTPSResourceConfig\n\n    def initialize(self) -&gt; AttrDict:\n        \"\"\"Initialize.\"\"\"\n        return AttrDict()\n\n    def get(self) -&gt; HTTPDownloadContent:\n        \"\"\"Download via http/https and store on local cache.\"\"\"\n        cache = DataCache(self.download_config.configuration.datacache_config)\n        if cache.config.accessKey and cache.config.accessKey in cache:\n            key = cache.config.accessKey\n        else:\n            req = requests.get(\n                str(self.download_config.downloadUrl),\n                allow_redirects=True,\n                timeout=(3, 27),  # timeout: (connect, read) in seconds\n            )\n            key = cache.add(req.content)\n\n        return HTTPDownloadContent(key=key)\n</code></pre>"},{"location":"all_strategies/#oteapi.strategies.download.https.HTTPSStrategy.download_config","title":"<code>download_config: HTTPSResourceConfig</code>  <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.download.https.HTTPSStrategy.get","title":"<code>get()</code>","text":"<p>Download via http/https and store on local cache.</p> Source code in <code>oteapi/strategies/download/https.py</code> <pre><code>def get(self) -&gt; HTTPDownloadContent:\n    \"\"\"Download via http/https and store on local cache.\"\"\"\n    cache = DataCache(self.download_config.configuration.datacache_config)\n    if cache.config.accessKey and cache.config.accessKey in cache:\n        key = cache.config.accessKey\n    else:\n        req = requests.get(\n            str(self.download_config.downloadUrl),\n            allow_redirects=True,\n            timeout=(3, 27),  # timeout: (connect, read) in seconds\n        )\n        key = cache.add(req.content)\n\n    return HTTPDownloadContent(key=key)\n</code></pre>"},{"location":"all_strategies/#oteapi.strategies.download.https.HTTPSStrategy.initialize","title":"<code>initialize()</code>","text":"<p>Initialize.</p> Source code in <code>oteapi/strategies/download/https.py</code> <pre><code>def initialize(self) -&gt; AttrDict:\n    \"\"\"Initialize.\"\"\"\n    return AttrDict()\n</code></pre>"},{"location":"all_strategies/#oteapi.strategies.download.sftp","title":"<code>sftp</code>","text":"<p>Strategy class for sftp/ftp</p>"},{"location":"all_strategies/#oteapi.strategies.download.sftp.AnyFtpUrl","title":"<code>AnyFtpUrl = Annotated[Url, UrlConstraints(allowed_schemes=['ftp', 'sftp'])]</code>  <code>module-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.download.sftp.SFTPConfig","title":"<code>SFTPConfig</code>","text":"<p>               Bases: <code>AttrDict</code></p> <p>(S)FTP-specific Configuration Data Model.</p> Source code in <code>oteapi/strategies/download/sftp.py</code> <pre><code>class SFTPConfig(AttrDict):\n    \"\"\"(S)FTP-specific Configuration Data Model.\"\"\"\n\n    datacache_config: Optional[DataCacheConfig] = Field(\n        None,\n        description=(\n            \"Configurations for the data cache for storing the downloaded file \"\n            \"content.\"\n        ),\n    )\n</code></pre>"},{"location":"all_strategies/#oteapi.strategies.download.sftp.SFTPConfig.datacache_config","title":"<code>datacache_config: Optional[DataCacheConfig] = Field(None, description='Configurations for the data cache for storing the downloaded file content.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.download.sftp.SFTPContent","title":"<code>SFTPContent</code>","text":"<p>               Bases: <code>AttrDict</code></p> <p>Class for returning values from Download SFTP strategy.</p> Source code in <code>oteapi/strategies/download/sftp.py</code> <pre><code>class SFTPContent(AttrDict):\n    \"\"\"Class for returning values from Download SFTP strategy.\"\"\"\n\n    key: str = Field(..., description=\"Key to access the data in the cache.\")\n</code></pre>"},{"location":"all_strategies/#oteapi.strategies.download.sftp.SFTPContent.key","title":"<code>key: str = Field(..., description='Key to access the data in the cache.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.download.sftp.SFTPResourceConfig","title":"<code>SFTPResourceConfig</code>","text":"<p>               Bases: <code>ResourceConfig</code></p> <p>(S)FTP download strategy filter config.</p> Source code in <code>oteapi/strategies/download/sftp.py</code> <pre><code>class SFTPResourceConfig(ResourceConfig):\n    \"\"\"(S)FTP download strategy filter config.\"\"\"\n\n    downloadUrl: AnyFtpUrl = Field(  # type: ignore[assignment]\n        ..., description=\"The (S)FTP URL, which will be downloaded.\"\n    )\n    configuration: SFTPConfig = Field(\n        SFTPConfig(), description=\"(S)FTP download strategy-specific configuration.\"\n    )\n</code></pre>"},{"location":"all_strategies/#oteapi.strategies.download.sftp.SFTPResourceConfig.configuration","title":"<code>configuration: SFTPConfig = Field(SFTPConfig(), description='(S)FTP download strategy-specific configuration.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.download.sftp.SFTPResourceConfig.downloadUrl","title":"<code>downloadUrl: AnyFtpUrl = Field(..., description='The (S)FTP URL, which will be downloaded.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.download.sftp.SFTPStrategy","title":"<code>SFTPStrategy</code>","text":"<p>Strategy for retrieving data via sftp.</p> <p>Registers strategies:</p> <ul> <li><code>(\"scheme\", \"ftp\")</code></li> <li><code>(\"scheme\", \"sftp\")</code></li> </ul> Source code in <code>oteapi/strategies/download/sftp.py</code> <pre><code>@dataclass\nclass SFTPStrategy:\n    \"\"\"Strategy for retrieving data via sftp.\n\n    **Registers strategies**:\n\n    - `(\"scheme\", \"ftp\")`\n    - `(\"scheme\", \"sftp\")`\n\n    \"\"\"\n\n    download_config: SFTPResourceConfig\n\n    def initialize(self) -&gt; AttrDict:\n        \"\"\"Initialize.\"\"\"\n        return AttrDict()\n\n    def get(self) -&gt; SFTPContent:\n        \"\"\"Download via sftp\"\"\"\n        cache = DataCache(self.download_config.configuration.datacache_config)\n        if cache.config.accessKey and cache.config.accessKey in cache:\n            key = cache.config.accessKey\n        else:\n            # Setup connection options\n            cnopts = pysftp.CnOpts()\n            cnopts.hostkeys = None\n\n            # open connection and store data locally\n            with pysftp.Connection(\n                host=self.download_config.downloadUrl.host,\n                username=self.download_config.downloadUrl.username,\n                password=self.download_config.downloadUrl.password,\n                port=self.download_config.downloadUrl.port,\n                cnopts=cnopts,\n            ) as sftp:\n                # Because of insane locking on Windows, we have to close\n                # the downloaded file before adding it to the cache\n                with NamedTemporaryFile(prefix=\"oteapi-sftp-\", delete=False) as handle:\n                    localpath = Path(handle.name).resolve()\n                try:\n                    sftp.get(self.download_config.downloadUrl.path, localpath=localpath)\n                    key = cache.add(localpath.read_bytes())\n                finally:\n                    localpath.unlink()\n\n        return SFTPContent(key=key)\n</code></pre>"},{"location":"all_strategies/#oteapi.strategies.download.sftp.SFTPStrategy.download_config","title":"<code>download_config: SFTPResourceConfig</code>  <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.download.sftp.SFTPStrategy.get","title":"<code>get()</code>","text":"<p>Download via sftp</p> Source code in <code>oteapi/strategies/download/sftp.py</code> <pre><code>def get(self) -&gt; SFTPContent:\n    \"\"\"Download via sftp\"\"\"\n    cache = DataCache(self.download_config.configuration.datacache_config)\n    if cache.config.accessKey and cache.config.accessKey in cache:\n        key = cache.config.accessKey\n    else:\n        # Setup connection options\n        cnopts = pysftp.CnOpts()\n        cnopts.hostkeys = None\n\n        # open connection and store data locally\n        with pysftp.Connection(\n            host=self.download_config.downloadUrl.host,\n            username=self.download_config.downloadUrl.username,\n            password=self.download_config.downloadUrl.password,\n            port=self.download_config.downloadUrl.port,\n            cnopts=cnopts,\n        ) as sftp:\n            # Because of insane locking on Windows, we have to close\n            # the downloaded file before adding it to the cache\n            with NamedTemporaryFile(prefix=\"oteapi-sftp-\", delete=False) as handle:\n                localpath = Path(handle.name).resolve()\n            try:\n                sftp.get(self.download_config.downloadUrl.path, localpath=localpath)\n                key = cache.add(localpath.read_bytes())\n            finally:\n                localpath.unlink()\n\n    return SFTPContent(key=key)\n</code></pre>"},{"location":"all_strategies/#oteapi.strategies.download.sftp.SFTPStrategy.initialize","title":"<code>initialize()</code>","text":"<p>Initialize.</p> Source code in <code>oteapi/strategies/download/sftp.py</code> <pre><code>def initialize(self) -&gt; AttrDict:\n    \"\"\"Initialize.\"\"\"\n    return AttrDict()\n</code></pre>"},{"location":"all_strategies/#oteapi.strategies.filter","title":"<code>filter</code>","text":""},{"location":"all_strategies/#oteapi.strategies.filter.crop_filter","title":"<code>crop_filter</code>","text":"<p>Demo-filter strategy</p>"},{"location":"all_strategies/#oteapi.strategies.filter.crop_filter.CropFilterContent","title":"<code>CropFilterContent</code>","text":"<p>               Bases: <code>AttrDict</code></p> <p>Return model for <code>CropImageFilter</code>.</p> Source code in <code>oteapi/strategies/filter/crop_filter.py</code> <pre><code>class CropFilterContent(AttrDict):\n    \"\"\"Return model for `CropImageFilter`.\"\"\"\n\n    imagecrop: Tuple[int, int, int, int] = Field(\n        ..., description=\"Box cropping parameters (left, top, right, bottom).\"\n    )\n</code></pre>"},{"location":"all_strategies/#oteapi.strategies.filter.crop_filter.CropFilterContent.imagecrop","title":"<code>imagecrop: Tuple[int, int, int, int] = Field(..., description='Box cropping parameters (left, top, right, bottom).')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.filter.crop_filter.CropImageConfig","title":"<code>CropImageConfig</code>","text":"<p>               Bases: <code>AttrDict</code></p> <p>Configuration model for crop data.</p> Source code in <code>oteapi/strategies/filter/crop_filter.py</code> <pre><code>class CropImageConfig(AttrDict):\n    \"\"\"Configuration model for crop data.\"\"\"\n\n    crop: Optional[Tuple[int, int, int, int]] = Field(\n        None, description=\"Box cropping parameters (left, top, right, bottom).\"\n    )\n</code></pre>"},{"location":"all_strategies/#oteapi.strategies.filter.crop_filter.CropImageConfig.crop","title":"<code>crop: Optional[Tuple[int, int, int, int]] = Field(None, description='Box cropping parameters (left, top, right, bottom).')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.filter.crop_filter.CropImageFilter","title":"<code>CropImageFilter</code>","text":"<p>Strategy for cropping an image.</p> <p>Registers strategies:</p> <ul> <li><code>(\"filterType\", \"filter/crop\")</code></li> </ul> Source code in <code>oteapi/strategies/filter/crop_filter.py</code> <pre><code>@dataclass\nclass CropImageFilter:\n    \"\"\"Strategy for cropping an image.\n\n    **Registers strategies**:\n\n    - `(\"filterType\", \"filter/crop\")`\n\n    \"\"\"\n\n    filter_config: CropImageFilterConfig\n\n    def initialize(self) -&gt; CropFilterContent:\n        \"\"\"Initialize strategy and return a dictionary.\"\"\"\n        if self.filter_config.configuration.crop is None:\n            raise ValueError(\"Crop filter requires crop configuration.\")\n\n        return CropFilterContent(\n            imagecrop=self.filter_config.configuration.crop,\n        )\n\n    def get(self) -&gt; AttrDict:\n        \"\"\"Execute strategy and return a dictionary\"\"\"\n        return AttrDict()\n</code></pre>"},{"location":"all_strategies/#oteapi.strategies.filter.crop_filter.CropImageFilter.filter_config","title":"<code>filter_config: CropImageFilterConfig</code>  <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.filter.crop_filter.CropImageFilter.get","title":"<code>get()</code>","text":"<p>Execute strategy and return a dictionary</p> Source code in <code>oteapi/strategies/filter/crop_filter.py</code> <pre><code>def get(self) -&gt; AttrDict:\n    \"\"\"Execute strategy and return a dictionary\"\"\"\n    return AttrDict()\n</code></pre>"},{"location":"all_strategies/#oteapi.strategies.filter.crop_filter.CropImageFilter.initialize","title":"<code>initialize()</code>","text":"<p>Initialize strategy and return a dictionary.</p> Source code in <code>oteapi/strategies/filter/crop_filter.py</code> <pre><code>def initialize(self) -&gt; CropFilterContent:\n    \"\"\"Initialize strategy and return a dictionary.\"\"\"\n    if self.filter_config.configuration.crop is None:\n        raise ValueError(\"Crop filter requires crop configuration.\")\n\n    return CropFilterContent(\n        imagecrop=self.filter_config.configuration.crop,\n    )\n</code></pre>"},{"location":"all_strategies/#oteapi.strategies.filter.crop_filter.CropImageFilterConfig","title":"<code>CropImageFilterConfig</code>","text":"<p>               Bases: <code>FilterConfig</code></p> <p>Crop filter strategy filter config.</p> Source code in <code>oteapi/strategies/filter/crop_filter.py</code> <pre><code>class CropImageFilterConfig(FilterConfig):\n    \"\"\"Crop filter strategy filter config.\"\"\"\n\n    filterType: Literal[\"filter/crop\"] = Field(\n        \"filter/crop\",\n        description=FilterConfig.model_fields[\"filterType\"].description,\n    )\n    configuration: CropImageConfig = Field(\n        ..., description=\"Image crop filter strategy-specific configuration.\"\n    )\n</code></pre>"},{"location":"all_strategies/#oteapi.strategies.filter.crop_filter.CropImageFilterConfig.configuration","title":"<code>configuration: CropImageConfig = Field(..., description='Image crop filter strategy-specific configuration.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.filter.crop_filter.CropImageFilterConfig.filterType","title":"<code>filterType: Literal['filter/crop'] = Field('filter/crop', description=FilterConfig.model_fields['filterType'].description)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.filter.sql_query_filter","title":"<code>sql_query_filter</code>","text":"<p>SQL query filter strategy.</p>"},{"location":"all_strategies/#oteapi.strategies.filter.sql_query_filter.SQLQueryFilter","title":"<code>SQLQueryFilter</code>","text":"<p>Strategy for a SQL query filter.</p> <p>Registers strategies:</p> <ul> <li><code>(\"filterType\", \"filter/sql\")</code></li> </ul> Source code in <code>oteapi/strategies/filter/sql_query_filter.py</code> <pre><code>@dataclass\nclass SQLQueryFilter:\n    \"\"\"Strategy for a SQL query filter.\n\n    **Registers strategies**:\n\n    - `(\"filterType\", \"filter/sql\")`\n\n    \"\"\"\n\n    filter_config: SqlQueryFilterConfig\n\n    def initialize(self) -&gt; SqlQueryContent:\n        \"\"\"Initialize strategy.\"\"\"\n        return SqlQueryContent(sqlquery=self.filter_config.query)\n\n    def get(self) -&gt; AttrDict:\n        \"\"\"Execute strategy and return a dictionary.\"\"\"\n        return AttrDict()\n</code></pre>"},{"location":"all_strategies/#oteapi.strategies.filter.sql_query_filter.SQLQueryFilter.filter_config","title":"<code>filter_config: SqlQueryFilterConfig</code>  <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.filter.sql_query_filter.SQLQueryFilter.get","title":"<code>get()</code>","text":"<p>Execute strategy and return a dictionary.</p> Source code in <code>oteapi/strategies/filter/sql_query_filter.py</code> <pre><code>def get(self) -&gt; AttrDict:\n    \"\"\"Execute strategy and return a dictionary.\"\"\"\n    return AttrDict()\n</code></pre>"},{"location":"all_strategies/#oteapi.strategies.filter.sql_query_filter.SQLQueryFilter.initialize","title":"<code>initialize()</code>","text":"<p>Initialize strategy.</p> Source code in <code>oteapi/strategies/filter/sql_query_filter.py</code> <pre><code>def initialize(self) -&gt; SqlQueryContent:\n    \"\"\"Initialize strategy.\"\"\"\n    return SqlQueryContent(sqlquery=self.filter_config.query)\n</code></pre>"},{"location":"all_strategies/#oteapi.strategies.filter.sql_query_filter.SqlQueryContent","title":"<code>SqlQueryContent</code>","text":"<p>               Bases: <code>AttrDict</code></p> <p>Class for returning values from SQL Query data model.</p> Source code in <code>oteapi/strategies/filter/sql_query_filter.py</code> <pre><code>class SqlQueryContent(AttrDict):\n    \"\"\"Class for returning values from SQL Query data model.\"\"\"\n\n    sqlquery: str = Field(..., description=\"A SQL query string.\")\n</code></pre>"},{"location":"all_strategies/#oteapi.strategies.filter.sql_query_filter.SqlQueryContent.sqlquery","title":"<code>sqlquery: str = Field(..., description='A SQL query string.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.filter.sql_query_filter.SqlQueryFilterConfig","title":"<code>SqlQueryFilterConfig</code>","text":"<p>               Bases: <code>FilterConfig</code></p> <p>SQL query filter strategy filter config.</p> Source code in <code>oteapi/strategies/filter/sql_query_filter.py</code> <pre><code>class SqlQueryFilterConfig(FilterConfig):\n    \"\"\"SQL query filter strategy filter config.\"\"\"\n\n    filterType: Literal[\"filter/sql\"] = Field(\n        \"filter/sql\",\n        description=FilterConfig.model_fields[\"filterType\"].description,\n    )\n    query: str = Field(..., description=\"A SQL query string.\")\n</code></pre>"},{"location":"all_strategies/#oteapi.strategies.filter.sql_query_filter.SqlQueryFilterConfig.filterType","title":"<code>filterType: Literal['filter/sql'] = Field('filter/sql', description=FilterConfig.model_fields['filterType'].description)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.filter.sql_query_filter.SqlQueryFilterConfig.query","title":"<code>query: str = Field(..., description='A SQL query string.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.mapping","title":"<code>mapping</code>","text":""},{"location":"all_strategies/#oteapi.strategies.mapping.mapping","title":"<code>mapping</code>","text":"<p>Mapping filter strategy.</p>"},{"location":"all_strategies/#oteapi.strategies.mapping.mapping.MappingStrategy","title":"<code>MappingStrategy</code>","text":"<p>Strategy for a mapping.</p> <p>The mapping strategy simply adds more prefixes and triples to the <code>prefixes</code> and <code>triples</code> fields in the session such that they are available for other strategies, like function strategies that convert between data models.</p> <p>Nothing is returned to avoid deleting existing mappings.</p> <p>Registers strategies:</p> <ul> <li><code>(\"mappingType\", \"triples\")</code></li> </ul> Source code in <code>oteapi/strategies/mapping/mapping.py</code> <pre><code>@dataclass\nclass MappingStrategy:\n    \"\"\"Strategy for a mapping.\n\n    The mapping strategy simply adds more prefixes and triples to the\n    `prefixes` and `triples` fields in the session such that they are\n    available for other strategies, like function strategies that convert\n    between data models.\n\n    Nothing is returned to avoid deleting existing mappings.\n\n    **Registers strategies**:\n\n    - `(\"mappingType\", \"triples\")`\n\n    \"\"\"\n\n    mapping_config: MappingConfig\n\n    def initialize(self) -&gt; MappingStrategyConfig:\n        \"\"\"Initialize strategy.\"\"\"\n\n        return MappingStrategyConfig(\n            prefixes=self.mapping_config.prefixes, triples=self.mapping_config.triples\n        )\n\n    def get(self) -&gt; AttrDict:\n        \"\"\"Execute strategy and return a dictionary.\"\"\"\n        return AttrDict()\n</code></pre>"},{"location":"all_strategies/#oteapi.strategies.mapping.mapping.MappingStrategy.mapping_config","title":"<code>mapping_config: MappingConfig</code>  <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.mapping.mapping.MappingStrategy.get","title":"<code>get()</code>","text":"<p>Execute strategy and return a dictionary.</p> Source code in <code>oteapi/strategies/mapping/mapping.py</code> <pre><code>def get(self) -&gt; AttrDict:\n    \"\"\"Execute strategy and return a dictionary.\"\"\"\n    return AttrDict()\n</code></pre>"},{"location":"all_strategies/#oteapi.strategies.mapping.mapping.MappingStrategy.initialize","title":"<code>initialize()</code>","text":"<p>Initialize strategy.</p> Source code in <code>oteapi/strategies/mapping/mapping.py</code> <pre><code>def initialize(self) -&gt; MappingStrategyConfig:\n    \"\"\"Initialize strategy.\"\"\"\n\n    return MappingStrategyConfig(\n        prefixes=self.mapping_config.prefixes, triples=self.mapping_config.triples\n    )\n</code></pre>"},{"location":"all_strategies/#oteapi.strategies.mapping.mapping.MappingStrategyConfig","title":"<code>MappingStrategyConfig</code>","text":"<p>               Bases: <code>AttrDict</code></p> <p>AttrDict model for mappings.</p> Source code in <code>oteapi/strategies/mapping/mapping.py</code> <pre><code>class MappingStrategyConfig(AttrDict):\n    \"\"\"AttrDict model for mappings.\"\"\"\n\n    prefixes: Dict[str, str] = Field(\n        ...,\n        description=(\n            \"Dictionary of shortnames that expands to an IRI \"\n            \"given as local value/IRI-expansion-pairs.\"\n        ),\n    )\n    triples: List[RDFTriple] = Field(\n        ...,\n        description=\"List of semantic triples given as (subject, predicate, object).\",\n    )\n</code></pre>"},{"location":"all_strategies/#oteapi.strategies.mapping.mapping.MappingStrategyConfig.prefixes","title":"<code>prefixes: Dict[str, str] = Field(..., description='Dictionary of shortnames that expands to an IRI given as local value/IRI-expansion-pairs.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.mapping.mapping.MappingStrategyConfig.triples","title":"<code>triples: List[RDFTriple] = Field(..., description='List of semantic triples given as (subject, predicate, object).')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.parse","title":"<code>parse</code>","text":""},{"location":"all_strategies/#oteapi.strategies.parse.application_json","title":"<code>application_json</code>","text":"<p>Strategy class for application/json.</p>"},{"location":"all_strategies/#oteapi.strategies.parse.application_json.JSONConfig","title":"<code>JSONConfig</code>","text":"<p>               Bases: <code>AttrDict</code></p> <p>JSON parse-specific Configuration Data Model.</p> Source code in <code>oteapi/strategies/parse/application_json.py</code> <pre><code>class JSONConfig(AttrDict):\n    \"\"\"JSON parse-specific Configuration Data Model.\"\"\"\n\n    downloadUrl: Optional[HostlessAnyUrl] = Field(\n        None, description=\"The HTTP(S) URL, which will be downloaded.\"\n    )\n    mediaType: Literal[\"application/json\"] = Field(\n        \"application/json\",\n        description=(\"The media type\"),\n    )\n    datacache_config: Optional[DataCacheConfig] = Field(\n        None,\n        description=(\n            \"Configurations for the data cache for storing the downloaded file \"\n            \"content.\"\n        ),\n    )\n</code></pre>"},{"location":"all_strategies/#oteapi.strategies.parse.application_json.JSONConfig.datacache_config","title":"<code>datacache_config: Optional[DataCacheConfig] = Field(None, description='Configurations for the data cache for storing the downloaded file content.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.parse.application_json.JSONConfig.downloadUrl","title":"<code>downloadUrl: Optional[HostlessAnyUrl] = Field(None, description='The HTTP(S) URL, which will be downloaded.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.parse.application_json.JSONConfig.mediaType","title":"<code>mediaType: Literal['application/json'] = Field('application/json', description='The media type')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.parse.application_json.JSONDataParseStrategy","title":"<code>JSONDataParseStrategy</code>","text":"<p>Parse strategy for JSON.</p> <p>Registers strategies:</p> <ul> <li><code>(\"parserType\", \"parser/json\")</code></li> </ul> Source code in <code>oteapi/strategies/parse/application_json.py</code> <pre><code>@dataclass\nclass JSONDataParseStrategy:\n    \"\"\"Parse strategy for JSON.\n\n    **Registers strategies**:\n\n    - `(\"parserType\", \"parser/json\")`\n\n    \"\"\"\n\n    parse_config: JSONParserConfig\n\n    def initialize(self) -&gt; AttrDict:\n        \"\"\"Initialize.\"\"\"\n        return AttrDict()\n\n    def get(self) -&gt; JSONParseContent:\n        \"\"\"Parse json.\"\"\"\n        downloader = create_strategy(\n            \"download\", self.parse_config.configuration.model_dump()\n        )\n        output = downloader.get()\n        cache = DataCache(self.parse_config.configuration.datacache_config)\n        content = cache.get(output[\"key\"])\n\n        if isinstance(content, dict):\n            return JSONParseContent(content=content)\n        return JSONParseContent(content=json.loads(content))\n</code></pre>"},{"location":"all_strategies/#oteapi.strategies.parse.application_json.JSONDataParseStrategy.parse_config","title":"<code>parse_config: JSONParserConfig</code>  <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.parse.application_json.JSONDataParseStrategy.get","title":"<code>get()</code>","text":"<p>Parse json.</p> Source code in <code>oteapi/strategies/parse/application_json.py</code> <pre><code>def get(self) -&gt; JSONParseContent:\n    \"\"\"Parse json.\"\"\"\n    downloader = create_strategy(\n        \"download\", self.parse_config.configuration.model_dump()\n    )\n    output = downloader.get()\n    cache = DataCache(self.parse_config.configuration.datacache_config)\n    content = cache.get(output[\"key\"])\n\n    if isinstance(content, dict):\n        return JSONParseContent(content=content)\n    return JSONParseContent(content=json.loads(content))\n</code></pre>"},{"location":"all_strategies/#oteapi.strategies.parse.application_json.JSONDataParseStrategy.initialize","title":"<code>initialize()</code>","text":"<p>Initialize.</p> Source code in <code>oteapi/strategies/parse/application_json.py</code> <pre><code>def initialize(self) -&gt; AttrDict:\n    \"\"\"Initialize.\"\"\"\n    return AttrDict()\n</code></pre>"},{"location":"all_strategies/#oteapi.strategies.parse.application_json.JSONParseContent","title":"<code>JSONParseContent</code>","text":"<p>               Bases: <code>AttrDict</code></p> <p>Class for returning values from JSON Parse.</p> Source code in <code>oteapi/strategies/parse/application_json.py</code> <pre><code>class JSONParseContent(AttrDict):\n    \"\"\"Class for returning values from JSON Parse.\"\"\"\n\n    content: dict = Field(..., description=\"Content of the JSON document.\")\n</code></pre>"},{"location":"all_strategies/#oteapi.strategies.parse.application_json.JSONParseContent.content","title":"<code>content: dict = Field(..., description='Content of the JSON document.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.parse.application_json.JSONParserConfig","title":"<code>JSONParserConfig</code>","text":"<p>               Bases: <code>ParserConfig</code></p> <p>JSON parse strategy filter config.</p> Source code in <code>oteapi/strategies/parse/application_json.py</code> <pre><code>class JSONParserConfig(ParserConfig):\n    \"\"\"JSON parse strategy filter config.\"\"\"\n\n    parserType: Literal[\"parser/json\"] = Field(\n        \"parser/json\",\n        description=ParserConfig.model_fields[\"parserType\"].description,\n    )\n    configuration: JSONConfig = Field(\n        ..., description=\"JSON parse strategy-specific configuration.\"\n    )\n</code></pre>"},{"location":"all_strategies/#oteapi.strategies.parse.application_json.JSONParserConfig.configuration","title":"<code>configuration: JSONConfig = Field(..., description='JSON parse strategy-specific configuration.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.parse.application_json.JSONParserConfig.parserType","title":"<code>parserType: Literal['parser/json'] = Field('parser/json', description=ParserConfig.model_fields['parserType'].description)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.parse.application_vnd_sqlite","title":"<code>application_vnd_sqlite</code>","text":"<p>Strategy class for application/vnd.sqlite3.</p>"},{"location":"all_strategies/#oteapi.strategies.parse.application_vnd_sqlite.SqLiteParseContent","title":"<code>SqLiteParseContent</code>","text":"<p>               Bases: <code>AttrDict</code></p> <p>Configuration model for SqLiteParse.</p> Source code in <code>oteapi/strategies/parse/application_vnd_sqlite.py</code> <pre><code>class SqLiteParseContent(AttrDict):\n    \"\"\"Configuration model for SqLiteParse.\"\"\"\n\n    result: list = Field(..., description=\"List of results from the query.\")\n</code></pre>"},{"location":"all_strategies/#oteapi.strategies.parse.application_vnd_sqlite.SqLiteParseContent.result","title":"<code>result: list = Field(..., description='List of results from the query.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.parse.application_vnd_sqlite.SqliteConfig","title":"<code>SqliteConfig</code>","text":"<p>               Bases: <code>AttrDict</code></p> <p>Configuration data model for <code>SqliteParseStrategy</code>.</p> Source code in <code>oteapi/strategies/parse/application_vnd_sqlite.py</code> <pre><code>class SqliteConfig(AttrDict):\n    \"\"\"Configuration data model for\n    [`SqliteParseStrategy`][oteapi.strategies.parse.application_vnd_sqlite.SqliteParseStrategy].\n    \"\"\"\n\n    # Resource config\n    downloadUrl: Optional[HostlessAnyUrl] = Field(\n        None, description=ResourceConfig.model_fields[\"downloadUrl\"].description\n    )\n    mediaType: Literal[\"application/vnd.sqlite3\"] = Field(\n        \"application/vnd.sqlite3\",\n        description=ResourceConfig.model_fields[\"mediaType\"].description,\n    )\n\n    # SQLite parse strategy-specific config\n    sqlquery: str = Field(\"\", description=\"A SQL query string.\")\n    datacache_config: Optional[DataCacheConfig] = Field(\n        None,\n        description=\"Configuration options for the local data cache.\",\n    )\n</code></pre>"},{"location":"all_strategies/#oteapi.strategies.parse.application_vnd_sqlite.SqliteConfig.datacache_config","title":"<code>datacache_config: Optional[DataCacheConfig] = Field(None, description='Configuration options for the local data cache.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.parse.application_vnd_sqlite.SqliteConfig.downloadUrl","title":"<code>downloadUrl: Optional[HostlessAnyUrl] = Field(None, description=ResourceConfig.model_fields['downloadUrl'].description)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.parse.application_vnd_sqlite.SqliteConfig.mediaType","title":"<code>mediaType: Literal['application/vnd.sqlite3'] = Field('application/vnd.sqlite3', description=ResourceConfig.model_fields['mediaType'].description)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.parse.application_vnd_sqlite.SqliteConfig.sqlquery","title":"<code>sqlquery: str = Field('', description='A SQL query string.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.parse.application_vnd_sqlite.SqliteParseStrategy","title":"<code>SqliteParseStrategy</code>","text":"<p>Parse strategy for SQLite.</p> <p>Purpose of this strategy: Download a SQLite database using <code>downloadUrl</code> and run a SQL query on the database to return all relevant rows.</p> Source code in <code>oteapi/strategies/parse/application_vnd_sqlite.py</code> <pre><code>@dataclass\nclass SqliteParseStrategy:\n    \"\"\"Parse strategy for SQLite.\n\n    Purpose of this strategy: Download a SQLite database using `downloadUrl` and run a\n    SQL query on the database to return all relevant rows.\n\n    \"\"\"\n\n    parse_config: SqliteParserConfig\n\n    def initialize(self) -&gt; AttrDict:\n        \"\"\"Initialize strategy.\"\"\"\n        return AttrDict()\n\n    def get(self) -&gt; SqLiteParseContent:\n        \"\"\"Parse SQLite query responses.\"\"\"\n\n        if self.parse_config.configuration.downloadUrl is None:\n            raise ValueError(\"No download URL provided.\")\n\n        if self.parse_config.configuration.mediaType != \"application/vnd.sqlite3\":\n            raise ValueError(\"Invalid media type.\")\n\n        # Retrieve SQLite file\n        downloader = create_strategy(\n            \"download\", self.parse_config.configuration.model_dump()\n        )\n        cache_key = downloader.get()[\"key\"]\n\n        cache = DataCache(self.parse_config.configuration.datacache_config)\n        with cache.getfile(cache_key, suffix=\"db\") as filename:\n            connection = create_connection(filename)\n            cursor = connection.cursor()\n            result = cursor.execute(self.parse_config.configuration.sqlquery).fetchall()\n            connection.close()\n        return SqLiteParseContent(result=result)\n</code></pre>"},{"location":"all_strategies/#oteapi.strategies.parse.application_vnd_sqlite.SqliteParseStrategy.parse_config","title":"<code>parse_config: SqliteParserConfig</code>  <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.parse.application_vnd_sqlite.SqliteParseStrategy.get","title":"<code>get()</code>","text":"<p>Parse SQLite query responses.</p> Source code in <code>oteapi/strategies/parse/application_vnd_sqlite.py</code> <pre><code>def get(self) -&gt; SqLiteParseContent:\n    \"\"\"Parse SQLite query responses.\"\"\"\n\n    if self.parse_config.configuration.downloadUrl is None:\n        raise ValueError(\"No download URL provided.\")\n\n    if self.parse_config.configuration.mediaType != \"application/vnd.sqlite3\":\n        raise ValueError(\"Invalid media type.\")\n\n    # Retrieve SQLite file\n    downloader = create_strategy(\n        \"download\", self.parse_config.configuration.model_dump()\n    )\n    cache_key = downloader.get()[\"key\"]\n\n    cache = DataCache(self.parse_config.configuration.datacache_config)\n    with cache.getfile(cache_key, suffix=\"db\") as filename:\n        connection = create_connection(filename)\n        cursor = connection.cursor()\n        result = cursor.execute(self.parse_config.configuration.sqlquery).fetchall()\n        connection.close()\n    return SqLiteParseContent(result=result)\n</code></pre>"},{"location":"all_strategies/#oteapi.strategies.parse.application_vnd_sqlite.SqliteParseStrategy.initialize","title":"<code>initialize()</code>","text":"<p>Initialize strategy.</p> Source code in <code>oteapi/strategies/parse/application_vnd_sqlite.py</code> <pre><code>def initialize(self) -&gt; AttrDict:\n    \"\"\"Initialize strategy.\"\"\"\n    return AttrDict()\n</code></pre>"},{"location":"all_strategies/#oteapi.strategies.parse.application_vnd_sqlite.SqliteParserConfig","title":"<code>SqliteParserConfig</code>","text":"<p>               Bases: <code>ParserConfig</code></p> <p>SQLite parse strategy resource config.</p> Source code in <code>oteapi/strategies/parse/application_vnd_sqlite.py</code> <pre><code>class SqliteParserConfig(ParserConfig):\n    \"\"\"SQLite parse strategy resource config.\"\"\"\n\n    parserType: Literal[\"parser/sqlite3\"] = Field(\n        \"parser/sqlite3\",\n        description=ParserConfig.model_fields[\"parserType\"].description,\n    )\n    configuration: SqliteConfig = Field(\n        ..., description=\"SQLite parse strategy-specific configuration.\"\n    )\n</code></pre>"},{"location":"all_strategies/#oteapi.strategies.parse.application_vnd_sqlite.SqliteParserConfig.configuration","title":"<code>configuration: SqliteConfig = Field(..., description='SQLite parse strategy-specific configuration.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.parse.application_vnd_sqlite.SqliteParserConfig.parserType","title":"<code>parserType: Literal['parser/sqlite3'] = Field('parser/sqlite3', description=ParserConfig.model_fields['parserType'].description)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.parse.application_vnd_sqlite.create_connection","title":"<code>create_connection(db_file)</code>","text":"<p>Create a database connection to SQLite database.</p> <p>Parameters:</p> Name Type Description Default <code>db_file</code> <code>Path</code> <p>Full path to SQLite database file.</p> required <p>Raises:</p> Type Description <code>Error</code> <p>If a DB connection cannot be made.</p> <p>Returns:</p> Type Description <code>Connection</code> <p>Connection object.</p> Source code in <code>oteapi/strategies/parse/application_vnd_sqlite.py</code> <pre><code>def create_connection(db_file: Path) -&gt; sqlite3.Connection:\n    \"\"\"Create a database connection to SQLite database.\n\n    Parameters:\n        db_file: Full path to SQLite database file.\n\n    Raises:\n        sqlite3.Error: If a DB connection cannot be made.\n\n    Returns:\n        Connection object.\n\n    \"\"\"\n    try:\n        return sqlite3.connect(db_file)\n    except sqlite3.Error as exc:\n        raise sqlite3.Error(\"Could not connect to given SQLite DB.\") from exc\n</code></pre>"},{"location":"all_strategies/#oteapi.strategies.parse.excel_xlsx","title":"<code>excel_xlsx</code>","text":"<p>Strategy class for workbook/xlsx.</p>"},{"location":"all_strategies/#oteapi.strategies.parse.excel_xlsx.XLSXParseConfig","title":"<code>XLSXParseConfig</code>","text":"<p>               Bases: <code>AttrDict</code></p> <p>Data model for retrieving a rectangular section of an Excel sheet.</p> Source code in <code>oteapi/strategies/parse/excel_xlsx.py</code> <pre><code>class XLSXParseConfig(AttrDict):\n    \"\"\"Data model for retrieving a rectangular section of an Excel sheet.\"\"\"\n\n    # Resource config\n    downloadUrl: Optional[HostlessAnyUrl] = Field(\n        None, description=ResourceConfig.model_fields[\"downloadUrl\"].description\n    )\n    mediaType: Literal[\n        \"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\"\n    ] = Field(\n        \"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\",\n        description=ResourceConfig.model_fields[\"mediaType\"].description,\n    )\n\n    # XLSX parse strategy-specific config\n    worksheet: str = Field(..., description=\"Name of worksheet to load.\")\n    row_from: Optional[int] = Field(\n        None,\n        description=\"Excel row number of first row. Defaults to first assigned row.\",\n    )\n    col_from: Optional[Union[int, str]] = Field(\n        None,\n        description=(\n            \"Excel column number or label of first column. Defaults to first assigned \"\n            \"column.\"\n        ),\n    )\n    row_to: Optional[int] = Field(\n        None, description=\"Excel row number of last row. Defaults to last assigned row.\"\n    )\n    col_to: Optional[Union[int, str]] = Field(\n        None,\n        description=(\n            \"Excel column number or label of last column. Defaults to last assigned \"\n            \"column.\"\n        ),\n    )\n    header_row: Optional[int] = Field(\n        None,\n        description=(\n            \"Row number with the headers. Defaults to `1` if header is given, \"\n            \"otherwise `None`.\"\n        ),\n    )\n    header: Optional[List[str]] = Field(\n        None,\n        description=(\n            \"Optional list of column names, specifying the columns to return. \"\n            \"These names they should match cells in `header_row`.\"\n        ),\n    )\n    new_header: Optional[List[str]] = Field(\n        None,\n        description=(\n            \"Optional list of new column names replacing `header` in the output.\"\n        ),\n    )\n    download_config: AttrDict = Field(\n        AttrDict(),\n        description=\"Configurations provided to a download strategy.\",\n    )\n    datacache_config: Optional[DataCacheConfig] = Field(\n        None,\n        description=(\n            \"Configurations for the data cache for retrieving the downloaded file \"\n            \"content.\"\n        ),\n    )\n</code></pre>"},{"location":"all_strategies/#oteapi.strategies.parse.excel_xlsx.XLSXParseConfig.col_from","title":"<code>col_from: Optional[Union[int, str]] = Field(None, description='Excel column number or label of first column. Defaults to first assigned column.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.parse.excel_xlsx.XLSXParseConfig.col_to","title":"<code>col_to: Optional[Union[int, str]] = Field(None, description='Excel column number or label of last column. Defaults to last assigned column.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.parse.excel_xlsx.XLSXParseConfig.datacache_config","title":"<code>datacache_config: Optional[DataCacheConfig] = Field(None, description='Configurations for the data cache for retrieving the downloaded file content.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.parse.excel_xlsx.XLSXParseConfig.downloadUrl","title":"<code>downloadUrl: Optional[HostlessAnyUrl] = Field(None, description=ResourceConfig.model_fields['downloadUrl'].description)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.parse.excel_xlsx.XLSXParseConfig.download_config","title":"<code>download_config: AttrDict = Field(AttrDict(), description='Configurations provided to a download strategy.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.parse.excel_xlsx.XLSXParseConfig.header","title":"<code>header: Optional[List[str]] = Field(None, description='Optional list of column names, specifying the columns to return. These names they should match cells in `header_row`.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.parse.excel_xlsx.XLSXParseConfig.header_row","title":"<code>header_row: Optional[int] = Field(None, description='Row number with the headers. Defaults to `1` if header is given, otherwise `None`.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.parse.excel_xlsx.XLSXParseConfig.mediaType","title":"<code>mediaType: Literal['application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'] = Field('application/vnd.openxmlformats-officedocument.spreadsheetml.sheet', description=ResourceConfig.model_fields['mediaType'].description)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.parse.excel_xlsx.XLSXParseConfig.new_header","title":"<code>new_header: Optional[List[str]] = Field(None, description='Optional list of new column names replacing `header` in the output.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.parse.excel_xlsx.XLSXParseConfig.row_from","title":"<code>row_from: Optional[int] = Field(None, description='Excel row number of first row. Defaults to first assigned row.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.parse.excel_xlsx.XLSXParseConfig.row_to","title":"<code>row_to: Optional[int] = Field(None, description='Excel row number of last row. Defaults to last assigned row.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.parse.excel_xlsx.XLSXParseConfig.worksheet","title":"<code>worksheet: str = Field(..., description='Name of worksheet to load.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.parse.excel_xlsx.XLSXParseContent","title":"<code>XLSXParseContent</code>","text":"<p>               Bases: <code>AttrDict</code></p> <p>Class for returning values from XLSXParse.</p> Source code in <code>oteapi/strategies/parse/excel_xlsx.py</code> <pre><code>class XLSXParseContent(AttrDict):\n    \"\"\"Class for returning values from XLSXParse.\"\"\"\n\n    data: Dict[str, list] = Field(\n        ...,\n        description=\"A dict with column-name/column-value pairs. The values are lists.\",\n    )\n</code></pre>"},{"location":"all_strategies/#oteapi.strategies.parse.excel_xlsx.XLSXParseContent.data","title":"<code>data: Dict[str, list] = Field(..., description='A dict with column-name/column-value pairs. The values are lists.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.parse.excel_xlsx.XLSXParseParserConfig","title":"<code>XLSXParseParserConfig</code>","text":"<p>               Bases: <code>ParserConfig</code></p> <p>XLSX parse strategy resource config.</p> Source code in <code>oteapi/strategies/parse/excel_xlsx.py</code> <pre><code>class XLSXParseParserConfig(ParserConfig):\n    \"\"\"XLSX parse strategy resource config.\"\"\"\n\n    parserType: Literal[\"parser/excel_xlsx\"] = Field(\n        \"parser/excel_xlsx\",\n        description=ParserConfig.model_fields[\"parserType\"].description,\n    )\n    configuration: XLSXParseConfig = Field(\n        ..., description=\"SQLite parse strategy-specific configuration.\"\n    )\n</code></pre>"},{"location":"all_strategies/#oteapi.strategies.parse.excel_xlsx.XLSXParseParserConfig.configuration","title":"<code>configuration: XLSXParseConfig = Field(..., description='SQLite parse strategy-specific configuration.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.parse.excel_xlsx.XLSXParseParserConfig.parserType","title":"<code>parserType: Literal['parser/excel_xlsx'] = Field('parser/excel_xlsx', description=ParserConfig.model_fields['parserType'].description)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.parse.excel_xlsx.XLSXParseStrategy","title":"<code>XLSXParseStrategy</code>","text":"<p>Parse strategy for Excel XLSX files.</p> <p>Registers strategies:</p> <ul> <li><code>(\"parserType\", \"excel_xlsx\")</code></li> </ul> Source code in <code>oteapi/strategies/parse/excel_xlsx.py</code> <pre><code>@dataclass\nclass XLSXParseStrategy:\n    \"\"\"Parse strategy for Excel XLSX files.\n\n    **Registers strategies**:\n\n    - `(\"parserType\", \"excel_xlsx\")`\n\n    \"\"\"\n\n    parse_config: XLSXParseParserConfig\n\n    def initialize(self) -&gt; AttrDict:\n        \"\"\"Initialize.\"\"\"\n        return AttrDict()\n\n    def get(self) -&gt; XLSXParseContent:\n        \"\"\"Parses selected region of an excel file.\n\n        Returns:\n            A dict with column-name/column-value pairs. The values are lists.\n\n        \"\"\"\n\n        config = self.parse_config.configuration\n\n        # Download the file\n        download_config = config.model_dump()\n        download_config[\"configuration\"] = config.download_config.model_dump()\n        output = create_strategy(\"download\", download_config).get()\n\n        if config.datacache_config and config.datacache_config.accessKey:\n            cache_key = config.datacache_config.accessKey\n        elif \"key\" in output:\n            cache_key = output[\"key\"]\n        else:\n            raise RuntimeError(\"No data cache key provided to the downloaded content\")\n\n        cache = DataCache(config.datacache_config)\n\n        with cache.getfile(key=cache_key, suffix=\".xlsx\") as filename:\n            # Note that we have to set read_only=False to ensure that\n            # load_workbook() properly closes the xlsx file after reading.\n            # Otherwise Windows will fail when the temporary file is removed\n            # when leaving the with statement.\n            workbook = load_workbook(filename=filename, read_only=False, data_only=True)\n\n        worksheet = workbook[config.worksheet]\n        set_model_defaults(config, worksheet)\n        columns = get_column_indices(config, worksheet)\n\n        data = []\n        for row in worksheet.iter_rows(\n            min_row=config.row_from,\n            max_row=config.row_to,\n            min_col=min(columns),\n            max_col=max(columns),\n        ):\n            data.append([row[c - 1].value for c in columns])\n\n        if config.header_row:\n            row = worksheet.iter_rows(\n                min_row=config.header_row,\n                max_row=config.header_row,\n                min_col=min(columns),\n                max_col=max(columns),\n            ).__next__()\n            header = [row[c - 1].value for c in columns]\n        else:\n            header = None\n\n        if config.new_header:\n            nhead = len(header) if header else len(data[0]) if data else 0\n            if len(config.new_header) != nhead:\n                raise TypeError(\n                    \"length of `new_header` \"\n                    f\"(={len(config.new_header)}) \"\n                    f\"doesn't match number of columns (={len(header) if header else 0})\"\n                )\n            if header:\n                for i, val in enumerate(config.new_header):\n                    if val is not None:\n                        header[i] = val\n            elif data:\n                header = config.new_header\n\n        if header is None:\n            header = [get_column_letter(col + 1) for col in range(len(data))]\n\n        transposed = [list(datum) for datum in zip(*data)]\n        return XLSXParseContent(\n            data={key: value for key, value in zip(header, transposed)}\n        )\n</code></pre>"},{"location":"all_strategies/#oteapi.strategies.parse.excel_xlsx.XLSXParseStrategy.parse_config","title":"<code>parse_config: XLSXParseParserConfig</code>  <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.parse.excel_xlsx.XLSXParseStrategy.get","title":"<code>get()</code>","text":"<p>Parses selected region of an excel file.</p> <p>Returns:</p> Type Description <code>XLSXParseContent</code> <p>A dict with column-name/column-value pairs. The values are lists.</p> Source code in <code>oteapi/strategies/parse/excel_xlsx.py</code> <pre><code>def get(self) -&gt; XLSXParseContent:\n    \"\"\"Parses selected region of an excel file.\n\n    Returns:\n        A dict with column-name/column-value pairs. The values are lists.\n\n    \"\"\"\n\n    config = self.parse_config.configuration\n\n    # Download the file\n    download_config = config.model_dump()\n    download_config[\"configuration\"] = config.download_config.model_dump()\n    output = create_strategy(\"download\", download_config).get()\n\n    if config.datacache_config and config.datacache_config.accessKey:\n        cache_key = config.datacache_config.accessKey\n    elif \"key\" in output:\n        cache_key = output[\"key\"]\n    else:\n        raise RuntimeError(\"No data cache key provided to the downloaded content\")\n\n    cache = DataCache(config.datacache_config)\n\n    with cache.getfile(key=cache_key, suffix=\".xlsx\") as filename:\n        # Note that we have to set read_only=False to ensure that\n        # load_workbook() properly closes the xlsx file after reading.\n        # Otherwise Windows will fail when the temporary file is removed\n        # when leaving the with statement.\n        workbook = load_workbook(filename=filename, read_only=False, data_only=True)\n\n    worksheet = workbook[config.worksheet]\n    set_model_defaults(config, worksheet)\n    columns = get_column_indices(config, worksheet)\n\n    data = []\n    for row in worksheet.iter_rows(\n        min_row=config.row_from,\n        max_row=config.row_to,\n        min_col=min(columns),\n        max_col=max(columns),\n    ):\n        data.append([row[c - 1].value for c in columns])\n\n    if config.header_row:\n        row = worksheet.iter_rows(\n            min_row=config.header_row,\n            max_row=config.header_row,\n            min_col=min(columns),\n            max_col=max(columns),\n        ).__next__()\n        header = [row[c - 1].value for c in columns]\n    else:\n        header = None\n\n    if config.new_header:\n        nhead = len(header) if header else len(data[0]) if data else 0\n        if len(config.new_header) != nhead:\n            raise TypeError(\n                \"length of `new_header` \"\n                f\"(={len(config.new_header)}) \"\n                f\"doesn't match number of columns (={len(header) if header else 0})\"\n            )\n        if header:\n            for i, val in enumerate(config.new_header):\n                if val is not None:\n                    header[i] = val\n        elif data:\n            header = config.new_header\n\n    if header is None:\n        header = [get_column_letter(col + 1) for col in range(len(data))]\n\n    transposed = [list(datum) for datum in zip(*data)]\n    return XLSXParseContent(\n        data={key: value for key, value in zip(header, transposed)}\n    )\n</code></pre>"},{"location":"all_strategies/#oteapi.strategies.parse.excel_xlsx.XLSXParseStrategy.initialize","title":"<code>initialize()</code>","text":"<p>Initialize.</p> Source code in <code>oteapi/strategies/parse/excel_xlsx.py</code> <pre><code>def initialize(self) -&gt; AttrDict:\n    \"\"\"Initialize.\"\"\"\n    return AttrDict()\n</code></pre>"},{"location":"all_strategies/#oteapi.strategies.parse.excel_xlsx.get_column_indices","title":"<code>get_column_indices(model, worksheet)</code>","text":"<p>Helper function returning a list of column indices.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>XLSXParseConfig</code> <p>The parsed data model.</p> required <code>worksheet</code> <code>Worksheet</code> <p>Excel worksheet, from which the header values will be retrieved.</p> required <p>Returns:</p> Type Description <code>Iterable[int]</code> <p>A list of column indices.</p> Source code in <code>oteapi/strategies/parse/excel_xlsx.py</code> <pre><code>def get_column_indices(\n    model: XLSXParseConfig, worksheet: \"Worksheet\"\n) -&gt; \"Iterable[int]\":\n    \"\"\"Helper function returning a list of column indices.\n\n    Parameters:\n        model: The parsed data model.\n        worksheet: Excel worksheet, from which the header values will be retrieved.\n\n    Returns:\n        A list of column indices.\n\n    \"\"\"\n    if not isinstance(model.col_from, int) or not isinstance(model.col_to, int):\n        raise TypeError(\"Expected `model.col_from` and `model.col_to` to be integers.\")\n\n    if model.header:\n        header_dict = {\n            worksheet.cell(model.header_row, col).value: col\n            for col in range(model.col_from, model.col_to + 1)\n        }\n        return [header_dict[h] for h in model.header]\n    return range(model.col_from, model.col_to + 1)\n</code></pre>"},{"location":"all_strategies/#oteapi.strategies.parse.excel_xlsx.set_model_defaults","title":"<code>set_model_defaults(model, worksheet)</code>","text":"<p>Update data model <code>model</code> with default values obtained from <code>worksheet</code>.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>XLSXParseConfig</code> <p>The parsed data model.</p> required <code>worksheet</code> <code>Worksheet</code> <p>Excel worksheet, from which the default values will be obtained.</p> required Source code in <code>oteapi/strategies/parse/excel_xlsx.py</code> <pre><code>def set_model_defaults(model: XLSXParseConfig, worksheet: \"Worksheet\") -&gt; None:\n    \"\"\"Update data model `model` with default values obtained from `worksheet`.\n\n    Parameters:\n        model: The parsed data model.\n        worksheet: Excel worksheet, from which the default values will be obtained.\n\n    \"\"\"\n    if model.row_from is None:\n        if model.header:\n            # assume that data starts on the first row after the header\n            model.row_from = model.header_row + 1 if model.header_row else 1\n        else:\n            model.row_from = worksheet.min_row\n\n    if model.row_to is None:\n        model.row_to = worksheet.max_row\n\n    if model.col_from is None:\n        model.col_from = worksheet.min_column\n    elif isinstance(model.col_from, str):\n        model.col_from = column_index_from_string(model.col_from)\n\n    if model.col_to is None:\n        model.col_to = worksheet.max_column\n    elif isinstance(model.col_to, str):\n        model.col_to = column_index_from_string(model.col_to)\n\n    if model.header and not model.header_row:\n        model.header_row = 1\n</code></pre>"},{"location":"all_strategies/#oteapi.strategies.parse.image","title":"<code>image</code>","text":"<p>Strategy class for image/jpg.</p>"},{"location":"all_strategies/#oteapi.strategies.parse.image.ImageConfig","title":"<code>ImageConfig</code>","text":"<p>               Bases: <code>AttrDict</code></p> <p>Configuration data model for <code>ImageDataParseStrategy</code>.</p> Source code in <code>oteapi/strategies/parse/image.py</code> <pre><code>class ImageConfig(AttrDict):\n    \"\"\"Configuration data model for\n    [`ImageDataParseStrategy`][oteapi.strategies.parse.image.ImageDataParseStrategy].\"\"\"\n\n    # Resource config\n    downloadUrl: Optional[HostlessAnyUrl] = Field(\n        None, description=ResourceConfig.model_fields[\"downloadUrl\"].description\n    )\n    mediaType: Optional[\n        Literal[\n            \"image/jpg\",\n            \"image/jpeg\",\n            \"image/jp2\",\n            \"image/png\",\n            \"image/gif\",\n            \"image/tiff\",\n            \"image/eps\",\n        ]\n    ] = Field(\n        None,\n        description=ResourceConfig.model_fields[\"mediaType\"].description,\n    )\n\n    # Image parse strategy-specific config\n    crop: Optional[Tuple[int, int, int, int]] = Field(\n        None,\n        description=\"Box cropping parameters (left, top, right, bottom).\",\n        # Effectively mapping 'imagecrop' to 'crop'.\n        # 'imagecrop' is used by the crop filter strategy.\n        validation_alias=AliasChoices(\"crop\", \"imagecrop\"),\n    )\n    datacache_config: Optional[DataCacheConfig] = Field(\n        None,\n        description=\"Configuration options for the local data cache.\",\n    )\n    image_key: Optional[str] = Field(\n        None,\n        description=\"Key to use when storing the image data in datacache.\",\n    )\n    image_mode: Optional[str] = Field(\n        None,\n        description=(\n            \"Pillow mode to convert image into. See \"\n            \"https://pillow.readthedocs.io/en/stable/handbook/concepts.html \"\n            \"for details.\"\n        ),\n    )\n</code></pre>"},{"location":"all_strategies/#oteapi.strategies.parse.image.ImageConfig.crop","title":"<code>crop: Optional[Tuple[int, int, int, int]] = Field(None, description='Box cropping parameters (left, top, right, bottom).', validation_alias=AliasChoices('crop', 'imagecrop'))</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.parse.image.ImageConfig.datacache_config","title":"<code>datacache_config: Optional[DataCacheConfig] = Field(None, description='Configuration options for the local data cache.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.parse.image.ImageConfig.downloadUrl","title":"<code>downloadUrl: Optional[HostlessAnyUrl] = Field(None, description=ResourceConfig.model_fields['downloadUrl'].description)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.parse.image.ImageConfig.image_key","title":"<code>image_key: Optional[str] = Field(None, description='Key to use when storing the image data in datacache.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.parse.image.ImageConfig.image_mode","title":"<code>image_mode: Optional[str] = Field(None, description='Pillow mode to convert image into. See https://pillow.readthedocs.io/en/stable/handbook/concepts.html for details.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.parse.image.ImageConfig.mediaType","title":"<code>mediaType: Optional[Literal['image/jpg', 'image/jpeg', 'image/jp2', 'image/png', 'image/gif', 'image/tiff', 'image/eps']] = Field(None, description=ResourceConfig.model_fields['mediaType'].description)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.parse.image.ImageDataParseStrategy","title":"<code>ImageDataParseStrategy</code>","text":"<p>Parse strategy for images.</p> <p>This strategy uses Pillow to read a raw image from the data cache, converts it into a NumPy array and stores the new array in the data cache.</p> <p>It also supports simple cropping and image conversions.</p> <p>The key to the new array and other metadata is returned. See <code>ImageParseContent</code> for more info.</p> Source code in <code>oteapi/strategies/parse/image.py</code> <pre><code>@dataclass\nclass ImageDataParseStrategy:\n    \"\"\"Parse strategy for images.\n\n    This strategy uses Pillow to read a raw image from the data cache,\n    converts it into a NumPy array and stores the new array in the\n    data cache.\n\n    It also supports simple cropping and image conversions.\n\n    The key to the new array and other metadata is returned. See\n    [`ImageParseContent`][oteapi.strategies.parse.image.ImageParseContent]\n    for more info.\n\n    \"\"\"\n\n    parse_config: ImageParserConfig\n\n    def initialize(self) -&gt; AttrDict:\n        \"\"\"Initialize strategy.\"\"\"\n        return AttrDict()\n\n    def get(self) -&gt; ImageParseContent:\n        \"\"\"Execute the strategy.\"\"\"\n\n        config = self.parse_config.configuration\n\n        if config.mediaType is None:\n            raise ValueError(\"No media type provided to the image parser\")\n\n        mime_format = config.mediaType.split(\"/\")[1]\n        image_format = SupportedFormat[mime_format].value\n\n        # Download the image\n        download_config = config.model_dump()\n        download_config[\"configuration\"] = config.model_dump()\n        output = create_strategy(\"download\", download_config).get()\n\n        if config.datacache_config and config.datacache_config.accessKey:\n            cache_key = config.datacache_config.accessKey\n        elif \"key\" in output:\n            cache_key = output[\"key\"]\n        else:\n            raise RuntimeError(\"No data cache key provided to the downloaded content\")\n\n        cache = DataCache(config.datacache_config)\n\n        # Treat image according to filter values\n        with (\n            cache.getfile(cache_key, suffix=mime_format) as filename,\n            Image.open(filename, formats=[image_format]) as image,\n        ):\n            if config.crop:\n                image = image.crop(config.crop)\n            if config.image_mode:\n                image = image.convert(mode=config.image_mode)\n\n            if image_format == \"GIF\" and image.info.get(\"version\", b\"\").startswith(\n                b\"GIF\"\n            ):\n                image.info.update(\n                    {\"version\": image.info.get(\"version\", b\"\")[len(b\"GIF\") :]}\n                )\n\n            image_key = cache.add(\n                image.tobytes(),\n                key=config.image_key,\n            )\n\n            if image.mode == \"P\":\n                image_palette_key = cache.add(image.getpalette())\n            else:\n                image_palette_key = None\n\n            # The returned content must be json serialisable - filter out all\n            # non-json serialisable fields in image.info\n            if image.info:\n                image_info = {\n                    key: val\n                    for key, val in image.info.items()\n                    if isinstance(val, (str, int, float, type(None), bool, tuple, list))\n                }\n            else:\n                image_info = {}\n\n            content = ImageParseContent(\n                image_key=image_key,\n                image_size=image.size,\n                image_mode=image.mode,\n                image_palette_key=image_palette_key,\n                image_info=image_info,\n            )\n\n        return content\n</code></pre>"},{"location":"all_strategies/#oteapi.strategies.parse.image.ImageDataParseStrategy.parse_config","title":"<code>parse_config: ImageParserConfig</code>  <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.parse.image.ImageDataParseStrategy.get","title":"<code>get()</code>","text":"<p>Execute the strategy.</p> Source code in <code>oteapi/strategies/parse/image.py</code> <pre><code>def get(self) -&gt; ImageParseContent:\n    \"\"\"Execute the strategy.\"\"\"\n\n    config = self.parse_config.configuration\n\n    if config.mediaType is None:\n        raise ValueError(\"No media type provided to the image parser\")\n\n    mime_format = config.mediaType.split(\"/\")[1]\n    image_format = SupportedFormat[mime_format].value\n\n    # Download the image\n    download_config = config.model_dump()\n    download_config[\"configuration\"] = config.model_dump()\n    output = create_strategy(\"download\", download_config).get()\n\n    if config.datacache_config and config.datacache_config.accessKey:\n        cache_key = config.datacache_config.accessKey\n    elif \"key\" in output:\n        cache_key = output[\"key\"]\n    else:\n        raise RuntimeError(\"No data cache key provided to the downloaded content\")\n\n    cache = DataCache(config.datacache_config)\n\n    # Treat image according to filter values\n    with (\n        cache.getfile(cache_key, suffix=mime_format) as filename,\n        Image.open(filename, formats=[image_format]) as image,\n    ):\n        if config.crop:\n            image = image.crop(config.crop)\n        if config.image_mode:\n            image = image.convert(mode=config.image_mode)\n\n        if image_format == \"GIF\" and image.info.get(\"version\", b\"\").startswith(\n            b\"GIF\"\n        ):\n            image.info.update(\n                {\"version\": image.info.get(\"version\", b\"\")[len(b\"GIF\") :]}\n            )\n\n        image_key = cache.add(\n            image.tobytes(),\n            key=config.image_key,\n        )\n\n        if image.mode == \"P\":\n            image_palette_key = cache.add(image.getpalette())\n        else:\n            image_palette_key = None\n\n        # The returned content must be json serialisable - filter out all\n        # non-json serialisable fields in image.info\n        if image.info:\n            image_info = {\n                key: val\n                for key, val in image.info.items()\n                if isinstance(val, (str, int, float, type(None), bool, tuple, list))\n            }\n        else:\n            image_info = {}\n\n        content = ImageParseContent(\n            image_key=image_key,\n            image_size=image.size,\n            image_mode=image.mode,\n            image_palette_key=image_palette_key,\n            image_info=image_info,\n        )\n\n    return content\n</code></pre>"},{"location":"all_strategies/#oteapi.strategies.parse.image.ImageDataParseStrategy.initialize","title":"<code>initialize()</code>","text":"<p>Initialize strategy.</p> Source code in <code>oteapi/strategies/parse/image.py</code> <pre><code>def initialize(self) -&gt; AttrDict:\n    \"\"\"Initialize strategy.\"\"\"\n    return AttrDict()\n</code></pre>"},{"location":"all_strategies/#oteapi.strategies.parse.image.ImageParseContent","title":"<code>ImageParseContent</code>","text":"<p>               Bases: <code>AttrDict</code></p> <p>Configuration model for the returned content from the Image parser.</p> <p>See Pillow handbook for more details on <code>image_mode</code>, <code>image_palette</code>, and <code>image_info</code>.</p> Source code in <code>oteapi/strategies/parse/image.py</code> <pre><code>class ImageParseContent(AttrDict):\n    \"\"\"Configuration model for the returned content from the Image parser.\n\n    See\n    [Pillow handbook](https://pillow.readthedocs.io/en/stable/handbook/concepts.html)\n    for more details on `image_mode`, `image_palette`, and `image_info`.\n    \"\"\"\n\n    image_key: str = Field(\n        ...,\n        description=\"Key with which the image content is stored in the data cache.\",\n    )\n    image_size: Tuple[int, int] = Field(\n        ...,\n        description=\"Image size (width, height).\",\n    )\n    image_mode: str = Field(\n        ...,\n        description=\"Image mode. Examples: 'L', 'P', 'RGB', 'RGBA'...\",\n    )\n    image_palette_key: Optional[str] = Field(\n        None,\n        description=\"Datacache key for colour palette if mode is 'P'.\",\n    )\n    image_info: dict = Field(\n        {},\n        description=\"Additional information about the image.\",\n    )\n</code></pre>"},{"location":"all_strategies/#oteapi.strategies.parse.image.ImageParseContent.image_info","title":"<code>image_info: dict = Field({}, description='Additional information about the image.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.parse.image.ImageParseContent.image_key","title":"<code>image_key: str = Field(..., description='Key with which the image content is stored in the data cache.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.parse.image.ImageParseContent.image_mode","title":"<code>image_mode: str = Field(..., description=\"Image mode. Examples: 'L', 'P', 'RGB', 'RGBA'...\")</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.parse.image.ImageParseContent.image_palette_key","title":"<code>image_palette_key: Optional[str] = Field(None, description=\"Datacache key for colour palette if mode is 'P'.\")</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.parse.image.ImageParseContent.image_size","title":"<code>image_size: Tuple[int, int] = Field(..., description='Image size (width, height).')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.parse.image.ImageParserConfig","title":"<code>ImageParserConfig</code>","text":"<p>               Bases: <code>ParserConfig</code></p> <p>Image parse strategy resource config.</p> Source code in <code>oteapi/strategies/parse/image.py</code> <pre><code>class ImageParserConfig(ParserConfig):\n    \"\"\"Image parse strategy resource config.\"\"\"\n\n    parserType: Literal[\"parser/image\"] = Field(\n        \"parser/image\",\n        description=ParserConfig.model_fields[\"parserType\"].description,\n    )\n    configuration: ImageConfig = Field(\n        ...,\n        description=\"Image parse strategy-specific configuration.\",\n    )\n</code></pre>"},{"location":"all_strategies/#oteapi.strategies.parse.image.ImageParserConfig.configuration","title":"<code>configuration: ImageConfig = Field(..., description='Image parse strategy-specific configuration.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.parse.image.ImageParserConfig.parserType","title":"<code>parserType: Literal['parser/image'] = Field('parser/image', description=ParserConfig.model_fields['parserType'].description)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.parse.image.SupportedFormat","title":"<code>SupportedFormat</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Supported formats for <code>ImageDataParseStrategy</code>.</p> Source code in <code>oteapi/strategies/parse/image.py</code> <pre><code>class SupportedFormat(Enum):\n    \"\"\"Supported formats for `ImageDataParseStrategy`.\"\"\"\n\n    jpeg = \"JPEG\"\n    jpg = \"JPEG\"\n    jp2 = \"JPEG2000\"\n    png = \"PNG\"\n    gif = \"GIF\"\n    tiff = \"TIFF\"\n    eps = \"EPS\"\n</code></pre>"},{"location":"all_strategies/#oteapi.strategies.parse.image.SupportedFormat.eps","title":"<code>eps = 'EPS'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.parse.image.SupportedFormat.gif","title":"<code>gif = 'GIF'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.parse.image.SupportedFormat.jp2","title":"<code>jp2 = 'JPEG2000'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.parse.image.SupportedFormat.jpeg","title":"<code>jpeg = 'JPEG'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.parse.image.SupportedFormat.jpg","title":"<code>jpg = 'JPEG'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.parse.image.SupportedFormat.png","title":"<code>png = 'PNG'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.parse.image.SupportedFormat.tiff","title":"<code>tiff = 'TIFF'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.parse.postgres","title":"<code>postgres</code>","text":"<p>Strategy class for application/vnd.postgresql</p>"},{"location":"all_strategies/#oteapi.strategies.parse.postgres.PostgresConfig","title":"<code>PostgresConfig</code>","text":"<p>               Bases: <code>AttrDict</code></p> <p>Configuration data model for <code>PostgresParserStrategy</code>.</p> Source code in <code>oteapi/strategies/parse/postgres.py</code> <pre><code>class PostgresConfig(AttrDict):\n    \"\"\"Configuration data model for\n    [`PostgresParserStrategy`][oteapi.strategies.parse.postgres.PostgresParserConfig].\n    \"\"\"\n\n    # Resource config\n    accessService: Literal[\"postgres\"] = Field(\n        \"postgres\",\n        description=ResourceConfig.model_fields[\"accessService\"].description,\n    )\n    accessUrl: Optional[HostlessAnyUrl] = Field(\n        None,\n        description=ResourceConfig.model_fields[\"accessUrl\"].description,\n    )\n\n    # Postgres specific config\n    datacache_config: Optional[DataCacheConfig] = Field(\n        None,\n        description=\"Configuration options for the local data cache.\",\n    )\n    user: Optional[str] = Field(None, description=\"postgres server username\")\n    dbname: Optional[str] = Field(None, description=\"postgres dbname name\")\n    password: Optional[str] = Field(None, description=\"postgres password\")\n    sqlquery: str = Field(\"\", description=\"A SQL query string.\")\n\n    @model_validator(mode=\"before\")\n    @classmethod\n    def adjust_url(cls, data: Any) -&gt; \"Dict[str, Any]\":\n        \"\"\"Model Validator\n        Verifies configuration consistency, merge configurations\n        and update the accessUrl property.\n        \"\"\"\n        if isinstance(data, BaseModel):\n            data = data.model_dump()\n        elif not isinstance(data, dict):\n            raise TypeError(\n                \"invalid data type, should be either dict or pydantic model\"\n            )\n\n        if \"accessUrl\" not in data:\n            return data\n\n        # Copy model-state into placeholders\n        accessUrl = AnyUrl(data[\"accessUrl\"])\n        default_config = PostgresConfig()\n        current_config: dict[str, Any] = data.get(\"configuration\", {})\n\n        if not accessUrl.host:\n            raise ValueError(\"missing host in accessUrl\")\n\n        def _get_and_validate_config_value(url_parameter: str, config_key: str) -&gt; str:\n            \"\"\"Get value from accessUrl or current_config, and check for mismatches.\"\"\"\n            value_from_url = getattr(accessUrl, url_parameter, None)\n            value_from_config = current_config.get(\n                config_key, getattr(default_config, config_key)\n            )\n\n            final_value = value_from_url or value_from_config\n\n            if value_from_config and final_value != value_from_config:\n                raise ValueError(\n                    f\"mismatching {url_parameter} in accessUrl and {config_key} in \"\n                    \"configuration\"\n                )\n\n            return final_value\n\n        user = _get_and_validate_config_value(\"username\", \"user\")\n        password = _get_and_validate_config_value(\"password\", \"password\")\n        dbname = _get_and_validate_config_value(\"path\", \"dbname\")\n\n        # Reconstruct accessUrl from the updated properties\n        data[\"accessUrl\"] = accessUrl.__class__.build(\n            scheme=accessUrl.scheme,\n            username=user,\n            password=password,\n            host=accessUrl.host,\n            port=accessUrl.port,\n            path=dbname,\n            query=accessUrl.query,\n            fragment=accessUrl.fragment,\n        )\n        return data\n</code></pre>"},{"location":"all_strategies/#oteapi.strategies.parse.postgres.PostgresConfig.accessService","title":"<code>accessService: Literal['postgres'] = Field('postgres', description=ResourceConfig.model_fields['accessService'].description)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.parse.postgres.PostgresConfig.accessUrl","title":"<code>accessUrl: Optional[HostlessAnyUrl] = Field(None, description=ResourceConfig.model_fields['accessUrl'].description)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.parse.postgres.PostgresConfig.datacache_config","title":"<code>datacache_config: Optional[DataCacheConfig] = Field(None, description='Configuration options for the local data cache.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.parse.postgres.PostgresConfig.dbname","title":"<code>dbname: Optional[str] = Field(None, description='postgres dbname name')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.parse.postgres.PostgresConfig.password","title":"<code>password: Optional[str] = Field(None, description='postgres password')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.parse.postgres.PostgresConfig.sqlquery","title":"<code>sqlquery: str = Field('', description='A SQL query string.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.parse.postgres.PostgresConfig.user","title":"<code>user: Optional[str] = Field(None, description='postgres server username')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.parse.postgres.PostgresConfig.adjust_url","title":"<code>adjust_url(data)</code>  <code>classmethod</code>","text":"<p>Model Validator Verifies configuration consistency, merge configurations and update the accessUrl property.</p> Source code in <code>oteapi/strategies/parse/postgres.py</code> <pre><code>@model_validator(mode=\"before\")\n@classmethod\ndef adjust_url(cls, data: Any) -&gt; \"Dict[str, Any]\":\n    \"\"\"Model Validator\n    Verifies configuration consistency, merge configurations\n    and update the accessUrl property.\n    \"\"\"\n    if isinstance(data, BaseModel):\n        data = data.model_dump()\n    elif not isinstance(data, dict):\n        raise TypeError(\n            \"invalid data type, should be either dict or pydantic model\"\n        )\n\n    if \"accessUrl\" not in data:\n        return data\n\n    # Copy model-state into placeholders\n    accessUrl = AnyUrl(data[\"accessUrl\"])\n    default_config = PostgresConfig()\n    current_config: dict[str, Any] = data.get(\"configuration\", {})\n\n    if not accessUrl.host:\n        raise ValueError(\"missing host in accessUrl\")\n\n    def _get_and_validate_config_value(url_parameter: str, config_key: str) -&gt; str:\n        \"\"\"Get value from accessUrl or current_config, and check for mismatches.\"\"\"\n        value_from_url = getattr(accessUrl, url_parameter, None)\n        value_from_config = current_config.get(\n            config_key, getattr(default_config, config_key)\n        )\n\n        final_value = value_from_url or value_from_config\n\n        if value_from_config and final_value != value_from_config:\n            raise ValueError(\n                f\"mismatching {url_parameter} in accessUrl and {config_key} in \"\n                \"configuration\"\n            )\n\n        return final_value\n\n    user = _get_and_validate_config_value(\"username\", \"user\")\n    password = _get_and_validate_config_value(\"password\", \"password\")\n    dbname = _get_and_validate_config_value(\"path\", \"dbname\")\n\n    # Reconstruct accessUrl from the updated properties\n    data[\"accessUrl\"] = accessUrl.__class__.build(\n        scheme=accessUrl.scheme,\n        username=user,\n        password=password,\n        host=accessUrl.host,\n        port=accessUrl.port,\n        path=dbname,\n        query=accessUrl.query,\n        fragment=accessUrl.fragment,\n    )\n    return data\n</code></pre>"},{"location":"all_strategies/#oteapi.strategies.parse.postgres.PostgresParserConfig","title":"<code>PostgresParserConfig</code>","text":"<p>               Bases: <code>ParserConfig</code></p> <p>Postgresql parse strategy config</p> Source code in <code>oteapi/strategies/parse/postgres.py</code> <pre><code>class PostgresParserConfig(ParserConfig):\n    \"\"\"Postgresql parse strategy config\"\"\"\n\n    parserType: Literal[\"parser/postgres\"] = Field(\n        \"parser/postgres\",\n        description=\"Type of registered resource strategy.\",\n    )\n    configuration: PostgresConfig = Field(\n        ...,\n        description=(\n            \"Configuration for resource. Values in the accessURL take precedence.\"\n        ),\n    )\n</code></pre>"},{"location":"all_strategies/#oteapi.strategies.parse.postgres.PostgresParserConfig.configuration","title":"<code>configuration: PostgresConfig = Field(..., description='Configuration for resource. Values in the accessURL take precedence.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.parse.postgres.PostgresParserConfig.parserType","title":"<code>parserType: Literal['parser/postgres'] = Field('parser/postgres', description='Type of registered resource strategy.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.parse.postgres.PostgresParserContent","title":"<code>PostgresParserContent</code>","text":"<p>               Bases: <code>AttrDict</code></p> <p>Configuration model for PostgresParser.</p> Source code in <code>oteapi/strategies/parse/postgres.py</code> <pre><code>class PostgresParserContent(AttrDict):\n    \"\"\"Configuration model for PostgresParser.\"\"\"\n\n    result: list = Field(..., description=\"List of results from the query.\")\n</code></pre>"},{"location":"all_strategies/#oteapi.strategies.parse.postgres.PostgresParserContent.result","title":"<code>result: list = Field(..., description='List of results from the query.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.parse.postgres.PostgresParserStrategy","title":"<code>PostgresParserStrategy</code>","text":"<p>Resource strategy for Postgres.</p> <p>Purpose of this strategy: Connect to a postgres DB and run a SQL query on the dbname to return all relevant rows.</p> Source code in <code>oteapi/strategies/parse/postgres.py</code> <pre><code>@dataclass\nclass PostgresParserStrategy:\n    \"\"\"Resource strategy for Postgres.\n\n    Purpose of this strategy: Connect to a postgres DB and run a\n    SQL query on the dbname to return all relevant rows.\n\n    \"\"\"\n\n    parser_config: PostgresParserConfig\n\n    def initialize(self) -&gt; AttrDict:\n        \"\"\"Initialize strategy.\"\"\"\n        return AttrDict()\n\n    def get(self) -&gt; PostgresParserContent:\n        \"\"\"Resource Postgres query responses.\"\"\"\n\n        if self.parser_config.configuration.accessUrl is None:\n            raise ValueError(\"accessUrl is required for PostgresParserStrategy\")\n\n        connection = create_connection(str(self.parser_config.configuration.accessUrl))\n        cursor = connection.cursor()\n        result = cursor.execute(self.parser_config.configuration.sqlquery).fetchall()\n        connection.close()\n        return PostgresParserContent(result=result)\n</code></pre>"},{"location":"all_strategies/#oteapi.strategies.parse.postgres.PostgresParserStrategy.parser_config","title":"<code>parser_config: PostgresParserConfig</code>  <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.parse.postgres.PostgresParserStrategy.get","title":"<code>get()</code>","text":"<p>Resource Postgres query responses.</p> Source code in <code>oteapi/strategies/parse/postgres.py</code> <pre><code>def get(self) -&gt; PostgresParserContent:\n    \"\"\"Resource Postgres query responses.\"\"\"\n\n    if self.parser_config.configuration.accessUrl is None:\n        raise ValueError(\"accessUrl is required for PostgresParserStrategy\")\n\n    connection = create_connection(str(self.parser_config.configuration.accessUrl))\n    cursor = connection.cursor()\n    result = cursor.execute(self.parser_config.configuration.sqlquery).fetchall()\n    connection.close()\n    return PostgresParserContent(result=result)\n</code></pre>"},{"location":"all_strategies/#oteapi.strategies.parse.postgres.PostgresParserStrategy.initialize","title":"<code>initialize()</code>","text":"<p>Initialize strategy.</p> Source code in <code>oteapi/strategies/parse/postgres.py</code> <pre><code>def initialize(self) -&gt; AttrDict:\n    \"\"\"Initialize strategy.\"\"\"\n    return AttrDict()\n</code></pre>"},{"location":"all_strategies/#oteapi.strategies.parse.postgres.create_connection","title":"<code>create_connection(url)</code>","text":"<p>Create a dbname connection to Postgres dbname.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>A valid PostgreSQL URL.</p> required <p>Raises:</p> Type Description <code>Error</code> <p>If a DB connection cannot be made.</p> <p>Returns:</p> Type Description <code>Connection</code> <p>Connection object.</p> Source code in <code>oteapi/strategies/parse/postgres.py</code> <pre><code>def create_connection(url: str) -&gt; psycopg.Connection:\n    \"\"\"Create a dbname connection to Postgres dbname.\n\n    Parameters:\n        url: A valid PostgreSQL URL.\n\n    Raises:\n        psycopg.Error: If a DB connection cannot be made.\n\n    Returns:\n        Connection object.\n\n    \"\"\"\n    try:\n        return psycopg.connect(url)\n    except psycopg.Error as exc:\n        raise psycopg.Error(\"Could not connect to given Postgres DB.\") from exc\n</code></pre>"},{"location":"all_strategies/#oteapi.strategies.parse.text_csv","title":"<code>text_csv</code>","text":"<p>Strategy class for parser/csv.</p>"},{"location":"all_strategies/#oteapi.strategies.parse.text_csv.CSVDialect","title":"<code>CSVDialect: Type[Enum] = Enum(value='CSVDialect', names={dialect.upper(): dialectfor dialect in csv.list_dialects()}, module=__name__, type=str)</code>  <code>module-attribute</code>","text":"<p>CSV dialects.</p> <p>All available dialects are retrieved through the <code>csv.list_dialects()</code> function, and will thus depend on the currently loaded and used Python interpreter.</p>"},{"location":"all_strategies/#oteapi.strategies.parse.text_csv.CSVConfig","title":"<code>CSVConfig</code>","text":"<p>               Bases: <code>AttrDict</code></p> <p>CSV parse-specific Configuration Data Model.</p> Source code in <code>oteapi/strategies/parse/text_csv.py</code> <pre><code>class CSVConfig(AttrDict):\n    \"\"\"CSV parse-specific Configuration Data Model.\"\"\"\n\n    # Resource config\n    downloadUrl: Optional[HostlessAnyUrl] = Field(\n        None,\n        description=ResourceConfig.model_fields[\"downloadUrl\"].description,\n    )\n    mediaType: Literal[\"text/csv\"] = Field(\n        \"text/csv\",\n        description=ResourceConfig.model_fields[\"mediaType\"].description,\n    )\n\n    # CSV parse strategy-specific configuration\n    datacache_config: Optional[DataCacheConfig] = Field(\n        None,\n        description=(\n            \"Configurations for the data cache for storing the downloaded file \"\n            \"content.\"\n        ),\n    )\n    dialect: DialectFormatting = Field(\n        DialectFormatting(),\n        description=(\n            \"Dialect and formatting parameters. See [the Python docs]\"\n            \"(https://docs.python.org/3/library/csv.html#csv-fmt-params) for more \"\n            \"information.\"\n        ),\n    )\n    reader: ReaderConfig = Field(\n        ReaderConfig(),\n        description=(\n            \"CSV DictReader configuration parameters. See [the Python docs]\"\n            \"(https://docs.python.org/3/library/csv.html#csv.DictReader) for more \"\n            \"information.\"\n        ),\n    )\n</code></pre>"},{"location":"all_strategies/#oteapi.strategies.parse.text_csv.CSVConfig.datacache_config","title":"<code>datacache_config: Optional[DataCacheConfig] = Field(None, description='Configurations for the data cache for storing the downloaded file content.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.parse.text_csv.CSVConfig.dialect","title":"<code>dialect: DialectFormatting = Field(DialectFormatting(), description='Dialect and formatting parameters. See [the Python docs](https://docs.python.org/3/library/csv.html#csv-fmt-params) for more information.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.parse.text_csv.CSVConfig.downloadUrl","title":"<code>downloadUrl: Optional[HostlessAnyUrl] = Field(None, description=ResourceConfig.model_fields['downloadUrl'].description)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.parse.text_csv.CSVConfig.mediaType","title":"<code>mediaType: Literal['text/csv'] = Field('text/csv', description=ResourceConfig.model_fields['mediaType'].description)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.parse.text_csv.CSVConfig.reader","title":"<code>reader: ReaderConfig = Field(ReaderConfig(), description='CSV DictReader configuration parameters. See [the Python docs](https://docs.python.org/3/library/csv.html#csv.DictReader) for more information.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.parse.text_csv.CSVParseContent","title":"<code>CSVParseContent</code>","text":"<p>               Bases: <code>AttrDict</code></p> <p>Class for returning values from CSV Parse.</p> Source code in <code>oteapi/strategies/parse/text_csv.py</code> <pre><code>class CSVParseContent(AttrDict):\n    \"\"\"Class for returning values from CSV Parse.\"\"\"\n\n    content: dict[Union[str, None], list[Any]] = Field(\n        ..., description=\"Content of the CSV document.\"\n    )\n</code></pre>"},{"location":"all_strategies/#oteapi.strategies.parse.text_csv.CSVParseContent.content","title":"<code>content: dict[Union[str, None], list[Any]] = Field(..., description='Content of the CSV document.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.parse.text_csv.CSVParseStrategy","title":"<code>CSVParseStrategy</code>","text":"<p>Parse strategy for CSV files.</p> Source code in <code>oteapi/strategies/parse/text_csv.py</code> <pre><code>@dataclass\nclass CSVParseStrategy:\n    \"\"\"Parse strategy for CSV files.\"\"\"\n\n    parse_config: CSVParserConfig\n\n    def initialize(self) -&gt; AttrDict:\n        \"\"\"Initialize.\"\"\"\n        return AttrDict()\n\n    def get(self) -&gt; CSVParseContent:\n        \"\"\"Parse CSV.\"\"\"\n        config = self.parse_config.configuration\n\n        # Download the file\n        download_config = config.model_dump()\n        download_config[\"configuration\"] = config.model_dump()\n        output = create_strategy(\"download\", download_config).get()\n\n        if config.datacache_config and config.datacache_config.accessKey:\n            cache_key = config.datacache_config.accessKey\n        elif \"key\" in output:\n            cache_key = output[\"key\"]\n        else:\n            raise RuntimeError(\"No data cache key provided to the downloaded content\")\n\n        cache = DataCache(config.datacache_config)\n\n        with cache.getfile(cache_key) as csvfile_path:\n            kwargs = config.dialect.model_dump(\n                exclude={\"base\", \"quoting\"}, exclude_unset=True\n            )\n\n            dialect = config.dialect.base\n            if dialect:\n                kwargs[\"dialect\"] = dialect.value\n            quoting = config.dialect.quoting\n            if quoting:\n                kwargs[\"quoting\"] = quoting.csv_constant()\n\n            kwargs.update(config.reader.model_dump(exclude_unset=True))\n\n            with open(\n                csvfile_path,\n                newline=\"\",\n                encoding=config.reader.encoding,\n            ) as csvfile:\n                csvreader = csv.DictReader(csvfile, **kwargs)\n                content: dict[Union[str, None], list[Any]] = defaultdict(list)\n                for row in csvreader:\n                    for field, value in row.items():\n                        if (\n                            csvreader.reader.dialect.quoting == csv.QUOTE_NONNUMERIC\n                            and isinstance(value, float)\n                            and value.is_integer()\n                        ):\n                            value = int(value)\n                        content[field].append(value)\n\n        for key in list(content):\n            if any(isinstance(value, float) for value in content[key]):\n                content[key] = [\n                    (\n                        float(value)\n                        if (value or value == 0.0 or value == 0)\n                        and value != csvreader.restval\n                        else float(\"nan\")\n                    )\n                    for value in content[key]\n                ]\n                continue\n            if any(isinstance(value, int) for value in content[key]):\n                content[key] = [\n                    (\n                        int(value)\n                        if (value or value == 0) and value != csvreader.restval\n                        else csvreader.restval\n                    )\n                    for value in content[key]\n                ]\n\n        return CSVParseContent(content=content)\n</code></pre>"},{"location":"all_strategies/#oteapi.strategies.parse.text_csv.CSVParseStrategy.parse_config","title":"<code>parse_config: CSVParserConfig</code>  <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.parse.text_csv.CSVParseStrategy.get","title":"<code>get()</code>","text":"<p>Parse CSV.</p> Source code in <code>oteapi/strategies/parse/text_csv.py</code> <pre><code>def get(self) -&gt; CSVParseContent:\n    \"\"\"Parse CSV.\"\"\"\n    config = self.parse_config.configuration\n\n    # Download the file\n    download_config = config.model_dump()\n    download_config[\"configuration\"] = config.model_dump()\n    output = create_strategy(\"download\", download_config).get()\n\n    if config.datacache_config and config.datacache_config.accessKey:\n        cache_key = config.datacache_config.accessKey\n    elif \"key\" in output:\n        cache_key = output[\"key\"]\n    else:\n        raise RuntimeError(\"No data cache key provided to the downloaded content\")\n\n    cache = DataCache(config.datacache_config)\n\n    with cache.getfile(cache_key) as csvfile_path:\n        kwargs = config.dialect.model_dump(\n            exclude={\"base\", \"quoting\"}, exclude_unset=True\n        )\n\n        dialect = config.dialect.base\n        if dialect:\n            kwargs[\"dialect\"] = dialect.value\n        quoting = config.dialect.quoting\n        if quoting:\n            kwargs[\"quoting\"] = quoting.csv_constant()\n\n        kwargs.update(config.reader.model_dump(exclude_unset=True))\n\n        with open(\n            csvfile_path,\n            newline=\"\",\n            encoding=config.reader.encoding,\n        ) as csvfile:\n            csvreader = csv.DictReader(csvfile, **kwargs)\n            content: dict[Union[str, None], list[Any]] = defaultdict(list)\n            for row in csvreader:\n                for field, value in row.items():\n                    if (\n                        csvreader.reader.dialect.quoting == csv.QUOTE_NONNUMERIC\n                        and isinstance(value, float)\n                        and value.is_integer()\n                    ):\n                        value = int(value)\n                    content[field].append(value)\n\n    for key in list(content):\n        if any(isinstance(value, float) for value in content[key]):\n            content[key] = [\n                (\n                    float(value)\n                    if (value or value == 0.0 or value == 0)\n                    and value != csvreader.restval\n                    else float(\"nan\")\n                )\n                for value in content[key]\n            ]\n            continue\n        if any(isinstance(value, int) for value in content[key]):\n            content[key] = [\n                (\n                    int(value)\n                    if (value or value == 0) and value != csvreader.restval\n                    else csvreader.restval\n                )\n                for value in content[key]\n            ]\n\n    return CSVParseContent(content=content)\n</code></pre>"},{"location":"all_strategies/#oteapi.strategies.parse.text_csv.CSVParseStrategy.initialize","title":"<code>initialize()</code>","text":"<p>Initialize.</p> Source code in <code>oteapi/strategies/parse/text_csv.py</code> <pre><code>def initialize(self) -&gt; AttrDict:\n    \"\"\"Initialize.\"\"\"\n    return AttrDict()\n</code></pre>"},{"location":"all_strategies/#oteapi.strategies.parse.text_csv.CSVParserConfig","title":"<code>CSVParserConfig</code>","text":"<p>               Bases: <code>ParserConfig</code></p> <p>CSV parse strategy filter config.</p> Source code in <code>oteapi/strategies/parse/text_csv.py</code> <pre><code>class CSVParserConfig(ParserConfig):\n    \"\"\"CSV parse strategy filter config.\"\"\"\n\n    parserType: Literal[\"parser/csv\"] = Field(\n        \"parser/csv\",\n        description=ParserConfig.model_fields[\"parserType\"].description,\n    )\n    configuration: CSVConfig = Field(\n        ..., description=\"CSV parse strategy-specific configuration.\"\n    )\n</code></pre>"},{"location":"all_strategies/#oteapi.strategies.parse.text_csv.CSVParserConfig.configuration","title":"<code>configuration: CSVConfig = Field(..., description='CSV parse strategy-specific configuration.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.parse.text_csv.CSVParserConfig.parserType","title":"<code>parserType: Literal['parser/csv'] = Field('parser/csv', description=ParserConfig.model_fields['parserType'].description)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.parse.text_csv.DialectFormatting","title":"<code>DialectFormatting</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Dialect and formatting parameters for CSV.</p> <p>See the Python docs for more information.</p> Note <p>As <code>Dialect.lineterminator</code> is hardcoded in <code>csv.reader</code>, it is left out of this model.</p> Source code in <code>oteapi/strategies/parse/text_csv.py</code> <pre><code>class DialectFormatting(BaseModel):\n    \"\"\"Dialect and formatting parameters for CSV.\n\n    See [the Python docs](https://docs.python.org/3/library/csv.html#csv-fmt-params)\n    for more information.\n\n    Note:\n        As `Dialect.lineterminator` is hardcoded in `csv.reader`, it is left out of\n        this model.\n\n    \"\"\"\n\n    base: Optional[CSVDialect] = Field(\n        None,\n        description=(\n            \"A specific CSV dialect, e.g., 'excel'. Any other parameters here will \"\n            \"overwrite the preset dialect parameters for the specified dialect.\"\n        ),\n    )\n    delimiter: Optional[str] = Field(\n        None,\n        description=(\n            \"A one-character string used to separate fields. \"\n            \"See [the Python docs entry](https://docs.python.org/3/library/csv.html\"\n            \"#csv.Dialect.delimiter) for more information.\"\n        ),\n        min_length=1,\n        max_length=1,\n    )\n    doublequote: Optional[bool] = Field(\n        None,\n        description=(\n            \"Controls how instances of [`quotechar`]\"\n            \"[oteapi.strategies.parse.text_csv.DialectFormatting.quotechar] \"\n            \"appearing inside a field should themselves be quoted. When `True`, the \"\n            \"character is doubled. When `False`, the [`escapechar`]\"\n            \"[oteapi.strategies.parse.text_csv.DialectFormatting.escapechar] \"\n            \"is used as a prefix to the [`quotechar`]\"\n            \"[oteapi.strategies.parse.text_csv.DialectFormatting.quotechar]. \"\n            \"See [the Python docs entry]\"\n            \"(https://docs.python.org/3/library/csv.html#csv.Dialect.doublequote) \"\n            \"for more information.\"\n        ),\n    )\n    escapechar: Optional[str] = Field(\n        None,\n        description=(\n            \"A one-character string used by the writer to escape the [`delimiter`]\"\n            \"[oteapi.strategies.parse.text_csv.DialectFormatting.delimiter] if \"\n            \"[`quoting`][oteapi.strategies.parse.text_csv.DialectFormatting.quoting] \"\n            \"is set to [`QUOTE_NONE`]\"\n            \"[oteapi.strategies.parse.text_csv.QuoteConstants.QUOTE_NONE] and the \"\n            \"[`quotechar`][oteapi.strategies.parse.text_csv.DialectFormatting.\"\n            \"quotechar] if [`doublequote`][oteapi.strategies.parse.text_csv.\"\n            \"DialectFormatting.doublequote] is `False`. On reading, the \"\n            \"[`escapechar`][oteapi.strategies.parse.text_csv.DialectFormatting.\"\n            \"escapechar] removes any special meaning from the following character. \"\n            \"See [the Python docs entry]\"\n            \"(https://docs.python.org/3/library/csv.html#csv.Dialect.escapechar) \"\n            \"for more information.\"\n        ),\n        min_length=1,\n        max_length=1,\n    )\n    quotechar: Optional[str] = Field(\n        None,\n        description=(\n            \"A one-character string used to quote fields containing special \"\n            \"characters, such as the [`delimiter`]\"\n            \"[oteapi.strategies.parse.text_csv.DialectFormatting.delimiter] or \"\n            \"[`quotechar`][oteapi.strategies.parse.text_csv.DialectFormatting.\"\n            \"quotechar], or which contain new-line characters. See \"\n            \"[the Python docs entry](https://docs.python.org/3/library/csv.html\"\n            \"#csv.Dialect.quotechar) for more information.\"\n        ),\n        min_length=1,\n        max_length=1,\n    )\n    quoting: Optional[QuoteConstants] = Field(\n        None,\n        description=(\n            \"Controls when quotes should be generated by the writer and recognised by \"\n            \"the reader. It can take on any of the `QUOTE_*` constants (see section \"\n            \"[Module Contents](https://docs.python.org/3/library/csv.html\"\n            \"#csv-contents)). See [the Python docs entry]\"\n            \"(https://docs.python.org/3/library/csv.html#csv.Dialect.quoting) \"\n            \"for more information.\"\n        ),\n    )\n    skipinitialspace: Optional[bool] = Field(\n        None,\n        description=(\n            \"When `True`, whitespace immediately following the [`delimiter`]\"\n            \"[oteapi.strategies.parse.text_csv.DialectFormatting.delimiter] is \"\n            \"ignored. See [the Python docs entry]\"\n            \"(https://docs.python.org/3/library/csv.html#csv.Dialect.skipinitialspace)\"\n            \" for more information.\"\n        ),\n    )\n    strict: Optional[bool] = Field(\n        None,\n        description=(\n            \"When `True`, raise exception [Error]\"\n            \"(https://docs.python.org/3/library/csv.html#csv.Error) on bad CSV input. \"\n            \"See [the Python docs entry](https://docs.python.org/3/library/csv.html\"\n            \"#csv.Dialect.strict) for more information.\"\n        ),\n    )\n\n    @field_validator(\"base\")\n    @classmethod\n    def validate_dialect_base(cls, value: str) -&gt; str:\n        \"\"\"Ensure the given `base` dialect is registered locally.\"\"\"\n        if value not in csv.list_dialects():\n            raise ValueError(\n                f\"{value!r} is not a known registered CSV dialect. \"\n                f\"Registered dialects: {', '.join(csv.list_dialects())}.\"\n            )\n        return value\n</code></pre>"},{"location":"all_strategies/#oteapi.strategies.parse.text_csv.DialectFormatting.base","title":"<code>base: Optional[CSVDialect] = Field(None, description=\"A specific CSV dialect, e.g., 'excel'. Any other parameters here will overwrite the preset dialect parameters for the specified dialect.\")</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.parse.text_csv.DialectFormatting.delimiter","title":"<code>delimiter: Optional[str] = Field(None, description='A one-character string used to separate fields. See [the Python docs entry](https://docs.python.org/3/library/csv.html#csv.Dialect.delimiter) for more information.', min_length=1, max_length=1)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.parse.text_csv.DialectFormatting.doublequote","title":"<code>doublequote: Optional[bool] = Field(None, description='Controls how instances of [`quotechar`][oteapi.strategies.parse.text_csv.DialectFormatting.quotechar] appearing inside a field should themselves be quoted. When `True`, the character is doubled. When `False`, the [`escapechar`][oteapi.strategies.parse.text_csv.DialectFormatting.escapechar] is used as a prefix to the [`quotechar`][oteapi.strategies.parse.text_csv.DialectFormatting.quotechar]. See [the Python docs entry](https://docs.python.org/3/library/csv.html#csv.Dialect.doublequote) for more information.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.parse.text_csv.DialectFormatting.escapechar","title":"<code>escapechar: Optional[str] = Field(None, description='A one-character string used by the writer to escape the [`delimiter`][oteapi.strategies.parse.text_csv.DialectFormatting.delimiter] if [`quoting`][oteapi.strategies.parse.text_csv.DialectFormatting.quoting] is set to [`QUOTE_NONE`][oteapi.strategies.parse.text_csv.QuoteConstants.QUOTE_NONE] and the [`quotechar`][oteapi.strategies.parse.text_csv.DialectFormatting.quotechar] if [`doublequote`][oteapi.strategies.parse.text_csv.DialectFormatting.doublequote] is `False`. On reading, the [`escapechar`][oteapi.strategies.parse.text_csv.DialectFormatting.escapechar] removes any special meaning from the following character. See [the Python docs entry](https://docs.python.org/3/library/csv.html#csv.Dialect.escapechar) for more information.', min_length=1, max_length=1)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.parse.text_csv.DialectFormatting.quotechar","title":"<code>quotechar: Optional[str] = Field(None, description='A one-character string used to quote fields containing special characters, such as the [`delimiter`][oteapi.strategies.parse.text_csv.DialectFormatting.delimiter] or [`quotechar`][oteapi.strategies.parse.text_csv.DialectFormatting.quotechar], or which contain new-line characters. See [the Python docs entry](https://docs.python.org/3/library/csv.html#csv.Dialect.quotechar) for more information.', min_length=1, max_length=1)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.parse.text_csv.DialectFormatting.quoting","title":"<code>quoting: Optional[QuoteConstants] = Field(None, description='Controls when quotes should be generated by the writer and recognised by the reader. It can take on any of the `QUOTE_*` constants (see section [Module Contents](https://docs.python.org/3/library/csv.html#csv-contents)). See [the Python docs entry](https://docs.python.org/3/library/csv.html#csv.Dialect.quoting) for more information.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.parse.text_csv.DialectFormatting.skipinitialspace","title":"<code>skipinitialspace: Optional[bool] = Field(None, description='When `True`, whitespace immediately following the [`delimiter`][oteapi.strategies.parse.text_csv.DialectFormatting.delimiter] is ignored. See [the Python docs entry](https://docs.python.org/3/library/csv.html#csv.Dialect.skipinitialspace) for more information.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.parse.text_csv.DialectFormatting.strict","title":"<code>strict: Optional[bool] = Field(None, description='When `True`, raise exception [Error](https://docs.python.org/3/library/csv.html#csv.Error) on bad CSV input. See [the Python docs entry](https://docs.python.org/3/library/csv.html#csv.Dialect.strict) for more information.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.parse.text_csv.DialectFormatting.validate_dialect_base","title":"<code>validate_dialect_base(value)</code>  <code>classmethod</code>","text":"<p>Ensure the given <code>base</code> dialect is registered locally.</p> Source code in <code>oteapi/strategies/parse/text_csv.py</code> <pre><code>@field_validator(\"base\")\n@classmethod\ndef validate_dialect_base(cls, value: str) -&gt; str:\n    \"\"\"Ensure the given `base` dialect is registered locally.\"\"\"\n    if value not in csv.list_dialects():\n        raise ValueError(\n            f\"{value!r} is not a known registered CSV dialect. \"\n            f\"Registered dialects: {', '.join(csv.list_dialects())}.\"\n        )\n    return value\n</code></pre>"},{"location":"all_strategies/#oteapi.strategies.parse.text_csv.QuoteConstants","title":"<code>QuoteConstants</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>CSV module <code>QUOTE_*</code> constants.</p> Source code in <code>oteapi/strategies/parse/text_csv.py</code> <pre><code>class QuoteConstants(str, Enum):\n    \"\"\"CSV module `QUOTE_*` constants.\"\"\"\n\n    QUOTE_ALL = \"QUOTE_ALL\"\n    QUOTE_MINIMAL = \"QUOTE_MINIMAL\"\n    QUOTE_NONUMERIC = \"QUOTE_NONNUMERIC\"\n    QUOTE_NONE = \"QUOTE_NONE\"\n\n    def csv_constant(self) -&gt; int:\n        \"\"\"Return the CSV lib equivalent constant.\"\"\"\n        return {\n            self.QUOTE_ALL: csv.QUOTE_ALL,\n            self.QUOTE_MINIMAL: csv.QUOTE_MINIMAL,\n            self.QUOTE_NONUMERIC: csv.QUOTE_NONNUMERIC,\n            self.QUOTE_NONE: csv.QUOTE_NONE,\n        }[self]\n</code></pre>"},{"location":"all_strategies/#oteapi.strategies.parse.text_csv.QuoteConstants.QUOTE_ALL","title":"<code>QUOTE_ALL = 'QUOTE_ALL'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.parse.text_csv.QuoteConstants.QUOTE_MINIMAL","title":"<code>QUOTE_MINIMAL = 'QUOTE_MINIMAL'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.parse.text_csv.QuoteConstants.QUOTE_NONE","title":"<code>QUOTE_NONE = 'QUOTE_NONE'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.parse.text_csv.QuoteConstants.QUOTE_NONUMERIC","title":"<code>QUOTE_NONUMERIC = 'QUOTE_NONNUMERIC'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.parse.text_csv.QuoteConstants.csv_constant","title":"<code>csv_constant()</code>","text":"<p>Return the CSV lib equivalent constant.</p> Source code in <code>oteapi/strategies/parse/text_csv.py</code> <pre><code>def csv_constant(self) -&gt; int:\n    \"\"\"Return the CSV lib equivalent constant.\"\"\"\n    return {\n        self.QUOTE_ALL: csv.QUOTE_ALL,\n        self.QUOTE_MINIMAL: csv.QUOTE_MINIMAL,\n        self.QUOTE_NONUMERIC: csv.QUOTE_NONNUMERIC,\n        self.QUOTE_NONE: csv.QUOTE_NONE,\n    }[self]\n</code></pre>"},{"location":"all_strategies/#oteapi.strategies.parse.text_csv.ReaderConfig","title":"<code>ReaderConfig</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>CSV DictReader configuration parameters.</p> <p>See the Python docs for more information.</p> Source code in <code>oteapi/strategies/parse/text_csv.py</code> <pre><code>class ReaderConfig(BaseModel):\n    \"\"\"CSV DictReader configuration parameters.\n\n    See [the Python docs](https://docs.python.org/3/library/csv.html#csv.DictReader)\n    for more information.\n    \"\"\"\n\n    fieldnames: Optional[list[str]] = Field(\n        None,\n        description=(\n            \"List of headers. If not set, the values in the first row of the CSV file \"\n            \"will be used as the field names.\"\n        ),\n    )\n    restkey: Optional[Hashable] = Field(\n        None,\n        description=(\n            \"If a row has more fields than [`fieldnames`]\"\n            \"[oteapi.strategies.parse.text_csv.ReaderConfig.fieldnames], the \"\n            \"remaining data is put in a list and stored with the field name specified \"\n            \"by [`restkey`][oteapi.strategies.parse.text_csv.ReaderConfig.restkey].\"\n        ),\n    )\n    restval: Optional[Any] = Field(\n        None,\n        description=(\n            \"If a non-blank row has fewer fields than the length of [`fieldnames`]\"\n            \"[oteapi.strategies.parse.text_csv.ReaderConfig.fieldnames], the missing \"\n            \"values are filled-in with the value of [`restval`]\"\n            \"[oteapi.strategies.parse.text_csv.ReaderConfig.restval].\"\n        ),\n    )\n    encoding: str = Field(\n        \"utf8\",\n        description=\"The file encoding.\",\n    )\n</code></pre>"},{"location":"all_strategies/#oteapi.strategies.parse.text_csv.ReaderConfig.encoding","title":"<code>encoding: str = Field('utf8', description='The file encoding.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.parse.text_csv.ReaderConfig.fieldnames","title":"<code>fieldnames: Optional[list[str]] = Field(None, description='List of headers. If not set, the values in the first row of the CSV file will be used as the field names.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.parse.text_csv.ReaderConfig.restkey","title":"<code>restkey: Optional[Hashable] = Field(None, description='If a row has more fields than [`fieldnames`][oteapi.strategies.parse.text_csv.ReaderConfig.fieldnames], the remaining data is put in a list and stored with the field name specified by [`restkey`][oteapi.strategies.parse.text_csv.ReaderConfig.restkey].')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.parse.text_csv.ReaderConfig.restval","title":"<code>restval: Optional[Any] = Field(None, description='If a non-blank row has fewer fields than the length of [`fieldnames`][oteapi.strategies.parse.text_csv.ReaderConfig.fieldnames], the missing values are filled-in with the value of [`restval`][oteapi.strategies.parse.text_csv.ReaderConfig.restval].')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.resource","title":"<code>resource</code>","text":""},{"location":"all_strategies/#oteapi.strategies.resource.resource_url","title":"<code>resource_url</code>","text":"<p>Strategy class for resource/url.</p>"},{"location":"all_strategies/#oteapi.strategies.resource.resource_url.ResourceURLConfig","title":"<code>ResourceURLConfig</code>","text":"<p>               Bases: <code>ResourceConfig</code></p> <p>Resource URL strategy config.</p> Source code in <code>oteapi/strategies/resource/resource_url.py</code> <pre><code>class ResourceURLConfig(ResourceConfig):\n    \"\"\"Resource URL strategy config.\"\"\"\n\n    resourceType: Literal[\"resource/url\"] = Field(\n        \"resource/url\",\n        description=ResourceConfig.model_fields[\"resourceType\"].description,\n    )\n    downloadUrl: HostlessAnyUrl = Field(\n        ...,\n        description=ResourceConfig.model_fields[\"downloadUrl\"].description,\n    )\n    mediaType: str = Field(\n        ...,\n        description=ResourceConfig.model_fields[\"mediaType\"].description,\n    )\n</code></pre>"},{"location":"all_strategies/#oteapi.strategies.resource.resource_url.ResourceURLConfig.downloadUrl","title":"<code>downloadUrl: HostlessAnyUrl = Field(..., description=ResourceConfig.model_fields['downloadUrl'].description)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.resource.resource_url.ResourceURLConfig.mediaType","title":"<code>mediaType: str = Field(..., description=ResourceConfig.model_fields['mediaType'].description)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.resource.resource_url.ResourceURLConfig.resourceType","title":"<code>resourceType: Literal['resource/url'] = Field('resource/url', description=ResourceConfig.model_fields['resourceType'].description)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.resource.resource_url.ResourceURLStrategy","title":"<code>ResourceURLStrategy</code>","text":"<p>Basic resource strategy targeting downloadUrl resources.</p> Source code in <code>oteapi/strategies/resource/resource_url.py</code> <pre><code>@dataclass\nclass ResourceURLStrategy:\n    \"\"\"Basic resource strategy targeting downloadUrl resources.\"\"\"\n\n    resource_config: ResourceURLConfig\n\n    def initialize(self) -&gt; \"AttrDict\":\n        \"\"\"Initialize.\"\"\"\n        return AttrDict()\n\n    def get(self) -&gt; \"AttrDict\":\n        \"\"\"resource distribution.\"\"\"\n        return AttrDict(\n            **self.resource_config.model_dump(\n                mode=\"json\", exclude_unset=True, exclude={\"resourceType\"}\n            )\n        )\n</code></pre>"},{"location":"all_strategies/#oteapi.strategies.resource.resource_url.ResourceURLStrategy.resource_config","title":"<code>resource_config: ResourceURLConfig</code>  <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.resource.resource_url.ResourceURLStrategy.get","title":"<code>get()</code>","text":"<p>resource distribution.</p> Source code in <code>oteapi/strategies/resource/resource_url.py</code> <pre><code>def get(self) -&gt; \"AttrDict\":\n    \"\"\"resource distribution.\"\"\"\n    return AttrDict(\n        **self.resource_config.model_dump(\n            mode=\"json\", exclude_unset=True, exclude={\"resourceType\"}\n        )\n    )\n</code></pre>"},{"location":"all_strategies/#oteapi.strategies.resource.resource_url.ResourceURLStrategy.initialize","title":"<code>initialize()</code>","text":"<p>Initialize.</p> Source code in <code>oteapi/strategies/resource/resource_url.py</code> <pre><code>def initialize(self) -&gt; \"AttrDict\":\n    \"\"\"Initialize.\"\"\"\n    return AttrDict()\n</code></pre>"},{"location":"all_strategies/#oteapi.strategies.transformation","title":"<code>transformation</code>","text":""},{"location":"all_strategies/#oteapi.strategies.transformation.celery_remote","title":"<code>celery_remote</code>","text":"<p>Transformation Plugin that uses the Celery framework to call remote workers.</p>"},{"location":"all_strategies/#oteapi.strategies.transformation.celery_remote.CELERY_APP","title":"<code>CELERY_APP = Celery(broker=f'redis://{REDIS_HOST}:{REDIS_PORT}', backend=f'redis://{REDIS_HOST}:{REDIS_PORT}')</code>  <code>module-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.transformation.celery_remote.REDIS_HOST","title":"<code>REDIS_HOST = os.getenv('OTEAPI_REDIS_HOST', 'redis')</code>  <code>module-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.transformation.celery_remote.REDIS_PORT","title":"<code>REDIS_PORT = int(os.getenv('OTEAPI_REDIS_PORT', '6379'))</code>  <code>module-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.transformation.celery_remote.CeleryConfig","title":"<code>CeleryConfig</code>","text":"<p>               Bases: <code>AttrDict</code></p> <p>Celery configuration.</p> <p>All fields here (including those added from the session through the <code>get()</code> method, as well as those added \"anonymously\") will be used as keyword arguments to the <code>send_task()</code> method for the Celery App.</p> Note <p>Using <code>alias</code> for the <code>name</code> field to favor populating it with <code>task_name</code> arguments, since this is the \"original\" field name. I.e., this is done for backwards compatibility.</p> <p>Special pydantic configuration settings:</p> <ul> <li><code>populate_by_name</code>   Allow populating CeleryConfig.name using <code>name</code> as well as <code>task_name</code>.</li> </ul> Source code in <code>oteapi/strategies/transformation/celery_remote.py</code> <pre><code>class CeleryConfig(AttrDict):\n    \"\"\"Celery configuration.\n\n    All fields here (including those added from the session through the `get()` method,\n    as well as those added \"anonymously\") will be used as keyword arguments to the\n    `send_task()` method for the Celery App.\n\n    Note:\n        Using `alias` for the `name` field to favor populating it with `task_name`\n        arguments, since this is the \"original\" field name. I.e., this is done for\n        backwards compatibility.\n\n    Special pydantic configuration settings:\n\n    - **`populate_by_name`**\n      Allow populating CeleryConfig.name using `name` as well as `task_name`.\n\n    \"\"\"\n\n    model_config = ConfigDict(populate_by_name=True)\n\n    name: str = Field(..., description=\"A task name.\", alias=\"task_name\")\n    args: list = Field(..., description=\"List of arguments for the task.\")\n</code></pre>"},{"location":"all_strategies/#oteapi.strategies.transformation.celery_remote.CeleryConfig.args","title":"<code>args: list = Field(..., description='List of arguments for the task.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.transformation.celery_remote.CeleryConfig.model_config","title":"<code>model_config = ConfigDict(populate_by_name=True)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.transformation.celery_remote.CeleryConfig.name","title":"<code>name: str = Field(..., description='A task name.', alias='task_name')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.transformation.celery_remote.CeleryContent","title":"<code>CeleryContent</code>","text":"<p>               Bases: <code>AttrDict</code></p> <p>Class for returning values from a Celery task.</p> Source code in <code>oteapi/strategies/transformation/celery_remote.py</code> <pre><code>class CeleryContent(AttrDict):\n    \"\"\"Class for returning values from a Celery task.\"\"\"\n\n    celery_task_id: str = Field(..., description=\"A Celery task identifier.\")\n</code></pre>"},{"location":"all_strategies/#oteapi.strategies.transformation.celery_remote.CeleryContent.celery_task_id","title":"<code>celery_task_id: str = Field(..., description='A Celery task identifier.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.transformation.celery_remote.CeleryRemoteStrategy","title":"<code>CeleryRemoteStrategy</code>","text":"<p>Submit job to remote Celery runner.</p> <p>Registers strategies:</p> <ul> <li><code>(\"transformationType\", \"celery/remote\")</code></li> </ul> Source code in <code>oteapi/strategies/transformation/celery_remote.py</code> <pre><code>@dataclass\nclass CeleryRemoteStrategy:\n    \"\"\"Submit job to remote Celery runner.\n\n    **Registers strategies**:\n\n    - `(\"transformationType\", \"celery/remote\")`\n\n    \"\"\"\n\n    transformation_config: CeleryStrategyConfig\n\n    def get(self) -&gt; CeleryContent:\n        \"\"\"Run a job, return a job ID.\"\"\"\n\n        result: \"Union[AsyncResult, Any]\" = CELERY_APP.send_task(\n            **self.transformation_config.configuration.model_dump()\n        )\n        return CeleryContent(celery_task_id=result.task_id)\n\n    def initialize(self) -&gt; AttrDict:\n        \"\"\"Initialize a job.\"\"\"\n        return AttrDict()\n\n    def status(self, task_id: str) -&gt; TransformationStatus:\n        \"\"\"Get job status.\"\"\"\n        result = AsyncResult(id=task_id, app=CELERY_APP)\n        return TransformationStatus(id=task_id, status=result.state)\n</code></pre>"},{"location":"all_strategies/#oteapi.strategies.transformation.celery_remote.CeleryRemoteStrategy.transformation_config","title":"<code>transformation_config: CeleryStrategyConfig</code>  <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.transformation.celery_remote.CeleryRemoteStrategy.get","title":"<code>get()</code>","text":"<p>Run a job, return a job ID.</p> Source code in <code>oteapi/strategies/transformation/celery_remote.py</code> <pre><code>def get(self) -&gt; CeleryContent:\n    \"\"\"Run a job, return a job ID.\"\"\"\n\n    result: \"Union[AsyncResult, Any]\" = CELERY_APP.send_task(\n        **self.transformation_config.configuration.model_dump()\n    )\n    return CeleryContent(celery_task_id=result.task_id)\n</code></pre>"},{"location":"all_strategies/#oteapi.strategies.transformation.celery_remote.CeleryRemoteStrategy.initialize","title":"<code>initialize()</code>","text":"<p>Initialize a job.</p> Source code in <code>oteapi/strategies/transformation/celery_remote.py</code> <pre><code>def initialize(self) -&gt; AttrDict:\n    \"\"\"Initialize a job.\"\"\"\n    return AttrDict()\n</code></pre>"},{"location":"all_strategies/#oteapi.strategies.transformation.celery_remote.CeleryRemoteStrategy.status","title":"<code>status(task_id)</code>","text":"<p>Get job status.</p> Source code in <code>oteapi/strategies/transformation/celery_remote.py</code> <pre><code>def status(self, task_id: str) -&gt; TransformationStatus:\n    \"\"\"Get job status.\"\"\"\n    result = AsyncResult(id=task_id, app=CELERY_APP)\n    return TransformationStatus(id=task_id, status=result.state)\n</code></pre>"},{"location":"all_strategies/#oteapi.strategies.transformation.celery_remote.CeleryStrategyConfig","title":"<code>CeleryStrategyConfig</code>","text":"<p>               Bases: <code>TransformationConfig</code></p> <p>Celery strategy-specific configuration.</p> Source code in <code>oteapi/strategies/transformation/celery_remote.py</code> <pre><code>class CeleryStrategyConfig(TransformationConfig):\n    \"\"\"Celery strategy-specific configuration.\"\"\"\n\n    transformationType: Literal[\"celery/remote\"] = Field(\n        \"celery/remote\",\n        description=TransformationConfig.model_fields[\"transformationType\"].description,\n    )\n    configuration: CeleryConfig = Field(\n        ..., description=\"Celery transformation strategy-specific configuration.\"\n    )\n</code></pre>"},{"location":"all_strategies/#oteapi.strategies.transformation.celery_remote.CeleryStrategyConfig.configuration","title":"<code>configuration: CeleryConfig = Field(..., description='Celery transformation strategy-specific configuration.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"all_strategies/#oteapi.strategies.transformation.celery_remote.CeleryStrategyConfig.transformationType","title":"<code>transformationType: Literal['celery/remote'] = Field('celery/remote', description=TransformationConfig.model_fields['transformationType'].description)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/settings/","title":"settings","text":"<p>BaseSettings for oteapi-core. This <code>configuration/settings</code>-class is intended to be incorporated as a parentclass into the configuration of an FastAPI application. See <code>https://fastapi.tiangolo.com/advanced/settings/</code> as reference.</p> <p>Otherwise, check <code>https://github.com/EMMC-ASBL/oteapi-services/blob/master/app/main.py</code> for a direct example of an inclusion of the OTE api and its settings into an FastAPI instance.</p>"},{"location":"api_reference/settings/#oteapi.settings.OteApiCoreSettings","title":"<code>OteApiCoreSettings</code>","text":"<p>               Bases: <code>BaseSettings</code></p> <p>Basic configuration for the oteapi-core.</p> Source code in <code>oteapi/settings.py</code> <pre><code>class OteApiCoreSettings(BaseSettings):\n    \"\"\"Basic configuration for the oteapi-core.\"\"\"\n\n    expose_secrets: bool = Field(\n        False,\n        description=\"\"\"Whether `SecretStr` in `pydantic` should be exposed or not.\n\n!!! warning\n    Depending on the configuration and user management of the services\n    using oteapi-core, secrets might be readable by other users when serialized!\n    This especially takes place when then models and configs are put into the cache.\n    Hence be careful while using this option in production.\n\"\"\",\n    )\n    model_config = SettingsConfigDict(env_prefix=\"OTEAPI_\")\n</code></pre>"},{"location":"api_reference/datacache/datacache/","title":"datacache","text":"<p>Data cache based on DiskCache. See Python-DiskCache.</p> <p>Features:</p> <ul> <li>Persistent cache between sessions.</li> <li>Default keys are hashes of the stored data.</li> <li>Automatic expiration of cached data.</li> <li>Sessions can selectively be cleaned up via tags.</li> <li>Store small values in SQLite database and large values in files.</li> <li>Underlying library is actively developed and tested on Linux, Mac and Windows.</li> <li>High performance.</li> </ul>"},{"location":"api_reference/datacache/datacache/#oteapi.datacache.datacache.DataCache","title":"<code>DataCache</code>","text":"<p>Initialize a cache instance with the given download configuration.</p> <p>This class is also available to import from <code>oteapi.datacache</code>, e.g.:</p> <pre><code>from oteapi.datacache import DataCache\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>Union[DataCacheConfig, Dict[str, Any]]</code> <p>Download configurations.</p> <code>None</code> <code>cache_dir</code> <code>Optional[Union[Path, str]]</code> <p>Cache directory overriding the config.</p> <code>None</code> <p>Attributes:</p> Name Type Description <code>config</code> <p>DataCacheConfig instance.</p> <code>cache_dir</code> <p>Subdirectory used for the Path to cache directory, e.g., <code>\"my_oteapi\"</code>.</p> Source code in <code>oteapi/datacache/datacache.py</code> <pre><code>class DataCache:\n    \"\"\"Initialize a cache instance with the given download configuration.\n\n    This class is also available to import from `oteapi.datacache`, e.g.:\n\n    ```python\n    from oteapi.datacache import DataCache\n    ```\n\n    Args:\n        config (Union[DataCacheConfig, Dict[str, Any]]): Download configurations.\n        cache_dir (Optional[Union[Path, str]]): Cache directory overriding the config.\n\n    Attributes:\n        config: DataCacheConfig instance.\n        cache_dir: Subdirectory used for the Path to cache directory, e.g.,\n            `\"my_oteapi\"`.\n\n    \"\"\"\n\n    def __init__(\n        self,\n        config: \"Optional[Union[DataCacheConfig, Dict[str, Any]]]\" = None,\n        cache_dir: \"Optional[Union[Path, str]]\" = None,\n    ) -&gt; None:\n        if config is None:\n            self.config = DataCacheConfig()\n        elif isinstance(config, (dict, AttrDict)):\n            self.config = DataCacheConfig(**config)\n        elif isinstance(config, DataCacheConfig):\n            self.config = config\n        else:\n            raise TypeError(\n                \"config should be either a `DataCacheConfig` data model or a \"\n                \"dictionary.\"\n            )\n\n        if not cache_dir:\n            cache_dir = self.config.cacheDir\n        if isinstance(cache_dir, str):\n            cache_dir = Path(cache_dir)\n        if cache_dir.is_absolute():\n            self.cache_dir = cache_dir\n        else:\n            self.cache_dir = Path(tempfile.gettempdir()).resolve() / cache_dir\n\n        self.diskcache = DiskCache(directory=self.cache_dir)\n\n    def __contains__(self, key) -&gt; bool:\n        return key in self.diskcache\n\n    def __len__(self) -&gt; int:\n        return len(self.diskcache)\n\n    def __getitem__(self, key) -&gt; \"Any\":\n        return self.get(key)\n\n    def __setitem__(self, key, value) -&gt; None:\n        self.add(value, key=key)\n\n    def __delitem__(self, key) -&gt; None:\n        del self.diskcache[key]\n\n    def __del__(self) -&gt; None:\n        self.diskcache.expire()\n        self.diskcache.close()\n\n    def add(\n        self,\n        value: \"Any\",\n        key: \"Optional[str]\" = None,\n        expire: \"Optional[int]\" = None,\n        tag: \"Optional[str]\" = None,\n        bind: \"Any\" = None,\n        json_encoder: \"Optional[Type[json.JSONEncoder]]\" = None,\n    ) -&gt; str:\n        \"\"\"Add a value to cache.\n\n        Existing value is overwritten if `key` is given and it already\n        exists in the cache.\n\n        Args:\n            value: The value to add to the cache.\n            key: If given, use this as the retrieval key. Otherwise the key is either\n                taken from the `accessKey` configuration or generated as a hash of\n                `value`.\n            expire: If given, the number of seconds before the value expire. Otherwise\n                it is taken from the configuration.\n            tag: Tag used with [`evict()`][oteapi.datacache.datacache.DataCache.evict]\n                for cleaning up a session.\n            bind: Remove `value` from the cache when the object provided with\n                this argument goes out of scope.  Note that `bind` must be a\n                weakref'able object.\n\n                The argument name refers to that we bind `value` to this\n                argument.\n            json_encoder: Customised json encoder forcomplex Python objects.\n\n        Returns:\n            A key that can be used to retrieve `value` from cache later.\n\n        \"\"\"\n        key = (\n            key\n            if key\n            else (\n                self.config.accessKey\n                if self.config.accessKey\n                else gethash(\n                    value,\n                    hashtype=self.config.hashType,\n                    json_encoder=json_encoder,\n                )\n            )\n        )\n\n        if bind is not None:\n\n            def remover(key):\n                del self[key]\n\n            weakref.finalize(bind, remover, key)\n\n        self.diskcache.set(\n            key,\n            value,\n            expire=expire if expire else self.config.expireTime,\n            tag=tag,\n        )\n        return key\n\n    def get(self, key: str) -&gt; \"Any\":\n        \"\"\"Return the value corresponding to `key`.\n\n        Args:\n            key: The requested cached object to retrieve a value for.\n\n        Returns:\n            The value corresponding to the `key` value.\n\n        \"\"\"\n        if key not in self.diskcache:\n            raise KeyError(key)\n        return self.diskcache.get(key)\n\n    @contextmanager\n    def getfile(\n        self,\n        key: str,\n        delete: bool = True,\n        filename: \"Optional[Union[Path, str]]\" = None,\n        prefix: \"Optional[str]\" = None,\n        suffix: \"Optional[str]\" = None,\n        directory: \"Optional[str]\" = None,\n    ) -&gt; \"Iterator[Path]\":\n        \"\"\"Write the value for `key` to file and return the filename.\n\n        The file is created in the default directory for temporary\n        files (which can be controlled by the `TEMPDIR`, `TEMP` or `TMP`\n        environment variables). It is readable and writable only for\n        the current user.\n\n        Example:\n            This method is intended to be used in a `with` statement, to\n            automatically delete the file when leaving the context:\n\n            ```python\n            cache = DataCache()\n            with cache.getfile('mykey') as filename:\n                # do something with filename...\n            # filename is deleted\n            ```\n\n        Args:\n            key: Key of value to write to file.\n            delete: Whether to automatically delete the created file when leaving the\n                context.\n            filename: Full path to created file. If not given, a unique filename will\n                be created.\n            prefix: Prefix to prepend to the returned file name (default is\n                `\"oteapi-download-\"`).\n            suffix: Suffix to append to the returned file name.\n            directory: File directory if `filename` is not provided (is `None`).\n\n        Yields:\n            Path object, referencing and representing the created file.\n\n        \"\"\"\n        if filename:\n            filename = Path(filename).resolve()\n            filename.write_bytes(self.get(key))\n        else:\n            prefix = prefix if prefix else \"oteapi-download-\"\n            with tempfile.NamedTemporaryFile(\n                prefix=prefix,\n                suffix=suffix,\n                dir=directory,\n                delete=False,\n            ) as handle:\n                handle.write(self.get(key))\n                filename = Path(handle.name).resolve()\n\n        try:\n            yield filename\n        finally:\n            if delete:\n                filename.unlink()\n\n    def evict(self, tag: str) -&gt; None:\n        \"\"\"Remove all cache items with the given tag.\n\n        Useful for cleaning up a session.\n\n        Args:\n            tag: Tag identifying objects.\n\n        \"\"\"\n        self.diskcache.evict(tag)\n\n    def clear(self) -&gt; None:\n        \"\"\"Remove all items from cache.\"\"\"\n        self.diskcache.clear()\n</code></pre>"},{"location":"api_reference/datacache/datacache/#oteapi.datacache.datacache.DataCache.add","title":"<code>add(value, key=None, expire=None, tag=None, bind=None, json_encoder=None)</code>","text":"<p>Add a value to cache.</p> <p>Existing value is overwritten if <code>key</code> is given and it already exists in the cache.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Any</code> <p>The value to add to the cache.</p> required <code>key</code> <code>Optional[str]</code> <p>If given, use this as the retrieval key. Otherwise the key is either taken from the <code>accessKey</code> configuration or generated as a hash of <code>value</code>.</p> <code>None</code> <code>expire</code> <code>Optional[int]</code> <p>If given, the number of seconds before the value expire. Otherwise it is taken from the configuration.</p> <code>None</code> <code>tag</code> <code>Optional[str]</code> <p>Tag used with <code>evict()</code> for cleaning up a session.</p> <code>None</code> <code>bind</code> <code>Any</code> <p>Remove <code>value</code> from the cache when the object provided with this argument goes out of scope.  Note that <code>bind</code> must be a weakref'able object.</p> <p>The argument name refers to that we bind <code>value</code> to this argument.</p> <code>None</code> <code>json_encoder</code> <code>Optional[Type[JSONEncoder]]</code> <p>Customised json encoder forcomplex Python objects.</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>A key that can be used to retrieve <code>value</code> from cache later.</p> Source code in <code>oteapi/datacache/datacache.py</code> <pre><code>def add(\n    self,\n    value: \"Any\",\n    key: \"Optional[str]\" = None,\n    expire: \"Optional[int]\" = None,\n    tag: \"Optional[str]\" = None,\n    bind: \"Any\" = None,\n    json_encoder: \"Optional[Type[json.JSONEncoder]]\" = None,\n) -&gt; str:\n    \"\"\"Add a value to cache.\n\n    Existing value is overwritten if `key` is given and it already\n    exists in the cache.\n\n    Args:\n        value: The value to add to the cache.\n        key: If given, use this as the retrieval key. Otherwise the key is either\n            taken from the `accessKey` configuration or generated as a hash of\n            `value`.\n        expire: If given, the number of seconds before the value expire. Otherwise\n            it is taken from the configuration.\n        tag: Tag used with [`evict()`][oteapi.datacache.datacache.DataCache.evict]\n            for cleaning up a session.\n        bind: Remove `value` from the cache when the object provided with\n            this argument goes out of scope.  Note that `bind` must be a\n            weakref'able object.\n\n            The argument name refers to that we bind `value` to this\n            argument.\n        json_encoder: Customised json encoder forcomplex Python objects.\n\n    Returns:\n        A key that can be used to retrieve `value` from cache later.\n\n    \"\"\"\n    key = (\n        key\n        if key\n        else (\n            self.config.accessKey\n            if self.config.accessKey\n            else gethash(\n                value,\n                hashtype=self.config.hashType,\n                json_encoder=json_encoder,\n            )\n        )\n    )\n\n    if bind is not None:\n\n        def remover(key):\n            del self[key]\n\n        weakref.finalize(bind, remover, key)\n\n    self.diskcache.set(\n        key,\n        value,\n        expire=expire if expire else self.config.expireTime,\n        tag=tag,\n    )\n    return key\n</code></pre>"},{"location":"api_reference/datacache/datacache/#oteapi.datacache.datacache.DataCache.clear","title":"<code>clear()</code>","text":"<p>Remove all items from cache.</p> Source code in <code>oteapi/datacache/datacache.py</code> <pre><code>def clear(self) -&gt; None:\n    \"\"\"Remove all items from cache.\"\"\"\n    self.diskcache.clear()\n</code></pre>"},{"location":"api_reference/datacache/datacache/#oteapi.datacache.datacache.DataCache.evict","title":"<code>evict(tag)</code>","text":"<p>Remove all cache items with the given tag.</p> <p>Useful for cleaning up a session.</p> <p>Parameters:</p> Name Type Description Default <code>tag</code> <code>str</code> <p>Tag identifying objects.</p> required Source code in <code>oteapi/datacache/datacache.py</code> <pre><code>def evict(self, tag: str) -&gt; None:\n    \"\"\"Remove all cache items with the given tag.\n\n    Useful for cleaning up a session.\n\n    Args:\n        tag: Tag identifying objects.\n\n    \"\"\"\n    self.diskcache.evict(tag)\n</code></pre>"},{"location":"api_reference/datacache/datacache/#oteapi.datacache.datacache.DataCache.get","title":"<code>get(key)</code>","text":"<p>Return the value corresponding to <code>key</code>.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The requested cached object to retrieve a value for.</p> required <p>Returns:</p> Type Description <code>Any</code> <p>The value corresponding to the <code>key</code> value.</p> Source code in <code>oteapi/datacache/datacache.py</code> <pre><code>def get(self, key: str) -&gt; \"Any\":\n    \"\"\"Return the value corresponding to `key`.\n\n    Args:\n        key: The requested cached object to retrieve a value for.\n\n    Returns:\n        The value corresponding to the `key` value.\n\n    \"\"\"\n    if key not in self.diskcache:\n        raise KeyError(key)\n    return self.diskcache.get(key)\n</code></pre>"},{"location":"api_reference/datacache/datacache/#oteapi.datacache.datacache.DataCache.getfile","title":"<code>getfile(key, delete=True, filename=None, prefix=None, suffix=None, directory=None)</code>","text":"<p>Write the value for <code>key</code> to file and return the filename.</p> <p>The file is created in the default directory for temporary files (which can be controlled by the <code>TEMPDIR</code>, <code>TEMP</code> or <code>TMP</code> environment variables). It is readable and writable only for the current user.</p> Example <p>This method is intended to be used in a <code>with</code> statement, to automatically delete the file when leaving the context:</p> <pre><code>cache = DataCache()\nwith cache.getfile('mykey') as filename:\n    # do something with filename...\n# filename is deleted\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>Key of value to write to file.</p> required <code>delete</code> <code>bool</code> <p>Whether to automatically delete the created file when leaving the context.</p> <code>True</code> <code>filename</code> <code>Optional[Union[Path, str]]</code> <p>Full path to created file. If not given, a unique filename will be created.</p> <code>None</code> <code>prefix</code> <code>Optional[str]</code> <p>Prefix to prepend to the returned file name (default is <code>\"oteapi-download-\"</code>).</p> <code>None</code> <code>suffix</code> <code>Optional[str]</code> <p>Suffix to append to the returned file name.</p> <code>None</code> <code>directory</code> <code>Optional[str]</code> <p>File directory if <code>filename</code> is not provided (is <code>None</code>).</p> <code>None</code> <p>Yields:</p> Type Description <code>Path</code> <p>Path object, referencing and representing the created file.</p> Source code in <code>oteapi/datacache/datacache.py</code> <pre><code>@contextmanager\ndef getfile(\n    self,\n    key: str,\n    delete: bool = True,\n    filename: \"Optional[Union[Path, str]]\" = None,\n    prefix: \"Optional[str]\" = None,\n    suffix: \"Optional[str]\" = None,\n    directory: \"Optional[str]\" = None,\n) -&gt; \"Iterator[Path]\":\n    \"\"\"Write the value for `key` to file and return the filename.\n\n    The file is created in the default directory for temporary\n    files (which can be controlled by the `TEMPDIR`, `TEMP` or `TMP`\n    environment variables). It is readable and writable only for\n    the current user.\n\n    Example:\n        This method is intended to be used in a `with` statement, to\n        automatically delete the file when leaving the context:\n\n        ```python\n        cache = DataCache()\n        with cache.getfile('mykey') as filename:\n            # do something with filename...\n        # filename is deleted\n        ```\n\n    Args:\n        key: Key of value to write to file.\n        delete: Whether to automatically delete the created file when leaving the\n            context.\n        filename: Full path to created file. If not given, a unique filename will\n            be created.\n        prefix: Prefix to prepend to the returned file name (default is\n            `\"oteapi-download-\"`).\n        suffix: Suffix to append to the returned file name.\n        directory: File directory if `filename` is not provided (is `None`).\n\n    Yields:\n        Path object, referencing and representing the created file.\n\n    \"\"\"\n    if filename:\n        filename = Path(filename).resolve()\n        filename.write_bytes(self.get(key))\n    else:\n        prefix = prefix if prefix else \"oteapi-download-\"\n        with tempfile.NamedTemporaryFile(\n            prefix=prefix,\n            suffix=suffix,\n            dir=directory,\n            delete=False,\n        ) as handle:\n            handle.write(self.get(key))\n            filename = Path(handle.name).resolve()\n\n    try:\n        yield filename\n    finally:\n        if delete:\n            filename.unlink()\n</code></pre>"},{"location":"api_reference/datacache/datacache/#oteapi.datacache.datacache.gethash","title":"<code>gethash(value, hashtype='sha256', encoding='utf-8', json_encoder=None)</code>","text":"<p>Return a hash of <code>value</code>.</p> <p>Can hash most python objects. Bytes and bytearrays are hashed directly. Strings are converted to bytes with the given encoding. All other objects are first serialised using json.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Any</code> <p>Value to hash.</p> required <code>hashtype</code> <code>str</code> <p>Any of the hash algorithms supported by hashlib.</p> <code>'sha256'</code> <code>encoding</code> <code>str</code> <p>Encoding used to convert strings to bytes before calculating the hash.</p> <code>'utf-8'</code> <code>json_encoder</code> <code>Optional[Type[JSONEncoder]]</code> <p>Customised json encoder for complex Python objects.</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>A hash of the input <code>value</code>.</p> Source code in <code>oteapi/datacache/datacache.py</code> <pre><code>def gethash(\n    value: \"Any\",\n    hashtype: str = \"sha256\",\n    encoding: str = \"utf-8\",\n    json_encoder: \"Optional[Type[json.JSONEncoder]]\" = None,\n) -&gt; str:\n    \"\"\"Return a hash of `value`.\n\n    Can hash most python objects. Bytes and bytearrays are hashed directly.\n    Strings are converted to bytes with the given encoding.\n    All other objects are first serialised using json.\n\n    Args:\n        value: Value to hash.\n        hashtype: Any of the hash algorithms supported by hashlib.\n        encoding: Encoding used to convert strings to bytes before\n            calculating the hash.\n        json_encoder: Customised json encoder for complex Python objects.\n\n    Returns:\n        A hash of the input `value`.\n\n    \"\"\"\n    hash_ = hashlib.new(hashtype)\n\n    if isinstance(value, str):\n        data = value.encode(encoding)\n    else:\n        data = value\n\n    try:\n        hash_.update(data)\n    except TypeError:\n        # Fallback, try to serialise using json...\n        data = json.dumps(\n            value,\n            ensure_ascii=False,\n            cls=json_encoder,\n            sort_keys=True,\n        ).encode(encoding)\n\n        hash_.update(data)\n\n    return hash_.hexdigest()\n</code></pre>"},{"location":"api_reference/interfaces/idownloadstrategy/","title":"idownloadstrategy","text":"<p>Download Strategy Interface</p>"},{"location":"api_reference/interfaces/idownloadstrategy/#oteapi.interfaces.idownloadstrategy.IDownloadStrategy","title":"<code>IDownloadStrategy</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Protocol</code></p> <p>Download Strategy Interface.</p> Source code in <code>oteapi/interfaces/idownloadstrategy.py</code> <pre><code>@dataclass  # type: ignore[misc]\nclass IDownloadStrategy(Protocol):\n    \"\"\"Download Strategy Interface.\"\"\"\n\n    download_config: \"ResourceConfig\"\n\n    def get(self) -&gt; \"AttrDict\":\n        \"\"\"Execute the strategy.\n\n        Returns:\n            An update model of key/value-pairs to be stored in the\n            session-specific context from services.\n\n        \"\"\"\n\n    def initialize(self) -&gt; \"AttrDict\":\n        \"\"\"Initialize data class.\n\n        This method will be called through the `/initialize` endpoint of the OTE-API\n        Services.\n\n        Returns:\n            An update model of key/value-pairs to be stored in the\n            session-specific context from services.\n\n        \"\"\"\n</code></pre>"},{"location":"api_reference/interfaces/idownloadstrategy/#oteapi.interfaces.idownloadstrategy.IDownloadStrategy.get","title":"<code>get()</code>","text":"<p>Execute the strategy.</p> <p>Returns:</p> Type Description <code>AttrDict</code> <p>An update model of key/value-pairs to be stored in the</p> <code>AttrDict</code> <p>session-specific context from services.</p> Source code in <code>oteapi/interfaces/idownloadstrategy.py</code> <pre><code>def get(self) -&gt; \"AttrDict\":\n    \"\"\"Execute the strategy.\n\n    Returns:\n        An update model of key/value-pairs to be stored in the\n        session-specific context from services.\n\n    \"\"\"\n</code></pre>"},{"location":"api_reference/interfaces/idownloadstrategy/#oteapi.interfaces.idownloadstrategy.IDownloadStrategy.initialize","title":"<code>initialize()</code>","text":"<p>Initialize data class.</p> <p>This method will be called through the <code>/initialize</code> endpoint of the OTE-API Services.</p> <p>Returns:</p> Type Description <code>AttrDict</code> <p>An update model of key/value-pairs to be stored in the</p> <code>AttrDict</code> <p>session-specific context from services.</p> Source code in <code>oteapi/interfaces/idownloadstrategy.py</code> <pre><code>def initialize(self) -&gt; \"AttrDict\":\n    \"\"\"Initialize data class.\n\n    This method will be called through the `/initialize` endpoint of the OTE-API\n    Services.\n\n    Returns:\n        An update model of key/value-pairs to be stored in the\n        session-specific context from services.\n\n    \"\"\"\n</code></pre>"},{"location":"api_reference/interfaces/ifilterstrategy/","title":"ifilterstrategy","text":"<p>Filter Strategy Interface</p>"},{"location":"api_reference/interfaces/ifilterstrategy/#oteapi.interfaces.ifilterstrategy.IFilterStrategy","title":"<code>IFilterStrategy</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Protocol</code></p> <p>Filter Strategy Interface.</p> Source code in <code>oteapi/interfaces/ifilterstrategy.py</code> <pre><code>@dataclass  # type: ignore[misc]\nclass IFilterStrategy(Protocol):\n    \"\"\"Filter Strategy Interface.\"\"\"\n\n    filter_config: \"FilterConfig\"\n\n    def get(self) -&gt; \"AttrDict\":\n        \"\"\"Execute the strategy.\n\n        Returns:\n            An update model of key/value-pairs to be stored in the\n            session-specific context from services.\n\n        \"\"\"\n\n    def initialize(self) -&gt; \"AttrDict\":\n        \"\"\"Initialize data class.\n\n        This method will be called through the `/initialize` endpoint of the OTE-API\n        Services.\n\n        Returns:\n            An update model of key/value-pairs to be stored in the\n            session-specific context from services.\n\n        \"\"\"\n</code></pre>"},{"location":"api_reference/interfaces/ifilterstrategy/#oteapi.interfaces.ifilterstrategy.IFilterStrategy.get","title":"<code>get()</code>","text":"<p>Execute the strategy.</p> <p>Returns:</p> Type Description <code>AttrDict</code> <p>An update model of key/value-pairs to be stored in the</p> <code>AttrDict</code> <p>session-specific context from services.</p> Source code in <code>oteapi/interfaces/ifilterstrategy.py</code> <pre><code>def get(self) -&gt; \"AttrDict\":\n    \"\"\"Execute the strategy.\n\n    Returns:\n        An update model of key/value-pairs to be stored in the\n        session-specific context from services.\n\n    \"\"\"\n</code></pre>"},{"location":"api_reference/interfaces/ifilterstrategy/#oteapi.interfaces.ifilterstrategy.IFilterStrategy.initialize","title":"<code>initialize()</code>","text":"<p>Initialize data class.</p> <p>This method will be called through the <code>/initialize</code> endpoint of the OTE-API Services.</p> <p>Returns:</p> Type Description <code>AttrDict</code> <p>An update model of key/value-pairs to be stored in the</p> <code>AttrDict</code> <p>session-specific context from services.</p> Source code in <code>oteapi/interfaces/ifilterstrategy.py</code> <pre><code>def initialize(self) -&gt; \"AttrDict\":\n    \"\"\"Initialize data class.\n\n    This method will be called through the `/initialize` endpoint of the OTE-API\n    Services.\n\n    Returns:\n        An update model of key/value-pairs to be stored in the\n        session-specific context from services.\n\n    \"\"\"\n</code></pre>"},{"location":"api_reference/interfaces/ifunctionstrategy/","title":"ifunctionstrategy","text":"<p>Function Strategy Interface</p>"},{"location":"api_reference/interfaces/ifunctionstrategy/#oteapi.interfaces.ifunctionstrategy.IFunctionStrategy","title":"<code>IFunctionStrategy</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Protocol</code></p> <p>Function Strategy Interface.</p> Source code in <code>oteapi/interfaces/ifunctionstrategy.py</code> <pre><code>@dataclass  # type: ignore[misc]\nclass IFunctionStrategy(Protocol):\n    \"\"\"Function Strategy Interface.\"\"\"\n\n    function_config: \"FunctionConfig\"\n\n    def get(self) -&gt; \"AttrDict\":\n        \"\"\"Execute the strategy.\n\n        Returns:\n            An update model of key/value-pairs to be stored in the\n            session-specific context from services.\n\n        \"\"\"\n\n    def initialize(self) -&gt; \"AttrDict\":\n        \"\"\"Initialize data class.\n\n        This method will be called through the `/initialize` endpoint of the OTE-API\n        Services.\n\n        Returns:\n            An update model of key/value-pairs to be stored in the\n            session-specific context from services.\n\n        \"\"\"\n</code></pre>"},{"location":"api_reference/interfaces/ifunctionstrategy/#oteapi.interfaces.ifunctionstrategy.IFunctionStrategy.get","title":"<code>get()</code>","text":"<p>Execute the strategy.</p> <p>Returns:</p> Type Description <code>AttrDict</code> <p>An update model of key/value-pairs to be stored in the</p> <code>AttrDict</code> <p>session-specific context from services.</p> Source code in <code>oteapi/interfaces/ifunctionstrategy.py</code> <pre><code>def get(self) -&gt; \"AttrDict\":\n    \"\"\"Execute the strategy.\n\n    Returns:\n        An update model of key/value-pairs to be stored in the\n        session-specific context from services.\n\n    \"\"\"\n</code></pre>"},{"location":"api_reference/interfaces/ifunctionstrategy/#oteapi.interfaces.ifunctionstrategy.IFunctionStrategy.initialize","title":"<code>initialize()</code>","text":"<p>Initialize data class.</p> <p>This method will be called through the <code>/initialize</code> endpoint of the OTE-API Services.</p> <p>Returns:</p> Type Description <code>AttrDict</code> <p>An update model of key/value-pairs to be stored in the</p> <code>AttrDict</code> <p>session-specific context from services.</p> Source code in <code>oteapi/interfaces/ifunctionstrategy.py</code> <pre><code>def initialize(self) -&gt; \"AttrDict\":\n    \"\"\"Initialize data class.\n\n    This method will be called through the `/initialize` endpoint of the OTE-API\n    Services.\n\n    Returns:\n        An update model of key/value-pairs to be stored in the\n        session-specific context from services.\n\n    \"\"\"\n</code></pre>"},{"location":"api_reference/interfaces/imappingstrategy/","title":"imappingstrategy","text":"<p>Mapping Strategy Interface</p>"},{"location":"api_reference/interfaces/imappingstrategy/#oteapi.interfaces.imappingstrategy.IMappingStrategy","title":"<code>IMappingStrategy</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Protocol</code></p> <p>Mapping Strategy Interface.</p> Source code in <code>oteapi/interfaces/imappingstrategy.py</code> <pre><code>@dataclass  # type: ignore[misc]\nclass IMappingStrategy(Protocol):\n    \"\"\"Mapping Strategy Interface.\"\"\"\n\n    mapping_config: \"MappingConfig\"\n\n    def get(self) -&gt; \"AttrDict\":\n        \"\"\"Execute the strategy.\n\n        Returns:\n            An update model of key/value-pairs to be stored in the\n            session-specific context from services.\n\n        \"\"\"\n\n    def initialize(self) -&gt; \"AttrDict\":\n        \"\"\"Initialize data class.\n\n        This method will be called through the `/initialize` endpoint of the OTE-API\n        Services.\n\n        Returns:\n            An update model of key/value-pairs to be stored in the\n            session-specific context from services.\n\n        \"\"\"\n</code></pre>"},{"location":"api_reference/interfaces/imappingstrategy/#oteapi.interfaces.imappingstrategy.IMappingStrategy.get","title":"<code>get()</code>","text":"<p>Execute the strategy.</p> <p>Returns:</p> Type Description <code>AttrDict</code> <p>An update model of key/value-pairs to be stored in the</p> <code>AttrDict</code> <p>session-specific context from services.</p> Source code in <code>oteapi/interfaces/imappingstrategy.py</code> <pre><code>def get(self) -&gt; \"AttrDict\":\n    \"\"\"Execute the strategy.\n\n    Returns:\n        An update model of key/value-pairs to be stored in the\n        session-specific context from services.\n\n    \"\"\"\n</code></pre>"},{"location":"api_reference/interfaces/imappingstrategy/#oteapi.interfaces.imappingstrategy.IMappingStrategy.initialize","title":"<code>initialize()</code>","text":"<p>Initialize data class.</p> <p>This method will be called through the <code>/initialize</code> endpoint of the OTE-API Services.</p> <p>Returns:</p> Type Description <code>AttrDict</code> <p>An update model of key/value-pairs to be stored in the</p> <code>AttrDict</code> <p>session-specific context from services.</p> Source code in <code>oteapi/interfaces/imappingstrategy.py</code> <pre><code>def initialize(self) -&gt; \"AttrDict\":\n    \"\"\"Initialize data class.\n\n    This method will be called through the `/initialize` endpoint of the OTE-API\n    Services.\n\n    Returns:\n        An update model of key/value-pairs to be stored in the\n        session-specific context from services.\n\n    \"\"\"\n</code></pre>"},{"location":"api_reference/interfaces/iparsestrategy/","title":"iparsestrategy","text":"<p>Parse Strategy Interface</p>"},{"location":"api_reference/interfaces/iparsestrategy/#oteapi.interfaces.iparsestrategy.IParseStrategy","title":"<code>IParseStrategy</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Protocol</code></p> <p>Parse Strategy Interface.</p> Source code in <code>oteapi/interfaces/iparsestrategy.py</code> <pre><code>@dataclass  # type: ignore[misc]\nclass IParseStrategy(Protocol):\n    \"\"\"Parse Strategy Interface.\"\"\"\n\n    parse_config: \"ParserConfig\"\n\n    def get(self) -&gt; \"AttrDict\":\n        \"\"\"Execute the strategy.\n\n        Returns:\n            An update model of key/value-pairs to be stored in the\n            session-specific context from services.\n\n        \"\"\"\n\n    def initialize(self) -&gt; \"AttrDict\":\n        \"\"\"Initialize data class.\n\n        This method will be called through the `/initialize` endpoint of the OTE-API\n        Services.\n\n        Returns:\n            An update model of key/value-pairs to be stored in the\n            session-specific context from services.\n\n        \"\"\"\n</code></pre>"},{"location":"api_reference/interfaces/iparsestrategy/#oteapi.interfaces.iparsestrategy.IParseStrategy.get","title":"<code>get()</code>","text":"<p>Execute the strategy.</p> <p>Returns:</p> Type Description <code>AttrDict</code> <p>An update model of key/value-pairs to be stored in the</p> <code>AttrDict</code> <p>session-specific context from services.</p> Source code in <code>oteapi/interfaces/iparsestrategy.py</code> <pre><code>def get(self) -&gt; \"AttrDict\":\n    \"\"\"Execute the strategy.\n\n    Returns:\n        An update model of key/value-pairs to be stored in the\n        session-specific context from services.\n\n    \"\"\"\n</code></pre>"},{"location":"api_reference/interfaces/iparsestrategy/#oteapi.interfaces.iparsestrategy.IParseStrategy.initialize","title":"<code>initialize()</code>","text":"<p>Initialize data class.</p> <p>This method will be called through the <code>/initialize</code> endpoint of the OTE-API Services.</p> <p>Returns:</p> Type Description <code>AttrDict</code> <p>An update model of key/value-pairs to be stored in the</p> <code>AttrDict</code> <p>session-specific context from services.</p> Source code in <code>oteapi/interfaces/iparsestrategy.py</code> <pre><code>def initialize(self) -&gt; \"AttrDict\":\n    \"\"\"Initialize data class.\n\n    This method will be called through the `/initialize` endpoint of the OTE-API\n    Services.\n\n    Returns:\n        An update model of key/value-pairs to be stored in the\n        session-specific context from services.\n\n    \"\"\"\n</code></pre>"},{"location":"api_reference/interfaces/iresourcestrategy/","title":"iresourcestrategy","text":"<p>Resource Strategy Interface</p>"},{"location":"api_reference/interfaces/iresourcestrategy/#oteapi.interfaces.iresourcestrategy.IResourceStrategy","title":"<code>IResourceStrategy</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Protocol</code></p> <p>Resource Strategy Interface.</p> Source code in <code>oteapi/interfaces/iresourcestrategy.py</code> <pre><code>@dataclass  # type: ignore[misc]\nclass IResourceStrategy(Protocol):\n    \"\"\"Resource Strategy Interface.\"\"\"\n\n    resource_config: \"ResourceConfig\"\n\n    def get(self) -&gt; \"AttrDict\":\n        \"\"\"Execute the strategy.\n\n        Returns:\n            An update model of key/value-pairs to be stored in the\n            session-specific context from services.\n\n        \"\"\"\n\n    def initialize(self) -&gt; \"AttrDict\":\n        \"\"\"Initialize data class.\n\n        This method will be called through the `/initialize` endpoint of the OTE-API\n        Services.\n\n        Returns:\n            An update model of key/value-pairs to be stored in the\n            session-specific context from services.\n\n        \"\"\"\n</code></pre>"},{"location":"api_reference/interfaces/iresourcestrategy/#oteapi.interfaces.iresourcestrategy.IResourceStrategy.get","title":"<code>get()</code>","text":"<p>Execute the strategy.</p> <p>Returns:</p> Type Description <code>AttrDict</code> <p>An update model of key/value-pairs to be stored in the</p> <code>AttrDict</code> <p>session-specific context from services.</p> Source code in <code>oteapi/interfaces/iresourcestrategy.py</code> <pre><code>def get(self) -&gt; \"AttrDict\":\n    \"\"\"Execute the strategy.\n\n    Returns:\n        An update model of key/value-pairs to be stored in the\n        session-specific context from services.\n\n    \"\"\"\n</code></pre>"},{"location":"api_reference/interfaces/iresourcestrategy/#oteapi.interfaces.iresourcestrategy.IResourceStrategy.initialize","title":"<code>initialize()</code>","text":"<p>Initialize data class.</p> <p>This method will be called through the <code>/initialize</code> endpoint of the OTE-API Services.</p> <p>Returns:</p> Type Description <code>AttrDict</code> <p>An update model of key/value-pairs to be stored in the</p> <code>AttrDict</code> <p>session-specific context from services.</p> Source code in <code>oteapi/interfaces/iresourcestrategy.py</code> <pre><code>def initialize(self) -&gt; \"AttrDict\":\n    \"\"\"Initialize data class.\n\n    This method will be called through the `/initialize` endpoint of the OTE-API\n    Services.\n\n    Returns:\n        An update model of key/value-pairs to be stored in the\n        session-specific context from services.\n\n    \"\"\"\n</code></pre>"},{"location":"api_reference/interfaces/itransformationstrategy/","title":"itransformationstrategy","text":"<p>Tranformation Strategy Interface</p>"},{"location":"api_reference/interfaces/itransformationstrategy/#oteapi.interfaces.itransformationstrategy.ITransformationStrategy","title":"<code>ITransformationStrategy</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Protocol</code></p> <p>Transformation Strategy Interface.</p> Source code in <code>oteapi/interfaces/itransformationstrategy.py</code> <pre><code>@dataclass  # type: ignore[misc]\nclass ITransformationStrategy(Protocol):\n    \"\"\"Transformation Strategy Interface.\"\"\"\n\n    transformation_config: \"TransformationConfig\"\n\n    def status(self, task_id: str) -&gt; \"TransformationStatus\":\n        \"\"\"Get job status.\n\n        Parameters:\n            task_id: The transformation job ID.\n\n        Returns:\n            An overview of the transformation job's status, including relevant\n            metadata.\n\n        \"\"\"\n\n    def get(self) -&gt; \"AttrDict\":\n        \"\"\"Execute the strategy i.e. running a transformation job.\n\n        Returns:\n            An update model of key/value-pairs to be stored in the\n            session-specific context from services.\n\n        \"\"\"\n\n    def initialize(self) -&gt; \"AttrDict\":\n        \"\"\"Initialize data class.\n\n        This method will be called through the `/initialize` endpoint of the OTE-API\n        Services.\n\n        Returns:\n            An update model of key/value-pairs to be stored in the\n            session-specific context from services.\n\n        \"\"\"\n</code></pre>"},{"location":"api_reference/interfaces/itransformationstrategy/#oteapi.interfaces.itransformationstrategy.ITransformationStrategy.get","title":"<code>get()</code>","text":"<p>Execute the strategy i.e. running a transformation job.</p> <p>Returns:</p> Type Description <code>AttrDict</code> <p>An update model of key/value-pairs to be stored in the</p> <code>AttrDict</code> <p>session-specific context from services.</p> Source code in <code>oteapi/interfaces/itransformationstrategy.py</code> <pre><code>def get(self) -&gt; \"AttrDict\":\n    \"\"\"Execute the strategy i.e. running a transformation job.\n\n    Returns:\n        An update model of key/value-pairs to be stored in the\n        session-specific context from services.\n\n    \"\"\"\n</code></pre>"},{"location":"api_reference/interfaces/itransformationstrategy/#oteapi.interfaces.itransformationstrategy.ITransformationStrategy.initialize","title":"<code>initialize()</code>","text":"<p>Initialize data class.</p> <p>This method will be called through the <code>/initialize</code> endpoint of the OTE-API Services.</p> <p>Returns:</p> Type Description <code>AttrDict</code> <p>An update model of key/value-pairs to be stored in the</p> <code>AttrDict</code> <p>session-specific context from services.</p> Source code in <code>oteapi/interfaces/itransformationstrategy.py</code> <pre><code>def initialize(self) -&gt; \"AttrDict\":\n    \"\"\"Initialize data class.\n\n    This method will be called through the `/initialize` endpoint of the OTE-API\n    Services.\n\n    Returns:\n        An update model of key/value-pairs to be stored in the\n        session-specific context from services.\n\n    \"\"\"\n</code></pre>"},{"location":"api_reference/interfaces/itransformationstrategy/#oteapi.interfaces.itransformationstrategy.ITransformationStrategy.status","title":"<code>status(task_id)</code>","text":"<p>Get job status.</p> <p>Parameters:</p> Name Type Description Default <code>task_id</code> <code>str</code> <p>The transformation job ID.</p> required <p>Returns:</p> Type Description <code>TransformationStatus</code> <p>An overview of the transformation job's status, including relevant</p> <code>TransformationStatus</code> <p>metadata.</p> Source code in <code>oteapi/interfaces/itransformationstrategy.py</code> <pre><code>def status(self, task_id: str) -&gt; \"TransformationStatus\":\n    \"\"\"Get job status.\n\n    Parameters:\n        task_id: The transformation job ID.\n\n    Returns:\n        An overview of the transformation job's status, including relevant\n        metadata.\n\n    \"\"\"\n</code></pre>"},{"location":"api_reference/models/datacacheconfig/","title":"datacacheconfig","text":"<p>Pydantic DataCache Configuration Data Model.</p>"},{"location":"api_reference/models/datacacheconfig/#oteapi.models.datacacheconfig.DataCacheConfig","title":"<code>DataCacheConfig</code>","text":"<p>               Bases: <code>AttrDict</code></p> <p>DataCache Configuration.</p> <p>This class should not be used directly as a configuration object for a strategy object, but only as a configuration field inside a configuration object.</p> Source code in <code>oteapi/models/datacacheconfig.py</code> <pre><code>class DataCacheConfig(AttrDict):\n    \"\"\"DataCache Configuration.\n\n    This class should not be used directly as a configuration object\n    for a strategy object, but only as a configuration field inside\n    a configuration object.\n    \"\"\"\n\n    cacheDir: Path = Field(Path(\"oteapi\"), description=\"Cache directory.\")\n    accessKey: Optional[str] = Field(\n        None,\n        description=\"Key with which the downloaded content can be accessed. \"\n        \"Should preferable be the hash (corresponding to `hashType`) of the \"\n        \"content if it is known.\",\n    )\n    hashType: str = Field(\n        \"md5\",\n        description=\"Hash algorithm to use for creating hash keys for stored \"\n        \"data. Can be any algorithm supported by hashlib.\",\n    )\n    expireTime: int = Field(\n        3600 * 24 * 14,\n        description=\"Number of seconds before the cache entry expires. \"\n        \"Zero means no expiration. Default is two weeks.\",\n    )\n    tag: Optional[str] = Field(\n        None,\n        description=\"Tag assigned to the downloaded content, typically \"\n        \"identifying a session. Used with the `evict()` method to clean up a \"\n        \"all cache entries with a given tag.\",\n    )\n</code></pre>"},{"location":"api_reference/models/datacacheconfig/#oteapi.models.datacacheconfig.DataCacheConfig.accessKey","title":"<code>accessKey: Optional[str] = Field(None, description='Key with which the downloaded content can be accessed. Should preferable be the hash (corresponding to `hashType`) of the content if it is known.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/models/datacacheconfig/#oteapi.models.datacacheconfig.DataCacheConfig.cacheDir","title":"<code>cacheDir: Path = Field(Path('oteapi'), description='Cache directory.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/models/datacacheconfig/#oteapi.models.datacacheconfig.DataCacheConfig.expireTime","title":"<code>expireTime: int = Field(3600 * 24 * 14, description='Number of seconds before the cache entry expires. Zero means no expiration. Default is two weeks.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/models/datacacheconfig/#oteapi.models.datacacheconfig.DataCacheConfig.hashType","title":"<code>hashType: str = Field('md5', description='Hash algorithm to use for creating hash keys for stored data. Can be any algorithm supported by hashlib.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/models/datacacheconfig/#oteapi.models.datacacheconfig.DataCacheConfig.tag","title":"<code>tag: Optional[str] = Field(None, description='Tag assigned to the downloaded content, typically identifying a session. Used with the `evict()` method to clean up a all cache entries with a given tag.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/models/filterconfig/","title":"filterconfig","text":"<p>Pydantic Filter Configuration Data Model.</p>"},{"location":"api_reference/models/filterconfig/#oteapi.models.filterconfig.FilterConfig","title":"<code>FilterConfig</code>","text":"<p>               Bases: <code>GenericConfig</code></p> <p>Filter Strategy Data Configuration.</p> Source code in <code>oteapi/models/filterconfig.py</code> <pre><code>class FilterConfig(GenericConfig):\n    \"\"\"Filter Strategy Data Configuration.\"\"\"\n\n    filterType: str = Field(\n        ..., description=\"Type of registered filter strategy. E.g., `filter/sql`.\"\n    )\n    query: Optional[str] = Field(None, description=\"Define a query operation.\")\n    condition: Optional[str] = Field(\n        None,\n        description=\"Logical statement indicating when a filter should be applied.\",\n    )\n    limit: Optional[int] = Field(\n        None, description=\"Number of items remaining after a filter expression.\"\n    )\n</code></pre>"},{"location":"api_reference/models/filterconfig/#oteapi.models.filterconfig.FilterConfig.condition","title":"<code>condition: Optional[str] = Field(None, description='Logical statement indicating when a filter should be applied.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/models/filterconfig/#oteapi.models.filterconfig.FilterConfig.filterType","title":"<code>filterType: str = Field(..., description='Type of registered filter strategy. E.g., `filter/sql`.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/models/filterconfig/#oteapi.models.filterconfig.FilterConfig.limit","title":"<code>limit: Optional[int] = Field(None, description='Number of items remaining after a filter expression.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/models/filterconfig/#oteapi.models.filterconfig.FilterConfig.query","title":"<code>query: Optional[str] = Field(None, description='Define a query operation.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/models/functionconfig/","title":"functionconfig","text":"<p>Pydantic Function Configuration Data Model.</p>"},{"location":"api_reference/models/functionconfig/#oteapi.models.functionconfig.FunctionConfig","title":"<code>FunctionConfig</code>","text":"<p>               Bases: <code>GenericConfig</code>, <code>SecretConfig</code></p> <p>Function Strategy Data Configuration.</p> Source code in <code>oteapi/models/functionconfig.py</code> <pre><code>class FunctionConfig(GenericConfig, SecretConfig):\n    \"\"\"Function Strategy Data Configuration.\"\"\"\n\n    functionType: str = Field(\n        ...,\n        description=(\"Type of registered function strategy.\"),\n    )\n</code></pre>"},{"location":"api_reference/models/functionconfig/#oteapi.models.functionconfig.FunctionConfig.functionType","title":"<code>functionType: str = Field(..., description='Type of registered function strategy.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/models/genericconfig/","title":"genericconfig","text":"<p>Generic data model for configuration attributes.</p>"},{"location":"api_reference/models/genericconfig/#oteapi.models.genericconfig.AttrDict","title":"<code>AttrDict</code>","text":"<p>               Bases: <code>BaseModel</code>, <code>MutableMapping</code></p> <p>An object whose attributes can also be accessed through subscription, like with a dictionary.</p> <p>Special pydantic configuration settings:</p> <ul> <li><code>extra</code>   Allow any attributes/fields to be defined - this is what makes this pydantic   model an attribute dictionary.</li> <li><code>validate_assignment</code>   Validate and cast set values.   This is mainly relevant for sub-classes of <code>AttrDict</code>, where specific   attributes have been defined.</li> <li><code>arbitrary_types_allowed</code>   If a custom type is used for an attribute that doesn't have a <code>validate()</code>   method, don't fail setting the attribute.</li> </ul> Source code in <code>oteapi/models/genericconfig.py</code> <pre><code>class AttrDict(BaseModel, MutableMapping):\n    \"\"\"An object whose attributes can also be accessed through\n    subscription, like with a dictionary.\n\n    Special pydantic configuration settings:\n\n    - **`extra`**\n      Allow any attributes/fields to be defined - this is what makes this pydantic\n      model an attribute dictionary.\n    - **`validate_assignment`**\n      Validate and cast set values.\n      This is mainly relevant for sub-classes of `AttrDict`, where specific\n      attributes have been defined.\n    - **`arbitrary_types_allowed`**\n      If a custom type is used for an attribute that doesn't have a `validate()`\n      method, don't fail setting the attribute.\n\n    \"\"\"\n\n    model_config = ConfigDict(\n        extra=\"allow\", validate_assignment=True, arbitrary_types_allowed=True\n    )\n\n    # Collection methods\n    def __contains__(self, key: object) -&gt; bool:\n        if not isinstance(key, str):\n            raise TypeError(f\"Keys must be of type `str`, not `{type(key).__name__}`.\")\n        return hasattr(self, key)\n\n    def __len__(self) -&gt; int:\n        return len(self.model_dump())\n\n    # Mapping methods\n    def __getitem__(self, key: \"Any\") -&gt; \"Any\":\n        if not isinstance(key, str):\n            raise TypeError(f\"Keys must be of type `str`, not `{type(key).__name__}`.\")\n        try:\n            return getattr(self, key)\n        except AttributeError as exc:\n            raise KeyError(key) from exc\n\n    def items(self):\n        return self.model_dump().items()\n\n    def keys(self):\n        return self.model_dump().keys()\n\n    def values(self):\n        return self.model_dump().values()\n\n    def get(self, key: str, default: \"Optional[Any]\" = None) -&gt; \"Any\":\n        return getattr(self, key, default)\n\n    def __eq__(self, value: object) -&gt; bool:\n        if isinstance(value, Mapping):\n            return self.model_dump() == value\n        if isinstance(value, BaseModel):\n            return BaseModel.__eq__(self, value)\n        return False\n\n    # MutableMapping methods\n    def __setitem__(self, key: \"Any\", value: \"Any\") -&gt; None:\n        if not isinstance(key, str):\n            raise TypeError(f\"Keys must be of type `str`, not `{type(key).__name__}`.\")\n        try:\n            return self.__setattr__(key, value)\n        except AttributeError as exc:\n            raise KeyError(key) from exc\n\n    def __delitem__(self, key: \"Any\") -&gt; None:\n        warnings.warn(\n            \"Item deletion used to reset fields to their default values. To keep using\"\n            \" this functionality, use the `reset_field()` method.\",\n            DeprecationWarning,\n        )\n\n        if not isinstance(key, str):\n            raise TypeError(f\"Keys must be of type `str`, not `{type(key).__name__}`.\")\n        try:\n            self.__delattr__(key)\n        except AttributeError as exc:\n            raise KeyError(key) from exc\n        else:\n            if key in self.model_fields_set:\n                self.model_fields_set.remove(key)\n\n    def clear(self) -&gt; None:\n        # Ignore the deprecation warning from `__delitem__`\n        with warnings.catch_warnings():\n            warnings.simplefilter(\"ignore\", DeprecationWarning)\n\n            for field in self.model_dump():\n                del self[field]\n\n    def update(  # type: ignore[override]\n        self,\n        other: \"Optional[Union[Mapping[str, Any], Iterable[tuple[str, Any]]]]\" = None,\n        **kwargs,\n    ) -&gt; None:\n        if other and isinstance(other, Mapping):\n            for key, value in other.items():\n                setattr(self, key, value)\n        elif other and isinstance(other, BaseModel):\n            for key, value in other:\n                setattr(self, key, value)\n        elif other and isinstance(other, Iterable):\n            for entry in other:\n                if not isinstance(entry, tuple):\n                    raise TypeError(\n                        \"`other` must be an iterable of tuples of length two.\"\n                    )\n                if not len(entry) == 2:\n                    raise ValueError(\n                        \"`other` must be an iterable of objects of length two.\"\n                    )\n            for key, value in other:  # type: ignore[misc]\n                setattr(self, key, value)\n        elif other:\n            raise TypeError(\n                \"`other` must be of type `dict`, `Mapping`, `BaseModel` or \"\n                \"`Iterable`, not `{type(other).__name__}`.\"\n            )\n        if kwargs:\n            for key, value in kwargs.items():\n                setattr(self, key, value)\n\n    def pop(self, key: str, default: \"Optional[Any]\" = PydanticUndefined) -&gt; \"Any\":\n        value = self.get(key, default)\n        if value == PydanticUndefined:\n            raise KeyError(key)\n        if key in self:\n            # Ignore the deprecation warning from `__delitem__`\n            with warnings.catch_warnings():\n                warnings.simplefilter(\"ignore\", DeprecationWarning)\n\n                del self[key]\n        return value\n\n    def popitem(self) -&gt; \"Tuple[str, Any]\":\n        \"\"\"MutableMapping `popitem`-method.\n\n        Important:\n            Unlike the regular `dict.popitem()` method, this one does _not_ respect\n            LIFO (last-in, first-out).\n            This is due to the fact that attributes are stored in a random order when\n            initializing the model.\n\n            However, it will respect LIFO with respect to the internal `model_fields`.\n\n        \"\"\"\n        if not self:\n            raise KeyError(f\"popitem(): {self.__class__.__name__} is empty\")\n\n        key = list(self.keys())[-1]\n        value = self.pop(key)\n        return key, value\n\n    def reset_field(self, field: str) -&gt; None:\n        \"\"\"Reset a field to its default value.\n\n        Warning:\n            This will remove/delete a field that is not part of the model schema.\n\n        Parameters:\n            field: The field to reset.\n\n        \"\"\"\n        if field not in self:\n            raise KeyError(f\"Field {field!r} does not exist.\")\n\n        if field in self.model_fields:\n            # Part of the model schema\n            schema_field = True\n\n            # Set the field to its default value\n            setattr(self, field, self.model_fields[field].default)\n        else:\n            # Not part of the model schema, but part of the extras\n            schema_field = False\n\n            # Remove the field altogether\n            if self.model_extra is None:\n                raise RuntimeError(\"Model has no extra fields.\")\n\n            try:\n                self.model_extra.pop(field)\n            except KeyError as exc:\n                raise RuntimeError(\n                    f\"Field {field!r} can not be found in the model fields or extras.\"\n                ) from exc\n\n        # Remove it from fields set by the user\n        if field in self.model_fields_set:\n            self.model_fields_set.remove(field)\n\n        # Check the field has been properly reset\n        if schema_field:\n            if field not in self:\n                raise RuntimeError(f\"Field {field!r} was not reset as expected.\")\n            if self[field] != self.model_fields[field].default:\n                raise RuntimeError(\n                    f\"Field {field!r} was not reset to its default value as expected.\"\n                )\n        else:\n            if field in self:\n                raise RuntimeError(f\"Field {field!r} was not removed as expected.\")\n        if field in self.model_fields_set:\n            raise RuntimeError(\n                f\"Field {field!r} was not removed from the set of user-set fields as \"\n                \"expected.\"\n            )\n</code></pre>"},{"location":"api_reference/models/genericconfig/#oteapi.models.genericconfig.AttrDict.model_config","title":"<code>model_config = ConfigDict(extra='allow', validate_assignment=True, arbitrary_types_allowed=True)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/models/genericconfig/#oteapi.models.genericconfig.AttrDict.clear","title":"<code>clear()</code>","text":"Source code in <code>oteapi/models/genericconfig.py</code> <pre><code>def clear(self) -&gt; None:\n    # Ignore the deprecation warning from `__delitem__`\n    with warnings.catch_warnings():\n        warnings.simplefilter(\"ignore\", DeprecationWarning)\n\n        for field in self.model_dump():\n            del self[field]\n</code></pre>"},{"location":"api_reference/models/genericconfig/#oteapi.models.genericconfig.AttrDict.get","title":"<code>get(key, default=None)</code>","text":"Source code in <code>oteapi/models/genericconfig.py</code> <pre><code>def get(self, key: str, default: \"Optional[Any]\" = None) -&gt; \"Any\":\n    return getattr(self, key, default)\n</code></pre>"},{"location":"api_reference/models/genericconfig/#oteapi.models.genericconfig.AttrDict.items","title":"<code>items()</code>","text":"Source code in <code>oteapi/models/genericconfig.py</code> <pre><code>def items(self):\n    return self.model_dump().items()\n</code></pre>"},{"location":"api_reference/models/genericconfig/#oteapi.models.genericconfig.AttrDict.keys","title":"<code>keys()</code>","text":"Source code in <code>oteapi/models/genericconfig.py</code> <pre><code>def keys(self):\n    return self.model_dump().keys()\n</code></pre>"},{"location":"api_reference/models/genericconfig/#oteapi.models.genericconfig.AttrDict.pop","title":"<code>pop(key, default=PydanticUndefined)</code>","text":"Source code in <code>oteapi/models/genericconfig.py</code> <pre><code>def pop(self, key: str, default: \"Optional[Any]\" = PydanticUndefined) -&gt; \"Any\":\n    value = self.get(key, default)\n    if value == PydanticUndefined:\n        raise KeyError(key)\n    if key in self:\n        # Ignore the deprecation warning from `__delitem__`\n        with warnings.catch_warnings():\n            warnings.simplefilter(\"ignore\", DeprecationWarning)\n\n            del self[key]\n    return value\n</code></pre>"},{"location":"api_reference/models/genericconfig/#oteapi.models.genericconfig.AttrDict.popitem","title":"<code>popitem()</code>","text":"<p>MutableMapping <code>popitem</code>-method.</p> Important <p>Unlike the regular <code>dict.popitem()</code> method, this one does not respect LIFO (last-in, first-out). This is due to the fact that attributes are stored in a random order when initializing the model.</p> <p>However, it will respect LIFO with respect to the internal <code>model_fields</code>.</p> Source code in <code>oteapi/models/genericconfig.py</code> <pre><code>def popitem(self) -&gt; \"Tuple[str, Any]\":\n    \"\"\"MutableMapping `popitem`-method.\n\n    Important:\n        Unlike the regular `dict.popitem()` method, this one does _not_ respect\n        LIFO (last-in, first-out).\n        This is due to the fact that attributes are stored in a random order when\n        initializing the model.\n\n        However, it will respect LIFO with respect to the internal `model_fields`.\n\n    \"\"\"\n    if not self:\n        raise KeyError(f\"popitem(): {self.__class__.__name__} is empty\")\n\n    key = list(self.keys())[-1]\n    value = self.pop(key)\n    return key, value\n</code></pre>"},{"location":"api_reference/models/genericconfig/#oteapi.models.genericconfig.AttrDict.reset_field","title":"<code>reset_field(field)</code>","text":"<p>Reset a field to its default value.</p> Warning <p>This will remove/delete a field that is not part of the model schema.</p> <p>Parameters:</p> Name Type Description Default <code>field</code> <code>str</code> <p>The field to reset.</p> required Source code in <code>oteapi/models/genericconfig.py</code> <pre><code>def reset_field(self, field: str) -&gt; None:\n    \"\"\"Reset a field to its default value.\n\n    Warning:\n        This will remove/delete a field that is not part of the model schema.\n\n    Parameters:\n        field: The field to reset.\n\n    \"\"\"\n    if field not in self:\n        raise KeyError(f\"Field {field!r} does not exist.\")\n\n    if field in self.model_fields:\n        # Part of the model schema\n        schema_field = True\n\n        # Set the field to its default value\n        setattr(self, field, self.model_fields[field].default)\n    else:\n        # Not part of the model schema, but part of the extras\n        schema_field = False\n\n        # Remove the field altogether\n        if self.model_extra is None:\n            raise RuntimeError(\"Model has no extra fields.\")\n\n        try:\n            self.model_extra.pop(field)\n        except KeyError as exc:\n            raise RuntimeError(\n                f\"Field {field!r} can not be found in the model fields or extras.\"\n            ) from exc\n\n    # Remove it from fields set by the user\n    if field in self.model_fields_set:\n        self.model_fields_set.remove(field)\n\n    # Check the field has been properly reset\n    if schema_field:\n        if field not in self:\n            raise RuntimeError(f\"Field {field!r} was not reset as expected.\")\n        if self[field] != self.model_fields[field].default:\n            raise RuntimeError(\n                f\"Field {field!r} was not reset to its default value as expected.\"\n            )\n    else:\n        if field in self:\n            raise RuntimeError(f\"Field {field!r} was not removed as expected.\")\n    if field in self.model_fields_set:\n        raise RuntimeError(\n            f\"Field {field!r} was not removed from the set of user-set fields as \"\n            \"expected.\"\n        )\n</code></pre>"},{"location":"api_reference/models/genericconfig/#oteapi.models.genericconfig.AttrDict.update","title":"<code>update(other=None, **kwargs)</code>","text":"Source code in <code>oteapi/models/genericconfig.py</code> <pre><code>def update(  # type: ignore[override]\n    self,\n    other: \"Optional[Union[Mapping[str, Any], Iterable[tuple[str, Any]]]]\" = None,\n    **kwargs,\n) -&gt; None:\n    if other and isinstance(other, Mapping):\n        for key, value in other.items():\n            setattr(self, key, value)\n    elif other and isinstance(other, BaseModel):\n        for key, value in other:\n            setattr(self, key, value)\n    elif other and isinstance(other, Iterable):\n        for entry in other:\n            if not isinstance(entry, tuple):\n                raise TypeError(\n                    \"`other` must be an iterable of tuples of length two.\"\n                )\n            if not len(entry) == 2:\n                raise ValueError(\n                    \"`other` must be an iterable of objects of length two.\"\n                )\n        for key, value in other:  # type: ignore[misc]\n            setattr(self, key, value)\n    elif other:\n        raise TypeError(\n            \"`other` must be of type `dict`, `Mapping`, `BaseModel` or \"\n            \"`Iterable`, not `{type(other).__name__}`.\"\n        )\n    if kwargs:\n        for key, value in kwargs.items():\n            setattr(self, key, value)\n</code></pre>"},{"location":"api_reference/models/genericconfig/#oteapi.models.genericconfig.AttrDict.values","title":"<code>values()</code>","text":"Source code in <code>oteapi/models/genericconfig.py</code> <pre><code>def values(self):\n    return self.model_dump().values()\n</code></pre>"},{"location":"api_reference/models/genericconfig/#oteapi.models.genericconfig.GenericConfig","title":"<code>GenericConfig</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Generic class for configuration objects.</p> <p>Special pydantic configuration settings:</p> <ul> <li><code>validate_assignment</code>   Validate and cast set values.   This is mainly relevant for sub-classes of <code>AttrDict</code>, where specific   attributes have been defined.</li> <li><code>arbitrary_types_allowed</code>   If a custom type is used for an attribute that doesn't have a <code>validate()</code>   method, don't fail setting the attribute.</li> </ul> Source code in <code>oteapi/models/genericconfig.py</code> <pre><code>class GenericConfig(BaseModel):\n    \"\"\"Generic class for configuration objects.\n\n    Special pydantic configuration settings:\n\n    - **`validate_assignment`**\n      Validate and cast set values.\n      This is mainly relevant for sub-classes of `AttrDict`, where specific\n      attributes have been defined.\n    - **`arbitrary_types_allowed`**\n      If a custom type is used for an attribute that doesn't have a `validate()`\n      method, don't fail setting the attribute.\n\n    \"\"\"\n\n    configuration: AttrDict = Field(\n        AttrDict(),\n        description=\"Model-specific configuration options which can either \"\n        \"be given as key/value-pairs or set as attributes.\",\n    )\n\n    description: str = Field(\n        __doc__,\n        description=\"A description of the configuration model.\",\n    )\n\n    @classmethod\n    def __init_subclass__(cls, **kwargs) -&gt; None:\n        \"\"\"Initialize subclass descriptions with their docstrings.\"\"\"\n        cls.model_fields[\"description\"].default = cls.__doc__\n\n    model_config = ConfigDict(validate_assignment=True, arbitrary_types_allowed=True)\n</code></pre>"},{"location":"api_reference/models/genericconfig/#oteapi.models.genericconfig.GenericConfig.configuration","title":"<code>configuration: AttrDict = Field(AttrDict(), description='Model-specific configuration options which can either be given as key/value-pairs or set as attributes.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/models/genericconfig/#oteapi.models.genericconfig.GenericConfig.description","title":"<code>description: str = Field(__doc__, description='A description of the configuration model.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/models/genericconfig/#oteapi.models.genericconfig.GenericConfig.model_config","title":"<code>model_config = ConfigDict(validate_assignment=True, arbitrary_types_allowed=True)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/models/mappingconfig/","title":"mappingconfig","text":"<p>Pydantic Mapping Configuration Data Model.</p>"},{"location":"api_reference/models/mappingconfig/#oteapi.models.mappingconfig.RDFTriple","title":"<code>RDFTriple = Tuple[str, str, str]</code>  <code>module-attribute</code>","text":""},{"location":"api_reference/models/mappingconfig/#oteapi.models.mappingconfig.MappingConfig","title":"<code>MappingConfig</code>","text":"<p>               Bases: <code>GenericConfig</code></p> <p>Mapping Strategy Data Configuration.</p> Source code in <code>oteapi/models/mappingconfig.py</code> <pre><code>class MappingConfig(GenericConfig):\n    \"\"\"Mapping Strategy Data Configuration.\"\"\"\n\n    mappingType: str = Field(\n        ...,\n        description=\"Type of registered mapping strategy.\",\n    )\n    prefixes: Optional[Dict[str, str]] = Field(\n        None,\n        description=(\n            \"Dictionary of shortnames that expands to an IRI given as local \"\n            \"value/IRI-expansion-pairs.\"\n        ),\n    )\n    triples: Optional[Set[RDFTriple]] = Field(\n        None,\n        description=\"Set of RDF triples given as (subject, predicate, object).\",\n    )\n</code></pre>"},{"location":"api_reference/models/mappingconfig/#oteapi.models.mappingconfig.MappingConfig.mappingType","title":"<code>mappingType: str = Field(..., description='Type of registered mapping strategy.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/models/mappingconfig/#oteapi.models.mappingconfig.MappingConfig.prefixes","title":"<code>prefixes: Optional[Dict[str, str]] = Field(None, description='Dictionary of shortnames that expands to an IRI given as local value/IRI-expansion-pairs.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/models/mappingconfig/#oteapi.models.mappingconfig.MappingConfig.triples","title":"<code>triples: Optional[Set[RDFTriple]] = Field(None, description='Set of RDF triples given as (subject, predicate, object).')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/models/parserconfig/","title":"parserconfig","text":"<p>Pydantic Parser Configuration Data Model.</p>"},{"location":"api_reference/models/parserconfig/#oteapi.models.parserconfig.ParserConfig","title":"<code>ParserConfig</code>","text":"<p>               Bases: <code>GenericConfig</code></p> <p>Parser Strategy Data Configuration.</p> Source code in <code>oteapi/models/parserconfig.py</code> <pre><code>class ParserConfig(GenericConfig):\n    \"\"\"Parser Strategy Data Configuration.\"\"\"\n\n    parserType: str = Field(..., description=\"Type of registered parser strategy.\")\n    entity: AnyHttpUrl = Field(..., description=\"IRI to the entity or collection.\")\n</code></pre>"},{"location":"api_reference/models/parserconfig/#oteapi.models.parserconfig.ParserConfig.entity","title":"<code>entity: AnyHttpUrl = Field(..., description='IRI to the entity or collection.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/models/parserconfig/#oteapi.models.parserconfig.ParserConfig.parserType","title":"<code>parserType: str = Field(..., description='Type of registered parser strategy.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/models/resourceconfig/","title":"resourceconfig","text":"<p>Pydantic Resource Configuration Data Model.</p>"},{"location":"api_reference/models/resourceconfig/#oteapi.models.resourceconfig.HostlessAnyUrl","title":"<code>HostlessAnyUrl = Annotated[Url, UrlConstraints(host_required=False)]</code>  <code>module-attribute</code>","text":""},{"location":"api_reference/models/resourceconfig/#oteapi.models.resourceconfig.ResourceConfig","title":"<code>ResourceConfig</code>","text":"<p>               Bases: <code>GenericConfig</code>, <code>SecretConfig</code></p> <p>Resource Strategy Data Configuration.</p> Important <p>Either of the pairs of attributes <code>downloadUrl</code>/<code>mediaType</code> or <code>accessUrl</code>/<code>accessService</code> MUST be specified.</p> Source code in <code>oteapi/models/resourceconfig.py</code> <pre><code>class ResourceConfig(GenericConfig, SecretConfig):\n    \"\"\"Resource Strategy Data Configuration.\n\n    Important:\n        Either of the pairs of attributes `downloadUrl`/`mediaType` or\n        `accessUrl`/`accessService` MUST be specified.\n\n    \"\"\"\n\n    resourceType: Optional[str] = Field(\n        None, description=\"Type of registered resource strategy.\"\n    )\n\n    downloadUrl: Optional[HostlessAnyUrl] = Field(\n        None,\n        description=(\n            \"Definition: The URL of the downloadable file in a given format. E.g. CSV \"\n            \"file or RDF file.\\n\\nUsage: `downloadURL` *SHOULD* be used for the URL at\"\n            \" which this distribution is available directly, typically through a HTTPS\"\n            \" GET request or SFTP.\"\n        ),\n    )\n    mediaType: Optional[str] = Field(\n        None,\n        description=(\n            \"The media type of the distribution as defined by IANA \"\n            \"[[IANA-MEDIA-TYPES](https://www.w3.org/TR/vocab-dcat-2/#bib-iana-media-types)]\"\n            \".\\n\\nUsage: This property *SHOULD* be used when the media\"\n            \" type of the distribution is defined in IANA \"\n            \"[[IANA-MEDIA-TYPES](https://www.w3.org/TR/vocab-dcat-2/#bib-iana-media-types)].\"\n        ),\n    )\n    accessUrl: Optional[HostlessAnyUrl] = Field(\n        None,\n        description=(\n            \"A URL of the resource that gives access to a distribution of \"\n            \"the dataset. E.g. landing page, feed, SPARQL endpoint.\\n\\nUsage: \"\n            \"`accessURL` *SHOULD* be used for the URL of a service or location that \"\n            \"can provide access to this distribution, typically through a Web form, \"\n            \"query or API call.\\n`downloadURL` is preferred for direct links to \"\n            \"downloadable resources.\"\n        ),\n    )\n    accessService: Optional[str] = Field(\n        None,\n        description=(\n            \"A data service that gives access to the distribution of the dataset.\"\n        ),\n    )\n    license: Optional[str] = Field(\n        None,\n        description=(\n            \"A legal document under which the distribution is made available.\"\n        ),\n    )\n    accessRights: Optional[str] = Field(\n        None,\n        description=(\n            \"A rights statement that concerns how the distribution is accessed.\"\n        ),\n    )\n    publisher: Optional[str] = Field(\n        None,\n        description=\"The entity responsible for making the resource/item available.\",\n    )\n\n    @model_validator(mode=\"after\")\n    def ensure_unique_url_pairs(self) -&gt; \"ResourceConfig\":\n        \"\"\"Ensure either downloadUrl/mediaType or accessUrl/accessService are defined.\n\n        It's fine to define them all, but at least one complete pair MUST be specified.\n        \"\"\"\n        if not (\n            all(getattr(self, _) for _ in [\"downloadUrl\", \"mediaType\"])\n            or all(getattr(self, _) for _ in [\"accessUrl\", \"accessService\"])\n        ):\n            raise ValueError(\n                \"Either of the pairs of attributes downloadUrl/mediaType or \"\n                \"accessUrl/accessService MUST be specified.\"\n            )\n        return self\n</code></pre>"},{"location":"api_reference/models/resourceconfig/#oteapi.models.resourceconfig.ResourceConfig.accessRights","title":"<code>accessRights: Optional[str] = Field(None, description='A rights statement that concerns how the distribution is accessed.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/models/resourceconfig/#oteapi.models.resourceconfig.ResourceConfig.accessService","title":"<code>accessService: Optional[str] = Field(None, description='A data service that gives access to the distribution of the dataset.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/models/resourceconfig/#oteapi.models.resourceconfig.ResourceConfig.accessUrl","title":"<code>accessUrl: Optional[HostlessAnyUrl] = Field(None, description='A URL of the resource that gives access to a distribution of the dataset. E.g. landing page, feed, SPARQL endpoint.\\n\\nUsage: `accessURL` *SHOULD* be used for the URL of a service or location that can provide access to this distribution, typically through a Web form, query or API call.\\n`downloadURL` is preferred for direct links to downloadable resources.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/models/resourceconfig/#oteapi.models.resourceconfig.ResourceConfig.downloadUrl","title":"<code>downloadUrl: Optional[HostlessAnyUrl] = Field(None, description='Definition: The URL of the downloadable file in a given format. E.g. CSV file or RDF file.\\n\\nUsage: `downloadURL` *SHOULD* be used for the URL at which this distribution is available directly, typically through a HTTPS GET request or SFTP.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/models/resourceconfig/#oteapi.models.resourceconfig.ResourceConfig.license","title":"<code>license: Optional[str] = Field(None, description='A legal document under which the distribution is made available.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/models/resourceconfig/#oteapi.models.resourceconfig.ResourceConfig.mediaType","title":"<code>mediaType: Optional[str] = Field(None, description='The media type of the distribution as defined by IANA [[IANA-MEDIA-TYPES](https://www.w3.org/TR/vocab-dcat-2/#bib-iana-media-types)].\\n\\nUsage: This property *SHOULD* be used when the media type of the distribution is defined in IANA [[IANA-MEDIA-TYPES](https://www.w3.org/TR/vocab-dcat-2/#bib-iana-media-types)].')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/models/resourceconfig/#oteapi.models.resourceconfig.ResourceConfig.publisher","title":"<code>publisher: Optional[str] = Field(None, description='The entity responsible for making the resource/item available.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/models/resourceconfig/#oteapi.models.resourceconfig.ResourceConfig.resourceType","title":"<code>resourceType: Optional[str] = Field(None, description='Type of registered resource strategy.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/models/resourceconfig/#oteapi.models.resourceconfig.ResourceConfig.ensure_unique_url_pairs","title":"<code>ensure_unique_url_pairs()</code>","text":"<p>Ensure either downloadUrl/mediaType or accessUrl/accessService are defined.</p> <p>It's fine to define them all, but at least one complete pair MUST be specified.</p> Source code in <code>oteapi/models/resourceconfig.py</code> <pre><code>@model_validator(mode=\"after\")\ndef ensure_unique_url_pairs(self) -&gt; \"ResourceConfig\":\n    \"\"\"Ensure either downloadUrl/mediaType or accessUrl/accessService are defined.\n\n    It's fine to define them all, but at least one complete pair MUST be specified.\n    \"\"\"\n    if not (\n        all(getattr(self, _) for _ in [\"downloadUrl\", \"mediaType\"])\n        or all(getattr(self, _) for _ in [\"accessUrl\", \"accessService\"])\n    ):\n        raise ValueError(\n            \"Either of the pairs of attributes downloadUrl/mediaType or \"\n            \"accessUrl/accessService MUST be specified.\"\n        )\n    return self\n</code></pre>"},{"location":"api_reference/models/secretconfig/","title":"secretconfig","text":"<p>AttrDict for specifying user credentials or secrets.</p>"},{"location":"api_reference/models/secretconfig/#oteapi.models.secretconfig.TogglableSecretStr","title":"<code>TogglableSecretStr = Annotated[SecretStr, PlainSerializer(lambda value: value.get_secret_value() if settings.expose_secrets else str(value), return_type=str, when_used='json-unless-none')]</code>  <code>module-attribute</code>","text":"<p>Annotated type alias for a secret string that can be toggled to be exposed or not.</p>"},{"location":"api_reference/models/secretconfig/#oteapi.models.secretconfig.SecretConfig","title":"<code>SecretConfig</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Simple model for handling secret in other config-models.</p> Source code in <code>oteapi/models/secretconfig.py</code> <pre><code>class SecretConfig(BaseModel):\n    \"\"\"Simple model for handling secret in other config-models.\"\"\"\n\n    user: Optional[TogglableSecretStr] = Field(\n        None, description=\"User name for authentication.\"\n    )\n    password: Optional[TogglableSecretStr] = Field(\n        None, description=\"Password for authentication.\"\n    )\n    token: Optional[TogglableSecretStr] = Field(\n        None,\n        description=(\n            \"An access token for providing access and meta data to an application.\"\n        ),\n    )\n    client_id: Optional[TogglableSecretStr] = Field(\n        None, description=\"Client ID for an OAUTH2 client.\"\n    )\n    client_secret: Optional[TogglableSecretStr] = Field(\n        None, description=\"Client secret for an OAUTH2 client.\"\n    )\n</code></pre>"},{"location":"api_reference/models/secretconfig/#oteapi.models.secretconfig.SecretConfig.client_id","title":"<code>client_id: Optional[TogglableSecretStr] = Field(None, description='Client ID for an OAUTH2 client.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/models/secretconfig/#oteapi.models.secretconfig.SecretConfig.client_secret","title":"<code>client_secret: Optional[TogglableSecretStr] = Field(None, description='Client secret for an OAUTH2 client.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/models/secretconfig/#oteapi.models.secretconfig.SecretConfig.password","title":"<code>password: Optional[TogglableSecretStr] = Field(None, description='Password for authentication.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/models/secretconfig/#oteapi.models.secretconfig.SecretConfig.token","title":"<code>token: Optional[TogglableSecretStr] = Field(None, description='An access token for providing access and meta data to an application.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/models/secretconfig/#oteapi.models.secretconfig.SecretConfig.user","title":"<code>user: Optional[TogglableSecretStr] = Field(None, description='User name for authentication.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/models/transformationconfig/","title":"transformationconfig","text":"<p>Pydantic Transformation Configuration Data Model.</p> <p>A transformation status data model is provided as well. This data model represents what should be returned from the strategy's <code>status()</code> method.</p>"},{"location":"api_reference/models/transformationconfig/#oteapi.models.transformationconfig.ProcessPriority","title":"<code>ProcessPriority</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Defining process priority enumerators.</p> <p>Process priorities:</p> <ul> <li>Low</li> <li>Medium</li> <li>High</li> </ul> Source code in <code>oteapi/models/transformationconfig.py</code> <pre><code>class ProcessPriority(str, Enum):\n    \"\"\"Defining process priority enumerators.\n\n    Process priorities:\n\n    - Low\n    - Medium\n    - High\n\n    \"\"\"\n\n    LOW = \"Low\"\n    MEDIUM = \"Medium\"\n    HIGH = \"High\"\n</code></pre>"},{"location":"api_reference/models/transformationconfig/#oteapi.models.transformationconfig.ProcessPriority.HIGH","title":"<code>HIGH = 'High'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/models/transformationconfig/#oteapi.models.transformationconfig.ProcessPriority.LOW","title":"<code>LOW = 'Low'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/models/transformationconfig/#oteapi.models.transformationconfig.ProcessPriority.MEDIUM","title":"<code>MEDIUM = 'Medium'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/models/transformationconfig/#oteapi.models.transformationconfig.TransformationConfig","title":"<code>TransformationConfig</code>","text":"<p>               Bases: <code>GenericConfig</code>, <code>SecretConfig</code></p> <p>Transformation Strategy Data Configuration.</p> Source code in <code>oteapi/models/transformationconfig.py</code> <pre><code>class TransformationConfig(GenericConfig, SecretConfig):\n    \"\"\"Transformation Strategy Data Configuration.\"\"\"\n\n    transformationType: str = Field(\n        ...,\n        description=(\n            \"Type of registered transformation strategy. E.g., `celery/remote`.\"\n        ),\n    )\n    name: Optional[str] = Field(\n        None, description=\"Human-readable name of the transformation strategy.\"\n    )\n    due: Optional[datetime] = Field(\n        None,\n        description=(\n            \"Optional field to indicate a due data/time for when a transformation \"\n            \"should finish.\"\n        ),\n    )\n    priority: Optional[ProcessPriority] = Field(\n        ProcessPriority.MEDIUM,\n        description=\"Define the process priority of the transformation execution.\",\n    )\n</code></pre>"},{"location":"api_reference/models/transformationconfig/#oteapi.models.transformationconfig.TransformationConfig.due","title":"<code>due: Optional[datetime] = Field(None, description='Optional field to indicate a due data/time for when a transformation should finish.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/models/transformationconfig/#oteapi.models.transformationconfig.TransformationConfig.name","title":"<code>name: Optional[str] = Field(None, description='Human-readable name of the transformation strategy.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/models/transformationconfig/#oteapi.models.transformationconfig.TransformationConfig.priority","title":"<code>priority: Optional[ProcessPriority] = Field(ProcessPriority.MEDIUM, description='Define the process priority of the transformation execution.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/models/transformationconfig/#oteapi.models.transformationconfig.TransformationConfig.transformationType","title":"<code>transformationType: str = Field(..., description='Type of registered transformation strategy. E.g., `celery/remote`.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/models/transformationconfig/#oteapi.models.transformationconfig.TransformationStatus","title":"<code>TransformationStatus</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Return from transformation status.</p> Source code in <code>oteapi/models/transformationconfig.py</code> <pre><code>class TransformationStatus(BaseModel):\n    \"\"\"Return from transformation status.\"\"\"\n\n    id: str = Field(..., description=\"ID for the given transformation process.\")\n    status: Optional[str] = Field(\n        None, description=\"Status for the transformation process.\"\n    )\n    messages: Optional[List[str]] = Field(\n        None, description=\"Messages related to the transformation process.\"\n    )\n    created: Optional[datetime] = Field(\n        None,\n        description=\"Time of creation for the transformation process. Given in UTC.\",\n    )\n    startTime: Optional[datetime] = Field(\n        None, description=\"Time when the transformation process started. Given in UTC.\"\n    )\n    finishTime: Optional[datetime] = Field(\n        None, description=\"Time when the tranformation process finished. Given in UTC.\"\n    )\n</code></pre>"},{"location":"api_reference/models/transformationconfig/#oteapi.models.transformationconfig.TransformationStatus.created","title":"<code>created: Optional[datetime] = Field(None, description='Time of creation for the transformation process. Given in UTC.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/models/transformationconfig/#oteapi.models.transformationconfig.TransformationStatus.finishTime","title":"<code>finishTime: Optional[datetime] = Field(None, description='Time when the tranformation process finished. Given in UTC.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/models/transformationconfig/#oteapi.models.transformationconfig.TransformationStatus.id","title":"<code>id: str = Field(..., description='ID for the given transformation process.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/models/transformationconfig/#oteapi.models.transformationconfig.TransformationStatus.messages","title":"<code>messages: Optional[List[str]] = Field(None, description='Messages related to the transformation process.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/models/transformationconfig/#oteapi.models.transformationconfig.TransformationStatus.startTime","title":"<code>startTime: Optional[datetime] = Field(None, description='Time when the transformation process started. Given in UTC.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/models/transformationconfig/#oteapi.models.transformationconfig.TransformationStatus.status","title":"<code>status: Optional[str] = Field(None, description='Status for the transformation process.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/models/triplestoreconfig/","title":"triplestoreconfig","text":"<p>Pydantic TripleStore Configuration Data Model.</p>"},{"location":"api_reference/models/triplestoreconfig/#oteapi.models.triplestoreconfig.ExcludeTogglableSecretStr","title":"<code>ExcludeTogglableSecretStr = Annotated[Optional[TogglableSecretStr], Field(exclude=True)]</code>  <code>module-attribute</code>","text":"<p>Annotated type alias for excluding a togglable secret from serialization.</p>"},{"location":"api_reference/models/triplestoreconfig/#oteapi.models.triplestoreconfig.TripleStoreConfig","title":"<code>TripleStoreConfig</code>","text":"<p>               Bases: <code>GenericConfig</code>, <code>SecretConfig</code></p> <p>TripleStore Configuration.</p> <p>This is a configuration for the <code>TripleStore</code>.</p> <p>This class should not be used directly as a configuration object for a strategy object, but only as a configuration field inside a configuration object.</p> Source code in <code>oteapi/models/triplestoreconfig.py</code> <pre><code>class TripleStoreConfig(GenericConfig, SecretConfig):\n    \"\"\"TripleStore Configuration.\n\n    This is a configuration for the\n    [`TripleStore`][oteapi.triplestore.triplestore.TripleStore].\n\n    This class should not be used directly as a configuration object\n    for a strategy object, but only as a configuration field inside\n    a configuration object.\n    \"\"\"\n\n    repositoryName: str = Field(\n        ..., description=\"The repository name, where the mappings are stored.\"\n    )\n    agraphHost: str = Field(..., description=\"AllegroGraph host name.\")\n    agraphPort: int = Field(..., description=\"AllegroGraph port number.\")\n\n    # Exclude these inherited fields from serialization\n    token: Annotated[ExcludeTogglableSecretStr, SecretConfig.model_fields[\"token\"]] = (\n        SecretConfig.model_fields[\"token\"].default\n    )\n    client_id: Annotated[\n        ExcludeTogglableSecretStr, SecretConfig.model_fields[\"client_id\"]\n    ] = SecretConfig.model_fields[\"client_id\"].default\n    client_secret: Annotated[\n        ExcludeTogglableSecretStr, SecretConfig.model_fields[\"client_secret\"]\n    ] = SecretConfig.model_fields[\"client_secret\"].default\n\n    @model_validator(mode=\"after\")\n    def ensure_user_pass(self) -&gt; \"TripleStoreConfig\":\n        \"\"\"Ensure that user/password are set, since they are optional in the\n        SecretConfig.\"\"\"\n        if not all(getattr(self, _) for _ in [\"user\", \"password\"]):\n            raise ValueError(\"User and password must be defined.\")\n        return self\n</code></pre>"},{"location":"api_reference/models/triplestoreconfig/#oteapi.models.triplestoreconfig.TripleStoreConfig.agraphHost","title":"<code>agraphHost: str = Field(..., description='AllegroGraph host name.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/models/triplestoreconfig/#oteapi.models.triplestoreconfig.TripleStoreConfig.agraphPort","title":"<code>agraphPort: int = Field(..., description='AllegroGraph port number.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/models/triplestoreconfig/#oteapi.models.triplestoreconfig.TripleStoreConfig.client_id","title":"<code>client_id: Annotated[ExcludeTogglableSecretStr, SecretConfig.model_fields[client_id]] = SecretConfig.model_fields['client_id'].default</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/models/triplestoreconfig/#oteapi.models.triplestoreconfig.TripleStoreConfig.client_secret","title":"<code>client_secret: Annotated[ExcludeTogglableSecretStr, SecretConfig.model_fields[client_secret]] = SecretConfig.model_fields['client_secret'].default</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/models/triplestoreconfig/#oteapi.models.triplestoreconfig.TripleStoreConfig.repositoryName","title":"<code>repositoryName: str = Field(..., description='The repository name, where the mappings are stored.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/models/triplestoreconfig/#oteapi.models.triplestoreconfig.TripleStoreConfig.token","title":"<code>token: Annotated[ExcludeTogglableSecretStr, SecretConfig.model_fields[token]] = SecretConfig.model_fields['token'].default</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/models/triplestoreconfig/#oteapi.models.triplestoreconfig.TripleStoreConfig.ensure_user_pass","title":"<code>ensure_user_pass()</code>","text":"<p>Ensure that user/password are set, since they are optional in the SecretConfig.</p> Source code in <code>oteapi/models/triplestoreconfig.py</code> <pre><code>@model_validator(mode=\"after\")\ndef ensure_user_pass(self) -&gt; \"TripleStoreConfig\":\n    \"\"\"Ensure that user/password are set, since they are optional in the\n    SecretConfig.\"\"\"\n    if not all(getattr(self, _) for _ in [\"user\", \"password\"]):\n        raise ValueError(\"User and password must be defined.\")\n    return self\n</code></pre>"},{"location":"api_reference/plugins/entry_points/","title":"entry_points","text":"<p>Load plugins through entry points.</p> <p>This module deals with handling all plugged in strategies through the entry points API and importlib metadata API.</p> <p>Special functionality is put in place to handle the OTE-API-specific entry points.</p> <p>Since the entry points are information complete in and of themselves, there is no need to import actual strategy classes until they are truly needed. This therefore implements lazy loading of all plugin strategies.</p>"},{"location":"api_reference/plugins/entry_points/#oteapi.plugins.entry_points.EntryPointNotFound","title":"<code>EntryPointNotFound</code>","text":"<p>               Bases: <code>Exception</code></p> <p>A given strategy implementation (class) cannot be found from the given entry point value.</p> Source code in <code>oteapi/plugins/entry_points.py</code> <pre><code>class EntryPointNotFound(Exception):\n    \"\"\"A given strategy implementation (class) cannot be found from the given entry\n    point value.\"\"\"\n</code></pre>"},{"location":"api_reference/plugins/entry_points/#oteapi.plugins.entry_points.EntryPointStrategy","title":"<code>EntryPointStrategy</code>","text":"<p>A strategy realized from an entry point.</p> <p>An entry point strategy is made unique by its \"strategy\", i.e., its (strategy type, strategy name)-tuple, e.g., <code>(\"download\", \"https\")</code>. This tuple can be retrieved from the <code>strategy</code> property, where the strategy type is represented by the <code>StrategyType</code> enumeration.</p> Note <p>It may be that in the future an entry points strategy is made unique by its \"full name\" instead, i.e., the entry point group + the entry points name, e.g., <code>oteapi.download:oteapi.https</code>. This value can be retrieved from the <code>full_name</code> property.</p> <p>This is a condition for uniqueness that is considered to be a superset of the current condition for uniqueness. It adds an extra package-specific uniqueness trait, allowing for different packages to implement the same strategies (which is currently not allowed according to the condition of uniqueness explained above).</p> <p>Currently there is no consensus on the API for handling this added strategy ambiguity.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the entry point name is not properly defined.</p> Source code in <code>oteapi/plugins/entry_points.py</code> <pre><code>class EntryPointStrategy:\n    \"\"\"A strategy realized from an entry point.\n\n    An entry point strategy is made unique by its \"strategy\", i.e., its\n    (strategy type, strategy name)-tuple, e.g., `(\"download\", \"https\")`.\n    This tuple can be retrieved from the\n    [`strategy`][oteapi.plugins.entry_points.EntryPointStrategy.strategy] property,\n    where the strategy type is represented by the\n    [`StrategyType`][oteapi.plugins.entry_points.StrategyType] enumeration.\n\n    Note:\n        It may be that in the future an entry points strategy is made unique by\n        its \"full name\" instead, i.e., the entry point group + the entry points name,\n        e.g., `oteapi.download:oteapi.https`.\n        This value can be retrieved from the\n        [`full_name`][oteapi.plugins.entry_points.EntryPointStrategy.full_name]\n        property.\n\n        This is a condition for uniqueness that is considered to be a superset of the\n        current condition for uniqueness.\n        It adds an extra package-specific uniqueness trait, allowing for different\n        packages to implement the same strategies (which is currently not allowed\n        according to the condition of uniqueness explained above).\n\n        Currently there is no consensus on the API for handling this added strategy\n        ambiguity.\n\n    Raises:\n        ValueError: If the entry point name is not properly defined.\n\n    \"\"\"\n\n    ENTRY_POINT_NAME_REGEX = re.compile(\n        r\"^(?P&lt;package_name&gt;[A-Za-z0-9]|[A-Za-z0-9][A-Za-z0-9._-]*[A-Za-z0-9])\\.(?P&lt;strategy_name&gt;.+)$\"\n    )\n    \"\"\"Regex for entry point names.\n\n    The package_name group is a valid non-normalized package name regex adapted from\n    PEP 508.\n    For more information, see: https://peps.python.org/pep-0508/#names.\n    \"\"\"\n\n    ENTRY_POINT_NAME_SEPARATOR = \":\"\n\n    def __init__(self, entry_point: \"EntryPoint\") -&gt; None:\n        self._entry_point = entry_point\n\n        match = self.ENTRY_POINT_NAME_REGEX.match(self._entry_point.name)\n        if match is None:\n            raise ValueError(\n                \"Could not determine package name and/or strategy name for entry \"\n                f\"point: {self.full_name}\"\n            )\n\n        self._match = match\n        self._type = StrategyType(self._entry_point.group[len(\"oteapi.\") :])\n        self._implementation: \"Optional[Type[IStrategy]]\" = None\n\n    @property\n    def type(self) -&gt; StrategyType:\n        \"\"\"The strategy type.\n\n        One part of the (strategy type, strategy name)-tuple.\n        \"\"\"\n        return self._type\n\n    @property\n    def name(self) -&gt; str:\n        \"\"\"The strategy name.\n\n        One part of the (strategy type, strategy name)-tuple.\n        \"\"\"\n        return self._match.group(\"strategy_name\")\n\n    @property\n    def strategy(self) -&gt; \"Tuple[StrategyType, str]\":\n        \"\"\"The unique index identifier for the strategy.\"\"\"\n        return self.type, self.name\n\n    @property\n    def package(self) -&gt; str:\n        \"\"\"The importable base package name for the strategy plugin.\"\"\"\n        return self._match.group(\"package_name\")\n\n    @property\n    def module(self) -&gt; str:\n        \"\"\"The fully resolved importable module path.\"\"\"\n        return self._entry_point.module  # type: ignore[attr-defined]\n\n    @property\n    def full_name(self) -&gt; str:\n        \"\"\"The full entry point name.\"\"\"\n        return (\n            f\"{self._entry_point.group}{self.ENTRY_POINT_NAME_SEPARATOR}\"\n            f\"{self._entry_point.name}\"\n        )\n\n    def __str__(self) -&gt; str:\n        return self.full_name\n\n    def __repr__(self) -&gt; str:\n        return f\"{self.__class__.__name__}(entry_point={self._entry_point!r})\"\n\n    @property\n    def implementation_name(self) -&gt; str:\n        \"\"\"The EntryPoint attr, which should be the strategy implementation class\n        name.\"\"\"\n        return self._entry_point.attr  # type: ignore[attr-defined]\n\n    @property\n    def implementation(self) -&gt; \"Type[IStrategy]\":\n        \"\"\"The actual strategy implementation.\"\"\"\n        if self._implementation is None:\n            self._implementation = self._load_implementation()\n        return self._implementation\n\n    def _load_implementation(self) -&gt; \"Type[IStrategy]\":\n        \"\"\"Load the strategy implementation.\n\n        Because the actual importing of the module does not happen until this method is\n        called, we are lazily loading in the strategy implementation.\n\n        There is no need to check through the `globals()` built-in for whether the\n        module and class have already been imported, because this caching layer is\n        already implemented in the `importlib` API.\n\n        Raises:\n            EntryPointNotFound: If the strategy implementation (class) the entry point\n                is pointing to cannot be found in the module or if the module cannot be\n                imported.\n\n        Returns:\n            The imported strategy implementation (class).\n\n        \"\"\"\n        try:\n            module = importlib.import_module(self.module)\n        except ImportError as exc:\n            raise EntryPointNotFound(\n                f\"{self.module} cannot be imported. Did you install the \"\n                f\"{self.package!r} package?\"\n            ) from exc\n\n        if hasattr(module, self.implementation_name):\n            return getattr(module, self.implementation_name)\n        raise EntryPointNotFound(\n            f\"{self.implementation_name} cannot be found in {self.module}\"\n        )\n\n    def __eq__(self, other: \"Any\") -&gt; bool:\n        if isinstance(other, self.__class__):\n            return hash(self) == hash(other)\n        return False\n\n    def __hash__(self) -&gt; int:\n        return hash(self.strategy)\n\n    def __lt__(self, other: \"Any\") -&gt; bool:\n        \"\"\"Whether or not `self` is less than (`&lt;`) `other`.\n\n        This is implemented to allow sorting (using `sorted()`).\n\n        The inequality is determined on the basis of the following properties:\n\n        1. [`type`][oteapi.plugins.entry_points.EntryPointStrategy.type]\n        2. [`package`][oteapi.plugins.entry_points.EntryPointStrategy.package]\n        3. [`name`][oteapi.plugins.entry_points.EntryPointStrategy.name]\n\n        Going from highest priority to lowest and in alphabetical ascending order.\n        \"\"\"\n        if isinstance(other, self.__class__):\n            if self.type == other.type:\n                if self.package == other.package:\n                    if self.name == other.name:\n                        # Considered equal, i.e., one can by definition not be unequal\n                        # with the other.\n                        return False\n                    return sorted([self.name, other.name])[0] == self.name\n                return sorted([self.package, other.package])[0] == self.package\n            return sorted([self.type.value, other.type.value])[0] == self.type.value\n        raise NotImplementedError(\n            f\"Less than comparison is not implemented for {type(other)} type objects.\"\n        )\n</code></pre>"},{"location":"api_reference/plugins/entry_points/#oteapi.plugins.entry_points.EntryPointStrategy.ENTRY_POINT_NAME_REGEX","title":"<code>ENTRY_POINT_NAME_REGEX = re.compile('^(?P&lt;package_name&gt;[A-Za-z0-9]|[A-Za-z0-9][A-Za-z0-9._-]*[A-Za-z0-9])\\\\.(?P&lt;strategy_name&gt;.+)$')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Regex for entry point names.</p> <p>The package_name group is a valid non-normalized package name regex adapted from PEP 508. For more information, see: https://peps.python.org/pep-0508/#names.</p>"},{"location":"api_reference/plugins/entry_points/#oteapi.plugins.entry_points.EntryPointStrategy.full_name","title":"<code>full_name: str</code>  <code>property</code>","text":"<p>The full entry point name.</p>"},{"location":"api_reference/plugins/entry_points/#oteapi.plugins.entry_points.EntryPointStrategy.implementation","title":"<code>implementation: Type[IStrategy]</code>  <code>property</code>","text":"<p>The actual strategy implementation.</p>"},{"location":"api_reference/plugins/entry_points/#oteapi.plugins.entry_points.EntryPointStrategy.implementation_name","title":"<code>implementation_name: str</code>  <code>property</code>","text":"<p>The EntryPoint attr, which should be the strategy implementation class name.</p>"},{"location":"api_reference/plugins/entry_points/#oteapi.plugins.entry_points.EntryPointStrategy.module","title":"<code>module: str</code>  <code>property</code>","text":"<p>The fully resolved importable module path.</p>"},{"location":"api_reference/plugins/entry_points/#oteapi.plugins.entry_points.EntryPointStrategy.name","title":"<code>name: str</code>  <code>property</code>","text":"<p>The strategy name.</p> <p>One part of the (strategy type, strategy name)-tuple.</p>"},{"location":"api_reference/plugins/entry_points/#oteapi.plugins.entry_points.EntryPointStrategy.package","title":"<code>package: str</code>  <code>property</code>","text":"<p>The importable base package name for the strategy plugin.</p>"},{"location":"api_reference/plugins/entry_points/#oteapi.plugins.entry_points.EntryPointStrategy.strategy","title":"<code>strategy: Tuple[StrategyType, str]</code>  <code>property</code>","text":"<p>The unique index identifier for the strategy.</p>"},{"location":"api_reference/plugins/entry_points/#oteapi.plugins.entry_points.EntryPointStrategy.type","title":"<code>type: StrategyType</code>  <code>property</code>","text":"<p>The strategy type.</p> <p>One part of the (strategy type, strategy name)-tuple.</p>"},{"location":"api_reference/plugins/entry_points/#oteapi.plugins.entry_points.EntryPointStrategyCollection","title":"<code>EntryPointStrategyCollection</code>","text":"<p>               Bases: <code>Collection</code></p> <p>A collection of <code>EntryPointStrategy</code>s.</p> Source code in <code>oteapi/plugins/entry_points.py</code> <pre><code>class EntryPointStrategyCollection(abc.Collection):\n    \"\"\"A collection of\n    [`EntryPointStrategy`][oteapi.plugins.entry_points.EntryPointStrategy]s.\"\"\"\n\n    def __init__(self, *entry_points: \"EntryPointStrategy\") -&gt; None:\n        self._entry_points: \"Set[EntryPointStrategy]\" = (\n            set(entry_points) if entry_points else set()\n        )\n\n    def add(self, *entry_points: EntryPointStrategy) -&gt; None:\n        \"\"\"Add entry points to the collection.\n\n        Parameters:\n            *entry_points (Iterable[EntryPointStrategy]): Entry points to add to the\n                collection.\n\n        \"\"\"\n        self._entry_points |= set(entry_points)\n\n    def remove(self, *entry_points: EntryPointStrategy) -&gt; None:\n        \"\"\"Remove entry points from the collection.\n\n        Parameters:\n            *entry_points (Iterable[EntryPointStrategy]): Entry points to remove from\n                the collection.\n\n        \"\"\"\n        self._entry_points -= set(entry_points)\n\n    def exclusive_add(self, *entry_points: EntryPointStrategy) -&gt; None:\n        \"\"\"Exclusively add entry points to the collection.\n\n        Parameters:\n            *entry_points (Iterable[EntryPointStrategy]): Entry points to add to the\n                collection.\n\n        Raises:\n            KeyError: If an entry point to be added already exists in the collection.\n\n        \"\"\"\n        for entry_point in entry_points:\n            if entry_point in self:\n                raise KeyError(\n                    f\"{entry_point.strategy} already exists in {self}. \"\n                    f\"(Tried adding {entry_point}.)\"\n                )\n            self.add(entry_point)\n\n    def __len__(self) -&gt; int:\n        return len(self._entry_points)\n\n    def __contains__(self, item: \"Any\") -&gt; bool:\n        \"\"\"Whether or not `item` is contained in the collection.\n\n        One can test with an `EntryPointStrategy`, a string of an entry point\n        strategy's full name, or a tuple of an entry point's strategy type and name.\n\n        Parameters:\n            item: Item to test whether it is contained in the collection.\n\n        Returns:\n            Whether or not `item` is contained in the collection.\n            If the `item` is an unrecognized type, `False` will be returned.\n\n        \"\"\"\n        if isinstance(item, EntryPointStrategy):\n            return item in self._entry_points\n        if isinstance(item, str):\n            for entry_point in self._entry_points:\n                if item == entry_point.full_name:\n                    return True\n        if isinstance(item, tuple):\n            if len(item) != 2 or (\n                not isinstance(item[0], (StrategyType, str))\n                or not isinstance(item[1], str)\n            ):\n                # Only tuples of type (Union[StrategyType, str], str) are allowed.\n                return False\n            try:\n                item_ = (StrategyType.init(item[0]), item[1])\n            except ValueError:\n                # We only want to return True or False\n                return False\n            for entry_point in self._entry_points:\n                if item_ == entry_point.strategy:\n                    return True\n        # For any other type:\n        return False\n\n    def __iter__(self) -&gt; \"Iterator[EntryPointStrategy]\":\n        yield from self._entry_points\n\n    def __getitem__(self, key: \"Any\") -&gt; EntryPointStrategy:\n        return self.get_entry_point(key)\n\n    def get_entry_point(\n        self,\n        key: \"Union[EntryPointStrategy, str, Tuple[Union[StrategyType, str], str]]\",\n    ) -&gt; EntryPointStrategy:\n        \"\"\"Retrieve an entry point from the collection.\n\n        Parameters:\n            key: The key to check for in the collection.\n\n        Raises:\n            KeyError: If an entry point cannot be found in the collection.\n            TypeError: If the `key` is not of an expected type. See the `key` parameter\n                above for the expected types.\n\n        Returns:\n            An entry point in the collection representing the key.\n\n        \"\"\"\n        if isinstance(key, (EntryPointStrategy, str, tuple)):\n            if key not in self:\n                raise KeyError(f\"{key} not found in {self}\")\n            return self._get_entry_point(key)\n        raise TypeError(\n            \"key should either be of type EntryPointStrategy, a string of the full \"\n            \"name or a strategy tuple.\"\n        )\n\n    def _get_entry_point(\n        self,\n        key: \"Union[EntryPointStrategy, str, Tuple[Union[StrategyType, str], str]]\",\n    ) -&gt; EntryPointStrategy:\n        \"\"\"Helper method for retrieving an entry point from the collection.\n\n        Important:\n            It is expected that the entry point representing the key exists in the\n            collection. For example through a `key in self` test.\n\n        Parameters:\n            key: The key to check for in the collection.\n\n        Raises:\n            RuntimeError: If an entry point cannot be found in the collection, since\n                this is a requirement.\n\n        Returns:\n            An entry point in the collection representing the key.\n\n        \"\"\"\n        if isinstance(key, EntryPointStrategy):\n            return key\n        if isinstance(key, str):\n            for entry_point in self._entry_points:\n                if key == entry_point.full_name:\n                    return entry_point\n        if isinstance(key, tuple):\n            key_ = (StrategyType(key[0]), key[1])\n            for entry_point in self._entry_points:\n                if key_ == entry_point.strategy:\n                    return entry_point\n        raise RuntimeError(\n            f\"{key} not found in {self}, which is a requirement for the \"\n            \"_get_entry_point method.\"\n        )\n\n    def __eq__(self, other: \"Any\") -&gt; bool:\n        if isinstance(other, self.__class__):\n            return hash(self) == hash(other)\n        return False\n\n    def __hash__(self) -&gt; int:\n        return hash(tuple(_ for _ in sorted(self._entry_points)))\n\n    def __str__(self) -&gt; str:\n        number_of_strategies: \"Dict[str, int]\" = {}\n        for entry_point in self._entry_points:\n            if entry_point.type.value in number_of_strategies:\n                number_of_strategies[entry_point.type.value] += 1\n            else:\n                number_of_strategies[entry_point.type.value] = 1\n        sorted_list = sorted(\n            f\"{key} ({value})\" for key, value in number_of_strategies.items()\n        )\n        return f\"&lt;{self.__class__.__name__}: \" f\"Strategies={', '.join(sorted_list)}&gt;\"\n\n    def __repr__(self) -&gt; str:\n        return f\"{self.__class__.__name__}(*{tuple(sorted(self._entry_points))!r})\"\n</code></pre>"},{"location":"api_reference/plugins/entry_points/#oteapi.plugins.entry_points.EntryPointStrategyCollection.add","title":"<code>add(*entry_points)</code>","text":"<p>Add entry points to the collection.</p> <p>Parameters:</p> Name Type Description Default <code>*entry_points</code> <code>Iterable[EntryPointStrategy]</code> <p>Entry points to add to the collection.</p> <code>()</code> Source code in <code>oteapi/plugins/entry_points.py</code> <pre><code>def add(self, *entry_points: EntryPointStrategy) -&gt; None:\n    \"\"\"Add entry points to the collection.\n\n    Parameters:\n        *entry_points (Iterable[EntryPointStrategy]): Entry points to add to the\n            collection.\n\n    \"\"\"\n    self._entry_points |= set(entry_points)\n</code></pre>"},{"location":"api_reference/plugins/entry_points/#oteapi.plugins.entry_points.EntryPointStrategyCollection.exclusive_add","title":"<code>exclusive_add(*entry_points)</code>","text":"<p>Exclusively add entry points to the collection.</p> <p>Parameters:</p> Name Type Description Default <code>*entry_points</code> <code>Iterable[EntryPointStrategy]</code> <p>Entry points to add to the collection.</p> <code>()</code> <p>Raises:</p> Type Description <code>KeyError</code> <p>If an entry point to be added already exists in the collection.</p> Source code in <code>oteapi/plugins/entry_points.py</code> <pre><code>def exclusive_add(self, *entry_points: EntryPointStrategy) -&gt; None:\n    \"\"\"Exclusively add entry points to the collection.\n\n    Parameters:\n        *entry_points (Iterable[EntryPointStrategy]): Entry points to add to the\n            collection.\n\n    Raises:\n        KeyError: If an entry point to be added already exists in the collection.\n\n    \"\"\"\n    for entry_point in entry_points:\n        if entry_point in self:\n            raise KeyError(\n                f\"{entry_point.strategy} already exists in {self}. \"\n                f\"(Tried adding {entry_point}.)\"\n            )\n        self.add(entry_point)\n</code></pre>"},{"location":"api_reference/plugins/entry_points/#oteapi.plugins.entry_points.EntryPointStrategyCollection.get_entry_point","title":"<code>get_entry_point(key)</code>","text":"<p>Retrieve an entry point from the collection.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>Union[EntryPointStrategy, str, Tuple[Union[StrategyType, str], str]]</code> <p>The key to check for in the collection.</p> required <p>Raises:</p> Type Description <code>KeyError</code> <p>If an entry point cannot be found in the collection.</p> <code>TypeError</code> <p>If the <code>key</code> is not of an expected type. See the <code>key</code> parameter above for the expected types.</p> <p>Returns:</p> Type Description <code>EntryPointStrategy</code> <p>An entry point in the collection representing the key.</p> Source code in <code>oteapi/plugins/entry_points.py</code> <pre><code>def get_entry_point(\n    self,\n    key: \"Union[EntryPointStrategy, str, Tuple[Union[StrategyType, str], str]]\",\n) -&gt; EntryPointStrategy:\n    \"\"\"Retrieve an entry point from the collection.\n\n    Parameters:\n        key: The key to check for in the collection.\n\n    Raises:\n        KeyError: If an entry point cannot be found in the collection.\n        TypeError: If the `key` is not of an expected type. See the `key` parameter\n            above for the expected types.\n\n    Returns:\n        An entry point in the collection representing the key.\n\n    \"\"\"\n    if isinstance(key, (EntryPointStrategy, str, tuple)):\n        if key not in self:\n            raise KeyError(f\"{key} not found in {self}\")\n        return self._get_entry_point(key)\n    raise TypeError(\n        \"key should either be of type EntryPointStrategy, a string of the full \"\n        \"name or a strategy tuple.\"\n    )\n</code></pre>"},{"location":"api_reference/plugins/entry_points/#oteapi.plugins.entry_points.EntryPointStrategyCollection.remove","title":"<code>remove(*entry_points)</code>","text":"<p>Remove entry points from the collection.</p> <p>Parameters:</p> Name Type Description Default <code>*entry_points</code> <code>Iterable[EntryPointStrategy]</code> <p>Entry points to remove from the collection.</p> <code>()</code> Source code in <code>oteapi/plugins/entry_points.py</code> <pre><code>def remove(self, *entry_points: EntryPointStrategy) -&gt; None:\n    \"\"\"Remove entry points from the collection.\n\n    Parameters:\n        *entry_points (Iterable[EntryPointStrategy]): Entry points to remove from\n            the collection.\n\n    \"\"\"\n    self._entry_points -= set(entry_points)\n</code></pre>"},{"location":"api_reference/plugins/entry_points/#oteapi.plugins.entry_points.StrategyType","title":"<code>StrategyType</code>","text":"<p>               Bases: <code>Enum</code></p> <p>An enumeration of available strategy types.</p> <p>Available strategy types:</p> <ul> <li>download</li> <li>filter</li> <li>function</li> <li>mapping</li> <li>parse</li> <li>resource</li> <li>transformation</li> </ul> Source code in <code>oteapi/plugins/entry_points.py</code> <pre><code>class StrategyType(Enum):\n    \"\"\"An enumeration of available strategy types.\n\n    Available strategy types:\n\n    - download\n    - filter\n    - function\n    - mapping\n    - parse\n    - resource\n    - transformation\n\n    \"\"\"\n\n    DOWNLOAD = \"download\"\n    FILTER = \"filter\"\n    FUNCTION = \"function\"\n    MAPPING = \"mapping\"\n    PARSE = \"parse\"\n    RESOURCE = \"resource\"\n    TRANSFORMATION = \"transformation\"\n\n    def map_to_field(self) -&gt; str:\n        \"\"\"Map enumeration value to the strategy type's field.\"\"\"\n        return {\n            \"download\": \"scheme\",\n            \"filter\": \"filterType\",\n            \"function\": \"functionType\",\n            \"mapping\": \"mappingType\",\n            \"parse\": \"parserType\",\n            \"resource\": \"resourceType\",\n            \"transformation\": \"transformationType\",\n        }[self.value]\n\n    @classmethod\n    def map_from_field(cls, strategy_type_field: str) -&gt; \"StrategyType\":\n        \"\"\"Map the strategy type's field to enumeration.\n\n        Parameters:\n            strategy_type_field: The strategy type's field. E.g., `scheme` for\n                `download`.\n\n        Raises:\n            KeyError: If the `strategy_type_field` is not valid.\n\n        Returns:\n            An enumeration instance representing the strategy type's field.\n\n        \"\"\"\n        return {\n            \"scheme\": cls.DOWNLOAD,\n            \"filterType\": cls.FILTER,\n            \"functionType\": cls.FUNCTION,\n            \"mappingType\": cls.MAPPING,\n            \"parserType\": cls.PARSE,\n            \"resourceType\": cls.RESOURCE,\n            \"transformationType\": cls.TRANSFORMATION,\n        }[strategy_type_field]\n\n    @classmethod\n    def init(cls, value: \"Union[str, StrategyType]\") -&gt; \"StrategyType\":\n        \"\"\"Initialize a StrategyType with more than just the enumeration value.\n\n        This method allows one to also initialize a StrategyType with an actual\n        strategy type string, e.g., `scheme`, `mediaType`, etc.\n\n        Raises:\n            ValueError: As normal if the enumeration value is not valid.\n\n        \"\"\"\n        if isinstance(value, str):\n            try:\n                return cls.map_from_field(value)\n            except KeyError:\n                pass\n        return cls(value)\n\n    @classmethod\n    def all_values(cls) -&gt; \"Tuple[str, ...]\":\n        \"\"\"Return all values.\"\"\"\n        return tuple(strategy_type.value for strategy_type in cls)\n\n    def __str__(self) -&gt; str:\n        return str(self.value)\n\n    def __repr__(self) -&gt; str:\n        return repr(str(self))\n\n    @property\n    def config_cls(self) -&gt; \"Type[StrategyConfig]\":\n        \"\"\"Return the strategy-specific `*Config` class.\"\"\"\n        return {  # type: ignore[return-value]\n            \"download\": ResourceConfig,\n            \"filter\": FilterConfig,\n            \"function\": FunctionConfig,\n            \"mapping\": MappingConfig,\n            \"parse\": ParserConfig,\n            \"resource\": ResourceConfig,\n            \"transformation\": TransformationConfig,\n        }[self.value]\n</code></pre>"},{"location":"api_reference/plugins/entry_points/#oteapi.plugins.entry_points.StrategyType.config_cls","title":"<code>config_cls: Type[StrategyConfig]</code>  <code>property</code>","text":"<p>Return the strategy-specific <code>*Config</code> class.</p>"},{"location":"api_reference/plugins/entry_points/#oteapi.plugins.entry_points.StrategyType.all_values","title":"<code>all_values()</code>  <code>classmethod</code>","text":"<p>Return all values.</p> Source code in <code>oteapi/plugins/entry_points.py</code> <pre><code>@classmethod\ndef all_values(cls) -&gt; \"Tuple[str, ...]\":\n    \"\"\"Return all values.\"\"\"\n    return tuple(strategy_type.value for strategy_type in cls)\n</code></pre>"},{"location":"api_reference/plugins/entry_points/#oteapi.plugins.entry_points.StrategyType.init","title":"<code>init(value)</code>  <code>classmethod</code>","text":"<p>Initialize a StrategyType with more than just the enumeration value.</p> <p>This method allows one to also initialize a StrategyType with an actual strategy type string, e.g., <code>scheme</code>, <code>mediaType</code>, etc.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>As normal if the enumeration value is not valid.</p> Source code in <code>oteapi/plugins/entry_points.py</code> <pre><code>@classmethod\ndef init(cls, value: \"Union[str, StrategyType]\") -&gt; \"StrategyType\":\n    \"\"\"Initialize a StrategyType with more than just the enumeration value.\n\n    This method allows one to also initialize a StrategyType with an actual\n    strategy type string, e.g., `scheme`, `mediaType`, etc.\n\n    Raises:\n        ValueError: As normal if the enumeration value is not valid.\n\n    \"\"\"\n    if isinstance(value, str):\n        try:\n            return cls.map_from_field(value)\n        except KeyError:\n            pass\n    return cls(value)\n</code></pre>"},{"location":"api_reference/plugins/entry_points/#oteapi.plugins.entry_points.StrategyType.map_from_field","title":"<code>map_from_field(strategy_type_field)</code>  <code>classmethod</code>","text":"<p>Map the strategy type's field to enumeration.</p> <p>Parameters:</p> Name Type Description Default <code>strategy_type_field</code> <code>str</code> <p>The strategy type's field. E.g., <code>scheme</code> for <code>download</code>.</p> required <p>Raises:</p> Type Description <code>KeyError</code> <p>If the <code>strategy_type_field</code> is not valid.</p> <p>Returns:</p> Type Description <code>StrategyType</code> <p>An enumeration instance representing the strategy type's field.</p> Source code in <code>oteapi/plugins/entry_points.py</code> <pre><code>@classmethod\ndef map_from_field(cls, strategy_type_field: str) -&gt; \"StrategyType\":\n    \"\"\"Map the strategy type's field to enumeration.\n\n    Parameters:\n        strategy_type_field: The strategy type's field. E.g., `scheme` for\n            `download`.\n\n    Raises:\n        KeyError: If the `strategy_type_field` is not valid.\n\n    Returns:\n        An enumeration instance representing the strategy type's field.\n\n    \"\"\"\n    return {\n        \"scheme\": cls.DOWNLOAD,\n        \"filterType\": cls.FILTER,\n        \"functionType\": cls.FUNCTION,\n        \"mappingType\": cls.MAPPING,\n        \"parserType\": cls.PARSE,\n        \"resourceType\": cls.RESOURCE,\n        \"transformationType\": cls.TRANSFORMATION,\n    }[strategy_type_field]\n</code></pre>"},{"location":"api_reference/plugins/entry_points/#oteapi.plugins.entry_points.StrategyType.map_to_field","title":"<code>map_to_field()</code>","text":"<p>Map enumeration value to the strategy type's field.</p> Source code in <code>oteapi/plugins/entry_points.py</code> <pre><code>def map_to_field(self) -&gt; str:\n    \"\"\"Map enumeration value to the strategy type's field.\"\"\"\n    return {\n        \"download\": \"scheme\",\n        \"filter\": \"filterType\",\n        \"function\": \"functionType\",\n        \"mapping\": \"mappingType\",\n        \"parse\": \"parserType\",\n        \"resource\": \"resourceType\",\n        \"transformation\": \"transformationType\",\n    }[self.value]\n</code></pre>"},{"location":"api_reference/plugins/entry_points/#oteapi.plugins.entry_points.get_strategy_entry_points","title":"<code>get_strategy_entry_points(strategy_type, enforce_uniqueness=True)</code>","text":"<p>Retrieve all entry points from a specific strategy type.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the strategy type is not supported.</p> <code>KeyError</code> <p>If <code>enforce_uniqueness</code> is <code>True</code> and an entry point strategy is duplicated.</p> <p>Parameters:</p> Name Type Description Default <code>strategy_type</code> <code>Union[StrategyType, str]</code> <p>A strategy type for which the entry points will be retrieved.</p> required <code>enforce_uniqueness</code> <code>bool</code> <p>Whether or not duplicate entry point strategies are allowed. Defaults to <code>True</code>, meaning duplicates are not allowed.</p> <code>True</code> <p>Returns:</p> Type Description <code>EntryPointStrategyCollection</code> <p>A collection of entry points for the specific strategy type.</p> Source code in <code>oteapi/plugins/entry_points.py</code> <pre><code>def get_strategy_entry_points(\n    strategy_type: \"Union[StrategyType, str]\",\n    enforce_uniqueness: bool = True,\n) -&gt; EntryPointStrategyCollection:\n    \"\"\"Retrieve all entry points from a specific strategy type.\n\n    Raises:\n        ValueError: If the strategy type is not supported.\n        KeyError: If `enforce_uniqueness` is `True` and an entry point strategy is\n            duplicated.\n\n    Parameters:\n        strategy_type: A strategy type for which the entry points will be retrieved.\n        enforce_uniqueness: Whether or not duplicate entry point strategies are\n            allowed. Defaults to `True`, meaning duplicates are *not* allowed.\n\n    Returns:\n        A collection of entry points for the specific strategy type.\n\n    \"\"\"\n    try:\n        strategy_type = StrategyType(strategy_type)\n    except ValueError as exc:\n        str_strategy_type = (\n            strategy_type\n            if isinstance(strategy_type, str)\n            else str(strategy_type.value)\n        )\n        raise ValueError(\n            f\"Strategy type {str_strategy_type!r} is not supported.\"\n        ) from exc\n\n    collection = EntryPointStrategyCollection()\n    oteapi_entry_points = sorted(\n        set(get_entry_points(group=f\"oteapi.{strategy_type.value}\"))\n    )\n\n    if enforce_uniqueness:\n        collection.exclusive_add(*(EntryPointStrategy(_) for _ in oteapi_entry_points))\n    else:\n        collection.add(*(EntryPointStrategy(_) for _ in oteapi_entry_points))\n\n    return collection\n</code></pre>"},{"location":"api_reference/plugins/factories/","title":"factories","text":"<p>Factory class for registering and creating strategy instances.</p> <p>Factory wrapper methods for creating the individual strategies.</p>"},{"location":"api_reference/plugins/factories/#oteapi.plugins.factories.StrategiesNotLoaded","title":"<code>StrategiesNotLoaded</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Entry point strategies have not been loaded, run <code>load_strategies()</code>.</p> Source code in <code>oteapi/plugins/factories.py</code> <pre><code>class StrategiesNotLoaded(Exception):\n    \"\"\"Entry point strategies have not been loaded, run\n    [`load_strategies()`][oteapi.plugins.factories.load_strategies].\"\"\"\n</code></pre>"},{"location":"api_reference/plugins/factories/#oteapi.plugins.factories.StrategyFactory","title":"<code>StrategyFactory</code>","text":"<p>Decorator-based Factory class.</p> <p>Attributes:</p> Name Type Description <code>strategy_create_func</code> <code>Dict[StrategyType, EntryPointStrategyCollection]</code> <p>An in-memory cache of all registered strategies.</p> Source code in <code>oteapi/plugins/factories.py</code> <pre><code>class StrategyFactory:\n    \"\"\"Decorator-based Factory class.\n\n    Attributes:\n        strategy_create_func (Dict[StrategyType, EntryPointStrategyCollection]): An\n            in-memory cache of all registered strategies.\n\n    \"\"\"\n\n    strategy_create_func: \"Dict[StrategyType, EntryPointStrategyCollection]\"\n\n    @classmethod\n    def make_strategy(\n        cls,\n        config: \"Union[StrategyConfig, Dict[str, Any]]\",\n        strategy_type: \"Union[StrategyType, str]\",\n    ) -&gt; \"IStrategy\":\n        \"\"\"Instantiate a strategy in a context class.\n\n        Parameters:\n            config: A strategy configuration.\n            strategy_type: The strategy type, e.g., `\"scheme\"`, `\"mediaType\"`, ... or\n                `\"download\"`, `\"parse\"`, ...\n                See the [`StrategyType`][oteapi.plugins.entry_points.StrategyType]\n                enumeration for a definition of valid strategy types.\n\n        Raises:\n            NotImplementedError: If the strategy cannot be found.\n            ValueError: If the `strategy_type` is not a valid strategy type.\n                See the [`StrategyType`][oteapi.plugins.entry_points.StrategyType]\n                enumeration for a definition of valid strategy types.\n            StrategiesNotLoaded: If the entry point strategies have not been loaded.\n\n        Returns:\n            An instantiated strategy. The strategy is instantiated with the provided\n            configuration, through the `config` parameter.\n\n        \"\"\"\n        if not hasattr(cls, \"strategy_create_func\"):\n            raise StrategiesNotLoaded(\n                \"Strategies have not been loaded, run `load_strategies()` or \"\n                \"`StrategyFactory.load_strategies()`.\"\n            )\n\n        if isinstance(strategy_type, str):\n            try:\n                strategy_type = StrategyType.init(strategy_type)\n            except ValueError as exc:\n                raise ValueError(\n                    f\"Strategy type {strategy_type!r} is not supported.\"\n                ) from exc\n        elif not isinstance(strategy_type, StrategyType):\n            raise TypeError(\n                \"strategy_type should be either of type StrategyType or a string.\"\n            )\n\n        # 'config': Must be a dict when instantiating the strategy's implementation.\n        # 'config_model': Is used to retrieve the correct strategy requested.\n        # Furthermore, creating 'config_model' ensures that the config is valid with\n        # respect to the strategy type, further reducing the risk of incorrect logical\n        # conclusions.\n        if isinstance(config, dict):\n            config_model = strategy_type.config_cls(**config)\n        elif isinstance(config, get_args(StrategyConfig)):\n            config_model = config\n            config = config.model_dump(mode=\"json\", exclude_unset=True)\n        else:\n            raise TypeError(\"config should be either of type StrategyConfig or a dict.\")\n\n        strategy_name: str = cls._get_strategy_name(config_model, strategy_type)\n\n        if (strategy_type, strategy_name) in cls.strategy_create_func[strategy_type]:\n            return cls.strategy_create_func[strategy_type][\n                (strategy_type, strategy_name)\n            ].implementation(\n                config  # type: ignore[arg-type]\n            )\n        raise NotImplementedError(\n            f\"The {strategy_type.value} strategy {strategy_name!r} does not exist.\"\n        )\n\n    @classmethod\n    def _get_strategy_name(\n        cls,\n        config: \"StrategyConfig\",\n        strategy_type: StrategyType,\n    ) -&gt; str:\n        \"\"\"Return the strategy name through the config.\n\n        This is a method to accommodate strategy type-specific quirks to retrieve the\n        strategy name.\n\n        Parameters:\n            config: A strategy configuration.\n            strategy_type: The strategy type as initialized in `make_strategy()`.\n\n        Returns:\n            The strategy name provided in the configuration.\n\n        \"\"\"\n        if strategy_type == StrategyType.DOWNLOAD:\n            return (\n                config.downloadUrl.scheme  # type: ignore[union-attr]\n                if config.downloadUrl is not None  # type: ignore[union-attr]\n                else \"\"\n            )\n        return getattr(config, strategy_type.map_to_field(), \"\")\n\n    @classmethod\n    def load_strategies(cls, test_for_uniqueness: bool = True) -&gt; None:\n        \"\"\"Load strategies from entry points and store in class attribute.\n\n        Important:\n            This is not a cached method.\n            The importlib.metadata API will be re-requested to load the entry points\n            and strategies.\n\n        Note:\n            This does *not* import the actual strategy implementations (classes).\n            It only loads the strategies from the registerred OTE-API entry points.\n\n        Raises:\n            KeyError: If `test_for_uniqueness` is `True` and an entry point strategy is\n                duplicated.\n\n        Parameters:\n            test_for_uniqueness: If `True`, this will raise `KeyError` should an entry\n                point strategy be duplicated. Otherwise, the first loaded entry point\n                strategy will silently become the implementation of choice for the\n                duplicated strategy and the duplicates will be ignored.\n\n        \"\"\"\n        cls.strategy_create_func = {\n            strategy_type: get_strategy_entry_points(\n                strategy_type, enforce_uniqueness=test_for_uniqueness\n            )\n            for strategy_type in StrategyType\n        }\n\n    @classmethod\n    def list_loaded_strategies(cls) -&gt; \"Dict[StrategyType, List[str]]\":\n        \"\"\"Lists all loaded strategy plugins (endpoints).\n\n        Returns:\n            A dictionary where keys are strategy types and values are lists of\n            loaded strategy names for each type.\n\n        Raises:\n            StrategiesNotLoaded: If the strategies are not loaded or\n                `strategy_create_func` is not properly initialized.\n        \"\"\"\n        if not hasattr(cls, \"strategy_create_func\") or not cls.strategy_create_func:\n            raise StrategiesNotLoaded(\n                \"Strategies are not loaded or `strategy_create_func` is not properly \"\n                \"initialized.\"\n            )\n\n        loaded_strategies = {}\n        for strategy_type, strategy_collection in cls.strategy_create_func.items():\n            # Assuming each item in the collection has a 'name' attribute or similar\n            loaded_strategies[strategy_type] = [\n                strategy.name for strategy in strategy_collection\n            ]\n\n        return loaded_strategies\n</code></pre>"},{"location":"api_reference/plugins/factories/#oteapi.plugins.factories.StrategyFactory.list_loaded_strategies","title":"<code>list_loaded_strategies()</code>  <code>classmethod</code>","text":"<p>Lists all loaded strategy plugins (endpoints).</p> <p>Returns:</p> Type Description <code>Dict[StrategyType, List[str]]</code> <p>A dictionary where keys are strategy types and values are lists of</p> <code>Dict[StrategyType, List[str]]</code> <p>loaded strategy names for each type.</p> <p>Raises:</p> Type Description <code>StrategiesNotLoaded</code> <p>If the strategies are not loaded or <code>strategy_create_func</code> is not properly initialized.</p> Source code in <code>oteapi/plugins/factories.py</code> <pre><code>@classmethod\ndef list_loaded_strategies(cls) -&gt; \"Dict[StrategyType, List[str]]\":\n    \"\"\"Lists all loaded strategy plugins (endpoints).\n\n    Returns:\n        A dictionary where keys are strategy types and values are lists of\n        loaded strategy names for each type.\n\n    Raises:\n        StrategiesNotLoaded: If the strategies are not loaded or\n            `strategy_create_func` is not properly initialized.\n    \"\"\"\n    if not hasattr(cls, \"strategy_create_func\") or not cls.strategy_create_func:\n        raise StrategiesNotLoaded(\n            \"Strategies are not loaded or `strategy_create_func` is not properly \"\n            \"initialized.\"\n        )\n\n    loaded_strategies = {}\n    for strategy_type, strategy_collection in cls.strategy_create_func.items():\n        # Assuming each item in the collection has a 'name' attribute or similar\n        loaded_strategies[strategy_type] = [\n            strategy.name for strategy in strategy_collection\n        ]\n\n    return loaded_strategies\n</code></pre>"},{"location":"api_reference/plugins/factories/#oteapi.plugins.factories.StrategyFactory.load_strategies","title":"<code>load_strategies(test_for_uniqueness=True)</code>  <code>classmethod</code>","text":"<p>Load strategies from entry points and store in class attribute.</p> Important <p>This is not a cached method. The importlib.metadata API will be re-requested to load the entry points and strategies.</p> Note <p>This does not import the actual strategy implementations (classes). It only loads the strategies from the registerred OTE-API entry points.</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If <code>test_for_uniqueness</code> is <code>True</code> and an entry point strategy is duplicated.</p> <p>Parameters:</p> Name Type Description Default <code>test_for_uniqueness</code> <code>bool</code> <p>If <code>True</code>, this will raise <code>KeyError</code> should an entry point strategy be duplicated. Otherwise, the first loaded entry point strategy will silently become the implementation of choice for the duplicated strategy and the duplicates will be ignored.</p> <code>True</code> Source code in <code>oteapi/plugins/factories.py</code> <pre><code>@classmethod\ndef load_strategies(cls, test_for_uniqueness: bool = True) -&gt; None:\n    \"\"\"Load strategies from entry points and store in class attribute.\n\n    Important:\n        This is not a cached method.\n        The importlib.metadata API will be re-requested to load the entry points\n        and strategies.\n\n    Note:\n        This does *not* import the actual strategy implementations (classes).\n        It only loads the strategies from the registerred OTE-API entry points.\n\n    Raises:\n        KeyError: If `test_for_uniqueness` is `True` and an entry point strategy is\n            duplicated.\n\n    Parameters:\n        test_for_uniqueness: If `True`, this will raise `KeyError` should an entry\n            point strategy be duplicated. Otherwise, the first loaded entry point\n            strategy will silently become the implementation of choice for the\n            duplicated strategy and the duplicates will be ignored.\n\n    \"\"\"\n    cls.strategy_create_func = {\n        strategy_type: get_strategy_entry_points(\n            strategy_type, enforce_uniqueness=test_for_uniqueness\n        )\n        for strategy_type in StrategyType\n    }\n</code></pre>"},{"location":"api_reference/plugins/factories/#oteapi.plugins.factories.StrategyFactory.make_strategy","title":"<code>make_strategy(config, strategy_type)</code>  <code>classmethod</code>","text":"<p>Instantiate a strategy in a context class.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>Union[StrategyConfig, Dict[str, Any]]</code> <p>A strategy configuration.</p> required <code>strategy_type</code> <code>Union[StrategyType, str]</code> <p>The strategy type, e.g., <code>\"scheme\"</code>, <code>\"mediaType\"</code>, ... or <code>\"download\"</code>, <code>\"parse\"</code>, ... See the <code>StrategyType</code> enumeration for a definition of valid strategy types.</p> required <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If the strategy cannot be found.</p> <code>ValueError</code> <p>If the <code>strategy_type</code> is not a valid strategy type. See the <code>StrategyType</code> enumeration for a definition of valid strategy types.</p> <code>StrategiesNotLoaded</code> <p>If the entry point strategies have not been loaded.</p> <p>Returns:</p> Type Description <code>IStrategy</code> <p>An instantiated strategy. The strategy is instantiated with the provided</p> <code>IStrategy</code> <p>configuration, through the <code>config</code> parameter.</p> Source code in <code>oteapi/plugins/factories.py</code> <pre><code>@classmethod\ndef make_strategy(\n    cls,\n    config: \"Union[StrategyConfig, Dict[str, Any]]\",\n    strategy_type: \"Union[StrategyType, str]\",\n) -&gt; \"IStrategy\":\n    \"\"\"Instantiate a strategy in a context class.\n\n    Parameters:\n        config: A strategy configuration.\n        strategy_type: The strategy type, e.g., `\"scheme\"`, `\"mediaType\"`, ... or\n            `\"download\"`, `\"parse\"`, ...\n            See the [`StrategyType`][oteapi.plugins.entry_points.StrategyType]\n            enumeration for a definition of valid strategy types.\n\n    Raises:\n        NotImplementedError: If the strategy cannot be found.\n        ValueError: If the `strategy_type` is not a valid strategy type.\n            See the [`StrategyType`][oteapi.plugins.entry_points.StrategyType]\n            enumeration for a definition of valid strategy types.\n        StrategiesNotLoaded: If the entry point strategies have not been loaded.\n\n    Returns:\n        An instantiated strategy. The strategy is instantiated with the provided\n        configuration, through the `config` parameter.\n\n    \"\"\"\n    if not hasattr(cls, \"strategy_create_func\"):\n        raise StrategiesNotLoaded(\n            \"Strategies have not been loaded, run `load_strategies()` or \"\n            \"`StrategyFactory.load_strategies()`.\"\n        )\n\n    if isinstance(strategy_type, str):\n        try:\n            strategy_type = StrategyType.init(strategy_type)\n        except ValueError as exc:\n            raise ValueError(\n                f\"Strategy type {strategy_type!r} is not supported.\"\n            ) from exc\n    elif not isinstance(strategy_type, StrategyType):\n        raise TypeError(\n            \"strategy_type should be either of type StrategyType or a string.\"\n        )\n\n    # 'config': Must be a dict when instantiating the strategy's implementation.\n    # 'config_model': Is used to retrieve the correct strategy requested.\n    # Furthermore, creating 'config_model' ensures that the config is valid with\n    # respect to the strategy type, further reducing the risk of incorrect logical\n    # conclusions.\n    if isinstance(config, dict):\n        config_model = strategy_type.config_cls(**config)\n    elif isinstance(config, get_args(StrategyConfig)):\n        config_model = config\n        config = config.model_dump(mode=\"json\", exclude_unset=True)\n    else:\n        raise TypeError(\"config should be either of type StrategyConfig or a dict.\")\n\n    strategy_name: str = cls._get_strategy_name(config_model, strategy_type)\n\n    if (strategy_type, strategy_name) in cls.strategy_create_func[strategy_type]:\n        return cls.strategy_create_func[strategy_type][\n            (strategy_type, strategy_name)\n        ].implementation(\n            config  # type: ignore[arg-type]\n        )\n    raise NotImplementedError(\n        f\"The {strategy_type.value} strategy {strategy_name!r} does not exist.\"\n    )\n</code></pre>"},{"location":"api_reference/plugins/factories/#oteapi.plugins.factories.create_strategy","title":"<code>create_strategy(strategy_type, config)</code>","text":"<p>Proxy function for <code>StrategyFactory.make_strategy()</code>.</p> <p>Parameters:</p> Name Type Description Default <code>strategy_type</code> <code>Union[StrategyType, str]</code> <p>A valid strategy type. See the <code>StrategyType</code> enumeration for a definition of valid strategy types.</p> required <code>config</code> <code>Union[StrategyConfig, Dict[str, Any]]</code> <p>A strategy configuration.</p> required <p>Returns:</p> Type Description <code>IStrategy</code> <p>The created strategy.</p> Source code in <code>oteapi/plugins/factories.py</code> <pre><code>def create_strategy(\n    strategy_type: \"Union[StrategyType, str]\",\n    config: \"Union[StrategyConfig, Dict[str, Any]]\",\n) -&gt; \"IStrategy\":\n    \"\"\"Proxy function for\n    [`StrategyFactory.make_strategy()`][oteapi.plugins.factories.StrategyFactory.make_strategy].\n\n    Parameters:\n        strategy_type: A valid strategy type.\n            See the [`StrategyType`][oteapi.plugins.entry_points.StrategyType]\n            enumeration for a definition of valid strategy types.\n        config: A strategy configuration.\n\n    Returns:\n        The created strategy.\n\n    \"\"\"\n    return StrategyFactory.make_strategy(config, strategy_type)\n</code></pre>"},{"location":"api_reference/plugins/factories/#oteapi.plugins.factories.list_strategies","title":"<code>list_strategies()</code>","text":"<p>Proxy function for <code>StrategyFactory.list_loaded_strategies()</code>.</p> <p>Returns:</p> Type Description <code>Dict[StrategyType, List[str]]</code> <p>A dictionary where keys are strategy types and values are lists of</p> <code>Dict[StrategyType, List[str]]</code> <p>loaded strategy names for each type.</p> Source code in <code>oteapi/plugins/factories.py</code> <pre><code>def list_strategies() -&gt; \"Dict[StrategyType, List[str]]\":\n    \"\"\"Proxy function for\n    [`StrategyFactory.list_loaded_strategies()`][oteapi.plugins.factories.StrategyFactory.list_loaded_strategies].\n\n    Returns:\n        A dictionary where keys are strategy types and values are lists of\n        loaded strategy names for each type.\n    \"\"\"\n    return StrategyFactory.list_loaded_strategies()\n</code></pre>"},{"location":"api_reference/plugins/factories/#oteapi.plugins.factories.load_strategies","title":"<code>load_strategies(test_for_uniqueness=True)</code>","text":"<p>Proxy function for <code>StrategyFactory.load_strategies()</code>.</p> <p>Parameters:</p> Name Type Description Default <code>test_for_uniqueness</code> <code>bool</code> <p>If <code>True</code>, this will raise <code>KeyError</code> should an entry point strategy be duplicated. Otherwise, the first loaded entry point strategy will silently become the implementation of choice for the duplicated strategy and the duplicates will be ignored.</p> <code>True</code> Source code in <code>oteapi/plugins/factories.py</code> <pre><code>def load_strategies(test_for_uniqueness: bool = True) -&gt; None:\n    \"\"\"Proxy function for\n    [`StrategyFactory.load_strategies()`][oteapi.plugins.factories.StrategyFactory.load_strategies].\n\n    Parameters:\n        test_for_uniqueness: If `True`, this will raise `KeyError` should an entry\n            point strategy be duplicated. Otherwise, the first loaded entry point\n            strategy will silently become the implementation of choice for the\n            duplicated strategy and the duplicates will be ignored.\n\n    \"\"\"\n    StrategyFactory.load_strategies(test_for_uniqueness)\n</code></pre>"},{"location":"api_reference/strategies/download/file/","title":"file","text":"<p>Download strategy class for the <code>file</code> scheme.</p>"},{"location":"api_reference/strategies/download/file/#oteapi.strategies.download.file.DownloadFileContent","title":"<code>DownloadFileContent</code>","text":"<p>               Bases: <code>AttrDict</code></p> <p>Class for returning values from Download File strategy.</p> Source code in <code>oteapi/strategies/download/file.py</code> <pre><code>class DownloadFileContent(AttrDict):\n    \"\"\"Class for returning values from Download File strategy.\"\"\"\n\n    key: str = Field(..., description=\"Key to access the data in the cache.\")\n</code></pre>"},{"location":"api_reference/strategies/download/file/#oteapi.strategies.download.file.DownloadFileContent.key","title":"<code>key: str = Field(..., description='Key to access the data in the cache.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/download/file/#oteapi.strategies.download.file.FileConfig","title":"<code>FileConfig</code>","text":"<p>               Bases: <code>AttrDict</code></p> <p>File-specific Configuration Data Model.</p> Source code in <code>oteapi/strategies/download/file.py</code> <pre><code>class FileConfig(AttrDict):\n    \"\"\"File-specific Configuration Data Model.\"\"\"\n\n    text: bool = Field(\n        False,\n        description=(\n            \"Whether the file should be opened in text mode. If `False`, the file will\"\n            \" be opened in bytes mode.\"\n        ),\n    )\n    encoding: Optional[str] = Field(\n        None,\n        description=(\n            \"Encoding used when opening the file. The default is platform dependent.\"\n        ),\n    )\n    datacache_config: Optional[DataCacheConfig] = Field(\n        None,\n        description=(\n            \"Configurations for the data cache for storing the downloaded file \"\n            \"content.\"\n        ),\n    )\n</code></pre>"},{"location":"api_reference/strategies/download/file/#oteapi.strategies.download.file.FileConfig.datacache_config","title":"<code>datacache_config: Optional[DataCacheConfig] = Field(None, description='Configurations for the data cache for storing the downloaded file content.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/download/file/#oteapi.strategies.download.file.FileConfig.encoding","title":"<code>encoding: Optional[str] = Field(None, description='Encoding used when opening the file. The default is platform dependent.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/download/file/#oteapi.strategies.download.file.FileConfig.text","title":"<code>text: bool = Field(False, description='Whether the file should be opened in text mode. If `False`, the file will be opened in bytes mode.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/download/file/#oteapi.strategies.download.file.FileResourceConfig","title":"<code>FileResourceConfig</code>","text":"<p>               Bases: <code>ResourceConfig</code></p> <p>File download strategy filter config.</p> Source code in <code>oteapi/strategies/download/file.py</code> <pre><code>class FileResourceConfig(ResourceConfig):\n    \"\"\"File download strategy filter config.\"\"\"\n\n    downloadUrl: FileUrl = Field(  # type: ignore[assignment]\n        ..., description=\"The file URL, which will be downloaded.\"\n    )\n    configuration: FileConfig = Field(\n        FileConfig(), description=\"File download strategy-specific configuration.\"\n    )\n\n    @field_validator(\"downloadUrl\")\n    @classmethod\n    def ensure_path_exists(cls, value: FileUrl) -&gt; FileUrl:\n        \"\"\"Ensure `path` is defined in `downloadUrl`.\"\"\"\n        if not value.path:\n            raise ValueError(\"downloadUrl must contain a `path` part.\")\n        return value\n</code></pre>"},{"location":"api_reference/strategies/download/file/#oteapi.strategies.download.file.FileResourceConfig.configuration","title":"<code>configuration: FileConfig = Field(FileConfig(), description='File download strategy-specific configuration.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/download/file/#oteapi.strategies.download.file.FileResourceConfig.downloadUrl","title":"<code>downloadUrl: FileUrl = Field(..., description='The file URL, which will be downloaded.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/download/file/#oteapi.strategies.download.file.FileResourceConfig.ensure_path_exists","title":"<code>ensure_path_exists(value)</code>  <code>classmethod</code>","text":"<p>Ensure <code>path</code> is defined in <code>downloadUrl</code>.</p> Source code in <code>oteapi/strategies/download/file.py</code> <pre><code>@field_validator(\"downloadUrl\")\n@classmethod\ndef ensure_path_exists(cls, value: FileUrl) -&gt; FileUrl:\n    \"\"\"Ensure `path` is defined in `downloadUrl`.\"\"\"\n    if not value.path:\n        raise ValueError(\"downloadUrl must contain a `path` part.\")\n    return value\n</code></pre>"},{"location":"api_reference/strategies/download/file/#oteapi.strategies.download.file.FileStrategy","title":"<code>FileStrategy</code>","text":"<p>Strategy for retrieving data from a local file.</p> <p>Registers strategies:</p> <ul> <li><code>(\"scheme\", \"file\")</code></li> </ul> Source code in <code>oteapi/strategies/download/file.py</code> <pre><code>@dataclass\nclass FileStrategy:\n    \"\"\"Strategy for retrieving data from a local file.\n\n    **Registers strategies**:\n\n    - `(\"scheme\", \"file\")`\n\n    \"\"\"\n\n    download_config: FileResourceConfig\n\n    def initialize(self) -&gt; AttrDict:\n        \"\"\"Initialize.\"\"\"\n        return AttrDict()\n\n    def get(self) -&gt; DownloadFileContent:\n        \"\"\"Read local file.\"\"\"\n        filename = uri_to_path(self.download_config.downloadUrl).resolve()\n\n        if not filename.exists():\n            raise FileNotFoundError(f\"File not found at {filename}\")\n\n        cache = DataCache(self.download_config.configuration.datacache_config)\n        if cache.config.accessKey and cache.config.accessKey in cache:\n            key = cache.config.accessKey\n        else:\n            key = cache.add(\n                filename.read_text(encoding=self.download_config.configuration.encoding)\n                if self.download_config.configuration.text\n                else filename.read_bytes()\n            )\n\n        return DownloadFileContent(key=key)\n</code></pre>"},{"location":"api_reference/strategies/download/file/#oteapi.strategies.download.file.FileStrategy.download_config","title":"<code>download_config: FileResourceConfig</code>  <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/download/file/#oteapi.strategies.download.file.FileStrategy.get","title":"<code>get()</code>","text":"<p>Read local file.</p> Source code in <code>oteapi/strategies/download/file.py</code> <pre><code>def get(self) -&gt; DownloadFileContent:\n    \"\"\"Read local file.\"\"\"\n    filename = uri_to_path(self.download_config.downloadUrl).resolve()\n\n    if not filename.exists():\n        raise FileNotFoundError(f\"File not found at {filename}\")\n\n    cache = DataCache(self.download_config.configuration.datacache_config)\n    if cache.config.accessKey and cache.config.accessKey in cache:\n        key = cache.config.accessKey\n    else:\n        key = cache.add(\n            filename.read_text(encoding=self.download_config.configuration.encoding)\n            if self.download_config.configuration.text\n            else filename.read_bytes()\n        )\n\n    return DownloadFileContent(key=key)\n</code></pre>"},{"location":"api_reference/strategies/download/file/#oteapi.strategies.download.file.FileStrategy.initialize","title":"<code>initialize()</code>","text":"<p>Initialize.</p> Source code in <code>oteapi/strategies/download/file.py</code> <pre><code>def initialize(self) -&gt; AttrDict:\n    \"\"\"Initialize.\"\"\"\n    return AttrDict()\n</code></pre>"},{"location":"api_reference/strategies/download/https/","title":"https","text":"<p>Download strategy class for http/https</p>"},{"location":"api_reference/strategies/download/https/#oteapi.strategies.download.https.HTTPDownloadContent","title":"<code>HTTPDownloadContent</code>","text":"<p>               Bases: <code>AttrDict</code></p> <p>Class for returning values from Download HTTPS strategy.</p> Source code in <code>oteapi/strategies/download/https.py</code> <pre><code>class HTTPDownloadContent(AttrDict):\n    \"\"\"Class for returning values from Download HTTPS strategy.\"\"\"\n\n    key: str = Field(..., description=\"Key to access the data in the cache.\")\n</code></pre>"},{"location":"api_reference/strategies/download/https/#oteapi.strategies.download.https.HTTPDownloadContent.key","title":"<code>key: str = Field(..., description='Key to access the data in the cache.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/download/https/#oteapi.strategies.download.https.HTTPSConfig","title":"<code>HTTPSConfig</code>","text":"<p>               Bases: <code>AttrDict</code></p> <p>HTTP(S)-specific Configuration Data Model.</p> Source code in <code>oteapi/strategies/download/https.py</code> <pre><code>class HTTPSConfig(AttrDict):\n    \"\"\"HTTP(S)-specific Configuration Data Model.\"\"\"\n\n    datacache_config: Optional[DataCacheConfig] = Field(\n        None,\n        description=(\n            \"Configurations for the data cache for storing the downloaded file \"\n            \"content.\"\n        ),\n    )\n</code></pre>"},{"location":"api_reference/strategies/download/https/#oteapi.strategies.download.https.HTTPSConfig.datacache_config","title":"<code>datacache_config: Optional[DataCacheConfig] = Field(None, description='Configurations for the data cache for storing the downloaded file content.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/download/https/#oteapi.strategies.download.https.HTTPSResourceConfig","title":"<code>HTTPSResourceConfig</code>","text":"<p>               Bases: <code>ResourceConfig</code></p> <p>HTTP(S) download strategy filter config.</p> Source code in <code>oteapi/strategies/download/https.py</code> <pre><code>class HTTPSResourceConfig(ResourceConfig):\n    \"\"\"HTTP(S) download strategy filter config.\"\"\"\n\n    downloadUrl: AnyHttpUrl = Field(  # type: ignore[assignment]\n        ..., description=\"The HTTP(S) URL, which will be downloaded.\"\n    )\n    configuration: HTTPSConfig = Field(\n        HTTPSConfig(), description=\"HTTP(S) download strategy-specific configuration.\"\n    )\n</code></pre>"},{"location":"api_reference/strategies/download/https/#oteapi.strategies.download.https.HTTPSResourceConfig.configuration","title":"<code>configuration: HTTPSConfig = Field(HTTPSConfig(), description='HTTP(S) download strategy-specific configuration.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/download/https/#oteapi.strategies.download.https.HTTPSResourceConfig.downloadUrl","title":"<code>downloadUrl: AnyHttpUrl = Field(..., description='The HTTP(S) URL, which will be downloaded.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/download/https/#oteapi.strategies.download.https.HTTPSStrategy","title":"<code>HTTPSStrategy</code>","text":"<p>Strategy for retrieving data via http.</p> <p>Registers strategies:</p> <ul> <li><code>(\"scheme\", \"http\")</code></li> <li><code>(\"scheme\", \"https\")</code></li> </ul> Source code in <code>oteapi/strategies/download/https.py</code> <pre><code>@dataclass\nclass HTTPSStrategy:\n    \"\"\"Strategy for retrieving data via http.\n\n    **Registers strategies**:\n\n    - `(\"scheme\", \"http\")`\n    - `(\"scheme\", \"https\")`\n\n    \"\"\"\n\n    download_config: HTTPSResourceConfig\n\n    def initialize(self) -&gt; AttrDict:\n        \"\"\"Initialize.\"\"\"\n        return AttrDict()\n\n    def get(self) -&gt; HTTPDownloadContent:\n        \"\"\"Download via http/https and store on local cache.\"\"\"\n        cache = DataCache(self.download_config.configuration.datacache_config)\n        if cache.config.accessKey and cache.config.accessKey in cache:\n            key = cache.config.accessKey\n        else:\n            req = requests.get(\n                str(self.download_config.downloadUrl),\n                allow_redirects=True,\n                timeout=(3, 27),  # timeout: (connect, read) in seconds\n            )\n            key = cache.add(req.content)\n\n        return HTTPDownloadContent(key=key)\n</code></pre>"},{"location":"api_reference/strategies/download/https/#oteapi.strategies.download.https.HTTPSStrategy.download_config","title":"<code>download_config: HTTPSResourceConfig</code>  <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/download/https/#oteapi.strategies.download.https.HTTPSStrategy.get","title":"<code>get()</code>","text":"<p>Download via http/https and store on local cache.</p> Source code in <code>oteapi/strategies/download/https.py</code> <pre><code>def get(self) -&gt; HTTPDownloadContent:\n    \"\"\"Download via http/https and store on local cache.\"\"\"\n    cache = DataCache(self.download_config.configuration.datacache_config)\n    if cache.config.accessKey and cache.config.accessKey in cache:\n        key = cache.config.accessKey\n    else:\n        req = requests.get(\n            str(self.download_config.downloadUrl),\n            allow_redirects=True,\n            timeout=(3, 27),  # timeout: (connect, read) in seconds\n        )\n        key = cache.add(req.content)\n\n    return HTTPDownloadContent(key=key)\n</code></pre>"},{"location":"api_reference/strategies/download/https/#oteapi.strategies.download.https.HTTPSStrategy.initialize","title":"<code>initialize()</code>","text":"<p>Initialize.</p> Source code in <code>oteapi/strategies/download/https.py</code> <pre><code>def initialize(self) -&gt; AttrDict:\n    \"\"\"Initialize.\"\"\"\n    return AttrDict()\n</code></pre>"},{"location":"api_reference/strategies/download/sftp/","title":"sftp","text":"<p>Strategy class for sftp/ftp</p>"},{"location":"api_reference/strategies/download/sftp/#oteapi.strategies.download.sftp.AnyFtpUrl","title":"<code>AnyFtpUrl = Annotated[Url, UrlConstraints(allowed_schemes=['ftp', 'sftp'])]</code>  <code>module-attribute</code>","text":""},{"location":"api_reference/strategies/download/sftp/#oteapi.strategies.download.sftp.SFTPConfig","title":"<code>SFTPConfig</code>","text":"<p>               Bases: <code>AttrDict</code></p> <p>(S)FTP-specific Configuration Data Model.</p> Source code in <code>oteapi/strategies/download/sftp.py</code> <pre><code>class SFTPConfig(AttrDict):\n    \"\"\"(S)FTP-specific Configuration Data Model.\"\"\"\n\n    datacache_config: Optional[DataCacheConfig] = Field(\n        None,\n        description=(\n            \"Configurations for the data cache for storing the downloaded file \"\n            \"content.\"\n        ),\n    )\n</code></pre>"},{"location":"api_reference/strategies/download/sftp/#oteapi.strategies.download.sftp.SFTPConfig.datacache_config","title":"<code>datacache_config: Optional[DataCacheConfig] = Field(None, description='Configurations for the data cache for storing the downloaded file content.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/download/sftp/#oteapi.strategies.download.sftp.SFTPContent","title":"<code>SFTPContent</code>","text":"<p>               Bases: <code>AttrDict</code></p> <p>Class for returning values from Download SFTP strategy.</p> Source code in <code>oteapi/strategies/download/sftp.py</code> <pre><code>class SFTPContent(AttrDict):\n    \"\"\"Class for returning values from Download SFTP strategy.\"\"\"\n\n    key: str = Field(..., description=\"Key to access the data in the cache.\")\n</code></pre>"},{"location":"api_reference/strategies/download/sftp/#oteapi.strategies.download.sftp.SFTPContent.key","title":"<code>key: str = Field(..., description='Key to access the data in the cache.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/download/sftp/#oteapi.strategies.download.sftp.SFTPResourceConfig","title":"<code>SFTPResourceConfig</code>","text":"<p>               Bases: <code>ResourceConfig</code></p> <p>(S)FTP download strategy filter config.</p> Source code in <code>oteapi/strategies/download/sftp.py</code> <pre><code>class SFTPResourceConfig(ResourceConfig):\n    \"\"\"(S)FTP download strategy filter config.\"\"\"\n\n    downloadUrl: AnyFtpUrl = Field(  # type: ignore[assignment]\n        ..., description=\"The (S)FTP URL, which will be downloaded.\"\n    )\n    configuration: SFTPConfig = Field(\n        SFTPConfig(), description=\"(S)FTP download strategy-specific configuration.\"\n    )\n</code></pre>"},{"location":"api_reference/strategies/download/sftp/#oteapi.strategies.download.sftp.SFTPResourceConfig.configuration","title":"<code>configuration: SFTPConfig = Field(SFTPConfig(), description='(S)FTP download strategy-specific configuration.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/download/sftp/#oteapi.strategies.download.sftp.SFTPResourceConfig.downloadUrl","title":"<code>downloadUrl: AnyFtpUrl = Field(..., description='The (S)FTP URL, which will be downloaded.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/download/sftp/#oteapi.strategies.download.sftp.SFTPStrategy","title":"<code>SFTPStrategy</code>","text":"<p>Strategy for retrieving data via sftp.</p> <p>Registers strategies:</p> <ul> <li><code>(\"scheme\", \"ftp\")</code></li> <li><code>(\"scheme\", \"sftp\")</code></li> </ul> Source code in <code>oteapi/strategies/download/sftp.py</code> <pre><code>@dataclass\nclass SFTPStrategy:\n    \"\"\"Strategy for retrieving data via sftp.\n\n    **Registers strategies**:\n\n    - `(\"scheme\", \"ftp\")`\n    - `(\"scheme\", \"sftp\")`\n\n    \"\"\"\n\n    download_config: SFTPResourceConfig\n\n    def initialize(self) -&gt; AttrDict:\n        \"\"\"Initialize.\"\"\"\n        return AttrDict()\n\n    def get(self) -&gt; SFTPContent:\n        \"\"\"Download via sftp\"\"\"\n        cache = DataCache(self.download_config.configuration.datacache_config)\n        if cache.config.accessKey and cache.config.accessKey in cache:\n            key = cache.config.accessKey\n        else:\n            # Setup connection options\n            cnopts = pysftp.CnOpts()\n            cnopts.hostkeys = None\n\n            # open connection and store data locally\n            with pysftp.Connection(\n                host=self.download_config.downloadUrl.host,\n                username=self.download_config.downloadUrl.username,\n                password=self.download_config.downloadUrl.password,\n                port=self.download_config.downloadUrl.port,\n                cnopts=cnopts,\n            ) as sftp:\n                # Because of insane locking on Windows, we have to close\n                # the downloaded file before adding it to the cache\n                with NamedTemporaryFile(prefix=\"oteapi-sftp-\", delete=False) as handle:\n                    localpath = Path(handle.name).resolve()\n                try:\n                    sftp.get(self.download_config.downloadUrl.path, localpath=localpath)\n                    key = cache.add(localpath.read_bytes())\n                finally:\n                    localpath.unlink()\n\n        return SFTPContent(key=key)\n</code></pre>"},{"location":"api_reference/strategies/download/sftp/#oteapi.strategies.download.sftp.SFTPStrategy.download_config","title":"<code>download_config: SFTPResourceConfig</code>  <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/download/sftp/#oteapi.strategies.download.sftp.SFTPStrategy.get","title":"<code>get()</code>","text":"<p>Download via sftp</p> Source code in <code>oteapi/strategies/download/sftp.py</code> <pre><code>def get(self) -&gt; SFTPContent:\n    \"\"\"Download via sftp\"\"\"\n    cache = DataCache(self.download_config.configuration.datacache_config)\n    if cache.config.accessKey and cache.config.accessKey in cache:\n        key = cache.config.accessKey\n    else:\n        # Setup connection options\n        cnopts = pysftp.CnOpts()\n        cnopts.hostkeys = None\n\n        # open connection and store data locally\n        with pysftp.Connection(\n            host=self.download_config.downloadUrl.host,\n            username=self.download_config.downloadUrl.username,\n            password=self.download_config.downloadUrl.password,\n            port=self.download_config.downloadUrl.port,\n            cnopts=cnopts,\n        ) as sftp:\n            # Because of insane locking on Windows, we have to close\n            # the downloaded file before adding it to the cache\n            with NamedTemporaryFile(prefix=\"oteapi-sftp-\", delete=False) as handle:\n                localpath = Path(handle.name).resolve()\n            try:\n                sftp.get(self.download_config.downloadUrl.path, localpath=localpath)\n                key = cache.add(localpath.read_bytes())\n            finally:\n                localpath.unlink()\n\n    return SFTPContent(key=key)\n</code></pre>"},{"location":"api_reference/strategies/download/sftp/#oteapi.strategies.download.sftp.SFTPStrategy.initialize","title":"<code>initialize()</code>","text":"<p>Initialize.</p> Source code in <code>oteapi/strategies/download/sftp.py</code> <pre><code>def initialize(self) -&gt; AttrDict:\n    \"\"\"Initialize.\"\"\"\n    return AttrDict()\n</code></pre>"},{"location":"api_reference/strategies/filter/crop_filter/","title":"crop_filter","text":"<p>Demo-filter strategy</p>"},{"location":"api_reference/strategies/filter/crop_filter/#oteapi.strategies.filter.crop_filter.CropFilterContent","title":"<code>CropFilterContent</code>","text":"<p>               Bases: <code>AttrDict</code></p> <p>Return model for <code>CropImageFilter</code>.</p> Source code in <code>oteapi/strategies/filter/crop_filter.py</code> <pre><code>class CropFilterContent(AttrDict):\n    \"\"\"Return model for `CropImageFilter`.\"\"\"\n\n    imagecrop: Tuple[int, int, int, int] = Field(\n        ..., description=\"Box cropping parameters (left, top, right, bottom).\"\n    )\n</code></pre>"},{"location":"api_reference/strategies/filter/crop_filter/#oteapi.strategies.filter.crop_filter.CropFilterContent.imagecrop","title":"<code>imagecrop: Tuple[int, int, int, int] = Field(..., description='Box cropping parameters (left, top, right, bottom).')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/filter/crop_filter/#oteapi.strategies.filter.crop_filter.CropImageConfig","title":"<code>CropImageConfig</code>","text":"<p>               Bases: <code>AttrDict</code></p> <p>Configuration model for crop data.</p> Source code in <code>oteapi/strategies/filter/crop_filter.py</code> <pre><code>class CropImageConfig(AttrDict):\n    \"\"\"Configuration model for crop data.\"\"\"\n\n    crop: Optional[Tuple[int, int, int, int]] = Field(\n        None, description=\"Box cropping parameters (left, top, right, bottom).\"\n    )\n</code></pre>"},{"location":"api_reference/strategies/filter/crop_filter/#oteapi.strategies.filter.crop_filter.CropImageConfig.crop","title":"<code>crop: Optional[Tuple[int, int, int, int]] = Field(None, description='Box cropping parameters (left, top, right, bottom).')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/filter/crop_filter/#oteapi.strategies.filter.crop_filter.CropImageFilter","title":"<code>CropImageFilter</code>","text":"<p>Strategy for cropping an image.</p> <p>Registers strategies:</p> <ul> <li><code>(\"filterType\", \"filter/crop\")</code></li> </ul> Source code in <code>oteapi/strategies/filter/crop_filter.py</code> <pre><code>@dataclass\nclass CropImageFilter:\n    \"\"\"Strategy for cropping an image.\n\n    **Registers strategies**:\n\n    - `(\"filterType\", \"filter/crop\")`\n\n    \"\"\"\n\n    filter_config: CropImageFilterConfig\n\n    def initialize(self) -&gt; CropFilterContent:\n        \"\"\"Initialize strategy and return a dictionary.\"\"\"\n        if self.filter_config.configuration.crop is None:\n            raise ValueError(\"Crop filter requires crop configuration.\")\n\n        return CropFilterContent(\n            imagecrop=self.filter_config.configuration.crop,\n        )\n\n    def get(self) -&gt; AttrDict:\n        \"\"\"Execute strategy and return a dictionary\"\"\"\n        return AttrDict()\n</code></pre>"},{"location":"api_reference/strategies/filter/crop_filter/#oteapi.strategies.filter.crop_filter.CropImageFilter.filter_config","title":"<code>filter_config: CropImageFilterConfig</code>  <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/filter/crop_filter/#oteapi.strategies.filter.crop_filter.CropImageFilter.get","title":"<code>get()</code>","text":"<p>Execute strategy and return a dictionary</p> Source code in <code>oteapi/strategies/filter/crop_filter.py</code> <pre><code>def get(self) -&gt; AttrDict:\n    \"\"\"Execute strategy and return a dictionary\"\"\"\n    return AttrDict()\n</code></pre>"},{"location":"api_reference/strategies/filter/crop_filter/#oteapi.strategies.filter.crop_filter.CropImageFilter.initialize","title":"<code>initialize()</code>","text":"<p>Initialize strategy and return a dictionary.</p> Source code in <code>oteapi/strategies/filter/crop_filter.py</code> <pre><code>def initialize(self) -&gt; CropFilterContent:\n    \"\"\"Initialize strategy and return a dictionary.\"\"\"\n    if self.filter_config.configuration.crop is None:\n        raise ValueError(\"Crop filter requires crop configuration.\")\n\n    return CropFilterContent(\n        imagecrop=self.filter_config.configuration.crop,\n    )\n</code></pre>"},{"location":"api_reference/strategies/filter/crop_filter/#oteapi.strategies.filter.crop_filter.CropImageFilterConfig","title":"<code>CropImageFilterConfig</code>","text":"<p>               Bases: <code>FilterConfig</code></p> <p>Crop filter strategy filter config.</p> Source code in <code>oteapi/strategies/filter/crop_filter.py</code> <pre><code>class CropImageFilterConfig(FilterConfig):\n    \"\"\"Crop filter strategy filter config.\"\"\"\n\n    filterType: Literal[\"filter/crop\"] = Field(\n        \"filter/crop\",\n        description=FilterConfig.model_fields[\"filterType\"].description,\n    )\n    configuration: CropImageConfig = Field(\n        ..., description=\"Image crop filter strategy-specific configuration.\"\n    )\n</code></pre>"},{"location":"api_reference/strategies/filter/crop_filter/#oteapi.strategies.filter.crop_filter.CropImageFilterConfig.configuration","title":"<code>configuration: CropImageConfig = Field(..., description='Image crop filter strategy-specific configuration.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/filter/crop_filter/#oteapi.strategies.filter.crop_filter.CropImageFilterConfig.filterType","title":"<code>filterType: Literal['filter/crop'] = Field('filter/crop', description=FilterConfig.model_fields['filterType'].description)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/filter/sql_query_filter/","title":"sql_query_filter","text":"<p>SQL query filter strategy.</p>"},{"location":"api_reference/strategies/filter/sql_query_filter/#oteapi.strategies.filter.sql_query_filter.SQLQueryFilter","title":"<code>SQLQueryFilter</code>","text":"<p>Strategy for a SQL query filter.</p> <p>Registers strategies:</p> <ul> <li><code>(\"filterType\", \"filter/sql\")</code></li> </ul> Source code in <code>oteapi/strategies/filter/sql_query_filter.py</code> <pre><code>@dataclass\nclass SQLQueryFilter:\n    \"\"\"Strategy for a SQL query filter.\n\n    **Registers strategies**:\n\n    - `(\"filterType\", \"filter/sql\")`\n\n    \"\"\"\n\n    filter_config: SqlQueryFilterConfig\n\n    def initialize(self) -&gt; SqlQueryContent:\n        \"\"\"Initialize strategy.\"\"\"\n        return SqlQueryContent(sqlquery=self.filter_config.query)\n\n    def get(self) -&gt; AttrDict:\n        \"\"\"Execute strategy and return a dictionary.\"\"\"\n        return AttrDict()\n</code></pre>"},{"location":"api_reference/strategies/filter/sql_query_filter/#oteapi.strategies.filter.sql_query_filter.SQLQueryFilter.filter_config","title":"<code>filter_config: SqlQueryFilterConfig</code>  <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/filter/sql_query_filter/#oteapi.strategies.filter.sql_query_filter.SQLQueryFilter.get","title":"<code>get()</code>","text":"<p>Execute strategy and return a dictionary.</p> Source code in <code>oteapi/strategies/filter/sql_query_filter.py</code> <pre><code>def get(self) -&gt; AttrDict:\n    \"\"\"Execute strategy and return a dictionary.\"\"\"\n    return AttrDict()\n</code></pre>"},{"location":"api_reference/strategies/filter/sql_query_filter/#oteapi.strategies.filter.sql_query_filter.SQLQueryFilter.initialize","title":"<code>initialize()</code>","text":"<p>Initialize strategy.</p> Source code in <code>oteapi/strategies/filter/sql_query_filter.py</code> <pre><code>def initialize(self) -&gt; SqlQueryContent:\n    \"\"\"Initialize strategy.\"\"\"\n    return SqlQueryContent(sqlquery=self.filter_config.query)\n</code></pre>"},{"location":"api_reference/strategies/filter/sql_query_filter/#oteapi.strategies.filter.sql_query_filter.SqlQueryContent","title":"<code>SqlQueryContent</code>","text":"<p>               Bases: <code>AttrDict</code></p> <p>Class for returning values from SQL Query data model.</p> Source code in <code>oteapi/strategies/filter/sql_query_filter.py</code> <pre><code>class SqlQueryContent(AttrDict):\n    \"\"\"Class for returning values from SQL Query data model.\"\"\"\n\n    sqlquery: str = Field(..., description=\"A SQL query string.\")\n</code></pre>"},{"location":"api_reference/strategies/filter/sql_query_filter/#oteapi.strategies.filter.sql_query_filter.SqlQueryContent.sqlquery","title":"<code>sqlquery: str = Field(..., description='A SQL query string.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/filter/sql_query_filter/#oteapi.strategies.filter.sql_query_filter.SqlQueryFilterConfig","title":"<code>SqlQueryFilterConfig</code>","text":"<p>               Bases: <code>FilterConfig</code></p> <p>SQL query filter strategy filter config.</p> Source code in <code>oteapi/strategies/filter/sql_query_filter.py</code> <pre><code>class SqlQueryFilterConfig(FilterConfig):\n    \"\"\"SQL query filter strategy filter config.\"\"\"\n\n    filterType: Literal[\"filter/sql\"] = Field(\n        \"filter/sql\",\n        description=FilterConfig.model_fields[\"filterType\"].description,\n    )\n    query: str = Field(..., description=\"A SQL query string.\")\n</code></pre>"},{"location":"api_reference/strategies/filter/sql_query_filter/#oteapi.strategies.filter.sql_query_filter.SqlQueryFilterConfig.filterType","title":"<code>filterType: Literal['filter/sql'] = Field('filter/sql', description=FilterConfig.model_fields['filterType'].description)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/filter/sql_query_filter/#oteapi.strategies.filter.sql_query_filter.SqlQueryFilterConfig.query","title":"<code>query: str = Field(..., description='A SQL query string.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/mapping/mapping/","title":"mapping","text":"<p>Mapping filter strategy.</p>"},{"location":"api_reference/strategies/mapping/mapping/#oteapi.strategies.mapping.mapping.MappingStrategy","title":"<code>MappingStrategy</code>","text":"<p>Strategy for a mapping.</p> <p>The mapping strategy simply adds more prefixes and triples to the <code>prefixes</code> and <code>triples</code> fields in the session such that they are available for other strategies, like function strategies that convert between data models.</p> <p>Nothing is returned to avoid deleting existing mappings.</p> <p>Registers strategies:</p> <ul> <li><code>(\"mappingType\", \"triples\")</code></li> </ul> Source code in <code>oteapi/strategies/mapping/mapping.py</code> <pre><code>@dataclass\nclass MappingStrategy:\n    \"\"\"Strategy for a mapping.\n\n    The mapping strategy simply adds more prefixes and triples to the\n    `prefixes` and `triples` fields in the session such that they are\n    available for other strategies, like function strategies that convert\n    between data models.\n\n    Nothing is returned to avoid deleting existing mappings.\n\n    **Registers strategies**:\n\n    - `(\"mappingType\", \"triples\")`\n\n    \"\"\"\n\n    mapping_config: MappingConfig\n\n    def initialize(self) -&gt; MappingStrategyConfig:\n        \"\"\"Initialize strategy.\"\"\"\n\n        return MappingStrategyConfig(\n            prefixes=self.mapping_config.prefixes, triples=self.mapping_config.triples\n        )\n\n    def get(self) -&gt; AttrDict:\n        \"\"\"Execute strategy and return a dictionary.\"\"\"\n        return AttrDict()\n</code></pre>"},{"location":"api_reference/strategies/mapping/mapping/#oteapi.strategies.mapping.mapping.MappingStrategy.mapping_config","title":"<code>mapping_config: MappingConfig</code>  <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/mapping/mapping/#oteapi.strategies.mapping.mapping.MappingStrategy.get","title":"<code>get()</code>","text":"<p>Execute strategy and return a dictionary.</p> Source code in <code>oteapi/strategies/mapping/mapping.py</code> <pre><code>def get(self) -&gt; AttrDict:\n    \"\"\"Execute strategy and return a dictionary.\"\"\"\n    return AttrDict()\n</code></pre>"},{"location":"api_reference/strategies/mapping/mapping/#oteapi.strategies.mapping.mapping.MappingStrategy.initialize","title":"<code>initialize()</code>","text":"<p>Initialize strategy.</p> Source code in <code>oteapi/strategies/mapping/mapping.py</code> <pre><code>def initialize(self) -&gt; MappingStrategyConfig:\n    \"\"\"Initialize strategy.\"\"\"\n\n    return MappingStrategyConfig(\n        prefixes=self.mapping_config.prefixes, triples=self.mapping_config.triples\n    )\n</code></pre>"},{"location":"api_reference/strategies/mapping/mapping/#oteapi.strategies.mapping.mapping.MappingStrategyConfig","title":"<code>MappingStrategyConfig</code>","text":"<p>               Bases: <code>AttrDict</code></p> <p>AttrDict model for mappings.</p> Source code in <code>oteapi/strategies/mapping/mapping.py</code> <pre><code>class MappingStrategyConfig(AttrDict):\n    \"\"\"AttrDict model for mappings.\"\"\"\n\n    prefixes: Dict[str, str] = Field(\n        ...,\n        description=(\n            \"Dictionary of shortnames that expands to an IRI \"\n            \"given as local value/IRI-expansion-pairs.\"\n        ),\n    )\n    triples: List[RDFTriple] = Field(\n        ...,\n        description=\"List of semantic triples given as (subject, predicate, object).\",\n    )\n</code></pre>"},{"location":"api_reference/strategies/mapping/mapping/#oteapi.strategies.mapping.mapping.MappingStrategyConfig.prefixes","title":"<code>prefixes: Dict[str, str] = Field(..., description='Dictionary of shortnames that expands to an IRI given as local value/IRI-expansion-pairs.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/mapping/mapping/#oteapi.strategies.mapping.mapping.MappingStrategyConfig.triples","title":"<code>triples: List[RDFTriple] = Field(..., description='List of semantic triples given as (subject, predicate, object).')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/parse/application_json/","title":"application_json","text":"<p>Strategy class for application/json.</p>"},{"location":"api_reference/strategies/parse/application_json/#oteapi.strategies.parse.application_json.JSONConfig","title":"<code>JSONConfig</code>","text":"<p>               Bases: <code>AttrDict</code></p> <p>JSON parse-specific Configuration Data Model.</p> Source code in <code>oteapi/strategies/parse/application_json.py</code> <pre><code>class JSONConfig(AttrDict):\n    \"\"\"JSON parse-specific Configuration Data Model.\"\"\"\n\n    downloadUrl: Optional[HostlessAnyUrl] = Field(\n        None, description=\"The HTTP(S) URL, which will be downloaded.\"\n    )\n    mediaType: Literal[\"application/json\"] = Field(\n        \"application/json\",\n        description=(\"The media type\"),\n    )\n    datacache_config: Optional[DataCacheConfig] = Field(\n        None,\n        description=(\n            \"Configurations for the data cache for storing the downloaded file \"\n            \"content.\"\n        ),\n    )\n</code></pre>"},{"location":"api_reference/strategies/parse/application_json/#oteapi.strategies.parse.application_json.JSONConfig.datacache_config","title":"<code>datacache_config: Optional[DataCacheConfig] = Field(None, description='Configurations for the data cache for storing the downloaded file content.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/parse/application_json/#oteapi.strategies.parse.application_json.JSONConfig.downloadUrl","title":"<code>downloadUrl: Optional[HostlessAnyUrl] = Field(None, description='The HTTP(S) URL, which will be downloaded.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/parse/application_json/#oteapi.strategies.parse.application_json.JSONConfig.mediaType","title":"<code>mediaType: Literal['application/json'] = Field('application/json', description='The media type')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/parse/application_json/#oteapi.strategies.parse.application_json.JSONDataParseStrategy","title":"<code>JSONDataParseStrategy</code>","text":"<p>Parse strategy for JSON.</p> <p>Registers strategies:</p> <ul> <li><code>(\"parserType\", \"parser/json\")</code></li> </ul> Source code in <code>oteapi/strategies/parse/application_json.py</code> <pre><code>@dataclass\nclass JSONDataParseStrategy:\n    \"\"\"Parse strategy for JSON.\n\n    **Registers strategies**:\n\n    - `(\"parserType\", \"parser/json\")`\n\n    \"\"\"\n\n    parse_config: JSONParserConfig\n\n    def initialize(self) -&gt; AttrDict:\n        \"\"\"Initialize.\"\"\"\n        return AttrDict()\n\n    def get(self) -&gt; JSONParseContent:\n        \"\"\"Parse json.\"\"\"\n        downloader = create_strategy(\n            \"download\", self.parse_config.configuration.model_dump()\n        )\n        output = downloader.get()\n        cache = DataCache(self.parse_config.configuration.datacache_config)\n        content = cache.get(output[\"key\"])\n\n        if isinstance(content, dict):\n            return JSONParseContent(content=content)\n        return JSONParseContent(content=json.loads(content))\n</code></pre>"},{"location":"api_reference/strategies/parse/application_json/#oteapi.strategies.parse.application_json.JSONDataParseStrategy.parse_config","title":"<code>parse_config: JSONParserConfig</code>  <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/parse/application_json/#oteapi.strategies.parse.application_json.JSONDataParseStrategy.get","title":"<code>get()</code>","text":"<p>Parse json.</p> Source code in <code>oteapi/strategies/parse/application_json.py</code> <pre><code>def get(self) -&gt; JSONParseContent:\n    \"\"\"Parse json.\"\"\"\n    downloader = create_strategy(\n        \"download\", self.parse_config.configuration.model_dump()\n    )\n    output = downloader.get()\n    cache = DataCache(self.parse_config.configuration.datacache_config)\n    content = cache.get(output[\"key\"])\n\n    if isinstance(content, dict):\n        return JSONParseContent(content=content)\n    return JSONParseContent(content=json.loads(content))\n</code></pre>"},{"location":"api_reference/strategies/parse/application_json/#oteapi.strategies.parse.application_json.JSONDataParseStrategy.initialize","title":"<code>initialize()</code>","text":"<p>Initialize.</p> Source code in <code>oteapi/strategies/parse/application_json.py</code> <pre><code>def initialize(self) -&gt; AttrDict:\n    \"\"\"Initialize.\"\"\"\n    return AttrDict()\n</code></pre>"},{"location":"api_reference/strategies/parse/application_json/#oteapi.strategies.parse.application_json.JSONParseContent","title":"<code>JSONParseContent</code>","text":"<p>               Bases: <code>AttrDict</code></p> <p>Class for returning values from JSON Parse.</p> Source code in <code>oteapi/strategies/parse/application_json.py</code> <pre><code>class JSONParseContent(AttrDict):\n    \"\"\"Class for returning values from JSON Parse.\"\"\"\n\n    content: dict = Field(..., description=\"Content of the JSON document.\")\n</code></pre>"},{"location":"api_reference/strategies/parse/application_json/#oteapi.strategies.parse.application_json.JSONParseContent.content","title":"<code>content: dict = Field(..., description='Content of the JSON document.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/parse/application_json/#oteapi.strategies.parse.application_json.JSONParserConfig","title":"<code>JSONParserConfig</code>","text":"<p>               Bases: <code>ParserConfig</code></p> <p>JSON parse strategy filter config.</p> Source code in <code>oteapi/strategies/parse/application_json.py</code> <pre><code>class JSONParserConfig(ParserConfig):\n    \"\"\"JSON parse strategy filter config.\"\"\"\n\n    parserType: Literal[\"parser/json\"] = Field(\n        \"parser/json\",\n        description=ParserConfig.model_fields[\"parserType\"].description,\n    )\n    configuration: JSONConfig = Field(\n        ..., description=\"JSON parse strategy-specific configuration.\"\n    )\n</code></pre>"},{"location":"api_reference/strategies/parse/application_json/#oteapi.strategies.parse.application_json.JSONParserConfig.configuration","title":"<code>configuration: JSONConfig = Field(..., description='JSON parse strategy-specific configuration.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/parse/application_json/#oteapi.strategies.parse.application_json.JSONParserConfig.parserType","title":"<code>parserType: Literal['parser/json'] = Field('parser/json', description=ParserConfig.model_fields['parserType'].description)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/parse/application_vnd_sqlite/","title":"application_vnd_sqlite","text":"<p>Strategy class for application/vnd.sqlite3.</p>"},{"location":"api_reference/strategies/parse/application_vnd_sqlite/#oteapi.strategies.parse.application_vnd_sqlite.SqLiteParseContent","title":"<code>SqLiteParseContent</code>","text":"<p>               Bases: <code>AttrDict</code></p> <p>Configuration model for SqLiteParse.</p> Source code in <code>oteapi/strategies/parse/application_vnd_sqlite.py</code> <pre><code>class SqLiteParseContent(AttrDict):\n    \"\"\"Configuration model for SqLiteParse.\"\"\"\n\n    result: list = Field(..., description=\"List of results from the query.\")\n</code></pre>"},{"location":"api_reference/strategies/parse/application_vnd_sqlite/#oteapi.strategies.parse.application_vnd_sqlite.SqLiteParseContent.result","title":"<code>result: list = Field(..., description='List of results from the query.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/parse/application_vnd_sqlite/#oteapi.strategies.parse.application_vnd_sqlite.SqliteConfig","title":"<code>SqliteConfig</code>","text":"<p>               Bases: <code>AttrDict</code></p> <p>Configuration data model for <code>SqliteParseStrategy</code>.</p> Source code in <code>oteapi/strategies/parse/application_vnd_sqlite.py</code> <pre><code>class SqliteConfig(AttrDict):\n    \"\"\"Configuration data model for\n    [`SqliteParseStrategy`][oteapi.strategies.parse.application_vnd_sqlite.SqliteParseStrategy].\n    \"\"\"\n\n    # Resource config\n    downloadUrl: Optional[HostlessAnyUrl] = Field(\n        None, description=ResourceConfig.model_fields[\"downloadUrl\"].description\n    )\n    mediaType: Literal[\"application/vnd.sqlite3\"] = Field(\n        \"application/vnd.sqlite3\",\n        description=ResourceConfig.model_fields[\"mediaType\"].description,\n    )\n\n    # SQLite parse strategy-specific config\n    sqlquery: str = Field(\"\", description=\"A SQL query string.\")\n    datacache_config: Optional[DataCacheConfig] = Field(\n        None,\n        description=\"Configuration options for the local data cache.\",\n    )\n</code></pre>"},{"location":"api_reference/strategies/parse/application_vnd_sqlite/#oteapi.strategies.parse.application_vnd_sqlite.SqliteConfig.datacache_config","title":"<code>datacache_config: Optional[DataCacheConfig] = Field(None, description='Configuration options for the local data cache.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/parse/application_vnd_sqlite/#oteapi.strategies.parse.application_vnd_sqlite.SqliteConfig.downloadUrl","title":"<code>downloadUrl: Optional[HostlessAnyUrl] = Field(None, description=ResourceConfig.model_fields['downloadUrl'].description)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/parse/application_vnd_sqlite/#oteapi.strategies.parse.application_vnd_sqlite.SqliteConfig.mediaType","title":"<code>mediaType: Literal['application/vnd.sqlite3'] = Field('application/vnd.sqlite3', description=ResourceConfig.model_fields['mediaType'].description)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/parse/application_vnd_sqlite/#oteapi.strategies.parse.application_vnd_sqlite.SqliteConfig.sqlquery","title":"<code>sqlquery: str = Field('', description='A SQL query string.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/parse/application_vnd_sqlite/#oteapi.strategies.parse.application_vnd_sqlite.SqliteParseStrategy","title":"<code>SqliteParseStrategy</code>","text":"<p>Parse strategy for SQLite.</p> <p>Purpose of this strategy: Download a SQLite database using <code>downloadUrl</code> and run a SQL query on the database to return all relevant rows.</p> Source code in <code>oteapi/strategies/parse/application_vnd_sqlite.py</code> <pre><code>@dataclass\nclass SqliteParseStrategy:\n    \"\"\"Parse strategy for SQLite.\n\n    Purpose of this strategy: Download a SQLite database using `downloadUrl` and run a\n    SQL query on the database to return all relevant rows.\n\n    \"\"\"\n\n    parse_config: SqliteParserConfig\n\n    def initialize(self) -&gt; AttrDict:\n        \"\"\"Initialize strategy.\"\"\"\n        return AttrDict()\n\n    def get(self) -&gt; SqLiteParseContent:\n        \"\"\"Parse SQLite query responses.\"\"\"\n\n        if self.parse_config.configuration.downloadUrl is None:\n            raise ValueError(\"No download URL provided.\")\n\n        if self.parse_config.configuration.mediaType != \"application/vnd.sqlite3\":\n            raise ValueError(\"Invalid media type.\")\n\n        # Retrieve SQLite file\n        downloader = create_strategy(\n            \"download\", self.parse_config.configuration.model_dump()\n        )\n        cache_key = downloader.get()[\"key\"]\n\n        cache = DataCache(self.parse_config.configuration.datacache_config)\n        with cache.getfile(cache_key, suffix=\"db\") as filename:\n            connection = create_connection(filename)\n            cursor = connection.cursor()\n            result = cursor.execute(self.parse_config.configuration.sqlquery).fetchall()\n            connection.close()\n        return SqLiteParseContent(result=result)\n</code></pre>"},{"location":"api_reference/strategies/parse/application_vnd_sqlite/#oteapi.strategies.parse.application_vnd_sqlite.SqliteParseStrategy.parse_config","title":"<code>parse_config: SqliteParserConfig</code>  <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/parse/application_vnd_sqlite/#oteapi.strategies.parse.application_vnd_sqlite.SqliteParseStrategy.get","title":"<code>get()</code>","text":"<p>Parse SQLite query responses.</p> Source code in <code>oteapi/strategies/parse/application_vnd_sqlite.py</code> <pre><code>def get(self) -&gt; SqLiteParseContent:\n    \"\"\"Parse SQLite query responses.\"\"\"\n\n    if self.parse_config.configuration.downloadUrl is None:\n        raise ValueError(\"No download URL provided.\")\n\n    if self.parse_config.configuration.mediaType != \"application/vnd.sqlite3\":\n        raise ValueError(\"Invalid media type.\")\n\n    # Retrieve SQLite file\n    downloader = create_strategy(\n        \"download\", self.parse_config.configuration.model_dump()\n    )\n    cache_key = downloader.get()[\"key\"]\n\n    cache = DataCache(self.parse_config.configuration.datacache_config)\n    with cache.getfile(cache_key, suffix=\"db\") as filename:\n        connection = create_connection(filename)\n        cursor = connection.cursor()\n        result = cursor.execute(self.parse_config.configuration.sqlquery).fetchall()\n        connection.close()\n    return SqLiteParseContent(result=result)\n</code></pre>"},{"location":"api_reference/strategies/parse/application_vnd_sqlite/#oteapi.strategies.parse.application_vnd_sqlite.SqliteParseStrategy.initialize","title":"<code>initialize()</code>","text":"<p>Initialize strategy.</p> Source code in <code>oteapi/strategies/parse/application_vnd_sqlite.py</code> <pre><code>def initialize(self) -&gt; AttrDict:\n    \"\"\"Initialize strategy.\"\"\"\n    return AttrDict()\n</code></pre>"},{"location":"api_reference/strategies/parse/application_vnd_sqlite/#oteapi.strategies.parse.application_vnd_sqlite.SqliteParserConfig","title":"<code>SqliteParserConfig</code>","text":"<p>               Bases: <code>ParserConfig</code></p> <p>SQLite parse strategy resource config.</p> Source code in <code>oteapi/strategies/parse/application_vnd_sqlite.py</code> <pre><code>class SqliteParserConfig(ParserConfig):\n    \"\"\"SQLite parse strategy resource config.\"\"\"\n\n    parserType: Literal[\"parser/sqlite3\"] = Field(\n        \"parser/sqlite3\",\n        description=ParserConfig.model_fields[\"parserType\"].description,\n    )\n    configuration: SqliteConfig = Field(\n        ..., description=\"SQLite parse strategy-specific configuration.\"\n    )\n</code></pre>"},{"location":"api_reference/strategies/parse/application_vnd_sqlite/#oteapi.strategies.parse.application_vnd_sqlite.SqliteParserConfig.configuration","title":"<code>configuration: SqliteConfig = Field(..., description='SQLite parse strategy-specific configuration.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/parse/application_vnd_sqlite/#oteapi.strategies.parse.application_vnd_sqlite.SqliteParserConfig.parserType","title":"<code>parserType: Literal['parser/sqlite3'] = Field('parser/sqlite3', description=ParserConfig.model_fields['parserType'].description)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/parse/application_vnd_sqlite/#oteapi.strategies.parse.application_vnd_sqlite.create_connection","title":"<code>create_connection(db_file)</code>","text":"<p>Create a database connection to SQLite database.</p> <p>Parameters:</p> Name Type Description Default <code>db_file</code> <code>Path</code> <p>Full path to SQLite database file.</p> required <p>Raises:</p> Type Description <code>Error</code> <p>If a DB connection cannot be made.</p> <p>Returns:</p> Type Description <code>Connection</code> <p>Connection object.</p> Source code in <code>oteapi/strategies/parse/application_vnd_sqlite.py</code> <pre><code>def create_connection(db_file: Path) -&gt; sqlite3.Connection:\n    \"\"\"Create a database connection to SQLite database.\n\n    Parameters:\n        db_file: Full path to SQLite database file.\n\n    Raises:\n        sqlite3.Error: If a DB connection cannot be made.\n\n    Returns:\n        Connection object.\n\n    \"\"\"\n    try:\n        return sqlite3.connect(db_file)\n    except sqlite3.Error as exc:\n        raise sqlite3.Error(\"Could not connect to given SQLite DB.\") from exc\n</code></pre>"},{"location":"api_reference/strategies/parse/excel_xlsx/","title":"excel_xlsx","text":"<p>Strategy class for workbook/xlsx.</p>"},{"location":"api_reference/strategies/parse/excel_xlsx/#oteapi.strategies.parse.excel_xlsx.XLSXParseConfig","title":"<code>XLSXParseConfig</code>","text":"<p>               Bases: <code>AttrDict</code></p> <p>Data model for retrieving a rectangular section of an Excel sheet.</p> Source code in <code>oteapi/strategies/parse/excel_xlsx.py</code> <pre><code>class XLSXParseConfig(AttrDict):\n    \"\"\"Data model for retrieving a rectangular section of an Excel sheet.\"\"\"\n\n    # Resource config\n    downloadUrl: Optional[HostlessAnyUrl] = Field(\n        None, description=ResourceConfig.model_fields[\"downloadUrl\"].description\n    )\n    mediaType: Literal[\n        \"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\"\n    ] = Field(\n        \"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\",\n        description=ResourceConfig.model_fields[\"mediaType\"].description,\n    )\n\n    # XLSX parse strategy-specific config\n    worksheet: str = Field(..., description=\"Name of worksheet to load.\")\n    row_from: Optional[int] = Field(\n        None,\n        description=\"Excel row number of first row. Defaults to first assigned row.\",\n    )\n    col_from: Optional[Union[int, str]] = Field(\n        None,\n        description=(\n            \"Excel column number or label of first column. Defaults to first assigned \"\n            \"column.\"\n        ),\n    )\n    row_to: Optional[int] = Field(\n        None, description=\"Excel row number of last row. Defaults to last assigned row.\"\n    )\n    col_to: Optional[Union[int, str]] = Field(\n        None,\n        description=(\n            \"Excel column number or label of last column. Defaults to last assigned \"\n            \"column.\"\n        ),\n    )\n    header_row: Optional[int] = Field(\n        None,\n        description=(\n            \"Row number with the headers. Defaults to `1` if header is given, \"\n            \"otherwise `None`.\"\n        ),\n    )\n    header: Optional[List[str]] = Field(\n        None,\n        description=(\n            \"Optional list of column names, specifying the columns to return. \"\n            \"These names they should match cells in `header_row`.\"\n        ),\n    )\n    new_header: Optional[List[str]] = Field(\n        None,\n        description=(\n            \"Optional list of new column names replacing `header` in the output.\"\n        ),\n    )\n    download_config: AttrDict = Field(\n        AttrDict(),\n        description=\"Configurations provided to a download strategy.\",\n    )\n    datacache_config: Optional[DataCacheConfig] = Field(\n        None,\n        description=(\n            \"Configurations for the data cache for retrieving the downloaded file \"\n            \"content.\"\n        ),\n    )\n</code></pre>"},{"location":"api_reference/strategies/parse/excel_xlsx/#oteapi.strategies.parse.excel_xlsx.XLSXParseConfig.col_from","title":"<code>col_from: Optional[Union[int, str]] = Field(None, description='Excel column number or label of first column. Defaults to first assigned column.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/parse/excel_xlsx/#oteapi.strategies.parse.excel_xlsx.XLSXParseConfig.col_to","title":"<code>col_to: Optional[Union[int, str]] = Field(None, description='Excel column number or label of last column. Defaults to last assigned column.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/parse/excel_xlsx/#oteapi.strategies.parse.excel_xlsx.XLSXParseConfig.datacache_config","title":"<code>datacache_config: Optional[DataCacheConfig] = Field(None, description='Configurations for the data cache for retrieving the downloaded file content.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/parse/excel_xlsx/#oteapi.strategies.parse.excel_xlsx.XLSXParseConfig.downloadUrl","title":"<code>downloadUrl: Optional[HostlessAnyUrl] = Field(None, description=ResourceConfig.model_fields['downloadUrl'].description)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/parse/excel_xlsx/#oteapi.strategies.parse.excel_xlsx.XLSXParseConfig.download_config","title":"<code>download_config: AttrDict = Field(AttrDict(), description='Configurations provided to a download strategy.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/parse/excel_xlsx/#oteapi.strategies.parse.excel_xlsx.XLSXParseConfig.header","title":"<code>header: Optional[List[str]] = Field(None, description='Optional list of column names, specifying the columns to return. These names they should match cells in `header_row`.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/parse/excel_xlsx/#oteapi.strategies.parse.excel_xlsx.XLSXParseConfig.header_row","title":"<code>header_row: Optional[int] = Field(None, description='Row number with the headers. Defaults to `1` if header is given, otherwise `None`.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/parse/excel_xlsx/#oteapi.strategies.parse.excel_xlsx.XLSXParseConfig.mediaType","title":"<code>mediaType: Literal['application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'] = Field('application/vnd.openxmlformats-officedocument.spreadsheetml.sheet', description=ResourceConfig.model_fields['mediaType'].description)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/parse/excel_xlsx/#oteapi.strategies.parse.excel_xlsx.XLSXParseConfig.new_header","title":"<code>new_header: Optional[List[str]] = Field(None, description='Optional list of new column names replacing `header` in the output.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/parse/excel_xlsx/#oteapi.strategies.parse.excel_xlsx.XLSXParseConfig.row_from","title":"<code>row_from: Optional[int] = Field(None, description='Excel row number of first row. Defaults to first assigned row.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/parse/excel_xlsx/#oteapi.strategies.parse.excel_xlsx.XLSXParseConfig.row_to","title":"<code>row_to: Optional[int] = Field(None, description='Excel row number of last row. Defaults to last assigned row.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/parse/excel_xlsx/#oteapi.strategies.parse.excel_xlsx.XLSXParseConfig.worksheet","title":"<code>worksheet: str = Field(..., description='Name of worksheet to load.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/parse/excel_xlsx/#oteapi.strategies.parse.excel_xlsx.XLSXParseContent","title":"<code>XLSXParseContent</code>","text":"<p>               Bases: <code>AttrDict</code></p> <p>Class for returning values from XLSXParse.</p> Source code in <code>oteapi/strategies/parse/excel_xlsx.py</code> <pre><code>class XLSXParseContent(AttrDict):\n    \"\"\"Class for returning values from XLSXParse.\"\"\"\n\n    data: Dict[str, list] = Field(\n        ...,\n        description=\"A dict with column-name/column-value pairs. The values are lists.\",\n    )\n</code></pre>"},{"location":"api_reference/strategies/parse/excel_xlsx/#oteapi.strategies.parse.excel_xlsx.XLSXParseContent.data","title":"<code>data: Dict[str, list] = Field(..., description='A dict with column-name/column-value pairs. The values are lists.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/parse/excel_xlsx/#oteapi.strategies.parse.excel_xlsx.XLSXParseParserConfig","title":"<code>XLSXParseParserConfig</code>","text":"<p>               Bases: <code>ParserConfig</code></p> <p>XLSX parse strategy resource config.</p> Source code in <code>oteapi/strategies/parse/excel_xlsx.py</code> <pre><code>class XLSXParseParserConfig(ParserConfig):\n    \"\"\"XLSX parse strategy resource config.\"\"\"\n\n    parserType: Literal[\"parser/excel_xlsx\"] = Field(\n        \"parser/excel_xlsx\",\n        description=ParserConfig.model_fields[\"parserType\"].description,\n    )\n    configuration: XLSXParseConfig = Field(\n        ..., description=\"SQLite parse strategy-specific configuration.\"\n    )\n</code></pre>"},{"location":"api_reference/strategies/parse/excel_xlsx/#oteapi.strategies.parse.excel_xlsx.XLSXParseParserConfig.configuration","title":"<code>configuration: XLSXParseConfig = Field(..., description='SQLite parse strategy-specific configuration.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/parse/excel_xlsx/#oteapi.strategies.parse.excel_xlsx.XLSXParseParserConfig.parserType","title":"<code>parserType: Literal['parser/excel_xlsx'] = Field('parser/excel_xlsx', description=ParserConfig.model_fields['parserType'].description)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/parse/excel_xlsx/#oteapi.strategies.parse.excel_xlsx.XLSXParseStrategy","title":"<code>XLSXParseStrategy</code>","text":"<p>Parse strategy for Excel XLSX files.</p> <p>Registers strategies:</p> <ul> <li><code>(\"parserType\", \"excel_xlsx\")</code></li> </ul> Source code in <code>oteapi/strategies/parse/excel_xlsx.py</code> <pre><code>@dataclass\nclass XLSXParseStrategy:\n    \"\"\"Parse strategy for Excel XLSX files.\n\n    **Registers strategies**:\n\n    - `(\"parserType\", \"excel_xlsx\")`\n\n    \"\"\"\n\n    parse_config: XLSXParseParserConfig\n\n    def initialize(self) -&gt; AttrDict:\n        \"\"\"Initialize.\"\"\"\n        return AttrDict()\n\n    def get(self) -&gt; XLSXParseContent:\n        \"\"\"Parses selected region of an excel file.\n\n        Returns:\n            A dict with column-name/column-value pairs. The values are lists.\n\n        \"\"\"\n\n        config = self.parse_config.configuration\n\n        # Download the file\n        download_config = config.model_dump()\n        download_config[\"configuration\"] = config.download_config.model_dump()\n        output = create_strategy(\"download\", download_config).get()\n\n        if config.datacache_config and config.datacache_config.accessKey:\n            cache_key = config.datacache_config.accessKey\n        elif \"key\" in output:\n            cache_key = output[\"key\"]\n        else:\n            raise RuntimeError(\"No data cache key provided to the downloaded content\")\n\n        cache = DataCache(config.datacache_config)\n\n        with cache.getfile(key=cache_key, suffix=\".xlsx\") as filename:\n            # Note that we have to set read_only=False to ensure that\n            # load_workbook() properly closes the xlsx file after reading.\n            # Otherwise Windows will fail when the temporary file is removed\n            # when leaving the with statement.\n            workbook = load_workbook(filename=filename, read_only=False, data_only=True)\n\n        worksheet = workbook[config.worksheet]\n        set_model_defaults(config, worksheet)\n        columns = get_column_indices(config, worksheet)\n\n        data = []\n        for row in worksheet.iter_rows(\n            min_row=config.row_from,\n            max_row=config.row_to,\n            min_col=min(columns),\n            max_col=max(columns),\n        ):\n            data.append([row[c - 1].value for c in columns])\n\n        if config.header_row:\n            row = worksheet.iter_rows(\n                min_row=config.header_row,\n                max_row=config.header_row,\n                min_col=min(columns),\n                max_col=max(columns),\n            ).__next__()\n            header = [row[c - 1].value for c in columns]\n        else:\n            header = None\n\n        if config.new_header:\n            nhead = len(header) if header else len(data[0]) if data else 0\n            if len(config.new_header) != nhead:\n                raise TypeError(\n                    \"length of `new_header` \"\n                    f\"(={len(config.new_header)}) \"\n                    f\"doesn't match number of columns (={len(header) if header else 0})\"\n                )\n            if header:\n                for i, val in enumerate(config.new_header):\n                    if val is not None:\n                        header[i] = val\n            elif data:\n                header = config.new_header\n\n        if header is None:\n            header = [get_column_letter(col + 1) for col in range(len(data))]\n\n        transposed = [list(datum) for datum in zip(*data)]\n        return XLSXParseContent(\n            data={key: value for key, value in zip(header, transposed)}\n        )\n</code></pre>"},{"location":"api_reference/strategies/parse/excel_xlsx/#oteapi.strategies.parse.excel_xlsx.XLSXParseStrategy.parse_config","title":"<code>parse_config: XLSXParseParserConfig</code>  <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/parse/excel_xlsx/#oteapi.strategies.parse.excel_xlsx.XLSXParseStrategy.get","title":"<code>get()</code>","text":"<p>Parses selected region of an excel file.</p> <p>Returns:</p> Type Description <code>XLSXParseContent</code> <p>A dict with column-name/column-value pairs. The values are lists.</p> Source code in <code>oteapi/strategies/parse/excel_xlsx.py</code> <pre><code>def get(self) -&gt; XLSXParseContent:\n    \"\"\"Parses selected region of an excel file.\n\n    Returns:\n        A dict with column-name/column-value pairs. The values are lists.\n\n    \"\"\"\n\n    config = self.parse_config.configuration\n\n    # Download the file\n    download_config = config.model_dump()\n    download_config[\"configuration\"] = config.download_config.model_dump()\n    output = create_strategy(\"download\", download_config).get()\n\n    if config.datacache_config and config.datacache_config.accessKey:\n        cache_key = config.datacache_config.accessKey\n    elif \"key\" in output:\n        cache_key = output[\"key\"]\n    else:\n        raise RuntimeError(\"No data cache key provided to the downloaded content\")\n\n    cache = DataCache(config.datacache_config)\n\n    with cache.getfile(key=cache_key, suffix=\".xlsx\") as filename:\n        # Note that we have to set read_only=False to ensure that\n        # load_workbook() properly closes the xlsx file after reading.\n        # Otherwise Windows will fail when the temporary file is removed\n        # when leaving the with statement.\n        workbook = load_workbook(filename=filename, read_only=False, data_only=True)\n\n    worksheet = workbook[config.worksheet]\n    set_model_defaults(config, worksheet)\n    columns = get_column_indices(config, worksheet)\n\n    data = []\n    for row in worksheet.iter_rows(\n        min_row=config.row_from,\n        max_row=config.row_to,\n        min_col=min(columns),\n        max_col=max(columns),\n    ):\n        data.append([row[c - 1].value for c in columns])\n\n    if config.header_row:\n        row = worksheet.iter_rows(\n            min_row=config.header_row,\n            max_row=config.header_row,\n            min_col=min(columns),\n            max_col=max(columns),\n        ).__next__()\n        header = [row[c - 1].value for c in columns]\n    else:\n        header = None\n\n    if config.new_header:\n        nhead = len(header) if header else len(data[0]) if data else 0\n        if len(config.new_header) != nhead:\n            raise TypeError(\n                \"length of `new_header` \"\n                f\"(={len(config.new_header)}) \"\n                f\"doesn't match number of columns (={len(header) if header else 0})\"\n            )\n        if header:\n            for i, val in enumerate(config.new_header):\n                if val is not None:\n                    header[i] = val\n        elif data:\n            header = config.new_header\n\n    if header is None:\n        header = [get_column_letter(col + 1) for col in range(len(data))]\n\n    transposed = [list(datum) for datum in zip(*data)]\n    return XLSXParseContent(\n        data={key: value for key, value in zip(header, transposed)}\n    )\n</code></pre>"},{"location":"api_reference/strategies/parse/excel_xlsx/#oteapi.strategies.parse.excel_xlsx.XLSXParseStrategy.initialize","title":"<code>initialize()</code>","text":"<p>Initialize.</p> Source code in <code>oteapi/strategies/parse/excel_xlsx.py</code> <pre><code>def initialize(self) -&gt; AttrDict:\n    \"\"\"Initialize.\"\"\"\n    return AttrDict()\n</code></pre>"},{"location":"api_reference/strategies/parse/excel_xlsx/#oteapi.strategies.parse.excel_xlsx.get_column_indices","title":"<code>get_column_indices(model, worksheet)</code>","text":"<p>Helper function returning a list of column indices.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>XLSXParseConfig</code> <p>The parsed data model.</p> required <code>worksheet</code> <code>Worksheet</code> <p>Excel worksheet, from which the header values will be retrieved.</p> required <p>Returns:</p> Type Description <code>Iterable[int]</code> <p>A list of column indices.</p> Source code in <code>oteapi/strategies/parse/excel_xlsx.py</code> <pre><code>def get_column_indices(\n    model: XLSXParseConfig, worksheet: \"Worksheet\"\n) -&gt; \"Iterable[int]\":\n    \"\"\"Helper function returning a list of column indices.\n\n    Parameters:\n        model: The parsed data model.\n        worksheet: Excel worksheet, from which the header values will be retrieved.\n\n    Returns:\n        A list of column indices.\n\n    \"\"\"\n    if not isinstance(model.col_from, int) or not isinstance(model.col_to, int):\n        raise TypeError(\"Expected `model.col_from` and `model.col_to` to be integers.\")\n\n    if model.header:\n        header_dict = {\n            worksheet.cell(model.header_row, col).value: col\n            for col in range(model.col_from, model.col_to + 1)\n        }\n        return [header_dict[h] for h in model.header]\n    return range(model.col_from, model.col_to + 1)\n</code></pre>"},{"location":"api_reference/strategies/parse/excel_xlsx/#oteapi.strategies.parse.excel_xlsx.set_model_defaults","title":"<code>set_model_defaults(model, worksheet)</code>","text":"<p>Update data model <code>model</code> with default values obtained from <code>worksheet</code>.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>XLSXParseConfig</code> <p>The parsed data model.</p> required <code>worksheet</code> <code>Worksheet</code> <p>Excel worksheet, from which the default values will be obtained.</p> required Source code in <code>oteapi/strategies/parse/excel_xlsx.py</code> <pre><code>def set_model_defaults(model: XLSXParseConfig, worksheet: \"Worksheet\") -&gt; None:\n    \"\"\"Update data model `model` with default values obtained from `worksheet`.\n\n    Parameters:\n        model: The parsed data model.\n        worksheet: Excel worksheet, from which the default values will be obtained.\n\n    \"\"\"\n    if model.row_from is None:\n        if model.header:\n            # assume that data starts on the first row after the header\n            model.row_from = model.header_row + 1 if model.header_row else 1\n        else:\n            model.row_from = worksheet.min_row\n\n    if model.row_to is None:\n        model.row_to = worksheet.max_row\n\n    if model.col_from is None:\n        model.col_from = worksheet.min_column\n    elif isinstance(model.col_from, str):\n        model.col_from = column_index_from_string(model.col_from)\n\n    if model.col_to is None:\n        model.col_to = worksheet.max_column\n    elif isinstance(model.col_to, str):\n        model.col_to = column_index_from_string(model.col_to)\n\n    if model.header and not model.header_row:\n        model.header_row = 1\n</code></pre>"},{"location":"api_reference/strategies/parse/image/","title":"image","text":"<p>Strategy class for image/jpg.</p>"},{"location":"api_reference/strategies/parse/image/#oteapi.strategies.parse.image.ImageConfig","title":"<code>ImageConfig</code>","text":"<p>               Bases: <code>AttrDict</code></p> <p>Configuration data model for <code>ImageDataParseStrategy</code>.</p> Source code in <code>oteapi/strategies/parse/image.py</code> <pre><code>class ImageConfig(AttrDict):\n    \"\"\"Configuration data model for\n    [`ImageDataParseStrategy`][oteapi.strategies.parse.image.ImageDataParseStrategy].\"\"\"\n\n    # Resource config\n    downloadUrl: Optional[HostlessAnyUrl] = Field(\n        None, description=ResourceConfig.model_fields[\"downloadUrl\"].description\n    )\n    mediaType: Optional[\n        Literal[\n            \"image/jpg\",\n            \"image/jpeg\",\n            \"image/jp2\",\n            \"image/png\",\n            \"image/gif\",\n            \"image/tiff\",\n            \"image/eps\",\n        ]\n    ] = Field(\n        None,\n        description=ResourceConfig.model_fields[\"mediaType\"].description,\n    )\n\n    # Image parse strategy-specific config\n    crop: Optional[Tuple[int, int, int, int]] = Field(\n        None,\n        description=\"Box cropping parameters (left, top, right, bottom).\",\n        # Effectively mapping 'imagecrop' to 'crop'.\n        # 'imagecrop' is used by the crop filter strategy.\n        validation_alias=AliasChoices(\"crop\", \"imagecrop\"),\n    )\n    datacache_config: Optional[DataCacheConfig] = Field(\n        None,\n        description=\"Configuration options for the local data cache.\",\n    )\n    image_key: Optional[str] = Field(\n        None,\n        description=\"Key to use when storing the image data in datacache.\",\n    )\n    image_mode: Optional[str] = Field(\n        None,\n        description=(\n            \"Pillow mode to convert image into. See \"\n            \"https://pillow.readthedocs.io/en/stable/handbook/concepts.html \"\n            \"for details.\"\n        ),\n    )\n</code></pre>"},{"location":"api_reference/strategies/parse/image/#oteapi.strategies.parse.image.ImageConfig.crop","title":"<code>crop: Optional[Tuple[int, int, int, int]] = Field(None, description='Box cropping parameters (left, top, right, bottom).', validation_alias=AliasChoices('crop', 'imagecrop'))</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/parse/image/#oteapi.strategies.parse.image.ImageConfig.datacache_config","title":"<code>datacache_config: Optional[DataCacheConfig] = Field(None, description='Configuration options for the local data cache.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/parse/image/#oteapi.strategies.parse.image.ImageConfig.downloadUrl","title":"<code>downloadUrl: Optional[HostlessAnyUrl] = Field(None, description=ResourceConfig.model_fields['downloadUrl'].description)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/parse/image/#oteapi.strategies.parse.image.ImageConfig.image_key","title":"<code>image_key: Optional[str] = Field(None, description='Key to use when storing the image data in datacache.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/parse/image/#oteapi.strategies.parse.image.ImageConfig.image_mode","title":"<code>image_mode: Optional[str] = Field(None, description='Pillow mode to convert image into. See https://pillow.readthedocs.io/en/stable/handbook/concepts.html for details.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/parse/image/#oteapi.strategies.parse.image.ImageConfig.mediaType","title":"<code>mediaType: Optional[Literal['image/jpg', 'image/jpeg', 'image/jp2', 'image/png', 'image/gif', 'image/tiff', 'image/eps']] = Field(None, description=ResourceConfig.model_fields['mediaType'].description)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/parse/image/#oteapi.strategies.parse.image.ImageDataParseStrategy","title":"<code>ImageDataParseStrategy</code>","text":"<p>Parse strategy for images.</p> <p>This strategy uses Pillow to read a raw image from the data cache, converts it into a NumPy array and stores the new array in the data cache.</p> <p>It also supports simple cropping and image conversions.</p> <p>The key to the new array and other metadata is returned. See <code>ImageParseContent</code> for more info.</p> Source code in <code>oteapi/strategies/parse/image.py</code> <pre><code>@dataclass\nclass ImageDataParseStrategy:\n    \"\"\"Parse strategy for images.\n\n    This strategy uses Pillow to read a raw image from the data cache,\n    converts it into a NumPy array and stores the new array in the\n    data cache.\n\n    It also supports simple cropping and image conversions.\n\n    The key to the new array and other metadata is returned. See\n    [`ImageParseContent`][oteapi.strategies.parse.image.ImageParseContent]\n    for more info.\n\n    \"\"\"\n\n    parse_config: ImageParserConfig\n\n    def initialize(self) -&gt; AttrDict:\n        \"\"\"Initialize strategy.\"\"\"\n        return AttrDict()\n\n    def get(self) -&gt; ImageParseContent:\n        \"\"\"Execute the strategy.\"\"\"\n\n        config = self.parse_config.configuration\n\n        if config.mediaType is None:\n            raise ValueError(\"No media type provided to the image parser\")\n\n        mime_format = config.mediaType.split(\"/\")[1]\n        image_format = SupportedFormat[mime_format].value\n\n        # Download the image\n        download_config = config.model_dump()\n        download_config[\"configuration\"] = config.model_dump()\n        output = create_strategy(\"download\", download_config).get()\n\n        if config.datacache_config and config.datacache_config.accessKey:\n            cache_key = config.datacache_config.accessKey\n        elif \"key\" in output:\n            cache_key = output[\"key\"]\n        else:\n            raise RuntimeError(\"No data cache key provided to the downloaded content\")\n\n        cache = DataCache(config.datacache_config)\n\n        # Treat image according to filter values\n        with (\n            cache.getfile(cache_key, suffix=mime_format) as filename,\n            Image.open(filename, formats=[image_format]) as image,\n        ):\n            if config.crop:\n                image = image.crop(config.crop)\n            if config.image_mode:\n                image = image.convert(mode=config.image_mode)\n\n            if image_format == \"GIF\" and image.info.get(\"version\", b\"\").startswith(\n                b\"GIF\"\n            ):\n                image.info.update(\n                    {\"version\": image.info.get(\"version\", b\"\")[len(b\"GIF\") :]}\n                )\n\n            image_key = cache.add(\n                image.tobytes(),\n                key=config.image_key,\n            )\n\n            if image.mode == \"P\":\n                image_palette_key = cache.add(image.getpalette())\n            else:\n                image_palette_key = None\n\n            # The returned content must be json serialisable - filter out all\n            # non-json serialisable fields in image.info\n            if image.info:\n                image_info = {\n                    key: val\n                    for key, val in image.info.items()\n                    if isinstance(val, (str, int, float, type(None), bool, tuple, list))\n                }\n            else:\n                image_info = {}\n\n            content = ImageParseContent(\n                image_key=image_key,\n                image_size=image.size,\n                image_mode=image.mode,\n                image_palette_key=image_palette_key,\n                image_info=image_info,\n            )\n\n        return content\n</code></pre>"},{"location":"api_reference/strategies/parse/image/#oteapi.strategies.parse.image.ImageDataParseStrategy.parse_config","title":"<code>parse_config: ImageParserConfig</code>  <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/parse/image/#oteapi.strategies.parse.image.ImageDataParseStrategy.get","title":"<code>get()</code>","text":"<p>Execute the strategy.</p> Source code in <code>oteapi/strategies/parse/image.py</code> <pre><code>def get(self) -&gt; ImageParseContent:\n    \"\"\"Execute the strategy.\"\"\"\n\n    config = self.parse_config.configuration\n\n    if config.mediaType is None:\n        raise ValueError(\"No media type provided to the image parser\")\n\n    mime_format = config.mediaType.split(\"/\")[1]\n    image_format = SupportedFormat[mime_format].value\n\n    # Download the image\n    download_config = config.model_dump()\n    download_config[\"configuration\"] = config.model_dump()\n    output = create_strategy(\"download\", download_config).get()\n\n    if config.datacache_config and config.datacache_config.accessKey:\n        cache_key = config.datacache_config.accessKey\n    elif \"key\" in output:\n        cache_key = output[\"key\"]\n    else:\n        raise RuntimeError(\"No data cache key provided to the downloaded content\")\n\n    cache = DataCache(config.datacache_config)\n\n    # Treat image according to filter values\n    with (\n        cache.getfile(cache_key, suffix=mime_format) as filename,\n        Image.open(filename, formats=[image_format]) as image,\n    ):\n        if config.crop:\n            image = image.crop(config.crop)\n        if config.image_mode:\n            image = image.convert(mode=config.image_mode)\n\n        if image_format == \"GIF\" and image.info.get(\"version\", b\"\").startswith(\n            b\"GIF\"\n        ):\n            image.info.update(\n                {\"version\": image.info.get(\"version\", b\"\")[len(b\"GIF\") :]}\n            )\n\n        image_key = cache.add(\n            image.tobytes(),\n            key=config.image_key,\n        )\n\n        if image.mode == \"P\":\n            image_palette_key = cache.add(image.getpalette())\n        else:\n            image_palette_key = None\n\n        # The returned content must be json serialisable - filter out all\n        # non-json serialisable fields in image.info\n        if image.info:\n            image_info = {\n                key: val\n                for key, val in image.info.items()\n                if isinstance(val, (str, int, float, type(None), bool, tuple, list))\n            }\n        else:\n            image_info = {}\n\n        content = ImageParseContent(\n            image_key=image_key,\n            image_size=image.size,\n            image_mode=image.mode,\n            image_palette_key=image_palette_key,\n            image_info=image_info,\n        )\n\n    return content\n</code></pre>"},{"location":"api_reference/strategies/parse/image/#oteapi.strategies.parse.image.ImageDataParseStrategy.initialize","title":"<code>initialize()</code>","text":"<p>Initialize strategy.</p> Source code in <code>oteapi/strategies/parse/image.py</code> <pre><code>def initialize(self) -&gt; AttrDict:\n    \"\"\"Initialize strategy.\"\"\"\n    return AttrDict()\n</code></pre>"},{"location":"api_reference/strategies/parse/image/#oteapi.strategies.parse.image.ImageParseContent","title":"<code>ImageParseContent</code>","text":"<p>               Bases: <code>AttrDict</code></p> <p>Configuration model for the returned content from the Image parser.</p> <p>See Pillow handbook for more details on <code>image_mode</code>, <code>image_palette</code>, and <code>image_info</code>.</p> Source code in <code>oteapi/strategies/parse/image.py</code> <pre><code>class ImageParseContent(AttrDict):\n    \"\"\"Configuration model for the returned content from the Image parser.\n\n    See\n    [Pillow handbook](https://pillow.readthedocs.io/en/stable/handbook/concepts.html)\n    for more details on `image_mode`, `image_palette`, and `image_info`.\n    \"\"\"\n\n    image_key: str = Field(\n        ...,\n        description=\"Key with which the image content is stored in the data cache.\",\n    )\n    image_size: Tuple[int, int] = Field(\n        ...,\n        description=\"Image size (width, height).\",\n    )\n    image_mode: str = Field(\n        ...,\n        description=\"Image mode. Examples: 'L', 'P', 'RGB', 'RGBA'...\",\n    )\n    image_palette_key: Optional[str] = Field(\n        None,\n        description=\"Datacache key for colour palette if mode is 'P'.\",\n    )\n    image_info: dict = Field(\n        {},\n        description=\"Additional information about the image.\",\n    )\n</code></pre>"},{"location":"api_reference/strategies/parse/image/#oteapi.strategies.parse.image.ImageParseContent.image_info","title":"<code>image_info: dict = Field({}, description='Additional information about the image.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/parse/image/#oteapi.strategies.parse.image.ImageParseContent.image_key","title":"<code>image_key: str = Field(..., description='Key with which the image content is stored in the data cache.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/parse/image/#oteapi.strategies.parse.image.ImageParseContent.image_mode","title":"<code>image_mode: str = Field(..., description=\"Image mode. Examples: 'L', 'P', 'RGB', 'RGBA'...\")</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/parse/image/#oteapi.strategies.parse.image.ImageParseContent.image_palette_key","title":"<code>image_palette_key: Optional[str] = Field(None, description=\"Datacache key for colour palette if mode is 'P'.\")</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/parse/image/#oteapi.strategies.parse.image.ImageParseContent.image_size","title":"<code>image_size: Tuple[int, int] = Field(..., description='Image size (width, height).')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/parse/image/#oteapi.strategies.parse.image.ImageParserConfig","title":"<code>ImageParserConfig</code>","text":"<p>               Bases: <code>ParserConfig</code></p> <p>Image parse strategy resource config.</p> Source code in <code>oteapi/strategies/parse/image.py</code> <pre><code>class ImageParserConfig(ParserConfig):\n    \"\"\"Image parse strategy resource config.\"\"\"\n\n    parserType: Literal[\"parser/image\"] = Field(\n        \"parser/image\",\n        description=ParserConfig.model_fields[\"parserType\"].description,\n    )\n    configuration: ImageConfig = Field(\n        ...,\n        description=\"Image parse strategy-specific configuration.\",\n    )\n</code></pre>"},{"location":"api_reference/strategies/parse/image/#oteapi.strategies.parse.image.ImageParserConfig.configuration","title":"<code>configuration: ImageConfig = Field(..., description='Image parse strategy-specific configuration.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/parse/image/#oteapi.strategies.parse.image.ImageParserConfig.parserType","title":"<code>parserType: Literal['parser/image'] = Field('parser/image', description=ParserConfig.model_fields['parserType'].description)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/parse/image/#oteapi.strategies.parse.image.SupportedFormat","title":"<code>SupportedFormat</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Supported formats for <code>ImageDataParseStrategy</code>.</p> Source code in <code>oteapi/strategies/parse/image.py</code> <pre><code>class SupportedFormat(Enum):\n    \"\"\"Supported formats for `ImageDataParseStrategy`.\"\"\"\n\n    jpeg = \"JPEG\"\n    jpg = \"JPEG\"\n    jp2 = \"JPEG2000\"\n    png = \"PNG\"\n    gif = \"GIF\"\n    tiff = \"TIFF\"\n    eps = \"EPS\"\n</code></pre>"},{"location":"api_reference/strategies/parse/image/#oteapi.strategies.parse.image.SupportedFormat.eps","title":"<code>eps = 'EPS'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/parse/image/#oteapi.strategies.parse.image.SupportedFormat.gif","title":"<code>gif = 'GIF'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/parse/image/#oteapi.strategies.parse.image.SupportedFormat.jp2","title":"<code>jp2 = 'JPEG2000'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/parse/image/#oteapi.strategies.parse.image.SupportedFormat.jpeg","title":"<code>jpeg = 'JPEG'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/parse/image/#oteapi.strategies.parse.image.SupportedFormat.jpg","title":"<code>jpg = 'JPEG'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/parse/image/#oteapi.strategies.parse.image.SupportedFormat.png","title":"<code>png = 'PNG'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/parse/image/#oteapi.strategies.parse.image.SupportedFormat.tiff","title":"<code>tiff = 'TIFF'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/parse/postgres/","title":"postgres","text":"<p>Strategy class for application/vnd.postgresql</p>"},{"location":"api_reference/strategies/parse/postgres/#oteapi.strategies.parse.postgres.PostgresConfig","title":"<code>PostgresConfig</code>","text":"<p>               Bases: <code>AttrDict</code></p> <p>Configuration data model for <code>PostgresParserStrategy</code>.</p> Source code in <code>oteapi/strategies/parse/postgres.py</code> <pre><code>class PostgresConfig(AttrDict):\n    \"\"\"Configuration data model for\n    [`PostgresParserStrategy`][oteapi.strategies.parse.postgres.PostgresParserConfig].\n    \"\"\"\n\n    # Resource config\n    accessService: Literal[\"postgres\"] = Field(\n        \"postgres\",\n        description=ResourceConfig.model_fields[\"accessService\"].description,\n    )\n    accessUrl: Optional[HostlessAnyUrl] = Field(\n        None,\n        description=ResourceConfig.model_fields[\"accessUrl\"].description,\n    )\n\n    # Postgres specific config\n    datacache_config: Optional[DataCacheConfig] = Field(\n        None,\n        description=\"Configuration options for the local data cache.\",\n    )\n    user: Optional[str] = Field(None, description=\"postgres server username\")\n    dbname: Optional[str] = Field(None, description=\"postgres dbname name\")\n    password: Optional[str] = Field(None, description=\"postgres password\")\n    sqlquery: str = Field(\"\", description=\"A SQL query string.\")\n\n    @model_validator(mode=\"before\")\n    @classmethod\n    def adjust_url(cls, data: Any) -&gt; \"Dict[str, Any]\":\n        \"\"\"Model Validator\n        Verifies configuration consistency, merge configurations\n        and update the accessUrl property.\n        \"\"\"\n        if isinstance(data, BaseModel):\n            data = data.model_dump()\n        elif not isinstance(data, dict):\n            raise TypeError(\n                \"invalid data type, should be either dict or pydantic model\"\n            )\n\n        if \"accessUrl\" not in data:\n            return data\n\n        # Copy model-state into placeholders\n        accessUrl = AnyUrl(data[\"accessUrl\"])\n        default_config = PostgresConfig()\n        current_config: dict[str, Any] = data.get(\"configuration\", {})\n\n        if not accessUrl.host:\n            raise ValueError(\"missing host in accessUrl\")\n\n        def _get_and_validate_config_value(url_parameter: str, config_key: str) -&gt; str:\n            \"\"\"Get value from accessUrl or current_config, and check for mismatches.\"\"\"\n            value_from_url = getattr(accessUrl, url_parameter, None)\n            value_from_config = current_config.get(\n                config_key, getattr(default_config, config_key)\n            )\n\n            final_value = value_from_url or value_from_config\n\n            if value_from_config and final_value != value_from_config:\n                raise ValueError(\n                    f\"mismatching {url_parameter} in accessUrl and {config_key} in \"\n                    \"configuration\"\n                )\n\n            return final_value\n\n        user = _get_and_validate_config_value(\"username\", \"user\")\n        password = _get_and_validate_config_value(\"password\", \"password\")\n        dbname = _get_and_validate_config_value(\"path\", \"dbname\")\n\n        # Reconstruct accessUrl from the updated properties\n        data[\"accessUrl\"] = accessUrl.__class__.build(\n            scheme=accessUrl.scheme,\n            username=user,\n            password=password,\n            host=accessUrl.host,\n            port=accessUrl.port,\n            path=dbname,\n            query=accessUrl.query,\n            fragment=accessUrl.fragment,\n        )\n        return data\n</code></pre>"},{"location":"api_reference/strategies/parse/postgres/#oteapi.strategies.parse.postgres.PostgresConfig.accessService","title":"<code>accessService: Literal['postgres'] = Field('postgres', description=ResourceConfig.model_fields['accessService'].description)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/parse/postgres/#oteapi.strategies.parse.postgres.PostgresConfig.accessUrl","title":"<code>accessUrl: Optional[HostlessAnyUrl] = Field(None, description=ResourceConfig.model_fields['accessUrl'].description)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/parse/postgres/#oteapi.strategies.parse.postgres.PostgresConfig.datacache_config","title":"<code>datacache_config: Optional[DataCacheConfig] = Field(None, description='Configuration options for the local data cache.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/parse/postgres/#oteapi.strategies.parse.postgres.PostgresConfig.dbname","title":"<code>dbname: Optional[str] = Field(None, description='postgres dbname name')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/parse/postgres/#oteapi.strategies.parse.postgres.PostgresConfig.password","title":"<code>password: Optional[str] = Field(None, description='postgres password')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/parse/postgres/#oteapi.strategies.parse.postgres.PostgresConfig.sqlquery","title":"<code>sqlquery: str = Field('', description='A SQL query string.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/parse/postgres/#oteapi.strategies.parse.postgres.PostgresConfig.user","title":"<code>user: Optional[str] = Field(None, description='postgres server username')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/parse/postgres/#oteapi.strategies.parse.postgres.PostgresConfig.adjust_url","title":"<code>adjust_url(data)</code>  <code>classmethod</code>","text":"<p>Model Validator Verifies configuration consistency, merge configurations and update the accessUrl property.</p> Source code in <code>oteapi/strategies/parse/postgres.py</code> <pre><code>@model_validator(mode=\"before\")\n@classmethod\ndef adjust_url(cls, data: Any) -&gt; \"Dict[str, Any]\":\n    \"\"\"Model Validator\n    Verifies configuration consistency, merge configurations\n    and update the accessUrl property.\n    \"\"\"\n    if isinstance(data, BaseModel):\n        data = data.model_dump()\n    elif not isinstance(data, dict):\n        raise TypeError(\n            \"invalid data type, should be either dict or pydantic model\"\n        )\n\n    if \"accessUrl\" not in data:\n        return data\n\n    # Copy model-state into placeholders\n    accessUrl = AnyUrl(data[\"accessUrl\"])\n    default_config = PostgresConfig()\n    current_config: dict[str, Any] = data.get(\"configuration\", {})\n\n    if not accessUrl.host:\n        raise ValueError(\"missing host in accessUrl\")\n\n    def _get_and_validate_config_value(url_parameter: str, config_key: str) -&gt; str:\n        \"\"\"Get value from accessUrl or current_config, and check for mismatches.\"\"\"\n        value_from_url = getattr(accessUrl, url_parameter, None)\n        value_from_config = current_config.get(\n            config_key, getattr(default_config, config_key)\n        )\n\n        final_value = value_from_url or value_from_config\n\n        if value_from_config and final_value != value_from_config:\n            raise ValueError(\n                f\"mismatching {url_parameter} in accessUrl and {config_key} in \"\n                \"configuration\"\n            )\n\n        return final_value\n\n    user = _get_and_validate_config_value(\"username\", \"user\")\n    password = _get_and_validate_config_value(\"password\", \"password\")\n    dbname = _get_and_validate_config_value(\"path\", \"dbname\")\n\n    # Reconstruct accessUrl from the updated properties\n    data[\"accessUrl\"] = accessUrl.__class__.build(\n        scheme=accessUrl.scheme,\n        username=user,\n        password=password,\n        host=accessUrl.host,\n        port=accessUrl.port,\n        path=dbname,\n        query=accessUrl.query,\n        fragment=accessUrl.fragment,\n    )\n    return data\n</code></pre>"},{"location":"api_reference/strategies/parse/postgres/#oteapi.strategies.parse.postgres.PostgresParserConfig","title":"<code>PostgresParserConfig</code>","text":"<p>               Bases: <code>ParserConfig</code></p> <p>Postgresql parse strategy config</p> Source code in <code>oteapi/strategies/parse/postgres.py</code> <pre><code>class PostgresParserConfig(ParserConfig):\n    \"\"\"Postgresql parse strategy config\"\"\"\n\n    parserType: Literal[\"parser/postgres\"] = Field(\n        \"parser/postgres\",\n        description=\"Type of registered resource strategy.\",\n    )\n    configuration: PostgresConfig = Field(\n        ...,\n        description=(\n            \"Configuration for resource. Values in the accessURL take precedence.\"\n        ),\n    )\n</code></pre>"},{"location":"api_reference/strategies/parse/postgres/#oteapi.strategies.parse.postgres.PostgresParserConfig.configuration","title":"<code>configuration: PostgresConfig = Field(..., description='Configuration for resource. Values in the accessURL take precedence.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/parse/postgres/#oteapi.strategies.parse.postgres.PostgresParserConfig.parserType","title":"<code>parserType: Literal['parser/postgres'] = Field('parser/postgres', description='Type of registered resource strategy.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/parse/postgres/#oteapi.strategies.parse.postgres.PostgresParserContent","title":"<code>PostgresParserContent</code>","text":"<p>               Bases: <code>AttrDict</code></p> <p>Configuration model for PostgresParser.</p> Source code in <code>oteapi/strategies/parse/postgres.py</code> <pre><code>class PostgresParserContent(AttrDict):\n    \"\"\"Configuration model for PostgresParser.\"\"\"\n\n    result: list = Field(..., description=\"List of results from the query.\")\n</code></pre>"},{"location":"api_reference/strategies/parse/postgres/#oteapi.strategies.parse.postgres.PostgresParserContent.result","title":"<code>result: list = Field(..., description='List of results from the query.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/parse/postgres/#oteapi.strategies.parse.postgres.PostgresParserStrategy","title":"<code>PostgresParserStrategy</code>","text":"<p>Resource strategy for Postgres.</p> <p>Purpose of this strategy: Connect to a postgres DB and run a SQL query on the dbname to return all relevant rows.</p> Source code in <code>oteapi/strategies/parse/postgres.py</code> <pre><code>@dataclass\nclass PostgresParserStrategy:\n    \"\"\"Resource strategy for Postgres.\n\n    Purpose of this strategy: Connect to a postgres DB and run a\n    SQL query on the dbname to return all relevant rows.\n\n    \"\"\"\n\n    parser_config: PostgresParserConfig\n\n    def initialize(self) -&gt; AttrDict:\n        \"\"\"Initialize strategy.\"\"\"\n        return AttrDict()\n\n    def get(self) -&gt; PostgresParserContent:\n        \"\"\"Resource Postgres query responses.\"\"\"\n\n        if self.parser_config.configuration.accessUrl is None:\n            raise ValueError(\"accessUrl is required for PostgresParserStrategy\")\n\n        connection = create_connection(str(self.parser_config.configuration.accessUrl))\n        cursor = connection.cursor()\n        result = cursor.execute(self.parser_config.configuration.sqlquery).fetchall()\n        connection.close()\n        return PostgresParserContent(result=result)\n</code></pre>"},{"location":"api_reference/strategies/parse/postgres/#oteapi.strategies.parse.postgres.PostgresParserStrategy.parser_config","title":"<code>parser_config: PostgresParserConfig</code>  <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/parse/postgres/#oteapi.strategies.parse.postgres.PostgresParserStrategy.get","title":"<code>get()</code>","text":"<p>Resource Postgres query responses.</p> Source code in <code>oteapi/strategies/parse/postgres.py</code> <pre><code>def get(self) -&gt; PostgresParserContent:\n    \"\"\"Resource Postgres query responses.\"\"\"\n\n    if self.parser_config.configuration.accessUrl is None:\n        raise ValueError(\"accessUrl is required for PostgresParserStrategy\")\n\n    connection = create_connection(str(self.parser_config.configuration.accessUrl))\n    cursor = connection.cursor()\n    result = cursor.execute(self.parser_config.configuration.sqlquery).fetchall()\n    connection.close()\n    return PostgresParserContent(result=result)\n</code></pre>"},{"location":"api_reference/strategies/parse/postgres/#oteapi.strategies.parse.postgres.PostgresParserStrategy.initialize","title":"<code>initialize()</code>","text":"<p>Initialize strategy.</p> Source code in <code>oteapi/strategies/parse/postgres.py</code> <pre><code>def initialize(self) -&gt; AttrDict:\n    \"\"\"Initialize strategy.\"\"\"\n    return AttrDict()\n</code></pre>"},{"location":"api_reference/strategies/parse/postgres/#oteapi.strategies.parse.postgres.create_connection","title":"<code>create_connection(url)</code>","text":"<p>Create a dbname connection to Postgres dbname.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>A valid PostgreSQL URL.</p> required <p>Raises:</p> Type Description <code>Error</code> <p>If a DB connection cannot be made.</p> <p>Returns:</p> Type Description <code>Connection</code> <p>Connection object.</p> Source code in <code>oteapi/strategies/parse/postgres.py</code> <pre><code>def create_connection(url: str) -&gt; psycopg.Connection:\n    \"\"\"Create a dbname connection to Postgres dbname.\n\n    Parameters:\n        url: A valid PostgreSQL URL.\n\n    Raises:\n        psycopg.Error: If a DB connection cannot be made.\n\n    Returns:\n        Connection object.\n\n    \"\"\"\n    try:\n        return psycopg.connect(url)\n    except psycopg.Error as exc:\n        raise psycopg.Error(\"Could not connect to given Postgres DB.\") from exc\n</code></pre>"},{"location":"api_reference/strategies/parse/text_csv/","title":"text_csv","text":"<p>Strategy class for parser/csv.</p>"},{"location":"api_reference/strategies/parse/text_csv/#oteapi.strategies.parse.text_csv.CSVDialect","title":"<code>CSVDialect: Type[Enum] = Enum(value='CSVDialect', names={dialect.upper(): dialectfor dialect in csv.list_dialects()}, module=__name__, type=str)</code>  <code>module-attribute</code>","text":"<p>CSV dialects.</p> <p>All available dialects are retrieved through the <code>csv.list_dialects()</code> function, and will thus depend on the currently loaded and used Python interpreter.</p>"},{"location":"api_reference/strategies/parse/text_csv/#oteapi.strategies.parse.text_csv.CSVConfig","title":"<code>CSVConfig</code>","text":"<p>               Bases: <code>AttrDict</code></p> <p>CSV parse-specific Configuration Data Model.</p> Source code in <code>oteapi/strategies/parse/text_csv.py</code> <pre><code>class CSVConfig(AttrDict):\n    \"\"\"CSV parse-specific Configuration Data Model.\"\"\"\n\n    # Resource config\n    downloadUrl: Optional[HostlessAnyUrl] = Field(\n        None,\n        description=ResourceConfig.model_fields[\"downloadUrl\"].description,\n    )\n    mediaType: Literal[\"text/csv\"] = Field(\n        \"text/csv\",\n        description=ResourceConfig.model_fields[\"mediaType\"].description,\n    )\n\n    # CSV parse strategy-specific configuration\n    datacache_config: Optional[DataCacheConfig] = Field(\n        None,\n        description=(\n            \"Configurations for the data cache for storing the downloaded file \"\n            \"content.\"\n        ),\n    )\n    dialect: DialectFormatting = Field(\n        DialectFormatting(),\n        description=(\n            \"Dialect and formatting parameters. See [the Python docs]\"\n            \"(https://docs.python.org/3/library/csv.html#csv-fmt-params) for more \"\n            \"information.\"\n        ),\n    )\n    reader: ReaderConfig = Field(\n        ReaderConfig(),\n        description=(\n            \"CSV DictReader configuration parameters. See [the Python docs]\"\n            \"(https://docs.python.org/3/library/csv.html#csv.DictReader) for more \"\n            \"information.\"\n        ),\n    )\n</code></pre>"},{"location":"api_reference/strategies/parse/text_csv/#oteapi.strategies.parse.text_csv.CSVConfig.datacache_config","title":"<code>datacache_config: Optional[DataCacheConfig] = Field(None, description='Configurations for the data cache for storing the downloaded file content.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/parse/text_csv/#oteapi.strategies.parse.text_csv.CSVConfig.dialect","title":"<code>dialect: DialectFormatting = Field(DialectFormatting(), description='Dialect and formatting parameters. See [the Python docs](https://docs.python.org/3/library/csv.html#csv-fmt-params) for more information.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/parse/text_csv/#oteapi.strategies.parse.text_csv.CSVConfig.downloadUrl","title":"<code>downloadUrl: Optional[HostlessAnyUrl] = Field(None, description=ResourceConfig.model_fields['downloadUrl'].description)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/parse/text_csv/#oteapi.strategies.parse.text_csv.CSVConfig.mediaType","title":"<code>mediaType: Literal['text/csv'] = Field('text/csv', description=ResourceConfig.model_fields['mediaType'].description)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/parse/text_csv/#oteapi.strategies.parse.text_csv.CSVConfig.reader","title":"<code>reader: ReaderConfig = Field(ReaderConfig(), description='CSV DictReader configuration parameters. See [the Python docs](https://docs.python.org/3/library/csv.html#csv.DictReader) for more information.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/parse/text_csv/#oteapi.strategies.parse.text_csv.CSVParseContent","title":"<code>CSVParseContent</code>","text":"<p>               Bases: <code>AttrDict</code></p> <p>Class for returning values from CSV Parse.</p> Source code in <code>oteapi/strategies/parse/text_csv.py</code> <pre><code>class CSVParseContent(AttrDict):\n    \"\"\"Class for returning values from CSV Parse.\"\"\"\n\n    content: dict[Union[str, None], list[Any]] = Field(\n        ..., description=\"Content of the CSV document.\"\n    )\n</code></pre>"},{"location":"api_reference/strategies/parse/text_csv/#oteapi.strategies.parse.text_csv.CSVParseContent.content","title":"<code>content: dict[Union[str, None], list[Any]] = Field(..., description='Content of the CSV document.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/parse/text_csv/#oteapi.strategies.parse.text_csv.CSVParseStrategy","title":"<code>CSVParseStrategy</code>","text":"<p>Parse strategy for CSV files.</p> Source code in <code>oteapi/strategies/parse/text_csv.py</code> <pre><code>@dataclass\nclass CSVParseStrategy:\n    \"\"\"Parse strategy for CSV files.\"\"\"\n\n    parse_config: CSVParserConfig\n\n    def initialize(self) -&gt; AttrDict:\n        \"\"\"Initialize.\"\"\"\n        return AttrDict()\n\n    def get(self) -&gt; CSVParseContent:\n        \"\"\"Parse CSV.\"\"\"\n        config = self.parse_config.configuration\n\n        # Download the file\n        download_config = config.model_dump()\n        download_config[\"configuration\"] = config.model_dump()\n        output = create_strategy(\"download\", download_config).get()\n\n        if config.datacache_config and config.datacache_config.accessKey:\n            cache_key = config.datacache_config.accessKey\n        elif \"key\" in output:\n            cache_key = output[\"key\"]\n        else:\n            raise RuntimeError(\"No data cache key provided to the downloaded content\")\n\n        cache = DataCache(config.datacache_config)\n\n        with cache.getfile(cache_key) as csvfile_path:\n            kwargs = config.dialect.model_dump(\n                exclude={\"base\", \"quoting\"}, exclude_unset=True\n            )\n\n            dialect = config.dialect.base\n            if dialect:\n                kwargs[\"dialect\"] = dialect.value\n            quoting = config.dialect.quoting\n            if quoting:\n                kwargs[\"quoting\"] = quoting.csv_constant()\n\n            kwargs.update(config.reader.model_dump(exclude_unset=True))\n\n            with open(\n                csvfile_path,\n                newline=\"\",\n                encoding=config.reader.encoding,\n            ) as csvfile:\n                csvreader = csv.DictReader(csvfile, **kwargs)\n                content: dict[Union[str, None], list[Any]] = defaultdict(list)\n                for row in csvreader:\n                    for field, value in row.items():\n                        if (\n                            csvreader.reader.dialect.quoting == csv.QUOTE_NONNUMERIC\n                            and isinstance(value, float)\n                            and value.is_integer()\n                        ):\n                            value = int(value)\n                        content[field].append(value)\n\n        for key in list(content):\n            if any(isinstance(value, float) for value in content[key]):\n                content[key] = [\n                    (\n                        float(value)\n                        if (value or value == 0.0 or value == 0)\n                        and value != csvreader.restval\n                        else float(\"nan\")\n                    )\n                    for value in content[key]\n                ]\n                continue\n            if any(isinstance(value, int) for value in content[key]):\n                content[key] = [\n                    (\n                        int(value)\n                        if (value or value == 0) and value != csvreader.restval\n                        else csvreader.restval\n                    )\n                    for value in content[key]\n                ]\n\n        return CSVParseContent(content=content)\n</code></pre>"},{"location":"api_reference/strategies/parse/text_csv/#oteapi.strategies.parse.text_csv.CSVParseStrategy.parse_config","title":"<code>parse_config: CSVParserConfig</code>  <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/parse/text_csv/#oteapi.strategies.parse.text_csv.CSVParseStrategy.get","title":"<code>get()</code>","text":"<p>Parse CSV.</p> Source code in <code>oteapi/strategies/parse/text_csv.py</code> <pre><code>def get(self) -&gt; CSVParseContent:\n    \"\"\"Parse CSV.\"\"\"\n    config = self.parse_config.configuration\n\n    # Download the file\n    download_config = config.model_dump()\n    download_config[\"configuration\"] = config.model_dump()\n    output = create_strategy(\"download\", download_config).get()\n\n    if config.datacache_config and config.datacache_config.accessKey:\n        cache_key = config.datacache_config.accessKey\n    elif \"key\" in output:\n        cache_key = output[\"key\"]\n    else:\n        raise RuntimeError(\"No data cache key provided to the downloaded content\")\n\n    cache = DataCache(config.datacache_config)\n\n    with cache.getfile(cache_key) as csvfile_path:\n        kwargs = config.dialect.model_dump(\n            exclude={\"base\", \"quoting\"}, exclude_unset=True\n        )\n\n        dialect = config.dialect.base\n        if dialect:\n            kwargs[\"dialect\"] = dialect.value\n        quoting = config.dialect.quoting\n        if quoting:\n            kwargs[\"quoting\"] = quoting.csv_constant()\n\n        kwargs.update(config.reader.model_dump(exclude_unset=True))\n\n        with open(\n            csvfile_path,\n            newline=\"\",\n            encoding=config.reader.encoding,\n        ) as csvfile:\n            csvreader = csv.DictReader(csvfile, **kwargs)\n            content: dict[Union[str, None], list[Any]] = defaultdict(list)\n            for row in csvreader:\n                for field, value in row.items():\n                    if (\n                        csvreader.reader.dialect.quoting == csv.QUOTE_NONNUMERIC\n                        and isinstance(value, float)\n                        and value.is_integer()\n                    ):\n                        value = int(value)\n                    content[field].append(value)\n\n    for key in list(content):\n        if any(isinstance(value, float) for value in content[key]):\n            content[key] = [\n                (\n                    float(value)\n                    if (value or value == 0.0 or value == 0)\n                    and value != csvreader.restval\n                    else float(\"nan\")\n                )\n                for value in content[key]\n            ]\n            continue\n        if any(isinstance(value, int) for value in content[key]):\n            content[key] = [\n                (\n                    int(value)\n                    if (value or value == 0) and value != csvreader.restval\n                    else csvreader.restval\n                )\n                for value in content[key]\n            ]\n\n    return CSVParseContent(content=content)\n</code></pre>"},{"location":"api_reference/strategies/parse/text_csv/#oteapi.strategies.parse.text_csv.CSVParseStrategy.initialize","title":"<code>initialize()</code>","text":"<p>Initialize.</p> Source code in <code>oteapi/strategies/parse/text_csv.py</code> <pre><code>def initialize(self) -&gt; AttrDict:\n    \"\"\"Initialize.\"\"\"\n    return AttrDict()\n</code></pre>"},{"location":"api_reference/strategies/parse/text_csv/#oteapi.strategies.parse.text_csv.CSVParserConfig","title":"<code>CSVParserConfig</code>","text":"<p>               Bases: <code>ParserConfig</code></p> <p>CSV parse strategy filter config.</p> Source code in <code>oteapi/strategies/parse/text_csv.py</code> <pre><code>class CSVParserConfig(ParserConfig):\n    \"\"\"CSV parse strategy filter config.\"\"\"\n\n    parserType: Literal[\"parser/csv\"] = Field(\n        \"parser/csv\",\n        description=ParserConfig.model_fields[\"parserType\"].description,\n    )\n    configuration: CSVConfig = Field(\n        ..., description=\"CSV parse strategy-specific configuration.\"\n    )\n</code></pre>"},{"location":"api_reference/strategies/parse/text_csv/#oteapi.strategies.parse.text_csv.CSVParserConfig.configuration","title":"<code>configuration: CSVConfig = Field(..., description='CSV parse strategy-specific configuration.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/parse/text_csv/#oteapi.strategies.parse.text_csv.CSVParserConfig.parserType","title":"<code>parserType: Literal['parser/csv'] = Field('parser/csv', description=ParserConfig.model_fields['parserType'].description)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/parse/text_csv/#oteapi.strategies.parse.text_csv.DialectFormatting","title":"<code>DialectFormatting</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Dialect and formatting parameters for CSV.</p> <p>See the Python docs for more information.</p> Note <p>As <code>Dialect.lineterminator</code> is hardcoded in <code>csv.reader</code>, it is left out of this model.</p> Source code in <code>oteapi/strategies/parse/text_csv.py</code> <pre><code>class DialectFormatting(BaseModel):\n    \"\"\"Dialect and formatting parameters for CSV.\n\n    See [the Python docs](https://docs.python.org/3/library/csv.html#csv-fmt-params)\n    for more information.\n\n    Note:\n        As `Dialect.lineterminator` is hardcoded in `csv.reader`, it is left out of\n        this model.\n\n    \"\"\"\n\n    base: Optional[CSVDialect] = Field(\n        None,\n        description=(\n            \"A specific CSV dialect, e.g., 'excel'. Any other parameters here will \"\n            \"overwrite the preset dialect parameters for the specified dialect.\"\n        ),\n    )\n    delimiter: Optional[str] = Field(\n        None,\n        description=(\n            \"A one-character string used to separate fields. \"\n            \"See [the Python docs entry](https://docs.python.org/3/library/csv.html\"\n            \"#csv.Dialect.delimiter) for more information.\"\n        ),\n        min_length=1,\n        max_length=1,\n    )\n    doublequote: Optional[bool] = Field(\n        None,\n        description=(\n            \"Controls how instances of [`quotechar`]\"\n            \"[oteapi.strategies.parse.text_csv.DialectFormatting.quotechar] \"\n            \"appearing inside a field should themselves be quoted. When `True`, the \"\n            \"character is doubled. When `False`, the [`escapechar`]\"\n            \"[oteapi.strategies.parse.text_csv.DialectFormatting.escapechar] \"\n            \"is used as a prefix to the [`quotechar`]\"\n            \"[oteapi.strategies.parse.text_csv.DialectFormatting.quotechar]. \"\n            \"See [the Python docs entry]\"\n            \"(https://docs.python.org/3/library/csv.html#csv.Dialect.doublequote) \"\n            \"for more information.\"\n        ),\n    )\n    escapechar: Optional[str] = Field(\n        None,\n        description=(\n            \"A one-character string used by the writer to escape the [`delimiter`]\"\n            \"[oteapi.strategies.parse.text_csv.DialectFormatting.delimiter] if \"\n            \"[`quoting`][oteapi.strategies.parse.text_csv.DialectFormatting.quoting] \"\n            \"is set to [`QUOTE_NONE`]\"\n            \"[oteapi.strategies.parse.text_csv.QuoteConstants.QUOTE_NONE] and the \"\n            \"[`quotechar`][oteapi.strategies.parse.text_csv.DialectFormatting.\"\n            \"quotechar] if [`doublequote`][oteapi.strategies.parse.text_csv.\"\n            \"DialectFormatting.doublequote] is `False`. On reading, the \"\n            \"[`escapechar`][oteapi.strategies.parse.text_csv.DialectFormatting.\"\n            \"escapechar] removes any special meaning from the following character. \"\n            \"See [the Python docs entry]\"\n            \"(https://docs.python.org/3/library/csv.html#csv.Dialect.escapechar) \"\n            \"for more information.\"\n        ),\n        min_length=1,\n        max_length=1,\n    )\n    quotechar: Optional[str] = Field(\n        None,\n        description=(\n            \"A one-character string used to quote fields containing special \"\n            \"characters, such as the [`delimiter`]\"\n            \"[oteapi.strategies.parse.text_csv.DialectFormatting.delimiter] or \"\n            \"[`quotechar`][oteapi.strategies.parse.text_csv.DialectFormatting.\"\n            \"quotechar], or which contain new-line characters. See \"\n            \"[the Python docs entry](https://docs.python.org/3/library/csv.html\"\n            \"#csv.Dialect.quotechar) for more information.\"\n        ),\n        min_length=1,\n        max_length=1,\n    )\n    quoting: Optional[QuoteConstants] = Field(\n        None,\n        description=(\n            \"Controls when quotes should be generated by the writer and recognised by \"\n            \"the reader. It can take on any of the `QUOTE_*` constants (see section \"\n            \"[Module Contents](https://docs.python.org/3/library/csv.html\"\n            \"#csv-contents)). See [the Python docs entry]\"\n            \"(https://docs.python.org/3/library/csv.html#csv.Dialect.quoting) \"\n            \"for more information.\"\n        ),\n    )\n    skipinitialspace: Optional[bool] = Field(\n        None,\n        description=(\n            \"When `True`, whitespace immediately following the [`delimiter`]\"\n            \"[oteapi.strategies.parse.text_csv.DialectFormatting.delimiter] is \"\n            \"ignored. See [the Python docs entry]\"\n            \"(https://docs.python.org/3/library/csv.html#csv.Dialect.skipinitialspace)\"\n            \" for more information.\"\n        ),\n    )\n    strict: Optional[bool] = Field(\n        None,\n        description=(\n            \"When `True`, raise exception [Error]\"\n            \"(https://docs.python.org/3/library/csv.html#csv.Error) on bad CSV input. \"\n            \"See [the Python docs entry](https://docs.python.org/3/library/csv.html\"\n            \"#csv.Dialect.strict) for more information.\"\n        ),\n    )\n\n    @field_validator(\"base\")\n    @classmethod\n    def validate_dialect_base(cls, value: str) -&gt; str:\n        \"\"\"Ensure the given `base` dialect is registered locally.\"\"\"\n        if value not in csv.list_dialects():\n            raise ValueError(\n                f\"{value!r} is not a known registered CSV dialect. \"\n                f\"Registered dialects: {', '.join(csv.list_dialects())}.\"\n            )\n        return value\n</code></pre>"},{"location":"api_reference/strategies/parse/text_csv/#oteapi.strategies.parse.text_csv.DialectFormatting.base","title":"<code>base: Optional[CSVDialect] = Field(None, description=\"A specific CSV dialect, e.g., 'excel'. Any other parameters here will overwrite the preset dialect parameters for the specified dialect.\")</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/parse/text_csv/#oteapi.strategies.parse.text_csv.DialectFormatting.delimiter","title":"<code>delimiter: Optional[str] = Field(None, description='A one-character string used to separate fields. See [the Python docs entry](https://docs.python.org/3/library/csv.html#csv.Dialect.delimiter) for more information.', min_length=1, max_length=1)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/parse/text_csv/#oteapi.strategies.parse.text_csv.DialectFormatting.doublequote","title":"<code>doublequote: Optional[bool] = Field(None, description='Controls how instances of [`quotechar`][oteapi.strategies.parse.text_csv.DialectFormatting.quotechar] appearing inside a field should themselves be quoted. When `True`, the character is doubled. When `False`, the [`escapechar`][oteapi.strategies.parse.text_csv.DialectFormatting.escapechar] is used as a prefix to the [`quotechar`][oteapi.strategies.parse.text_csv.DialectFormatting.quotechar]. See [the Python docs entry](https://docs.python.org/3/library/csv.html#csv.Dialect.doublequote) for more information.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/parse/text_csv/#oteapi.strategies.parse.text_csv.DialectFormatting.escapechar","title":"<code>escapechar: Optional[str] = Field(None, description='A one-character string used by the writer to escape the [`delimiter`][oteapi.strategies.parse.text_csv.DialectFormatting.delimiter] if [`quoting`][oteapi.strategies.parse.text_csv.DialectFormatting.quoting] is set to [`QUOTE_NONE`][oteapi.strategies.parse.text_csv.QuoteConstants.QUOTE_NONE] and the [`quotechar`][oteapi.strategies.parse.text_csv.DialectFormatting.quotechar] if [`doublequote`][oteapi.strategies.parse.text_csv.DialectFormatting.doublequote] is `False`. On reading, the [`escapechar`][oteapi.strategies.parse.text_csv.DialectFormatting.escapechar] removes any special meaning from the following character. See [the Python docs entry](https://docs.python.org/3/library/csv.html#csv.Dialect.escapechar) for more information.', min_length=1, max_length=1)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/parse/text_csv/#oteapi.strategies.parse.text_csv.DialectFormatting.quotechar","title":"<code>quotechar: Optional[str] = Field(None, description='A one-character string used to quote fields containing special characters, such as the [`delimiter`][oteapi.strategies.parse.text_csv.DialectFormatting.delimiter] or [`quotechar`][oteapi.strategies.parse.text_csv.DialectFormatting.quotechar], or which contain new-line characters. See [the Python docs entry](https://docs.python.org/3/library/csv.html#csv.Dialect.quotechar) for more information.', min_length=1, max_length=1)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/parse/text_csv/#oteapi.strategies.parse.text_csv.DialectFormatting.quoting","title":"<code>quoting: Optional[QuoteConstants] = Field(None, description='Controls when quotes should be generated by the writer and recognised by the reader. It can take on any of the `QUOTE_*` constants (see section [Module Contents](https://docs.python.org/3/library/csv.html#csv-contents)). See [the Python docs entry](https://docs.python.org/3/library/csv.html#csv.Dialect.quoting) for more information.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/parse/text_csv/#oteapi.strategies.parse.text_csv.DialectFormatting.skipinitialspace","title":"<code>skipinitialspace: Optional[bool] = Field(None, description='When `True`, whitespace immediately following the [`delimiter`][oteapi.strategies.parse.text_csv.DialectFormatting.delimiter] is ignored. See [the Python docs entry](https://docs.python.org/3/library/csv.html#csv.Dialect.skipinitialspace) for more information.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/parse/text_csv/#oteapi.strategies.parse.text_csv.DialectFormatting.strict","title":"<code>strict: Optional[bool] = Field(None, description='When `True`, raise exception [Error](https://docs.python.org/3/library/csv.html#csv.Error) on bad CSV input. See [the Python docs entry](https://docs.python.org/3/library/csv.html#csv.Dialect.strict) for more information.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/parse/text_csv/#oteapi.strategies.parse.text_csv.DialectFormatting.validate_dialect_base","title":"<code>validate_dialect_base(value)</code>  <code>classmethod</code>","text":"<p>Ensure the given <code>base</code> dialect is registered locally.</p> Source code in <code>oteapi/strategies/parse/text_csv.py</code> <pre><code>@field_validator(\"base\")\n@classmethod\ndef validate_dialect_base(cls, value: str) -&gt; str:\n    \"\"\"Ensure the given `base` dialect is registered locally.\"\"\"\n    if value not in csv.list_dialects():\n        raise ValueError(\n            f\"{value!r} is not a known registered CSV dialect. \"\n            f\"Registered dialects: {', '.join(csv.list_dialects())}.\"\n        )\n    return value\n</code></pre>"},{"location":"api_reference/strategies/parse/text_csv/#oteapi.strategies.parse.text_csv.QuoteConstants","title":"<code>QuoteConstants</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>CSV module <code>QUOTE_*</code> constants.</p> Source code in <code>oteapi/strategies/parse/text_csv.py</code> <pre><code>class QuoteConstants(str, Enum):\n    \"\"\"CSV module `QUOTE_*` constants.\"\"\"\n\n    QUOTE_ALL = \"QUOTE_ALL\"\n    QUOTE_MINIMAL = \"QUOTE_MINIMAL\"\n    QUOTE_NONUMERIC = \"QUOTE_NONNUMERIC\"\n    QUOTE_NONE = \"QUOTE_NONE\"\n\n    def csv_constant(self) -&gt; int:\n        \"\"\"Return the CSV lib equivalent constant.\"\"\"\n        return {\n            self.QUOTE_ALL: csv.QUOTE_ALL,\n            self.QUOTE_MINIMAL: csv.QUOTE_MINIMAL,\n            self.QUOTE_NONUMERIC: csv.QUOTE_NONNUMERIC,\n            self.QUOTE_NONE: csv.QUOTE_NONE,\n        }[self]\n</code></pre>"},{"location":"api_reference/strategies/parse/text_csv/#oteapi.strategies.parse.text_csv.QuoteConstants.QUOTE_ALL","title":"<code>QUOTE_ALL = 'QUOTE_ALL'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/parse/text_csv/#oteapi.strategies.parse.text_csv.QuoteConstants.QUOTE_MINIMAL","title":"<code>QUOTE_MINIMAL = 'QUOTE_MINIMAL'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/parse/text_csv/#oteapi.strategies.parse.text_csv.QuoteConstants.QUOTE_NONE","title":"<code>QUOTE_NONE = 'QUOTE_NONE'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/parse/text_csv/#oteapi.strategies.parse.text_csv.QuoteConstants.QUOTE_NONUMERIC","title":"<code>QUOTE_NONUMERIC = 'QUOTE_NONNUMERIC'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/parse/text_csv/#oteapi.strategies.parse.text_csv.QuoteConstants.csv_constant","title":"<code>csv_constant()</code>","text":"<p>Return the CSV lib equivalent constant.</p> Source code in <code>oteapi/strategies/parse/text_csv.py</code> <pre><code>def csv_constant(self) -&gt; int:\n    \"\"\"Return the CSV lib equivalent constant.\"\"\"\n    return {\n        self.QUOTE_ALL: csv.QUOTE_ALL,\n        self.QUOTE_MINIMAL: csv.QUOTE_MINIMAL,\n        self.QUOTE_NONUMERIC: csv.QUOTE_NONNUMERIC,\n        self.QUOTE_NONE: csv.QUOTE_NONE,\n    }[self]\n</code></pre>"},{"location":"api_reference/strategies/parse/text_csv/#oteapi.strategies.parse.text_csv.ReaderConfig","title":"<code>ReaderConfig</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>CSV DictReader configuration parameters.</p> <p>See the Python docs for more information.</p> Source code in <code>oteapi/strategies/parse/text_csv.py</code> <pre><code>class ReaderConfig(BaseModel):\n    \"\"\"CSV DictReader configuration parameters.\n\n    See [the Python docs](https://docs.python.org/3/library/csv.html#csv.DictReader)\n    for more information.\n    \"\"\"\n\n    fieldnames: Optional[list[str]] = Field(\n        None,\n        description=(\n            \"List of headers. If not set, the values in the first row of the CSV file \"\n            \"will be used as the field names.\"\n        ),\n    )\n    restkey: Optional[Hashable] = Field(\n        None,\n        description=(\n            \"If a row has more fields than [`fieldnames`]\"\n            \"[oteapi.strategies.parse.text_csv.ReaderConfig.fieldnames], the \"\n            \"remaining data is put in a list and stored with the field name specified \"\n            \"by [`restkey`][oteapi.strategies.parse.text_csv.ReaderConfig.restkey].\"\n        ),\n    )\n    restval: Optional[Any] = Field(\n        None,\n        description=(\n            \"If a non-blank row has fewer fields than the length of [`fieldnames`]\"\n            \"[oteapi.strategies.parse.text_csv.ReaderConfig.fieldnames], the missing \"\n            \"values are filled-in with the value of [`restval`]\"\n            \"[oteapi.strategies.parse.text_csv.ReaderConfig.restval].\"\n        ),\n    )\n    encoding: str = Field(\n        \"utf8\",\n        description=\"The file encoding.\",\n    )\n</code></pre>"},{"location":"api_reference/strategies/parse/text_csv/#oteapi.strategies.parse.text_csv.ReaderConfig.encoding","title":"<code>encoding: str = Field('utf8', description='The file encoding.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/parse/text_csv/#oteapi.strategies.parse.text_csv.ReaderConfig.fieldnames","title":"<code>fieldnames: Optional[list[str]] = Field(None, description='List of headers. If not set, the values in the first row of the CSV file will be used as the field names.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/parse/text_csv/#oteapi.strategies.parse.text_csv.ReaderConfig.restkey","title":"<code>restkey: Optional[Hashable] = Field(None, description='If a row has more fields than [`fieldnames`][oteapi.strategies.parse.text_csv.ReaderConfig.fieldnames], the remaining data is put in a list and stored with the field name specified by [`restkey`][oteapi.strategies.parse.text_csv.ReaderConfig.restkey].')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/parse/text_csv/#oteapi.strategies.parse.text_csv.ReaderConfig.restval","title":"<code>restval: Optional[Any] = Field(None, description='If a non-blank row has fewer fields than the length of [`fieldnames`][oteapi.strategies.parse.text_csv.ReaderConfig.fieldnames], the missing values are filled-in with the value of [`restval`][oteapi.strategies.parse.text_csv.ReaderConfig.restval].')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/resource/resource_url/","title":"resource_url","text":"<p>Strategy class for resource/url.</p>"},{"location":"api_reference/strategies/resource/resource_url/#oteapi.strategies.resource.resource_url.ResourceURLConfig","title":"<code>ResourceURLConfig</code>","text":"<p>               Bases: <code>ResourceConfig</code></p> <p>Resource URL strategy config.</p> Source code in <code>oteapi/strategies/resource/resource_url.py</code> <pre><code>class ResourceURLConfig(ResourceConfig):\n    \"\"\"Resource URL strategy config.\"\"\"\n\n    resourceType: Literal[\"resource/url\"] = Field(\n        \"resource/url\",\n        description=ResourceConfig.model_fields[\"resourceType\"].description,\n    )\n    downloadUrl: HostlessAnyUrl = Field(\n        ...,\n        description=ResourceConfig.model_fields[\"downloadUrl\"].description,\n    )\n    mediaType: str = Field(\n        ...,\n        description=ResourceConfig.model_fields[\"mediaType\"].description,\n    )\n</code></pre>"},{"location":"api_reference/strategies/resource/resource_url/#oteapi.strategies.resource.resource_url.ResourceURLConfig.downloadUrl","title":"<code>downloadUrl: HostlessAnyUrl = Field(..., description=ResourceConfig.model_fields['downloadUrl'].description)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/resource/resource_url/#oteapi.strategies.resource.resource_url.ResourceURLConfig.mediaType","title":"<code>mediaType: str = Field(..., description=ResourceConfig.model_fields['mediaType'].description)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/resource/resource_url/#oteapi.strategies.resource.resource_url.ResourceURLConfig.resourceType","title":"<code>resourceType: Literal['resource/url'] = Field('resource/url', description=ResourceConfig.model_fields['resourceType'].description)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/resource/resource_url/#oteapi.strategies.resource.resource_url.ResourceURLStrategy","title":"<code>ResourceURLStrategy</code>","text":"<p>Basic resource strategy targeting downloadUrl resources.</p> Source code in <code>oteapi/strategies/resource/resource_url.py</code> <pre><code>@dataclass\nclass ResourceURLStrategy:\n    \"\"\"Basic resource strategy targeting downloadUrl resources.\"\"\"\n\n    resource_config: ResourceURLConfig\n\n    def initialize(self) -&gt; \"AttrDict\":\n        \"\"\"Initialize.\"\"\"\n        return AttrDict()\n\n    def get(self) -&gt; \"AttrDict\":\n        \"\"\"resource distribution.\"\"\"\n        return AttrDict(\n            **self.resource_config.model_dump(\n                mode=\"json\", exclude_unset=True, exclude={\"resourceType\"}\n            )\n        )\n</code></pre>"},{"location":"api_reference/strategies/resource/resource_url/#oteapi.strategies.resource.resource_url.ResourceURLStrategy.resource_config","title":"<code>resource_config: ResourceURLConfig</code>  <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/resource/resource_url/#oteapi.strategies.resource.resource_url.ResourceURLStrategy.get","title":"<code>get()</code>","text":"<p>resource distribution.</p> Source code in <code>oteapi/strategies/resource/resource_url.py</code> <pre><code>def get(self) -&gt; \"AttrDict\":\n    \"\"\"resource distribution.\"\"\"\n    return AttrDict(\n        **self.resource_config.model_dump(\n            mode=\"json\", exclude_unset=True, exclude={\"resourceType\"}\n        )\n    )\n</code></pre>"},{"location":"api_reference/strategies/resource/resource_url/#oteapi.strategies.resource.resource_url.ResourceURLStrategy.initialize","title":"<code>initialize()</code>","text":"<p>Initialize.</p> Source code in <code>oteapi/strategies/resource/resource_url.py</code> <pre><code>def initialize(self) -&gt; \"AttrDict\":\n    \"\"\"Initialize.\"\"\"\n    return AttrDict()\n</code></pre>"},{"location":"api_reference/strategies/transformation/celery_remote/","title":"celery_remote","text":"<p>Transformation Plugin that uses the Celery framework to call remote workers.</p>"},{"location":"api_reference/strategies/transformation/celery_remote/#oteapi.strategies.transformation.celery_remote.CELERY_APP","title":"<code>CELERY_APP = Celery(broker=f'redis://{REDIS_HOST}:{REDIS_PORT}', backend=f'redis://{REDIS_HOST}:{REDIS_PORT}')</code>  <code>module-attribute</code>","text":""},{"location":"api_reference/strategies/transformation/celery_remote/#oteapi.strategies.transformation.celery_remote.REDIS_HOST","title":"<code>REDIS_HOST = os.getenv('OTEAPI_REDIS_HOST', 'redis')</code>  <code>module-attribute</code>","text":""},{"location":"api_reference/strategies/transformation/celery_remote/#oteapi.strategies.transformation.celery_remote.REDIS_PORT","title":"<code>REDIS_PORT = int(os.getenv('OTEAPI_REDIS_PORT', '6379'))</code>  <code>module-attribute</code>","text":""},{"location":"api_reference/strategies/transformation/celery_remote/#oteapi.strategies.transformation.celery_remote.CeleryConfig","title":"<code>CeleryConfig</code>","text":"<p>               Bases: <code>AttrDict</code></p> <p>Celery configuration.</p> <p>All fields here (including those added from the session through the <code>get()</code> method, as well as those added \"anonymously\") will be used as keyword arguments to the <code>send_task()</code> method for the Celery App.</p> Note <p>Using <code>alias</code> for the <code>name</code> field to favor populating it with <code>task_name</code> arguments, since this is the \"original\" field name. I.e., this is done for backwards compatibility.</p> <p>Special pydantic configuration settings:</p> <ul> <li><code>populate_by_name</code>   Allow populating CeleryConfig.name using <code>name</code> as well as <code>task_name</code>.</li> </ul> Source code in <code>oteapi/strategies/transformation/celery_remote.py</code> <pre><code>class CeleryConfig(AttrDict):\n    \"\"\"Celery configuration.\n\n    All fields here (including those added from the session through the `get()` method,\n    as well as those added \"anonymously\") will be used as keyword arguments to the\n    `send_task()` method for the Celery App.\n\n    Note:\n        Using `alias` for the `name` field to favor populating it with `task_name`\n        arguments, since this is the \"original\" field name. I.e., this is done for\n        backwards compatibility.\n\n    Special pydantic configuration settings:\n\n    - **`populate_by_name`**\n      Allow populating CeleryConfig.name using `name` as well as `task_name`.\n\n    \"\"\"\n\n    model_config = ConfigDict(populate_by_name=True)\n\n    name: str = Field(..., description=\"A task name.\", alias=\"task_name\")\n    args: list = Field(..., description=\"List of arguments for the task.\")\n</code></pre>"},{"location":"api_reference/strategies/transformation/celery_remote/#oteapi.strategies.transformation.celery_remote.CeleryConfig.args","title":"<code>args: list = Field(..., description='List of arguments for the task.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/transformation/celery_remote/#oteapi.strategies.transformation.celery_remote.CeleryConfig.model_config","title":"<code>model_config = ConfigDict(populate_by_name=True)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/transformation/celery_remote/#oteapi.strategies.transformation.celery_remote.CeleryConfig.name","title":"<code>name: str = Field(..., description='A task name.', alias='task_name')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/transformation/celery_remote/#oteapi.strategies.transformation.celery_remote.CeleryContent","title":"<code>CeleryContent</code>","text":"<p>               Bases: <code>AttrDict</code></p> <p>Class for returning values from a Celery task.</p> Source code in <code>oteapi/strategies/transformation/celery_remote.py</code> <pre><code>class CeleryContent(AttrDict):\n    \"\"\"Class for returning values from a Celery task.\"\"\"\n\n    celery_task_id: str = Field(..., description=\"A Celery task identifier.\")\n</code></pre>"},{"location":"api_reference/strategies/transformation/celery_remote/#oteapi.strategies.transformation.celery_remote.CeleryContent.celery_task_id","title":"<code>celery_task_id: str = Field(..., description='A Celery task identifier.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/transformation/celery_remote/#oteapi.strategies.transformation.celery_remote.CeleryRemoteStrategy","title":"<code>CeleryRemoteStrategy</code>","text":"<p>Submit job to remote Celery runner.</p> <p>Registers strategies:</p> <ul> <li><code>(\"transformationType\", \"celery/remote\")</code></li> </ul> Source code in <code>oteapi/strategies/transformation/celery_remote.py</code> <pre><code>@dataclass\nclass CeleryRemoteStrategy:\n    \"\"\"Submit job to remote Celery runner.\n\n    **Registers strategies**:\n\n    - `(\"transformationType\", \"celery/remote\")`\n\n    \"\"\"\n\n    transformation_config: CeleryStrategyConfig\n\n    def get(self) -&gt; CeleryContent:\n        \"\"\"Run a job, return a job ID.\"\"\"\n\n        result: \"Union[AsyncResult, Any]\" = CELERY_APP.send_task(\n            **self.transformation_config.configuration.model_dump()\n        )\n        return CeleryContent(celery_task_id=result.task_id)\n\n    def initialize(self) -&gt; AttrDict:\n        \"\"\"Initialize a job.\"\"\"\n        return AttrDict()\n\n    def status(self, task_id: str) -&gt; TransformationStatus:\n        \"\"\"Get job status.\"\"\"\n        result = AsyncResult(id=task_id, app=CELERY_APP)\n        return TransformationStatus(id=task_id, status=result.state)\n</code></pre>"},{"location":"api_reference/strategies/transformation/celery_remote/#oteapi.strategies.transformation.celery_remote.CeleryRemoteStrategy.transformation_config","title":"<code>transformation_config: CeleryStrategyConfig</code>  <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/transformation/celery_remote/#oteapi.strategies.transformation.celery_remote.CeleryRemoteStrategy.get","title":"<code>get()</code>","text":"<p>Run a job, return a job ID.</p> Source code in <code>oteapi/strategies/transformation/celery_remote.py</code> <pre><code>def get(self) -&gt; CeleryContent:\n    \"\"\"Run a job, return a job ID.\"\"\"\n\n    result: \"Union[AsyncResult, Any]\" = CELERY_APP.send_task(\n        **self.transformation_config.configuration.model_dump()\n    )\n    return CeleryContent(celery_task_id=result.task_id)\n</code></pre>"},{"location":"api_reference/strategies/transformation/celery_remote/#oteapi.strategies.transformation.celery_remote.CeleryRemoteStrategy.initialize","title":"<code>initialize()</code>","text":"<p>Initialize a job.</p> Source code in <code>oteapi/strategies/transformation/celery_remote.py</code> <pre><code>def initialize(self) -&gt; AttrDict:\n    \"\"\"Initialize a job.\"\"\"\n    return AttrDict()\n</code></pre>"},{"location":"api_reference/strategies/transformation/celery_remote/#oteapi.strategies.transformation.celery_remote.CeleryRemoteStrategy.status","title":"<code>status(task_id)</code>","text":"<p>Get job status.</p> Source code in <code>oteapi/strategies/transformation/celery_remote.py</code> <pre><code>def status(self, task_id: str) -&gt; TransformationStatus:\n    \"\"\"Get job status.\"\"\"\n    result = AsyncResult(id=task_id, app=CELERY_APP)\n    return TransformationStatus(id=task_id, status=result.state)\n</code></pre>"},{"location":"api_reference/strategies/transformation/celery_remote/#oteapi.strategies.transformation.celery_remote.CeleryStrategyConfig","title":"<code>CeleryStrategyConfig</code>","text":"<p>               Bases: <code>TransformationConfig</code></p> <p>Celery strategy-specific configuration.</p> Source code in <code>oteapi/strategies/transformation/celery_remote.py</code> <pre><code>class CeleryStrategyConfig(TransformationConfig):\n    \"\"\"Celery strategy-specific configuration.\"\"\"\n\n    transformationType: Literal[\"celery/remote\"] = Field(\n        \"celery/remote\",\n        description=TransformationConfig.model_fields[\"transformationType\"].description,\n    )\n    configuration: CeleryConfig = Field(\n        ..., description=\"Celery transformation strategy-specific configuration.\"\n    )\n</code></pre>"},{"location":"api_reference/strategies/transformation/celery_remote/#oteapi.strategies.transformation.celery_remote.CeleryStrategyConfig.configuration","title":"<code>configuration: CeleryConfig = Field(..., description='Celery transformation strategy-specific configuration.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/strategies/transformation/celery_remote/#oteapi.strategies.transformation.celery_remote.CeleryStrategyConfig.transformationType","title":"<code>transformationType: Literal['celery/remote'] = Field('celery/remote', description=TransformationConfig.model_fields['transformationType'].description)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api_reference/triplestore/triplestore/","title":"triplestore","text":"<p>An RDF triplestore using Allegrograph https://franz.com/agraph/support/documentation/current/python/api.html https://franz.com/agraph/support/documentation/current/agraph-introduction.html</p> <p>Features:</p> <ul> <li>Store mapping data (triple format)</li> <li>AllegroGraph has a well documented python API package</li> </ul>"},{"location":"api_reference/triplestore/triplestore/#oteapi.triplestore.triplestore.TripleStore","title":"<code>TripleStore</code>","text":"<p>This class is available to import from <code>oteapi.triplestore</code>, e.g.:</p> <p><pre><code>from oteapi.triplestore import TripleStore\n</code></pre> Init must initialize the triple store connection</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>Union[TripleStoreConfig, Dict[str, Any]]</code> <p>RDF triple-store configuration.</p> required <p>Attributes:</p> Name Type Description <code>config</code> <code>TripleStoreConfig</code> <p>The RDF triple-store configuration.</p> Source code in <code>oteapi/triplestore/triplestore.py</code> <pre><code>class TripleStore:\n    \"\"\"\n    This class is available to import from `oteapi.triplestore`, e.g.:\n\n    ```python\n    from oteapi.triplestore import TripleStore\n    ```\n    Init must initialize the triple store connection\n\n    Args:\n        config (Union[TripleStoreConfig, Dict[str, Any]]): RDF triple-store\n            configuration.\n\n    Attributes:\n        config (TripleStoreConfig): The RDF triple-store configuration.\n\n    \"\"\"\n\n    def __init__(\n        self,\n        config: \"Union[TripleStoreConfig, Dict[str, Any]]\",\n    ) -&gt; None:\n        if isinstance(config, (dict, AttrDict)):\n            self.config = TripleStoreConfig(**config)\n        elif isinstance(config, TripleStoreConfig):\n            self.config = config\n        else:\n            raise TypeError(\n                \"config should be either a `TripleStoreConfig` data model or a \"\n                \"dictionary.\"\n            )\n        self.server = AllegroGraphServer(\n            self.config.agraphHost,\n            self.config.agraphPort,\n            self.config.user.get_secret_value(),  # type: ignore [union-attr]\n            self.config.password.get_secret_value(),  # type: ignore [union-attr]\n        )\n\n    def add(self, triples: RDFTriple) -&gt; None:\n        \"\"\"\n        Add triples to the triplestore.\n\n        Args:\n            triples: triples turtle format(&lt;s&gt; &lt;o&gt; &lt;p&gt;.).\n\n        \"\"\"\n        with ag_connect(\n            self.config.repositoryName,\n            host=self.config.agraphHost,\n            port=self.config.agraphPort,\n            user=self.config.user.get_secret_value(),  # type: ignore [union-attr]\n            password=self.config.password.get_secret_value(),  # type: ignore [union-attr]  # noqa: E501\n        ) as connection:\n            connection.addData(triples)\n            connection.close()\n\n    def get(self, sparql_query: str) -&gt; \"Any\":\n        \"\"\"Return the query result.\n\n        Args:\n            sparql_query: The SPARQL search query.\n\n        Returns:\n            The output of the search query in the form of a list of RDF triples.\n\n        \"\"\"\n        connection = self.server.openSession(\n            reason(\"&lt;\" + str(self.config.repositoryName) + \"&gt;\")\n        )\n        try:\n            tuple_query = connection.prepareTupleQuery(query=sparql_query)\n            response = []\n\n            with tuple_query.evaluate(output_format=TupleFormat.JSON) as results:\n                for result in results:\n                    triple = {}\n                    if \"'s': \" in str(result):\n                        triple[\"s\"] = str(result.getValue(\"s\"))\n                    if \"'p': \" in str(result):\n                        triple[\"p\"] = str(result.getValue(\"p\"))\n                    if \"'o': \" in str(result):\n                        triple[\"o\"] = str(result.getValue(\"o\"))\n                    response.append(triple)\n            connection.close()\n            return response\n        except RequestError as error:\n            return {\"Error\": error}\n\n    def update_delete(self, sparql_query: str) -&gt; None:\n        \"\"\"Remove and update triples.\n\n        Useful for modifying and cleaning up mappings.\n\n        Args:\n            sparql_query: The sparql update/delete query.\n        Returns:\n            True if update was successful.\n\n        \"\"\"\n        with ag_connect(\n            self.config.repositoryName,\n            host=self.config.agraphHost,\n            port=self.config.agraphPort,\n            user=self.config.user.get_secret_value(),  # type: ignore [union-attr]\n            password=self.config.password.get_secret_value(),  # type: ignore [union-attr]  # noqa: E501\n        ) as connection:\n            update_query = connection.prepareUpdate(query=sparql_query)\n            update_query.evaluate()\n            connection.close()\n</code></pre>"},{"location":"api_reference/triplestore/triplestore/#oteapi.triplestore.triplestore.TripleStore.add","title":"<code>add(triples)</code>","text":"<p>Add triples to the triplestore.</p> <p>Parameters:</p> Name Type Description Default <code>triples</code> <code>RDFTriple</code> <p>triples turtle format( <p>.).</p> required Source code in <code>oteapi/triplestore/triplestore.py</code> <pre><code>def add(self, triples: RDFTriple) -&gt; None:\n    \"\"\"\n    Add triples to the triplestore.\n\n    Args:\n        triples: triples turtle format(&lt;s&gt; &lt;o&gt; &lt;p&gt;.).\n\n    \"\"\"\n    with ag_connect(\n        self.config.repositoryName,\n        host=self.config.agraphHost,\n        port=self.config.agraphPort,\n        user=self.config.user.get_secret_value(),  # type: ignore [union-attr]\n        password=self.config.password.get_secret_value(),  # type: ignore [union-attr]  # noqa: E501\n    ) as connection:\n        connection.addData(triples)\n        connection.close()\n</code></pre>"},{"location":"api_reference/triplestore/triplestore/#oteapi.triplestore.triplestore.TripleStore.get","title":"<code>get(sparql_query)</code>","text":"<p>Return the query result.</p> <p>Parameters:</p> Name Type Description Default <code>sparql_query</code> <code>str</code> <p>The SPARQL search query.</p> required <p>Returns:</p> Type Description <code>Any</code> <p>The output of the search query in the form of a list of RDF triples.</p> Source code in <code>oteapi/triplestore/triplestore.py</code> <pre><code>def get(self, sparql_query: str) -&gt; \"Any\":\n    \"\"\"Return the query result.\n\n    Args:\n        sparql_query: The SPARQL search query.\n\n    Returns:\n        The output of the search query in the form of a list of RDF triples.\n\n    \"\"\"\n    connection = self.server.openSession(\n        reason(\"&lt;\" + str(self.config.repositoryName) + \"&gt;\")\n    )\n    try:\n        tuple_query = connection.prepareTupleQuery(query=sparql_query)\n        response = []\n\n        with tuple_query.evaluate(output_format=TupleFormat.JSON) as results:\n            for result in results:\n                triple = {}\n                if \"'s': \" in str(result):\n                    triple[\"s\"] = str(result.getValue(\"s\"))\n                if \"'p': \" in str(result):\n                    triple[\"p\"] = str(result.getValue(\"p\"))\n                if \"'o': \" in str(result):\n                    triple[\"o\"] = str(result.getValue(\"o\"))\n                response.append(triple)\n        connection.close()\n        return response\n    except RequestError as error:\n        return {\"Error\": error}\n</code></pre>"},{"location":"api_reference/triplestore/triplestore/#oteapi.triplestore.triplestore.TripleStore.update_delete","title":"<code>update_delete(sparql_query)</code>","text":"<p>Remove and update triples.</p> <p>Useful for modifying and cleaning up mappings.</p> <p>Parameters:</p> Name Type Description Default <code>sparql_query</code> <code>str</code> <p>The sparql update/delete query.</p> required <p>Returns:     True if update was successful.</p> Source code in <code>oteapi/triplestore/triplestore.py</code> <pre><code>def update_delete(self, sparql_query: str) -&gt; None:\n    \"\"\"Remove and update triples.\n\n    Useful for modifying and cleaning up mappings.\n\n    Args:\n        sparql_query: The sparql update/delete query.\n    Returns:\n        True if update was successful.\n\n    \"\"\"\n    with ag_connect(\n        self.config.repositoryName,\n        host=self.config.agraphHost,\n        port=self.config.agraphPort,\n        user=self.config.user.get_secret_value(),  # type: ignore [union-attr]\n        password=self.config.password.get_secret_value(),  # type: ignore [union-attr]  # noqa: E501\n    ) as connection:\n        update_query = connection.prepareUpdate(query=sparql_query)\n        update_query.evaluate()\n        connection.close()\n</code></pre>"},{"location":"api_reference/utils/config_updater/","title":"config_updater","text":"<p>Utility functions for updating GenericConfig instances.</p>"},{"location":"api_reference/utils/config_updater/#oteapi.utils.config_updater.populate_config_from_session","title":"<code>populate_config_from_session(session, config)</code>","text":"<p>Update the configuration attributes of a GenericConfig object using values from a session. If a key already exists in the config's configuration and has a different value from the session, an exception will be raised.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>Dict</code> <p>A session containing configuration attributes.</p> required <code>config</code> <code>GenericConfig</code> <p>A GenericConfig object to be updated.</p> required Source code in <code>oteapi/utils/config_updater.py</code> <pre><code>def populate_config_from_session(\n    session: \"Dict[str, Any]\",\n    config: GenericConfig,\n) -&gt; None:\n    \"\"\"\n    Update the configuration attributes of a GenericConfig object\n    using values from a session. If a key already exists in the\n    config's configuration and has a different value from the session,\n    an exception will be raised.\n\n    Args:\n        session (Dict): A session containing configuration attributes.\n        config (GenericConfig): A GenericConfig object to be updated.\n    \"\"\"\n    # Determine which keys to update\n    keys_to_update = list(session.keys())\n\n    for key in keys_to_update:\n        if (\n            # \"configuration\" in config\n            key in config.configuration\n            and session[key] != config.configuration[key]\n        ):\n            raise ValueError(\n                f\"Key '{key}' in config has different value than in session.\"\n            )\n\n        try:\n            config.configuration[key] = session[key]\n        except Exception as error:\n            raise RuntimeError(\n                f\"Failed to update key '{key}' in the config. Reason: {str(error)}\"\n            ) from error\n</code></pre>"},{"location":"api_reference/utils/paths/","title":"paths","text":"<p>Utility functions for handling paths.</p>"},{"location":"api_reference/utils/paths/#oteapi.utils.paths.uri_to_path","title":"<code>uri_to_path(uri)</code>","text":"<p>Convert URI to pathlib.Path.</p> <p>Support both Windows and Posix path types.</p> Information <p><code>urllib.parse.urlparse()</code> leaves an initial slash in front of the drive letter when parsing a file URL for an absolute path on Windows.</p> <p>Example: <code>urlparse(\"file:///C:/Windows\").path</code> -&gt; <code>\"/C:/Windows\"</code></p> <p>To solve this, the initial forward slash is removed prior to casting to <code>pathlib.Path</code>.</p> <p>Parameters:</p> Name Type Description Default <code>uri</code> <code>Union[str, AnyUrl, ParseResult]</code> <p>The URI/IRI/URL. Either as a string or a parsed URL.</p> required <p>Returns:</p> Type Description <code>Path</code> <p>A properly converted URI/IRI/URL to <code>pathlib.Path</code>.</p> Source code in <code>oteapi/utils/paths.py</code> <pre><code>def uri_to_path(uri: \"Union[str, AnyUrl, ParseResult]\") -&gt; Path:\n    \"\"\"Convert URI to pathlib.Path.\n\n    Support both Windows and Posix path types.\n\n    Information:\n        `urllib.parse.urlparse()` leaves an initial slash in front of the drive letter\n        when parsing a file URL for an absolute path on Windows.\n\n        Example: `urlparse(\"file:///C:/Windows\").path` -&gt; `\"/C:/Windows\"`\n\n        To solve this, the initial forward slash is removed prior to casting to\n        `pathlib.Path`.\n\n    Parameters:\n        uri: The URI/IRI/URL. Either as a string or a parsed URL.\n\n    Returns:\n        A properly converted URI/IRI/URL to `pathlib.Path`.\n\n    \"\"\"\n    if not isinstance(uri, ParseResult):\n        uri = urlparse(str(uri))\n\n    uri_path = (uri.netloc + uri.path) if uri.scheme == \"file\" else uri.path\n\n    if uri.scheme != \"file\":\n        warnings.warn(\n            \"A 'file'-scheme was expected for the 'uri' in 'uri_to_path()', instead a \"\n            f\"{uri.scheme!r} was received. Still converting to `pathlib.Path` using \"\n            \"the 'path' of the URI.\"\n        )\n\n    path = Path(uri_path)\n    if isinstance(path, PureWindowsPath):\n        path = Path(uri_path.lstrip(\"/\"))\n    return path\n</code></pre>"}]}