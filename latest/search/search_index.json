{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Open Translation Environment (OTE) API Core \u00b6 Framework for accessing data resources, mapping data models, describing the data to ontologies and perform data transformations We highly recommend reading this page in the official documentation . About OTEAPI Core \u00b6 OTEAPI Core provides the core functionality of OTEAPI, which stands for the Open Translation Environment API . It uses the strategy software design pattern to implement a simple and easy to extend access to a large range of data resources. Semantic interoperability is supported via mapping of data models describing the data to ontologies. Transformations, mainly intended to transform data between representations, are also supported, but transformations can also be used for running simulations in a simple workflow. OTEAPI Core includes: A set of standard strategies; A plugin system for loading the standard strategies, as well as third party strategies; Data models for configuring the strategies; A Python library, through which the data can be accessed; and An efficient data cache module that avoids downloading the same content several times. Types of strategies \u00b6 Download strategy \u00b6 Download strategy patterns use a given protocol to download content into the data cache. They are configured with the ResourceConfig data model, using the scheme of the downloadUrl field for strategy selection. The configuration field can be used to configure how the downloaded content is stored in the cache using the DownloadConfig data model. Standard downloaded strategies: file , https , http , sftp , ftp Parse strategy \u00b6 Parse strategy patterns convert content from the data cache to a Python dict. Like download strategies, they are configured with the ResourceConfig data model, using the mediaType field for strategy selection. Additional strategy-specific configurations can be provided via the configuration field. Standard parse strategies: application/json , image/jpg , image/jpeg , image/jp2 , image/png , image/gif , image/tiff , image/eps , application/vnd.openxmlformats-officedocument.spreadsheetml.sheet , application/vnd.sqlite3 Resource strategy \u00b6 Resource strategy patterns can retrieve/upload data to external data services. They are configured with the ResourceConfig data model, using the scheme of the accessUrl and accessService fields. The scheme of the accessUrl is used for strategy selection. Mapping strategy \u00b6 Strategies for mapping fields/properties in data models to ontological concepts. Filter strategy \u00b6 Filter strategies can update the configuration of other strategies. They can also update values in the data cache. Standard filter strategies: filter/crop , filter/sql Function strategy \u00b6 Function strategies are synchronous transformations that (normally) run directly on the server hosting the OTE service. Transformation strategy \u00b6 Transformation strategies are a special form of a function strategy intended for long-running transformations. In this sense, they represent asynchronous functions running in the background or on external resources. Standard transformation strategies: celery/remote Entry points for plugins \u00b6 The way strategies are registered and found is through entry points . Special group names allow understanding the strategy type and the entry point values allow understanding of what kind of strategy a specific class implements. A full overview of recognized entry point group names can be seen in Table of entry point strategies . Defining entry points \u00b6 In the following examples, let's imagine we have a package importable in Python through my_plugin and contains two download strategies and a single parse strategy: A peer-2-peer download strategy, implemented in a class named Peer2PeerDownload importable from my_plugin.strategies.download.peer_2_peer . A MongoDB download strategy, implemented in a class named MongoRetrieve importable from my_plugin.strategies.mongo . A MongoDB parse strategy, implemented in a class named MongoParse importable from my_plugin.strategies.mongo . There are now various different ways to let the Python environment know of these strategies through entry points. setup.py \u00b6 In the package's setup.py file, one can specify entry points. Here, an example snippet is shown using setuptools : # setup.py from setuptools import setup setup ( # ..., entry_points = { \"oteapi.download\" : [ \"my_plugin.p2p = my_plugin.strategies.download.peer_2_peer:Peer2PeerDownload\" , \"my_plugin.mongo = my_plugin.strategies.mongo:MongoRetrieve\" , ], \"oteapi.parse\" : [ \"my_plugin.application/vnd.mongo+json = my_plugin.strategies.mongo:MongoParse\" , ] }, ) YAML/JSON custom files \u00b6 Use custom files that are later parsed and used in a setup.py file. entry_points : oteapi.download : - \"my_plugin.p2p = my_plugin.strategies.download.peer_2_peer:Peer2PeerDownload\" - \"my_plugin.mongo = my_plugin.strategies.mongo:MongoRetrieve\" oteapi.parse : - \"my_plugin.application/vnd.mongo+json = my_plugin.strategies.mongo:MongoParse\" { \"entry_points\" : { \"oteapi.download\" : [ \"my_plugin.p2p = my_plugin.strategies.download.peer_2_peer:Peer2PeerDownload\" , \"my_plugin.mongo = my_plugin.strategies.mongo:MongoRetrieve\" ], \"oteapi.parse\" : [ \"my_plugin.application/vnd.mongo+json = my_plugin.strategies.mongo:MongoParse\" ] } } setup.cfg / pyproject.toml \u00b6 A more modern approach is to use setup.cfg or pyproject.toml . [options.entry_points] oteapi.download = my_plugin.p2p = my_plugin.strategies.download.peer_2_peer:Peer2PeerDownload my_plugin.mongo = my_plugin.strategies.mongo:MongoRetrieve oteapi.parse = my_plugin.application/vnd.mongo+json = my_plugin.strategies.mongo:MongoParse Syntax and semantics \u00b6 As seen above, there are a few different syntactical flavors of how to list the entry points. However, the \"value\" stays the same throughout. General Python entry points \u00b6 The general syntax for entry points is based on ini files and parsed using the built-in configparser module described here . Specifically for entry points the nomenclature is the following: [options.entry_points] GROUP = NAME = VALUE The VALUE is then further split into: PACKAGE.MODULE:OBJECT.ATTRIBUTE [EXTRA1, EXTRA2] . OTEAPI strategy entry points \u00b6 From the general syntax outlined above, OTEAPI Core then implements rules and requirements regarding the syntax for strategies. A class MUST be specified (as an OBJECT ). The NAME MUST consist of exactly two parts: PACKAGE and strategy type value in the form of PACKAGE.STRATEGY_TYPE_VALUE . The GROUP MUST be a valid OTEAPI entry point group, see Table of entry point strategies for a full list of valid OTEAPI entry point group values. To understand what the strategy type value should be, see Table of entry point strategies . Table of entry point strategies \u00b6 Strategy Type Name Strategy Type Value Entry Point Group Documentation Reference Download scheme oteapi.download Download strategy Filter filterType oteapi.filter Filter strategy Function functionType oteapi.function Function strategy Mapping mappingType oteapi.mapping Mapping strategy Parse mediaType oteapi.parse Parse strategy Resource accessService oteapi.resource Resource strategy Transformation transformationType oteapi.transformation Transformation strategy Other OTEAPI-related repositories \u00b6 OTEAPI Services - a RESTful interface to OTEAPI Core OTELib - a Python interface to OTEAPI Services OTEAPI Plugin Template - a cookiecutter template for OTEAPI Plugins Installation \u00b6 OTEAPI Core can be installed with: pip install oteapi-core For developers \u00b6 If you want to install OTEAPI Core to have a developer environment, please clone down the repository from GitHub and install: git clone https://github.com/EMMC-ASBL/oteapi-core /path/to/oteapi-core pip install -U --upgrade-strategy = eager -e /path/to/oteapi-core [ dev ] Note, /path/to/oteapi-core can be left out of the first line, but then it must be updated in the second line, either to ./oteapi-core / oteapi-core or . if you cd into the generated folder wherein the repository has been cloned. The --upgrade-strategy=eager part can be left out. We recommend installing within a dedicated virtual environment. To test the installation, you can run: cd /path/to/oteapi-core pytest If you run into issues at this stage, please open an issue . License \u00b6 OTEAPI Core is released under the MIT license with copyright \u00a9 SINTEF. Acknowledgment \u00b6 OTEAPI Core has been supported by the following projects: OntoTrans (2020-2024) that receives funding from the European Union\u2019s Horizon 2020 Research and Innovation Programme, under Grant Agreement no. 862136. VIPCOAT (2021-2025) receives funding from the European Union\u2019s Horizon 2020 Research and Innovation Programme - DT-NMBP-11-2020 Open Innovation Platform for Materials Modelling, under Grant Agreement no: 952903. OpenModel (2021-2025) receives funding from the European Union\u2019s Horizon 2020 Research and Innovation Programme - DT-NMBP-11-2020 Open Innovation Platform for Materials Modelling, under Grant Agreement no: 953167.","title":"Home"},{"location":"#open-translation-environment-ote-api-core","text":"Framework for accessing data resources, mapping data models, describing the data to ontologies and perform data transformations We highly recommend reading this page in the official documentation .","title":"Open Translation Environment (OTE) API Core"},{"location":"#about-oteapi-core","text":"OTEAPI Core provides the core functionality of OTEAPI, which stands for the Open Translation Environment API . It uses the strategy software design pattern to implement a simple and easy to extend access to a large range of data resources. Semantic interoperability is supported via mapping of data models describing the data to ontologies. Transformations, mainly intended to transform data between representations, are also supported, but transformations can also be used for running simulations in a simple workflow. OTEAPI Core includes: A set of standard strategies; A plugin system for loading the standard strategies, as well as third party strategies; Data models for configuring the strategies; A Python library, through which the data can be accessed; and An efficient data cache module that avoids downloading the same content several times.","title":"About OTEAPI Core"},{"location":"#types-of-strategies","text":"","title":"Types of strategies"},{"location":"#download-strategy","text":"Download strategy patterns use a given protocol to download content into the data cache. They are configured with the ResourceConfig data model, using the scheme of the downloadUrl field for strategy selection. The configuration field can be used to configure how the downloaded content is stored in the cache using the DownloadConfig data model. Standard downloaded strategies: file , https , http , sftp , ftp","title":"Download strategy"},{"location":"#parse-strategy","text":"Parse strategy patterns convert content from the data cache to a Python dict. Like download strategies, they are configured with the ResourceConfig data model, using the mediaType field for strategy selection. Additional strategy-specific configurations can be provided via the configuration field. Standard parse strategies: application/json , image/jpg , image/jpeg , image/jp2 , image/png , image/gif , image/tiff , image/eps , application/vnd.openxmlformats-officedocument.spreadsheetml.sheet , application/vnd.sqlite3","title":"Parse strategy"},{"location":"#resource-strategy","text":"Resource strategy patterns can retrieve/upload data to external data services. They are configured with the ResourceConfig data model, using the scheme of the accessUrl and accessService fields. The scheme of the accessUrl is used for strategy selection.","title":"Resource strategy"},{"location":"#mapping-strategy","text":"Strategies for mapping fields/properties in data models to ontological concepts.","title":"Mapping strategy"},{"location":"#filter-strategy","text":"Filter strategies can update the configuration of other strategies. They can also update values in the data cache. Standard filter strategies: filter/crop , filter/sql","title":"Filter strategy"},{"location":"#function-strategy","text":"Function strategies are synchronous transformations that (normally) run directly on the server hosting the OTE service.","title":"Function strategy"},{"location":"#transformation-strategy","text":"Transformation strategies are a special form of a function strategy intended for long-running transformations. In this sense, they represent asynchronous functions running in the background or on external resources. Standard transformation strategies: celery/remote","title":"Transformation strategy"},{"location":"#entry-points-for-plugins","text":"The way strategies are registered and found is through entry points . Special group names allow understanding the strategy type and the entry point values allow understanding of what kind of strategy a specific class implements. A full overview of recognized entry point group names can be seen in Table of entry point strategies .","title":"Entry points for plugins"},{"location":"#defining-entry-points","text":"In the following examples, let's imagine we have a package importable in Python through my_plugin and contains two download strategies and a single parse strategy: A peer-2-peer download strategy, implemented in a class named Peer2PeerDownload importable from my_plugin.strategies.download.peer_2_peer . A MongoDB download strategy, implemented in a class named MongoRetrieve importable from my_plugin.strategies.mongo . A MongoDB parse strategy, implemented in a class named MongoParse importable from my_plugin.strategies.mongo . There are now various different ways to let the Python environment know of these strategies through entry points.","title":"Defining entry points"},{"location":"#setuppy","text":"In the package's setup.py file, one can specify entry points. Here, an example snippet is shown using setuptools : # setup.py from setuptools import setup setup ( # ..., entry_points = { \"oteapi.download\" : [ \"my_plugin.p2p = my_plugin.strategies.download.peer_2_peer:Peer2PeerDownload\" , \"my_plugin.mongo = my_plugin.strategies.mongo:MongoRetrieve\" , ], \"oteapi.parse\" : [ \"my_plugin.application/vnd.mongo+json = my_plugin.strategies.mongo:MongoParse\" , ] }, )","title":"setup.py"},{"location":"#yamljson-custom-files","text":"Use custom files that are later parsed and used in a setup.py file. entry_points : oteapi.download : - \"my_plugin.p2p = my_plugin.strategies.download.peer_2_peer:Peer2PeerDownload\" - \"my_plugin.mongo = my_plugin.strategies.mongo:MongoRetrieve\" oteapi.parse : - \"my_plugin.application/vnd.mongo+json = my_plugin.strategies.mongo:MongoParse\" { \"entry_points\" : { \"oteapi.download\" : [ \"my_plugin.p2p = my_plugin.strategies.download.peer_2_peer:Peer2PeerDownload\" , \"my_plugin.mongo = my_plugin.strategies.mongo:MongoRetrieve\" ], \"oteapi.parse\" : [ \"my_plugin.application/vnd.mongo+json = my_plugin.strategies.mongo:MongoParse\" ] } }","title":"YAML/JSON custom files"},{"location":"#setupcfgpyprojecttoml","text":"A more modern approach is to use setup.cfg or pyproject.toml . [options.entry_points] oteapi.download = my_plugin.p2p = my_plugin.strategies.download.peer_2_peer:Peer2PeerDownload my_plugin.mongo = my_plugin.strategies.mongo:MongoRetrieve oteapi.parse = my_plugin.application/vnd.mongo+json = my_plugin.strategies.mongo:MongoParse","title":"setup.cfg/pyproject.toml"},{"location":"#syntax-and-semantics","text":"As seen above, there are a few different syntactical flavors of how to list the entry points. However, the \"value\" stays the same throughout.","title":"Syntax and semantics"},{"location":"#general-python-entry-points","text":"The general syntax for entry points is based on ini files and parsed using the built-in configparser module described here . Specifically for entry points the nomenclature is the following: [options.entry_points] GROUP = NAME = VALUE The VALUE is then further split into: PACKAGE.MODULE:OBJECT.ATTRIBUTE [EXTRA1, EXTRA2] .","title":"General Python entry points"},{"location":"#oteapi-strategy-entry-points","text":"From the general syntax outlined above, OTEAPI Core then implements rules and requirements regarding the syntax for strategies. A class MUST be specified (as an OBJECT ). The NAME MUST consist of exactly two parts: PACKAGE and strategy type value in the form of PACKAGE.STRATEGY_TYPE_VALUE . The GROUP MUST be a valid OTEAPI entry point group, see Table of entry point strategies for a full list of valid OTEAPI entry point group values. To understand what the strategy type value should be, see Table of entry point strategies .","title":"OTEAPI strategy entry points"},{"location":"#table-of-entry-point-strategies","text":"Strategy Type Name Strategy Type Value Entry Point Group Documentation Reference Download scheme oteapi.download Download strategy Filter filterType oteapi.filter Filter strategy Function functionType oteapi.function Function strategy Mapping mappingType oteapi.mapping Mapping strategy Parse mediaType oteapi.parse Parse strategy Resource accessService oteapi.resource Resource strategy Transformation transformationType oteapi.transformation Transformation strategy","title":"Table of entry point strategies"},{"location":"#other-oteapi-related-repositories","text":"OTEAPI Services - a RESTful interface to OTEAPI Core OTELib - a Python interface to OTEAPI Services OTEAPI Plugin Template - a cookiecutter template for OTEAPI Plugins","title":"Other OTEAPI-related repositories"},{"location":"#installation","text":"OTEAPI Core can be installed with: pip install oteapi-core","title":"Installation"},{"location":"#for-developers","text":"If you want to install OTEAPI Core to have a developer environment, please clone down the repository from GitHub and install: git clone https://github.com/EMMC-ASBL/oteapi-core /path/to/oteapi-core pip install -U --upgrade-strategy = eager -e /path/to/oteapi-core [ dev ] Note, /path/to/oteapi-core can be left out of the first line, but then it must be updated in the second line, either to ./oteapi-core / oteapi-core or . if you cd into the generated folder wherein the repository has been cloned. The --upgrade-strategy=eager part can be left out. We recommend installing within a dedicated virtual environment. To test the installation, you can run: cd /path/to/oteapi-core pytest If you run into issues at this stage, please open an issue .","title":"For developers"},{"location":"#license","text":"OTEAPI Core is released under the MIT license with copyright \u00a9 SINTEF.","title":"License"},{"location":"#acknowledgment","text":"OTEAPI Core has been supported by the following projects: OntoTrans (2020-2024) that receives funding from the European Union\u2019s Horizon 2020 Research and Innovation Programme, under Grant Agreement no. 862136. VIPCOAT (2021-2025) receives funding from the European Union\u2019s Horizon 2020 Research and Innovation Programme - DT-NMBP-11-2020 Open Innovation Platform for Materials Modelling, under Grant Agreement no: 952903. OpenModel (2021-2025) receives funding from the European Union\u2019s Horizon 2020 Research and Innovation Programme - DT-NMBP-11-2020 Open Innovation Platform for Materials Modelling, under Grant Agreement no: 953167.","title":"Acknowledgment"},{"location":"CHANGELOG/","text":"Changelog \u00b6 Unreleased \u00b6 Full Changelog Implemented enhancements: Create a triple store class #120 v0.1.5 (2022-03-23) \u00b6 Full Changelog Implemented enhancements: Fix pydantic model types according to default values #117 Closed issues: Fix badge links in README #122 Merged pull requests: Update README.md #134 ( quaat ) [Auto-generated] Update dependencies #130 ( TEAM4-0 ) triplestore class which does add, delete/update and get mappings/triples #128 ( Treesarj ) Add links to badges in README #126 ( CasperWA ) Fix pydantic model type and default values #125 ( CasperWA ) v0.1.4 (2022-03-11) \u00b6 Full Changelog Implemented enhancements: Support passing a dictionary as config to create_strategy() #123 Merged pull requests: Using the StrategyType to deliver the *Config cls #124 ( CasperWA ) v0.1.3 (2022-03-10) \u00b6 Full Changelog Implemented enhancements: Move pytest fixtures into oteapi package #121 Add pop() (and possibly popitem() ) to AttrDict #118 Allow to bind values added to the data cache to an object, such that they automatically will be remove when the object goes out of scope #114 Add some badges to the README #91 Fixed bugs: The image strategy puts binary data in the session #107 Merged pull requests: Implement and test pop() and popitem() for AttrDict #119 ( CasperWA ) [Auto-generated] Update dependencies #116 ( TEAM4-0 ) Allow to bind the lifetime of datacache values to the lifetime of the session #115 ( jesper-friis ) Added mapping strategy #112 ( jesper-friis ) Corrected the sql_query_filter. #110 ( jesper-friis ) Store image data in datacache instead of session #108 ( jesper-friis ) Update README #106 ( CasperWA ) v0.1.2 (2022-03-03) \u00b6 Full Changelog Implemented enhancements: Go through ignored dev tools comments #76 Fixed bugs: Issue with AttrDict.update() for AttrDict subclasses #101 GH GraphQL type issue in auto-merge workflow #96 Merged pull requests: Update \"ignore\" statements #103 ( CasperWA ) Add test for AttrDict.update() method #102 ( CasperWA ) [Auto-generated] Update dependencies #100 ( TEAM4-0 ) Use ID! type instead of String! #97 ( CasperWA ) v0.1.1 (2022-02-24) \u00b6 Full Changelog Implemented enhancements: Avoid registerring the incomplete text/csv parse strategy #95 Use special *Config classes where necessary #93 Closed issues: Clean up the handling of paths in the file download strategy #84 Merged pull requests: Update data cache invocation #94 ( CasperWA ) [Auto-generated] Update dependencies #92 ( TEAM4-0 ) v0.1.0 (2022-02-22) \u00b6 Full Changelog Implemented enhancements: Clean up tests #75 Image parser: Use datacache #63 Fixed bugs: Entrypoint does not seem to be updated during rebuild #86 Use proper file scheme URLs in tests #74 xlsx parse strategy fails parsing file on Windows #23 Closed issues: Use standard library functions instead of homemade code for handling file:// URIs #88 Remove image/eps as supported image format #68 Merged pull requests: EntryPoint duplicity #87 ( CasperWA ) Added support for dumping numpy arrays to the datacache #83 ( jesper-friis ) [Auto-generated] Update dependencies #82 ( TEAM4-0 ) Pydantic dataclasses #81 ( CasperWA ) Made datacache accepting AttrDict configuration #70 ( jesper-friis ) v0.0.6 (2022-02-14) \u00b6 Full Changelog Implemented enhancements: New Function strategy #19 Fixed bugs: ResourceConfig.configuration should be a dict #65 Configuration bug #34 Change mediaType for json to application/json #24 Closed issues: AttrDict cannot be **unpacked #69 Add tests of configuration object subscripting functionality #61 Tests require installation #50 Rename image_jpeg.py #48 Write unit tests #11 Merged pull requests: Sg/session update model #78 ( sygout ) New Function strategy #73 ( CasperWA ) Made ResourceConfig.configuration a dict #67 ( jesper-friis ) [Auto-generated] Update dependencies #66 ( TEAM4-0 ) Add some dictionary functionality to configuration models #53 ( TorgeirUstad ) All new tests #35 ( TorgeirUstad ) v0.0.5 (2022-02-04) \u00b6 Full Changelog Implemented enhancements: Consider removing the create_*_strategy() functions #57 Lazy strategy loading #21 Extend and \"safeguard\" plugin loading through entry points #10 Fixed bugs: Out-of-scope CVE from NumPy makes safety cry #54 pyproject.toml addopts line doesn't work on Windows #51 Ignore ID 44715 for safety #55 ( CasperWA ) Merged pull requests: [Auto-generated] Update dependencies #56 ( TEAM4-0 ) Add Windows pytest CI job #52 ( CasperWA ) Start implementing entry point logic #47 ( CasperWA ) v0.0.4 (2022-01-26) \u00b6 Full Changelog Implemented enhancements: Setup dependency handling via dependabot #31 Attempt simplifying strategy factory function #13 Fixed bugs: Update pytest command in CI to fix codecov #42 Publish workflow failing - invoke not installed #40 Closed issues: Use new TEAM 4.0[bot] email throughout #38 Make datacache safe to call from within a running asyncio event loop #26 Setup documentation framework #9 Merged pull requests: [Auto-generated] Update dependencies #45 ( TEAM4-0 ) Add pytest options to pyproject.toml #43 ( CasperWA ) Install the dev extra in publish workflow #41 ( CasperWA ) Use the updated @TEAM4-0 email address #39 ( CasperWA ) Implement CI/CD for dependabot #33 ( CasperWA ) Remove asyncio from datacache #32 ( jesper-friis ) Setup docs framework and implement creating any strategy function #29 ( CasperWA ) v0.0.3 (2022-01-21) \u00b6 Full Changelog Implemented enhancements: Remove non-\"standard\" strategies #14 Clean up the API #12 Fixed bugs: Update CI/CD to only use Python 3.9 #25 References in README are wrong #18 Closed issues: Bring back pre-commit #16 Publish docker image #15 Merged pull requests: Updated cd_release.yml to python 3.9 #28 ( kriwiik ) Add back pre-commit #22 ( CasperWA ) Fixed README.md References #20 ( anasayb ) Clean up Python API #17 ( CasperWA ) v0.0.2 (2022-01-14) \u00b6 Full Changelog Implemented enhancements: Release and tests CD/CI #1 ( CasperWA ) Fixed bugs: CD publish release workflow not working #4 CD release not working - wrong utils path #2 Merged pull requests: Cleanup #8 ( jesper-friis ) Renamed oteapi/strategy-interfaces to oteapi/interfaces and updated paths in all Python modules #6 ( jesper-friis ) Update workflows to make CD work #5 ( CasperWA ) Fix location of utility files for GH Actions #3 ( CasperWA ) * This Changelog was automatically generated by github_changelog_generator","title":"Changelog"},{"location":"CHANGELOG/#changelog","text":"","title":"Changelog"},{"location":"CHANGELOG/#unreleased","text":"Full Changelog Implemented enhancements: Create a triple store class #120","title":"Unreleased"},{"location":"CHANGELOG/#v015-2022-03-23","text":"Full Changelog Implemented enhancements: Fix pydantic model types according to default values #117 Closed issues: Fix badge links in README #122 Merged pull requests: Update README.md #134 ( quaat ) [Auto-generated] Update dependencies #130 ( TEAM4-0 ) triplestore class which does add, delete/update and get mappings/triples #128 ( Treesarj ) Add links to badges in README #126 ( CasperWA ) Fix pydantic model type and default values #125 ( CasperWA )","title":"v0.1.5 (2022-03-23)"},{"location":"CHANGELOG/#v014-2022-03-11","text":"Full Changelog Implemented enhancements: Support passing a dictionary as config to create_strategy() #123 Merged pull requests: Using the StrategyType to deliver the *Config cls #124 ( CasperWA )","title":"v0.1.4 (2022-03-11)"},{"location":"CHANGELOG/#v013-2022-03-10","text":"Full Changelog Implemented enhancements: Move pytest fixtures into oteapi package #121 Add pop() (and possibly popitem() ) to AttrDict #118 Allow to bind values added to the data cache to an object, such that they automatically will be remove when the object goes out of scope #114 Add some badges to the README #91 Fixed bugs: The image strategy puts binary data in the session #107 Merged pull requests: Implement and test pop() and popitem() for AttrDict #119 ( CasperWA ) [Auto-generated] Update dependencies #116 ( TEAM4-0 ) Allow to bind the lifetime of datacache values to the lifetime of the session #115 ( jesper-friis ) Added mapping strategy #112 ( jesper-friis ) Corrected the sql_query_filter. #110 ( jesper-friis ) Store image data in datacache instead of session #108 ( jesper-friis ) Update README #106 ( CasperWA )","title":"v0.1.3 (2022-03-10)"},{"location":"CHANGELOG/#v012-2022-03-03","text":"Full Changelog Implemented enhancements: Go through ignored dev tools comments #76 Fixed bugs: Issue with AttrDict.update() for AttrDict subclasses #101 GH GraphQL type issue in auto-merge workflow #96 Merged pull requests: Update \"ignore\" statements #103 ( CasperWA ) Add test for AttrDict.update() method #102 ( CasperWA ) [Auto-generated] Update dependencies #100 ( TEAM4-0 ) Use ID! type instead of String! #97 ( CasperWA )","title":"v0.1.2 (2022-03-03)"},{"location":"CHANGELOG/#v011-2022-02-24","text":"Full Changelog Implemented enhancements: Avoid registerring the incomplete text/csv parse strategy #95 Use special *Config classes where necessary #93 Closed issues: Clean up the handling of paths in the file download strategy #84 Merged pull requests: Update data cache invocation #94 ( CasperWA ) [Auto-generated] Update dependencies #92 ( TEAM4-0 )","title":"v0.1.1 (2022-02-24)"},{"location":"CHANGELOG/#v010-2022-02-22","text":"Full Changelog Implemented enhancements: Clean up tests #75 Image parser: Use datacache #63 Fixed bugs: Entrypoint does not seem to be updated during rebuild #86 Use proper file scheme URLs in tests #74 xlsx parse strategy fails parsing file on Windows #23 Closed issues: Use standard library functions instead of homemade code for handling file:// URIs #88 Remove image/eps as supported image format #68 Merged pull requests: EntryPoint duplicity #87 ( CasperWA ) Added support for dumping numpy arrays to the datacache #83 ( jesper-friis ) [Auto-generated] Update dependencies #82 ( TEAM4-0 ) Pydantic dataclasses #81 ( CasperWA ) Made datacache accepting AttrDict configuration #70 ( jesper-friis )","title":"v0.1.0 (2022-02-22)"},{"location":"CHANGELOG/#v006-2022-02-14","text":"Full Changelog Implemented enhancements: New Function strategy #19 Fixed bugs: ResourceConfig.configuration should be a dict #65 Configuration bug #34 Change mediaType for json to application/json #24 Closed issues: AttrDict cannot be **unpacked #69 Add tests of configuration object subscripting functionality #61 Tests require installation #50 Rename image_jpeg.py #48 Write unit tests #11 Merged pull requests: Sg/session update model #78 ( sygout ) New Function strategy #73 ( CasperWA ) Made ResourceConfig.configuration a dict #67 ( jesper-friis ) [Auto-generated] Update dependencies #66 ( TEAM4-0 ) Add some dictionary functionality to configuration models #53 ( TorgeirUstad ) All new tests #35 ( TorgeirUstad )","title":"v0.0.6 (2022-02-14)"},{"location":"CHANGELOG/#v005-2022-02-04","text":"Full Changelog Implemented enhancements: Consider removing the create_*_strategy() functions #57 Lazy strategy loading #21 Extend and \"safeguard\" plugin loading through entry points #10 Fixed bugs: Out-of-scope CVE from NumPy makes safety cry #54 pyproject.toml addopts line doesn't work on Windows #51 Ignore ID 44715 for safety #55 ( CasperWA ) Merged pull requests: [Auto-generated] Update dependencies #56 ( TEAM4-0 ) Add Windows pytest CI job #52 ( CasperWA ) Start implementing entry point logic #47 ( CasperWA )","title":"v0.0.5 (2022-02-04)"},{"location":"CHANGELOG/#v004-2022-01-26","text":"Full Changelog Implemented enhancements: Setup dependency handling via dependabot #31 Attempt simplifying strategy factory function #13 Fixed bugs: Update pytest command in CI to fix codecov #42 Publish workflow failing - invoke not installed #40 Closed issues: Use new TEAM 4.0[bot] email throughout #38 Make datacache safe to call from within a running asyncio event loop #26 Setup documentation framework #9 Merged pull requests: [Auto-generated] Update dependencies #45 ( TEAM4-0 ) Add pytest options to pyproject.toml #43 ( CasperWA ) Install the dev extra in publish workflow #41 ( CasperWA ) Use the updated @TEAM4-0 email address #39 ( CasperWA ) Implement CI/CD for dependabot #33 ( CasperWA ) Remove asyncio from datacache #32 ( jesper-friis ) Setup docs framework and implement creating any strategy function #29 ( CasperWA )","title":"v0.0.4 (2022-01-26)"},{"location":"CHANGELOG/#v003-2022-01-21","text":"Full Changelog Implemented enhancements: Remove non-\"standard\" strategies #14 Clean up the API #12 Fixed bugs: Update CI/CD to only use Python 3.9 #25 References in README are wrong #18 Closed issues: Bring back pre-commit #16 Publish docker image #15 Merged pull requests: Updated cd_release.yml to python 3.9 #28 ( kriwiik ) Add back pre-commit #22 ( CasperWA ) Fixed README.md References #20 ( anasayb ) Clean up Python API #17 ( CasperWA )","title":"v0.0.3 (2022-01-21)"},{"location":"CHANGELOG/#v002-2022-01-14","text":"Full Changelog Implemented enhancements: Release and tests CD/CI #1 ( CasperWA ) Fixed bugs: CD publish release workflow not working #4 CD release not working - wrong utils path #2 Merged pull requests: Cleanup #8 ( jesper-friis ) Renamed oteapi/strategy-interfaces to oteapi/interfaces and updated paths in all Python modules #6 ( jesper-friis ) Update workflows to make CD work #5 ( CasperWA ) Fix location of utility files for GH Actions #3 ( CasperWA ) * This Changelog was automatically generated by github_changelog_generator","title":"v0.0.2 (2022-01-14)"},{"location":"LICENSE/","text":"MIT License Copyright (c) 2020-2022 SINTEF Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"License"},{"location":"all_models/","text":"OTE-API Configuration Models \u00b6 This page provides documentation for the oteapi.models submodule, where all the OTE-API strategy configuration data models are located. When creating instances of these models, the data types are automatically validated. oteapi.models module. This module contains all the pydantic configuration models. AttrDict \u00b6 Bases: BaseModel , Mapping An object whose attributes can also be accessed through subscription, like with a dictionary. Source code in oteapi/models/genericconfig.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 class AttrDict ( BaseModel , Mapping ): \"\"\"An object whose attributes can also be accessed through subscription, like with a dictionary.\"\"\" def __contains__ ( self , name : \"Any\" ) -> bool : \"\"\"Enable using the 'in' operator on this object.\"\"\" return self . __dict__ . __contains__ ( name ) def __delitem__ ( self , key : str ) -> None : \"\"\"Enable deletion access through subscription. If the item is a pydantic field, reset it and remove it from the set of set fields. Otherwise, delete the attribute. \"\"\" if key in self . __dict__ : if key in self . __fields__ : # Reset field to default and remove from set of set fields setattr ( self , key , self . __fields__ [ key ] . default ) self . __fields_set__ . remove ( key ) # pylint: disable=no-member else : self . __delattr__ ( key ) else : raise KeyError ( key ) def __getitem__ ( self , key : str ) -> \"Any\" : \"\"\"Enable read access through subscription.\"\"\" if key in self . __dict__ : return getattr ( self , key ) raise KeyError ( key ) def __setitem__ ( self , key : str , value : \"Any\" ) -> None : \"\"\"Enable write access through subscription.\"\"\" setattr ( self , key , value ) def __len__ ( self ): \"\"\"Return number of items.\"\"\" return self . __dict__ . __len__ () def __iter__ ( self ): \"\"\"Enable **unpacking.\"\"\" return self . __dict__ . __iter__ () def items ( self ): \"\"\"Return a view of all (key, value) pairs.\"\"\" return self . __dict__ . items () def keys ( self ): \"\"\"Return a view of all keys.\"\"\" return self . __dict__ . keys () def values ( self ): \"\"\"Return a view of all values.\"\"\" return self . __dict__ . values () def get ( self , key : str , default : \"Optional[Any]\" = None ) -> \"Any\" : \"\"\"Mapping `get`-method.\"\"\" return self . __dict__ . get ( key , default ) def __ne__ ( self , other : \"Any\" ) -> bool : \"\"\"Implement the != operator.\"\"\" if isinstance ( other , BaseModel ): return self . dict () != other . dict () return self . dict () != other def update ( self , other : \"Optional[Union[dict, AttrDict, Iterable[Any]]]\" = None , ** kwargs ) -> None : \"\"\"MutableMapping `update`-method.\"\"\" if other and isinstance ( other , ( dict , Mapping )): for key , value in other . items (): setattr ( self , key , value ) elif other and isinstance ( other , BaseModel ): for key , value in other . dict () . items (): setattr ( self , key , value ) elif other and isinstance ( other , Iterable ): for entry in other : if not len ( entry ) == 2 : raise ValueError ( \"`other` must be an iterable of objects of length two.\" ) for key , value in other : setattr ( self , key , value ) if kwargs : for key , value in kwargs . items (): setattr ( self , key , value ) def pop ( self , key : str , default : \"Optional[Any]\" = Undefined ) -> \"Any\" : \"\"\"MutableMapping `pop`-method.\"\"\" value = self . get ( key , default ) if value == Undefined : raise KeyError ( key ) if key in self : del self [ key ] return value def popitem ( self ) -> \"Tuple[str, Any]\" : \"\"\"MutableMapping `popitem`-method. Important: Unlike the regular `dict.popitem()` method, this one does _not_ respect LIFO (last-in, first-out). This is due to the fact that attributes are stored in a random order when initializing the model. However, it will respect LIFO with respect to the internal `__dict__`. \"\"\" if not self : raise KeyError ( f \"popitem(): { self . __class__ . __name__ } is empty\" ) key = list ( self . __dict__ )[ - 1 ] value = self . pop ( key ) return key , value class Config : \"\"\"Pydantic configuration for `AttrDict`. * **`extra`** Allow any attributes/fields to be defined - this is what makes this pydantic model an attribute dictionary. * **`validate_assignment`** Validate and cast set values. This is mainly relevant for sub-classes of `AttrDict`, where specific attributes have been defined. * **`arbitrary_types_allowed`** If a custom type is used for an attribute that doesn't have a `validate()` method, don't fail setting the attribute. \"\"\" extra = \"allow\" validate_assignment = True arbitrary_types_allowed = True Config \u00b6 Pydantic configuration for AttrDict . extra Allow any attributes/fields to be defined - this is what makes this pydantic model an attribute dictionary. validate_assignment Validate and cast set values. This is mainly relevant for sub-classes of AttrDict , where specific attributes have been defined. arbitrary_types_allowed If a custom type is used for an attribute that doesn't have a validate() method, don't fail setting the attribute. Source code in oteapi/models/genericconfig.py 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 class Config : \"\"\"Pydantic configuration for `AttrDict`. * **`extra`** Allow any attributes/fields to be defined - this is what makes this pydantic model an attribute dictionary. * **`validate_assignment`** Validate and cast set values. This is mainly relevant for sub-classes of `AttrDict`, where specific attributes have been defined. * **`arbitrary_types_allowed`** If a custom type is used for an attribute that doesn't have a `validate()` method, don't fail setting the attribute. \"\"\" extra = \"allow\" validate_assignment = True arbitrary_types_allowed = True __contains__ ( name ) \u00b6 Enable using the 'in' operator on this object. Source code in oteapi/models/genericconfig.py 15 16 17 def __contains__ ( self , name : \"Any\" ) -> bool : \"\"\"Enable using the 'in' operator on this object.\"\"\" return self . __dict__ . __contains__ ( name ) __delitem__ ( key ) \u00b6 Enable deletion access through subscription. If the item is a pydantic field, reset it and remove it from the set of set fields. Otherwise, delete the attribute. Source code in oteapi/models/genericconfig.py 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 def __delitem__ ( self , key : str ) -> None : \"\"\"Enable deletion access through subscription. If the item is a pydantic field, reset it and remove it from the set of set fields. Otherwise, delete the attribute. \"\"\" if key in self . __dict__ : if key in self . __fields__ : # Reset field to default and remove from set of set fields setattr ( self , key , self . __fields__ [ key ] . default ) self . __fields_set__ . remove ( key ) # pylint: disable=no-member else : self . __delattr__ ( key ) else : raise KeyError ( key ) __getitem__ ( key ) \u00b6 Enable read access through subscription. Source code in oteapi/models/genericconfig.py 36 37 38 39 40 def __getitem__ ( self , key : str ) -> \"Any\" : \"\"\"Enable read access through subscription.\"\"\" if key in self . __dict__ : return getattr ( self , key ) raise KeyError ( key ) __iter__ () \u00b6 Enable **unpacking. Source code in oteapi/models/genericconfig.py 50 51 52 def __iter__ ( self ): \"\"\"Enable **unpacking.\"\"\" return self . __dict__ . __iter__ () __len__ () \u00b6 Return number of items. Source code in oteapi/models/genericconfig.py 46 47 48 def __len__ ( self ): \"\"\"Return number of items.\"\"\" return self . __dict__ . __len__ () __ne__ ( other ) \u00b6 Implement the != operator. Source code in oteapi/models/genericconfig.py 70 71 72 73 74 def __ne__ ( self , other : \"Any\" ) -> bool : \"\"\"Implement the != operator.\"\"\" if isinstance ( other , BaseModel ): return self . dict () != other . dict () return self . dict () != other __setitem__ ( key , value ) \u00b6 Enable write access through subscription. Source code in oteapi/models/genericconfig.py 42 43 44 def __setitem__ ( self , key : str , value : \"Any\" ) -> None : \"\"\"Enable write access through subscription.\"\"\" setattr ( self , key , value ) get ( key , default = None ) \u00b6 Mapping get -method. Source code in oteapi/models/genericconfig.py 66 67 68 def get ( self , key : str , default : \"Optional[Any]\" = None ) -> \"Any\" : \"\"\"Mapping `get`-method.\"\"\" return self . __dict__ . get ( key , default ) items () \u00b6 Return a view of all (key, value) pairs. Source code in oteapi/models/genericconfig.py 54 55 56 def items ( self ): \"\"\"Return a view of all (key, value) pairs.\"\"\" return self . __dict__ . items () keys () \u00b6 Return a view of all keys. Source code in oteapi/models/genericconfig.py 58 59 60 def keys ( self ): \"\"\"Return a view of all keys.\"\"\" return self . __dict__ . keys () pop ( key , default = Undefined ) \u00b6 MutableMapping pop -method. Source code in oteapi/models/genericconfig.py 98 99 100 101 102 103 104 105 def pop ( self , key : str , default : \"Optional[Any]\" = Undefined ) -> \"Any\" : \"\"\"MutableMapping `pop`-method.\"\"\" value = self . get ( key , default ) if value == Undefined : raise KeyError ( key ) if key in self : del self [ key ] return value popitem () \u00b6 MutableMapping popitem -method. Important Unlike the regular dict.popitem() method, this one does not respect LIFO (last-in, first-out). This is due to the fact that attributes are stored in a random order when initializing the model. However, it will respect LIFO with respect to the internal __dict__ . Source code in oteapi/models/genericconfig.py 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 def popitem ( self ) -> \"Tuple[str, Any]\" : \"\"\"MutableMapping `popitem`-method. Important: Unlike the regular `dict.popitem()` method, this one does _not_ respect LIFO (last-in, first-out). This is due to the fact that attributes are stored in a random order when initializing the model. However, it will respect LIFO with respect to the internal `__dict__`. \"\"\" if not self : raise KeyError ( f \"popitem(): { self . __class__ . __name__ } is empty\" ) key = list ( self . __dict__ )[ - 1 ] value = self . pop ( key ) return key , value update ( other = None , ** kwargs ) \u00b6 MutableMapping update -method. Source code in oteapi/models/genericconfig.py 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 def update ( self , other : \"Optional[Union[dict, AttrDict, Iterable[Any]]]\" = None , ** kwargs ) -> None : \"\"\"MutableMapping `update`-method.\"\"\" if other and isinstance ( other , ( dict , Mapping )): for key , value in other . items (): setattr ( self , key , value ) elif other and isinstance ( other , BaseModel ): for key , value in other . dict () . items (): setattr ( self , key , value ) elif other and isinstance ( other , Iterable ): for entry in other : if not len ( entry ) == 2 : raise ValueError ( \"`other` must be an iterable of objects of length two.\" ) for key , value in other : setattr ( self , key , value ) if kwargs : for key , value in kwargs . items (): setattr ( self , key , value ) values () \u00b6 Return a view of all values. Source code in oteapi/models/genericconfig.py 62 63 64 def values ( self ): \"\"\"Return a view of all values.\"\"\" return self . __dict__ . values () DataCacheConfig \u00b6 Bases: AttrDict DataCache Configuration. This class should not be used directly as a configuration object for a strategy object, but only as a configuration field inside a configuration object. Source code in oteapi/models/datacacheconfig.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 class DataCacheConfig ( AttrDict ): \"\"\"DataCache Configuration. This class should not be used directly as a configuration object for a strategy object, but only as a configuration field inside a configuration object. \"\"\" cacheDir : Path = Field ( Path ( \"oteapi\" ), description = \"Cache directory.\" ) accessKey : Optional [ str ] = Field ( None , description = \"Key with which the downloaded content can be accessed. \" \"Should preferable be the hash (corresponding to `hashType`) of the \" \"content if it is known.\" , ) hashType : str = Field ( \"md5\" , description = \"Hash algorithm to use for creating hash keys for stored \" \"data. Can be any algorithm supported by hashlib.\" , ) expireTime : int = Field ( 3600 * 24 * 14 , description = \"Number of seconds before the cache entry expires. \" \"Zero means no expiration. Default is two weeks.\" , ) tag : Optional [ str ] = Field ( None , description = \"Tag assigned to the downloaded content, typically \" \"identifying a session. Used with the `evict()` method to clean up a \" \"all cache entries with a given tag.\" , ) FilterConfig \u00b6 Bases: GenericConfig Filter Strategy Data Configuration. Source code in oteapi/models/filterconfig.py 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class FilterConfig ( GenericConfig ): \"\"\"Filter Strategy Data Configuration.\"\"\" filterType : str = Field ( ... , description = \"Type of registered filter strategy. E.g., `filter/sql`.\" ) query : Optional [ str ] = Field ( None , description = \"Define a query operation.\" ) condition : Optional [ str ] = Field ( None , description = \"Logical statement indicating when a filter should be applied.\" , ) limit : Optional [ int ] = Field ( None , description = \"Number of items remaining after a filter expression.\" ) FunctionConfig \u00b6 Bases: GenericConfig Function Strategy Data Configuration. Source code in oteapi/models/functionconfig.py 7 8 9 10 11 12 13 class FunctionConfig ( GenericConfig ): \"\"\"Function Strategy Data Configuration.\"\"\" functionType : str = Field ( ... , description = ( \"Type of registered function strategy.\" ), ) GenericConfig \u00b6 Bases: BaseModel Generic class for configuration objects. Source code in oteapi/models/genericconfig.py 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 class GenericConfig ( BaseModel ): \"\"\"Generic class for configuration objects.\"\"\" configuration : AttrDict = Field ( AttrDict (), description = \"Model-specific configuration options which can either \" \"be given as key/value-pairs or set as attributes.\" , ) description : str = Field ( __doc__ , description = \"A description of the configuration model.\" , ) @classmethod def __init_subclass__ ( cls ) -> None : \"\"\"Initialize subclass descriptions with their docstrings.\"\"\" cls . __fields__ [ \"description\" ] . default = cls . __doc__ class Config : \"\"\"Pydantic configuration for `GenericConfig`. * **`validate_assignment`** Validate and cast set values. This is mainly relevant for sub-classes of `AttrDict`, where specific attributes have been defined. * **`arbitrary_types_allowed`** If a custom type is used for an attribute that doesn't have a `validate()` method, don't fail setting the attribute. \"\"\" validate_assignment = True arbitrary_types_allowed = True Config \u00b6 Pydantic configuration for GenericConfig . validate_assignment Validate and cast set values. This is mainly relevant for sub-classes of AttrDict , where specific attributes have been defined. arbitrary_types_allowed If a custom type is used for an attribute that doesn't have a validate() method, don't fail setting the attribute. Source code in oteapi/models/genericconfig.py 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 class Config : \"\"\"Pydantic configuration for `GenericConfig`. * **`validate_assignment`** Validate and cast set values. This is mainly relevant for sub-classes of `AttrDict`, where specific attributes have been defined. * **`arbitrary_types_allowed`** If a custom type is used for an attribute that doesn't have a `validate()` method, don't fail setting the attribute. \"\"\" validate_assignment = True arbitrary_types_allowed = True __init_subclass__ () classmethod \u00b6 Initialize subclass descriptions with their docstrings. Source code in oteapi/models/genericconfig.py 161 162 163 164 @classmethod def __init_subclass__ ( cls ) -> None : \"\"\"Initialize subclass descriptions with their docstrings.\"\"\" cls . __fields__ [ \"description\" ] . default = cls . __doc__ MappingConfig \u00b6 Bases: GenericConfig Mapping Strategy Data Configuration. Source code in oteapi/models/mappingconfig.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class MappingConfig ( GenericConfig ): \"\"\"Mapping Strategy Data Configuration.\"\"\" mappingType : str = Field ( ... , description = \"Type of registered mapping strategy.\" , ) prefixes : Optional [ Dict [ str , str ]] = Field ( None , description = ( \"List of shortnames that expands to an IRI given as local \" \"value/IRI-expansion-pairs.\" ), ) triples : Optional [ List [ RDFTriple ]] = Field ( None , description = \"List of RDF triples given as (subject, predicate, object).\" , ) ResourceConfig \u00b6 Bases: GenericConfig Resource Strategy Data Configuration. Important Either of the pairs of attributes downloadUrl / mediaType or accessUrl / accessService MUST be specified. Source code in oteapi/models/resourceconfig.py 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 class ResourceConfig ( GenericConfig ): \"\"\"Resource Strategy Data Configuration. Important: Either of the pairs of attributes `downloadUrl`/`mediaType` or `accessUrl`/`accessService` MUST be specified. \"\"\" downloadUrl : Optional [ HostlessAnyUrl ] = Field ( None , description = ( \"Definition: The URL of the downloadable file in a given format. E.g. CSV \" \"file or RDF file. \\n\\n Usage: `downloadURL` *SHOULD* be used for the URL at\" \" which this distribution is available directly, typically through a HTTPS\" \" GET request or SFTP.\" ), ) mediaType : Optional [ str ] = Field ( None , description = ( \"The media type of the distribution as defined by IANA \" \"[[IANA-MEDIA-TYPES](https://www.w3.org/TR/vocab-dcat-2/#bib-iana-media-types)]\" \". \\n\\n Usage: This property *SHOULD* be used when the media\" \" type of the distribution is defined in IANA \" \"[[IANA-MEDIA-TYPES](https://www.w3.org/TR/vocab-dcat-2/#bib-iana-media-types)].\" ), ) accessUrl : Optional [ HostlessAnyUrl ] = Field ( None , description = ( \"A URL of the resource that gives access to a distribution of \" \"the dataset. E.g. landing page, feed, SPARQL endpoint. \\n\\n Usage: \" \"`accessURL` *SHOULD* be used for the URL of a service or location that \" \"can provide access to this distribution, typically through a Web form, \" \"query or API call. \\n `downloadURL` is preferred for direct links to \" \"downloadable resources.\" ), ) accessService : Optional [ str ] = Field ( None , description = ( \"A data service that gives access to the distribution of the dataset.\" ), ) license : Optional [ str ] = Field ( None , description = ( \"A legal document under which the distribution is made available.\" ), ) accessRights : Optional [ str ] = Field ( None , description = ( \"A rights statement that concerns how the distribution is accessed.\" ), ) publisher : Optional [ str ] = Field ( None , description = \"The entity responsible for making the resource/item available.\" , ) @root_validator def ensure_unique_url_pairs ( # pylint: disable=no-self-use cls , values : \"Dict[str, Any]\" ) -> \"Dict[str, Any]\" : \"\"\"Ensure either downloadUrl/mediaType or accessUrl/accessService are defined. It's fine to define them all, but at least one complete pair MUST be specified. \"\"\" if not ( all ( values . get ( _ ) for _ in [ \"downloadUrl\" , \"mediaType\" ]) or all ( values . get ( _ ) for _ in [ \"accessUrl\" , \"accessService\" ]) ): raise ValueError ( \"Either of the pairs of attributes downloadUrl/mediaType or \" \"accessUrl/accessService MUST be specified.\" ) return values ensure_unique_url_pairs ( values ) \u00b6 Ensure either downloadUrl/mediaType or accessUrl/accessService are defined. It's fine to define them all, but at least one complete pair MUST be specified. Source code in oteapi/models/resourceconfig.py 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 @root_validator def ensure_unique_url_pairs ( # pylint: disable=no-self-use cls , values : \"Dict[str, Any]\" ) -> \"Dict[str, Any]\" : \"\"\"Ensure either downloadUrl/mediaType or accessUrl/accessService are defined. It's fine to define them all, but at least one complete pair MUST be specified. \"\"\" if not ( all ( values . get ( _ ) for _ in [ \"downloadUrl\" , \"mediaType\" ]) or all ( values . get ( _ ) for _ in [ \"accessUrl\" , \"accessService\" ]) ): raise ValueError ( \"Either of the pairs of attributes downloadUrl/mediaType or \" \"accessUrl/accessService MUST be specified.\" ) return values SessionUpdate \u00b6 Bases: AttrDict Session Update Data Model for returning values. Source code in oteapi/models/sessionupdate.py 5 6 class SessionUpdate ( AttrDict ): \"\"\"Session Update Data Model for returning values.\"\"\" TransformationConfig \u00b6 Bases: GenericConfig Transformation Strategy Data Configuration. Source code in oteapi/models/transformationconfig.py 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 class TransformationConfig ( GenericConfig ): \"\"\"Transformation Strategy Data Configuration.\"\"\" transformationType : str = Field ( ... , description = ( \"Type of registered transformation strategy. E.g., `celery/remote`.\" ), ) name : Optional [ str ] = Field ( None , description = \"Human-readable name of the transformation strategy.\" ) due : Optional [ datetime ] = Field ( None , description = ( \"Optional field to indicate a due data/time for when a transformation \" \"should finish.\" ), ) priority : Optional [ ProcessPriority ] = Field ( ProcessPriority . MEDIUM , description = \"Define the process priority of the transformation execution.\" , ) secret : Optional [ str ] = Field ( None , description = \"Authorization secret given when running a transformation.\" , ) TransformationStatus \u00b6 Bases: BaseModel Return from transformation status. Source code in oteapi/models/transformationconfig.py 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 class TransformationStatus ( BaseModel ): \"\"\"Return from transformation status.\"\"\" id : str = Field ( ... , description = \"ID for the given transformation process.\" ) status : Optional [ str ] = Field ( None , description = \"Status for the transformation process.\" ) messages : Optional [ List [ str ]] = Field ( None , description = \"Messages related to the transformation process.\" ) created : Optional [ datetime ] = Field ( None , description = \"Time of creation for the transformation process. Given in UTC.\" , ) startTime : Optional [ datetime ] = Field ( None , description = \"Time when the transformation process started. Given in UTC.\" ) finishTime : Optional [ datetime ] = Field ( None , description = \"Time when the tranformation process finished. Given in UTC.\" ) TripleStoreConfig \u00b6 Bases: AttrDict TripleStore Configuration. This is a configuration for the TripleStore . This class should not be used directly as a configuration object for a strategy object, but only as a configuration field inside a configuration object. Source code in oteapi/models/triplestoreconfig.py 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 class TripleStoreConfig ( AttrDict ): \"\"\"TripleStore Configuration. This is a configuration for the [`TripleStore`][oteapi.triplestore.triplestore.TripleStore]. This class should not be used directly as a configuration object for a strategy object, but only as a configuration field inside a configuration object. \"\"\" repositoryName : str = Field ( ... , description = \"The repository name, where the mappings are stored.\" ) agraphHost : str = Field ( ... , description = \"AllegroGraph host name.\" , ) agraphPort : int = Field ( ... , description = \"AllegroGraph port number.\" , ) agraphUser : str = Field ( ... , description = \"AllegroGraph user name.\" , ) agraphPassword : SecretStr = Field ( ... , description = \"AllegroGraph user password.\" , ) datacacheconfig \u00b6 Pydantic DataCache Configuration Data Model. DataCacheConfig \u00b6 Bases: AttrDict DataCache Configuration. This class should not be used directly as a configuration object for a strategy object, but only as a configuration field inside a configuration object. Source code in oteapi/models/datacacheconfig.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 class DataCacheConfig ( AttrDict ): \"\"\"DataCache Configuration. This class should not be used directly as a configuration object for a strategy object, but only as a configuration field inside a configuration object. \"\"\" cacheDir : Path = Field ( Path ( \"oteapi\" ), description = \"Cache directory.\" ) accessKey : Optional [ str ] = Field ( None , description = \"Key with which the downloaded content can be accessed. \" \"Should preferable be the hash (corresponding to `hashType`) of the \" \"content if it is known.\" , ) hashType : str = Field ( \"md5\" , description = \"Hash algorithm to use for creating hash keys for stored \" \"data. Can be any algorithm supported by hashlib.\" , ) expireTime : int = Field ( 3600 * 24 * 14 , description = \"Number of seconds before the cache entry expires. \" \"Zero means no expiration. Default is two weeks.\" , ) tag : Optional [ str ] = Field ( None , description = \"Tag assigned to the downloaded content, typically \" \"identifying a session. Used with the `evict()` method to clean up a \" \"all cache entries with a given tag.\" , ) filterconfig \u00b6 Pydantic Filter Configuration Data Model. FilterConfig \u00b6 Bases: GenericConfig Filter Strategy Data Configuration. Source code in oteapi/models/filterconfig.py 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class FilterConfig ( GenericConfig ): \"\"\"Filter Strategy Data Configuration.\"\"\" filterType : str = Field ( ... , description = \"Type of registered filter strategy. E.g., `filter/sql`.\" ) query : Optional [ str ] = Field ( None , description = \"Define a query operation.\" ) condition : Optional [ str ] = Field ( None , description = \"Logical statement indicating when a filter should be applied.\" , ) limit : Optional [ int ] = Field ( None , description = \"Number of items remaining after a filter expression.\" ) functionconfig \u00b6 Pydantic Function Configuration Data Model. FunctionConfig \u00b6 Bases: GenericConfig Function Strategy Data Configuration. Source code in oteapi/models/functionconfig.py 7 8 9 10 11 12 13 class FunctionConfig ( GenericConfig ): \"\"\"Function Strategy Data Configuration.\"\"\" functionType : str = Field ( ... , description = ( \"Type of registered function strategy.\" ), ) genericconfig \u00b6 Generic data model for configuration attributes. AttrDict \u00b6 Bases: BaseModel , Mapping An object whose attributes can also be accessed through subscription, like with a dictionary. Source code in oteapi/models/genericconfig.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 class AttrDict ( BaseModel , Mapping ): \"\"\"An object whose attributes can also be accessed through subscription, like with a dictionary.\"\"\" def __contains__ ( self , name : \"Any\" ) -> bool : \"\"\"Enable using the 'in' operator on this object.\"\"\" return self . __dict__ . __contains__ ( name ) def __delitem__ ( self , key : str ) -> None : \"\"\"Enable deletion access through subscription. If the item is a pydantic field, reset it and remove it from the set of set fields. Otherwise, delete the attribute. \"\"\" if key in self . __dict__ : if key in self . __fields__ : # Reset field to default and remove from set of set fields setattr ( self , key , self . __fields__ [ key ] . default ) self . __fields_set__ . remove ( key ) # pylint: disable=no-member else : self . __delattr__ ( key ) else : raise KeyError ( key ) def __getitem__ ( self , key : str ) -> \"Any\" : \"\"\"Enable read access through subscription.\"\"\" if key in self . __dict__ : return getattr ( self , key ) raise KeyError ( key ) def __setitem__ ( self , key : str , value : \"Any\" ) -> None : \"\"\"Enable write access through subscription.\"\"\" setattr ( self , key , value ) def __len__ ( self ): \"\"\"Return number of items.\"\"\" return self . __dict__ . __len__ () def __iter__ ( self ): \"\"\"Enable **unpacking.\"\"\" return self . __dict__ . __iter__ () def items ( self ): \"\"\"Return a view of all (key, value) pairs.\"\"\" return self . __dict__ . items () def keys ( self ): \"\"\"Return a view of all keys.\"\"\" return self . __dict__ . keys () def values ( self ): \"\"\"Return a view of all values.\"\"\" return self . __dict__ . values () def get ( self , key : str , default : \"Optional[Any]\" = None ) -> \"Any\" : \"\"\"Mapping `get`-method.\"\"\" return self . __dict__ . get ( key , default ) def __ne__ ( self , other : \"Any\" ) -> bool : \"\"\"Implement the != operator.\"\"\" if isinstance ( other , BaseModel ): return self . dict () != other . dict () return self . dict () != other def update ( self , other : \"Optional[Union[dict, AttrDict, Iterable[Any]]]\" = None , ** kwargs ) -> None : \"\"\"MutableMapping `update`-method.\"\"\" if other and isinstance ( other , ( dict , Mapping )): for key , value in other . items (): setattr ( self , key , value ) elif other and isinstance ( other , BaseModel ): for key , value in other . dict () . items (): setattr ( self , key , value ) elif other and isinstance ( other , Iterable ): for entry in other : if not len ( entry ) == 2 : raise ValueError ( \"`other` must be an iterable of objects of length two.\" ) for key , value in other : setattr ( self , key , value ) if kwargs : for key , value in kwargs . items (): setattr ( self , key , value ) def pop ( self , key : str , default : \"Optional[Any]\" = Undefined ) -> \"Any\" : \"\"\"MutableMapping `pop`-method.\"\"\" value = self . get ( key , default ) if value == Undefined : raise KeyError ( key ) if key in self : del self [ key ] return value def popitem ( self ) -> \"Tuple[str, Any]\" : \"\"\"MutableMapping `popitem`-method. Important: Unlike the regular `dict.popitem()` method, this one does _not_ respect LIFO (last-in, first-out). This is due to the fact that attributes are stored in a random order when initializing the model. However, it will respect LIFO with respect to the internal `__dict__`. \"\"\" if not self : raise KeyError ( f \"popitem(): { self . __class__ . __name__ } is empty\" ) key = list ( self . __dict__ )[ - 1 ] value = self . pop ( key ) return key , value class Config : \"\"\"Pydantic configuration for `AttrDict`. * **`extra`** Allow any attributes/fields to be defined - this is what makes this pydantic model an attribute dictionary. * **`validate_assignment`** Validate and cast set values. This is mainly relevant for sub-classes of `AttrDict`, where specific attributes have been defined. * **`arbitrary_types_allowed`** If a custom type is used for an attribute that doesn't have a `validate()` method, don't fail setting the attribute. \"\"\" extra = \"allow\" validate_assignment = True arbitrary_types_allowed = True Config \u00b6 Pydantic configuration for AttrDict . extra Allow any attributes/fields to be defined - this is what makes this pydantic model an attribute dictionary. validate_assignment Validate and cast set values. This is mainly relevant for sub-classes of AttrDict , where specific attributes have been defined. arbitrary_types_allowed If a custom type is used for an attribute that doesn't have a validate() method, don't fail setting the attribute. Source code in oteapi/models/genericconfig.py 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 class Config : \"\"\"Pydantic configuration for `AttrDict`. * **`extra`** Allow any attributes/fields to be defined - this is what makes this pydantic model an attribute dictionary. * **`validate_assignment`** Validate and cast set values. This is mainly relevant for sub-classes of `AttrDict`, where specific attributes have been defined. * **`arbitrary_types_allowed`** If a custom type is used for an attribute that doesn't have a `validate()` method, don't fail setting the attribute. \"\"\" extra = \"allow\" validate_assignment = True arbitrary_types_allowed = True __contains__ ( name ) \u00b6 Enable using the 'in' operator on this object. Source code in oteapi/models/genericconfig.py 15 16 17 def __contains__ ( self , name : \"Any\" ) -> bool : \"\"\"Enable using the 'in' operator on this object.\"\"\" return self . __dict__ . __contains__ ( name ) __delitem__ ( key ) \u00b6 Enable deletion access through subscription. If the item is a pydantic field, reset it and remove it from the set of set fields. Otherwise, delete the attribute. Source code in oteapi/models/genericconfig.py 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 def __delitem__ ( self , key : str ) -> None : \"\"\"Enable deletion access through subscription. If the item is a pydantic field, reset it and remove it from the set of set fields. Otherwise, delete the attribute. \"\"\" if key in self . __dict__ : if key in self . __fields__ : # Reset field to default and remove from set of set fields setattr ( self , key , self . __fields__ [ key ] . default ) self . __fields_set__ . remove ( key ) # pylint: disable=no-member else : self . __delattr__ ( key ) else : raise KeyError ( key ) __getitem__ ( key ) \u00b6 Enable read access through subscription. Source code in oteapi/models/genericconfig.py 36 37 38 39 40 def __getitem__ ( self , key : str ) -> \"Any\" : \"\"\"Enable read access through subscription.\"\"\" if key in self . __dict__ : return getattr ( self , key ) raise KeyError ( key ) __iter__ () \u00b6 Enable **unpacking. Source code in oteapi/models/genericconfig.py 50 51 52 def __iter__ ( self ): \"\"\"Enable **unpacking.\"\"\" return self . __dict__ . __iter__ () __len__ () \u00b6 Return number of items. Source code in oteapi/models/genericconfig.py 46 47 48 def __len__ ( self ): \"\"\"Return number of items.\"\"\" return self . __dict__ . __len__ () __ne__ ( other ) \u00b6 Implement the != operator. Source code in oteapi/models/genericconfig.py 70 71 72 73 74 def __ne__ ( self , other : \"Any\" ) -> bool : \"\"\"Implement the != operator.\"\"\" if isinstance ( other , BaseModel ): return self . dict () != other . dict () return self . dict () != other __setitem__ ( key , value ) \u00b6 Enable write access through subscription. Source code in oteapi/models/genericconfig.py 42 43 44 def __setitem__ ( self , key : str , value : \"Any\" ) -> None : \"\"\"Enable write access through subscription.\"\"\" setattr ( self , key , value ) get ( key , default = None ) \u00b6 Mapping get -method. Source code in oteapi/models/genericconfig.py 66 67 68 def get ( self , key : str , default : \"Optional[Any]\" = None ) -> \"Any\" : \"\"\"Mapping `get`-method.\"\"\" return self . __dict__ . get ( key , default ) items () \u00b6 Return a view of all (key, value) pairs. Source code in oteapi/models/genericconfig.py 54 55 56 def items ( self ): \"\"\"Return a view of all (key, value) pairs.\"\"\" return self . __dict__ . items () keys () \u00b6 Return a view of all keys. Source code in oteapi/models/genericconfig.py 58 59 60 def keys ( self ): \"\"\"Return a view of all keys.\"\"\" return self . __dict__ . keys () pop ( key , default = Undefined ) \u00b6 MutableMapping pop -method. Source code in oteapi/models/genericconfig.py 98 99 100 101 102 103 104 105 def pop ( self , key : str , default : \"Optional[Any]\" = Undefined ) -> \"Any\" : \"\"\"MutableMapping `pop`-method.\"\"\" value = self . get ( key , default ) if value == Undefined : raise KeyError ( key ) if key in self : del self [ key ] return value popitem () \u00b6 MutableMapping popitem -method. Important Unlike the regular dict.popitem() method, this one does not respect LIFO (last-in, first-out). This is due to the fact that attributes are stored in a random order when initializing the model. However, it will respect LIFO with respect to the internal __dict__ . Source code in oteapi/models/genericconfig.py 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 def popitem ( self ) -> \"Tuple[str, Any]\" : \"\"\"MutableMapping `popitem`-method. Important: Unlike the regular `dict.popitem()` method, this one does _not_ respect LIFO (last-in, first-out). This is due to the fact that attributes are stored in a random order when initializing the model. However, it will respect LIFO with respect to the internal `__dict__`. \"\"\" if not self : raise KeyError ( f \"popitem(): { self . __class__ . __name__ } is empty\" ) key = list ( self . __dict__ )[ - 1 ] value = self . pop ( key ) return key , value update ( other = None , ** kwargs ) \u00b6 MutableMapping update -method. Source code in oteapi/models/genericconfig.py 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 def update ( self , other : \"Optional[Union[dict, AttrDict, Iterable[Any]]]\" = None , ** kwargs ) -> None : \"\"\"MutableMapping `update`-method.\"\"\" if other and isinstance ( other , ( dict , Mapping )): for key , value in other . items (): setattr ( self , key , value ) elif other and isinstance ( other , BaseModel ): for key , value in other . dict () . items (): setattr ( self , key , value ) elif other and isinstance ( other , Iterable ): for entry in other : if not len ( entry ) == 2 : raise ValueError ( \"`other` must be an iterable of objects of length two.\" ) for key , value in other : setattr ( self , key , value ) if kwargs : for key , value in kwargs . items (): setattr ( self , key , value ) values () \u00b6 Return a view of all values. Source code in oteapi/models/genericconfig.py 62 63 64 def values ( self ): \"\"\"Return a view of all values.\"\"\" return self . __dict__ . values () GenericConfig \u00b6 Bases: BaseModel Generic class for configuration objects. Source code in oteapi/models/genericconfig.py 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 class GenericConfig ( BaseModel ): \"\"\"Generic class for configuration objects.\"\"\" configuration : AttrDict = Field ( AttrDict (), description = \"Model-specific configuration options which can either \" \"be given as key/value-pairs or set as attributes.\" , ) description : str = Field ( __doc__ , description = \"A description of the configuration model.\" , ) @classmethod def __init_subclass__ ( cls ) -> None : \"\"\"Initialize subclass descriptions with their docstrings.\"\"\" cls . __fields__ [ \"description\" ] . default = cls . __doc__ class Config : \"\"\"Pydantic configuration for `GenericConfig`. * **`validate_assignment`** Validate and cast set values. This is mainly relevant for sub-classes of `AttrDict`, where specific attributes have been defined. * **`arbitrary_types_allowed`** If a custom type is used for an attribute that doesn't have a `validate()` method, don't fail setting the attribute. \"\"\" validate_assignment = True arbitrary_types_allowed = True Config \u00b6 Pydantic configuration for GenericConfig . validate_assignment Validate and cast set values. This is mainly relevant for sub-classes of AttrDict , where specific attributes have been defined. arbitrary_types_allowed If a custom type is used for an attribute that doesn't have a validate() method, don't fail setting the attribute. Source code in oteapi/models/genericconfig.py 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 class Config : \"\"\"Pydantic configuration for `GenericConfig`. * **`validate_assignment`** Validate and cast set values. This is mainly relevant for sub-classes of `AttrDict`, where specific attributes have been defined. * **`arbitrary_types_allowed`** If a custom type is used for an attribute that doesn't have a `validate()` method, don't fail setting the attribute. \"\"\" validate_assignment = True arbitrary_types_allowed = True __init_subclass__ () classmethod \u00b6 Initialize subclass descriptions with their docstrings. Source code in oteapi/models/genericconfig.py 161 162 163 164 @classmethod def __init_subclass__ ( cls ) -> None : \"\"\"Initialize subclass descriptions with their docstrings.\"\"\" cls . __fields__ [ \"description\" ] . default = cls . __doc__ mappingconfig \u00b6 Pydantic Mapping Configuration Data Model. MappingConfig \u00b6 Bases: GenericConfig Mapping Strategy Data Configuration. Source code in oteapi/models/mappingconfig.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class MappingConfig ( GenericConfig ): \"\"\"Mapping Strategy Data Configuration.\"\"\" mappingType : str = Field ( ... , description = \"Type of registered mapping strategy.\" , ) prefixes : Optional [ Dict [ str , str ]] = Field ( None , description = ( \"List of shortnames that expands to an IRI given as local \" \"value/IRI-expansion-pairs.\" ), ) triples : Optional [ List [ RDFTriple ]] = Field ( None , description = \"List of RDF triples given as (subject, predicate, object).\" , ) resourceconfig \u00b6 Pydantic Resource Configuration Data Model. HostlessAnyUrl \u00b6 Bases: AnyUrl AnyUrl, but allow not having a host. Source code in oteapi/models/resourceconfig.py 12 13 14 15 class HostlessAnyUrl ( AnyUrl ): \"\"\"AnyUrl, but allow not having a host.\"\"\" host_required = False ResourceConfig \u00b6 Bases: GenericConfig Resource Strategy Data Configuration. Important Either of the pairs of attributes downloadUrl / mediaType or accessUrl / accessService MUST be specified. Source code in oteapi/models/resourceconfig.py 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 class ResourceConfig ( GenericConfig ): \"\"\"Resource Strategy Data Configuration. Important: Either of the pairs of attributes `downloadUrl`/`mediaType` or `accessUrl`/`accessService` MUST be specified. \"\"\" downloadUrl : Optional [ HostlessAnyUrl ] = Field ( None , description = ( \"Definition: The URL of the downloadable file in a given format. E.g. CSV \" \"file or RDF file. \\n\\n Usage: `downloadURL` *SHOULD* be used for the URL at\" \" which this distribution is available directly, typically through a HTTPS\" \" GET request or SFTP.\" ), ) mediaType : Optional [ str ] = Field ( None , description = ( \"The media type of the distribution as defined by IANA \" \"[[IANA-MEDIA-TYPES](https://www.w3.org/TR/vocab-dcat-2/#bib-iana-media-types)]\" \". \\n\\n Usage: This property *SHOULD* be used when the media\" \" type of the distribution is defined in IANA \" \"[[IANA-MEDIA-TYPES](https://www.w3.org/TR/vocab-dcat-2/#bib-iana-media-types)].\" ), ) accessUrl : Optional [ HostlessAnyUrl ] = Field ( None , description = ( \"A URL of the resource that gives access to a distribution of \" \"the dataset. E.g. landing page, feed, SPARQL endpoint. \\n\\n Usage: \" \"`accessURL` *SHOULD* be used for the URL of a service or location that \" \"can provide access to this distribution, typically through a Web form, \" \"query or API call. \\n `downloadURL` is preferred for direct links to \" \"downloadable resources.\" ), ) accessService : Optional [ str ] = Field ( None , description = ( \"A data service that gives access to the distribution of the dataset.\" ), ) license : Optional [ str ] = Field ( None , description = ( \"A legal document under which the distribution is made available.\" ), ) accessRights : Optional [ str ] = Field ( None , description = ( \"A rights statement that concerns how the distribution is accessed.\" ), ) publisher : Optional [ str ] = Field ( None , description = \"The entity responsible for making the resource/item available.\" , ) @root_validator def ensure_unique_url_pairs ( # pylint: disable=no-self-use cls , values : \"Dict[str, Any]\" ) -> \"Dict[str, Any]\" : \"\"\"Ensure either downloadUrl/mediaType or accessUrl/accessService are defined. It's fine to define them all, but at least one complete pair MUST be specified. \"\"\" if not ( all ( values . get ( _ ) for _ in [ \"downloadUrl\" , \"mediaType\" ]) or all ( values . get ( _ ) for _ in [ \"accessUrl\" , \"accessService\" ]) ): raise ValueError ( \"Either of the pairs of attributes downloadUrl/mediaType or \" \"accessUrl/accessService MUST be specified.\" ) return values ensure_unique_url_pairs ( values ) \u00b6 Ensure either downloadUrl/mediaType or accessUrl/accessService are defined. It's fine to define them all, but at least one complete pair MUST be specified. Source code in oteapi/models/resourceconfig.py 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 @root_validator def ensure_unique_url_pairs ( # pylint: disable=no-self-use cls , values : \"Dict[str, Any]\" ) -> \"Dict[str, Any]\" : \"\"\"Ensure either downloadUrl/mediaType or accessUrl/accessService are defined. It's fine to define them all, but at least one complete pair MUST be specified. \"\"\" if not ( all ( values . get ( _ ) for _ in [ \"downloadUrl\" , \"mediaType\" ]) or all ( values . get ( _ ) for _ in [ \"accessUrl\" , \"accessService\" ]) ): raise ValueError ( \"Either of the pairs of attributes downloadUrl/mediaType or \" \"accessUrl/accessService MUST be specified.\" ) return values sessionupdate \u00b6 Pydantic SessionUpdate Data Model. SessionUpdate \u00b6 Bases: AttrDict Session Update Data Model for returning values. Source code in oteapi/models/sessionupdate.py 5 6 class SessionUpdate ( AttrDict ): \"\"\"Session Update Data Model for returning values.\"\"\" transformationconfig \u00b6 Pydantic Transformation Configuration Data Model. A transformation status data model is provided as well. This data model represents what should be returned from the strategy's status() method. ProcessPriority \u00b6 Bases: str , Enum Defining process priority enumerators. Process priorities: Low Medium High Source code in oteapi/models/transformationconfig.py 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class ProcessPriority ( str , Enum ): \"\"\"Defining process priority enumerators. Process priorities: - Low - Medium - High \"\"\" LOW = \"Low\" MEDIUM = \"Medium\" HIGH = \"High\" TransformationConfig \u00b6 Bases: GenericConfig Transformation Strategy Data Configuration. Source code in oteapi/models/transformationconfig.py 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 class TransformationConfig ( GenericConfig ): \"\"\"Transformation Strategy Data Configuration.\"\"\" transformationType : str = Field ( ... , description = ( \"Type of registered transformation strategy. E.g., `celery/remote`.\" ), ) name : Optional [ str ] = Field ( None , description = \"Human-readable name of the transformation strategy.\" ) due : Optional [ datetime ] = Field ( None , description = ( \"Optional field to indicate a due data/time for when a transformation \" \"should finish.\" ), ) priority : Optional [ ProcessPriority ] = Field ( ProcessPriority . MEDIUM , description = \"Define the process priority of the transformation execution.\" , ) secret : Optional [ str ] = Field ( None , description = \"Authorization secret given when running a transformation.\" , ) TransformationStatus \u00b6 Bases: BaseModel Return from transformation status. Source code in oteapi/models/transformationconfig.py 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 class TransformationStatus ( BaseModel ): \"\"\"Return from transformation status.\"\"\" id : str = Field ( ... , description = \"ID for the given transformation process.\" ) status : Optional [ str ] = Field ( None , description = \"Status for the transformation process.\" ) messages : Optional [ List [ str ]] = Field ( None , description = \"Messages related to the transformation process.\" ) created : Optional [ datetime ] = Field ( None , description = \"Time of creation for the transformation process. Given in UTC.\" , ) startTime : Optional [ datetime ] = Field ( None , description = \"Time when the transformation process started. Given in UTC.\" ) finishTime : Optional [ datetime ] = Field ( None , description = \"Time when the tranformation process finished. Given in UTC.\" ) triplestoreconfig \u00b6 Pydantic TripleStore Configuration Data Model. TripleStoreConfig \u00b6 Bases: AttrDict TripleStore Configuration. This is a configuration for the TripleStore . This class should not be used directly as a configuration object for a strategy object, but only as a configuration field inside a configuration object. Source code in oteapi/models/triplestoreconfig.py 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 class TripleStoreConfig ( AttrDict ): \"\"\"TripleStore Configuration. This is a configuration for the [`TripleStore`][oteapi.triplestore.triplestore.TripleStore]. This class should not be used directly as a configuration object for a strategy object, but only as a configuration field inside a configuration object. \"\"\" repositoryName : str = Field ( ... , description = \"The repository name, where the mappings are stored.\" ) agraphHost : str = Field ( ... , description = \"AllegroGraph host name.\" , ) agraphPort : int = Field ( ... , description = \"AllegroGraph port number.\" , ) agraphUser : str = Field ( ... , description = \"AllegroGraph user name.\" , ) agraphPassword : SecretStr = Field ( ... , description = \"AllegroGraph user password.\" , )","title":"OTE-API Configuration Models"},{"location":"all_models/#ote-api-configuration-models","text":"This page provides documentation for the oteapi.models submodule, where all the OTE-API strategy configuration data models are located. When creating instances of these models, the data types are automatically validated. oteapi.models module. This module contains all the pydantic configuration models.","title":"OTE-API Configuration Models"},{"location":"all_models/#oteapi.models.AttrDict","text":"Bases: BaseModel , Mapping An object whose attributes can also be accessed through subscription, like with a dictionary. Source code in oteapi/models/genericconfig.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 class AttrDict ( BaseModel , Mapping ): \"\"\"An object whose attributes can also be accessed through subscription, like with a dictionary.\"\"\" def __contains__ ( self , name : \"Any\" ) -> bool : \"\"\"Enable using the 'in' operator on this object.\"\"\" return self . __dict__ . __contains__ ( name ) def __delitem__ ( self , key : str ) -> None : \"\"\"Enable deletion access through subscription. If the item is a pydantic field, reset it and remove it from the set of set fields. Otherwise, delete the attribute. \"\"\" if key in self . __dict__ : if key in self . __fields__ : # Reset field to default and remove from set of set fields setattr ( self , key , self . __fields__ [ key ] . default ) self . __fields_set__ . remove ( key ) # pylint: disable=no-member else : self . __delattr__ ( key ) else : raise KeyError ( key ) def __getitem__ ( self , key : str ) -> \"Any\" : \"\"\"Enable read access through subscription.\"\"\" if key in self . __dict__ : return getattr ( self , key ) raise KeyError ( key ) def __setitem__ ( self , key : str , value : \"Any\" ) -> None : \"\"\"Enable write access through subscription.\"\"\" setattr ( self , key , value ) def __len__ ( self ): \"\"\"Return number of items.\"\"\" return self . __dict__ . __len__ () def __iter__ ( self ): \"\"\"Enable **unpacking.\"\"\" return self . __dict__ . __iter__ () def items ( self ): \"\"\"Return a view of all (key, value) pairs.\"\"\" return self . __dict__ . items () def keys ( self ): \"\"\"Return a view of all keys.\"\"\" return self . __dict__ . keys () def values ( self ): \"\"\"Return a view of all values.\"\"\" return self . __dict__ . values () def get ( self , key : str , default : \"Optional[Any]\" = None ) -> \"Any\" : \"\"\"Mapping `get`-method.\"\"\" return self . __dict__ . get ( key , default ) def __ne__ ( self , other : \"Any\" ) -> bool : \"\"\"Implement the != operator.\"\"\" if isinstance ( other , BaseModel ): return self . dict () != other . dict () return self . dict () != other def update ( self , other : \"Optional[Union[dict, AttrDict, Iterable[Any]]]\" = None , ** kwargs ) -> None : \"\"\"MutableMapping `update`-method.\"\"\" if other and isinstance ( other , ( dict , Mapping )): for key , value in other . items (): setattr ( self , key , value ) elif other and isinstance ( other , BaseModel ): for key , value in other . dict () . items (): setattr ( self , key , value ) elif other and isinstance ( other , Iterable ): for entry in other : if not len ( entry ) == 2 : raise ValueError ( \"`other` must be an iterable of objects of length two.\" ) for key , value in other : setattr ( self , key , value ) if kwargs : for key , value in kwargs . items (): setattr ( self , key , value ) def pop ( self , key : str , default : \"Optional[Any]\" = Undefined ) -> \"Any\" : \"\"\"MutableMapping `pop`-method.\"\"\" value = self . get ( key , default ) if value == Undefined : raise KeyError ( key ) if key in self : del self [ key ] return value def popitem ( self ) -> \"Tuple[str, Any]\" : \"\"\"MutableMapping `popitem`-method. Important: Unlike the regular `dict.popitem()` method, this one does _not_ respect LIFO (last-in, first-out). This is due to the fact that attributes are stored in a random order when initializing the model. However, it will respect LIFO with respect to the internal `__dict__`. \"\"\" if not self : raise KeyError ( f \"popitem(): { self . __class__ . __name__ } is empty\" ) key = list ( self . __dict__ )[ - 1 ] value = self . pop ( key ) return key , value class Config : \"\"\"Pydantic configuration for `AttrDict`. * **`extra`** Allow any attributes/fields to be defined - this is what makes this pydantic model an attribute dictionary. * **`validate_assignment`** Validate and cast set values. This is mainly relevant for sub-classes of `AttrDict`, where specific attributes have been defined. * **`arbitrary_types_allowed`** If a custom type is used for an attribute that doesn't have a `validate()` method, don't fail setting the attribute. \"\"\" extra = \"allow\" validate_assignment = True arbitrary_types_allowed = True","title":"AttrDict"},{"location":"all_models/#oteapi.models.genericconfig.AttrDict.Config","text":"Pydantic configuration for AttrDict . extra Allow any attributes/fields to be defined - this is what makes this pydantic model an attribute dictionary. validate_assignment Validate and cast set values. This is mainly relevant for sub-classes of AttrDict , where specific attributes have been defined. arbitrary_types_allowed If a custom type is used for an attribute that doesn't have a validate() method, don't fail setting the attribute. Source code in oteapi/models/genericconfig.py 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 class Config : \"\"\"Pydantic configuration for `AttrDict`. * **`extra`** Allow any attributes/fields to be defined - this is what makes this pydantic model an attribute dictionary. * **`validate_assignment`** Validate and cast set values. This is mainly relevant for sub-classes of `AttrDict`, where specific attributes have been defined. * **`arbitrary_types_allowed`** If a custom type is used for an attribute that doesn't have a `validate()` method, don't fail setting the attribute. \"\"\" extra = \"allow\" validate_assignment = True arbitrary_types_allowed = True","title":"Config"},{"location":"all_models/#oteapi.models.genericconfig.AttrDict.__contains__","text":"Enable using the 'in' operator on this object. Source code in oteapi/models/genericconfig.py 15 16 17 def __contains__ ( self , name : \"Any\" ) -> bool : \"\"\"Enable using the 'in' operator on this object.\"\"\" return self . __dict__ . __contains__ ( name )","title":"__contains__()"},{"location":"all_models/#oteapi.models.genericconfig.AttrDict.__delitem__","text":"Enable deletion access through subscription. If the item is a pydantic field, reset it and remove it from the set of set fields. Otherwise, delete the attribute. Source code in oteapi/models/genericconfig.py 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 def __delitem__ ( self , key : str ) -> None : \"\"\"Enable deletion access through subscription. If the item is a pydantic field, reset it and remove it from the set of set fields. Otherwise, delete the attribute. \"\"\" if key in self . __dict__ : if key in self . __fields__ : # Reset field to default and remove from set of set fields setattr ( self , key , self . __fields__ [ key ] . default ) self . __fields_set__ . remove ( key ) # pylint: disable=no-member else : self . __delattr__ ( key ) else : raise KeyError ( key )","title":"__delitem__()"},{"location":"all_models/#oteapi.models.genericconfig.AttrDict.__getitem__","text":"Enable read access through subscription. Source code in oteapi/models/genericconfig.py 36 37 38 39 40 def __getitem__ ( self , key : str ) -> \"Any\" : \"\"\"Enable read access through subscription.\"\"\" if key in self . __dict__ : return getattr ( self , key ) raise KeyError ( key )","title":"__getitem__()"},{"location":"all_models/#oteapi.models.genericconfig.AttrDict.__iter__","text":"Enable **unpacking. Source code in oteapi/models/genericconfig.py 50 51 52 def __iter__ ( self ): \"\"\"Enable **unpacking.\"\"\" return self . __dict__ . __iter__ ()","title":"__iter__()"},{"location":"all_models/#oteapi.models.genericconfig.AttrDict.__len__","text":"Return number of items. Source code in oteapi/models/genericconfig.py 46 47 48 def __len__ ( self ): \"\"\"Return number of items.\"\"\" return self . __dict__ . __len__ ()","title":"__len__()"},{"location":"all_models/#oteapi.models.genericconfig.AttrDict.__ne__","text":"Implement the != operator. Source code in oteapi/models/genericconfig.py 70 71 72 73 74 def __ne__ ( self , other : \"Any\" ) -> bool : \"\"\"Implement the != operator.\"\"\" if isinstance ( other , BaseModel ): return self . dict () != other . dict () return self . dict () != other","title":"__ne__()"},{"location":"all_models/#oteapi.models.genericconfig.AttrDict.__setitem__","text":"Enable write access through subscription. Source code in oteapi/models/genericconfig.py 42 43 44 def __setitem__ ( self , key : str , value : \"Any\" ) -> None : \"\"\"Enable write access through subscription.\"\"\" setattr ( self , key , value )","title":"__setitem__()"},{"location":"all_models/#oteapi.models.genericconfig.AttrDict.get","text":"Mapping get -method. Source code in oteapi/models/genericconfig.py 66 67 68 def get ( self , key : str , default : \"Optional[Any]\" = None ) -> \"Any\" : \"\"\"Mapping `get`-method.\"\"\" return self . __dict__ . get ( key , default )","title":"get()"},{"location":"all_models/#oteapi.models.genericconfig.AttrDict.items","text":"Return a view of all (key, value) pairs. Source code in oteapi/models/genericconfig.py 54 55 56 def items ( self ): \"\"\"Return a view of all (key, value) pairs.\"\"\" return self . __dict__ . items ()","title":"items()"},{"location":"all_models/#oteapi.models.genericconfig.AttrDict.keys","text":"Return a view of all keys. Source code in oteapi/models/genericconfig.py 58 59 60 def keys ( self ): \"\"\"Return a view of all keys.\"\"\" return self . __dict__ . keys ()","title":"keys()"},{"location":"all_models/#oteapi.models.genericconfig.AttrDict.pop","text":"MutableMapping pop -method. Source code in oteapi/models/genericconfig.py 98 99 100 101 102 103 104 105 def pop ( self , key : str , default : \"Optional[Any]\" = Undefined ) -> \"Any\" : \"\"\"MutableMapping `pop`-method.\"\"\" value = self . get ( key , default ) if value == Undefined : raise KeyError ( key ) if key in self : del self [ key ] return value","title":"pop()"},{"location":"all_models/#oteapi.models.genericconfig.AttrDict.popitem","text":"MutableMapping popitem -method. Important Unlike the regular dict.popitem() method, this one does not respect LIFO (last-in, first-out). This is due to the fact that attributes are stored in a random order when initializing the model. However, it will respect LIFO with respect to the internal __dict__ . Source code in oteapi/models/genericconfig.py 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 def popitem ( self ) -> \"Tuple[str, Any]\" : \"\"\"MutableMapping `popitem`-method. Important: Unlike the regular `dict.popitem()` method, this one does _not_ respect LIFO (last-in, first-out). This is due to the fact that attributes are stored in a random order when initializing the model. However, it will respect LIFO with respect to the internal `__dict__`. \"\"\" if not self : raise KeyError ( f \"popitem(): { self . __class__ . __name__ } is empty\" ) key = list ( self . __dict__ )[ - 1 ] value = self . pop ( key ) return key , value","title":"popitem()"},{"location":"all_models/#oteapi.models.genericconfig.AttrDict.update","text":"MutableMapping update -method. Source code in oteapi/models/genericconfig.py 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 def update ( self , other : \"Optional[Union[dict, AttrDict, Iterable[Any]]]\" = None , ** kwargs ) -> None : \"\"\"MutableMapping `update`-method.\"\"\" if other and isinstance ( other , ( dict , Mapping )): for key , value in other . items (): setattr ( self , key , value ) elif other and isinstance ( other , BaseModel ): for key , value in other . dict () . items (): setattr ( self , key , value ) elif other and isinstance ( other , Iterable ): for entry in other : if not len ( entry ) == 2 : raise ValueError ( \"`other` must be an iterable of objects of length two.\" ) for key , value in other : setattr ( self , key , value ) if kwargs : for key , value in kwargs . items (): setattr ( self , key , value )","title":"update()"},{"location":"all_models/#oteapi.models.genericconfig.AttrDict.values","text":"Return a view of all values. Source code in oteapi/models/genericconfig.py 62 63 64 def values ( self ): \"\"\"Return a view of all values.\"\"\" return self . __dict__ . values ()","title":"values()"},{"location":"all_models/#oteapi.models.DataCacheConfig","text":"Bases: AttrDict DataCache Configuration. This class should not be used directly as a configuration object for a strategy object, but only as a configuration field inside a configuration object. Source code in oteapi/models/datacacheconfig.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 class DataCacheConfig ( AttrDict ): \"\"\"DataCache Configuration. This class should not be used directly as a configuration object for a strategy object, but only as a configuration field inside a configuration object. \"\"\" cacheDir : Path = Field ( Path ( \"oteapi\" ), description = \"Cache directory.\" ) accessKey : Optional [ str ] = Field ( None , description = \"Key with which the downloaded content can be accessed. \" \"Should preferable be the hash (corresponding to `hashType`) of the \" \"content if it is known.\" , ) hashType : str = Field ( \"md5\" , description = \"Hash algorithm to use for creating hash keys for stored \" \"data. Can be any algorithm supported by hashlib.\" , ) expireTime : int = Field ( 3600 * 24 * 14 , description = \"Number of seconds before the cache entry expires. \" \"Zero means no expiration. Default is two weeks.\" , ) tag : Optional [ str ] = Field ( None , description = \"Tag assigned to the downloaded content, typically \" \"identifying a session. Used with the `evict()` method to clean up a \" \"all cache entries with a given tag.\" , )","title":"DataCacheConfig"},{"location":"all_models/#oteapi.models.FilterConfig","text":"Bases: GenericConfig Filter Strategy Data Configuration. Source code in oteapi/models/filterconfig.py 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class FilterConfig ( GenericConfig ): \"\"\"Filter Strategy Data Configuration.\"\"\" filterType : str = Field ( ... , description = \"Type of registered filter strategy. E.g., `filter/sql`.\" ) query : Optional [ str ] = Field ( None , description = \"Define a query operation.\" ) condition : Optional [ str ] = Field ( None , description = \"Logical statement indicating when a filter should be applied.\" , ) limit : Optional [ int ] = Field ( None , description = \"Number of items remaining after a filter expression.\" )","title":"FilterConfig"},{"location":"all_models/#oteapi.models.FunctionConfig","text":"Bases: GenericConfig Function Strategy Data Configuration. Source code in oteapi/models/functionconfig.py 7 8 9 10 11 12 13 class FunctionConfig ( GenericConfig ): \"\"\"Function Strategy Data Configuration.\"\"\" functionType : str = Field ( ... , description = ( \"Type of registered function strategy.\" ), )","title":"FunctionConfig"},{"location":"all_models/#oteapi.models.GenericConfig","text":"Bases: BaseModel Generic class for configuration objects. Source code in oteapi/models/genericconfig.py 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 class GenericConfig ( BaseModel ): \"\"\"Generic class for configuration objects.\"\"\" configuration : AttrDict = Field ( AttrDict (), description = \"Model-specific configuration options which can either \" \"be given as key/value-pairs or set as attributes.\" , ) description : str = Field ( __doc__ , description = \"A description of the configuration model.\" , ) @classmethod def __init_subclass__ ( cls ) -> None : \"\"\"Initialize subclass descriptions with their docstrings.\"\"\" cls . __fields__ [ \"description\" ] . default = cls . __doc__ class Config : \"\"\"Pydantic configuration for `GenericConfig`. * **`validate_assignment`** Validate and cast set values. This is mainly relevant for sub-classes of `AttrDict`, where specific attributes have been defined. * **`arbitrary_types_allowed`** If a custom type is used for an attribute that doesn't have a `validate()` method, don't fail setting the attribute. \"\"\" validate_assignment = True arbitrary_types_allowed = True","title":"GenericConfig"},{"location":"all_models/#oteapi.models.genericconfig.GenericConfig.Config","text":"Pydantic configuration for GenericConfig . validate_assignment Validate and cast set values. This is mainly relevant for sub-classes of AttrDict , where specific attributes have been defined. arbitrary_types_allowed If a custom type is used for an attribute that doesn't have a validate() method, don't fail setting the attribute. Source code in oteapi/models/genericconfig.py 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 class Config : \"\"\"Pydantic configuration for `GenericConfig`. * **`validate_assignment`** Validate and cast set values. This is mainly relevant for sub-classes of `AttrDict`, where specific attributes have been defined. * **`arbitrary_types_allowed`** If a custom type is used for an attribute that doesn't have a `validate()` method, don't fail setting the attribute. \"\"\" validate_assignment = True arbitrary_types_allowed = True","title":"Config"},{"location":"all_models/#oteapi.models.genericconfig.GenericConfig.__init_subclass__","text":"Initialize subclass descriptions with their docstrings. Source code in oteapi/models/genericconfig.py 161 162 163 164 @classmethod def __init_subclass__ ( cls ) -> None : \"\"\"Initialize subclass descriptions with their docstrings.\"\"\" cls . __fields__ [ \"description\" ] . default = cls . __doc__","title":"__init_subclass__()"},{"location":"all_models/#oteapi.models.MappingConfig","text":"Bases: GenericConfig Mapping Strategy Data Configuration. Source code in oteapi/models/mappingconfig.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class MappingConfig ( GenericConfig ): \"\"\"Mapping Strategy Data Configuration.\"\"\" mappingType : str = Field ( ... , description = \"Type of registered mapping strategy.\" , ) prefixes : Optional [ Dict [ str , str ]] = Field ( None , description = ( \"List of shortnames that expands to an IRI given as local \" \"value/IRI-expansion-pairs.\" ), ) triples : Optional [ List [ RDFTriple ]] = Field ( None , description = \"List of RDF triples given as (subject, predicate, object).\" , )","title":"MappingConfig"},{"location":"all_models/#oteapi.models.ResourceConfig","text":"Bases: GenericConfig Resource Strategy Data Configuration. Important Either of the pairs of attributes downloadUrl / mediaType or accessUrl / accessService MUST be specified. Source code in oteapi/models/resourceconfig.py 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 class ResourceConfig ( GenericConfig ): \"\"\"Resource Strategy Data Configuration. Important: Either of the pairs of attributes `downloadUrl`/`mediaType` or `accessUrl`/`accessService` MUST be specified. \"\"\" downloadUrl : Optional [ HostlessAnyUrl ] = Field ( None , description = ( \"Definition: The URL of the downloadable file in a given format. E.g. CSV \" \"file or RDF file. \\n\\n Usage: `downloadURL` *SHOULD* be used for the URL at\" \" which this distribution is available directly, typically through a HTTPS\" \" GET request or SFTP.\" ), ) mediaType : Optional [ str ] = Field ( None , description = ( \"The media type of the distribution as defined by IANA \" \"[[IANA-MEDIA-TYPES](https://www.w3.org/TR/vocab-dcat-2/#bib-iana-media-types)]\" \". \\n\\n Usage: This property *SHOULD* be used when the media\" \" type of the distribution is defined in IANA \" \"[[IANA-MEDIA-TYPES](https://www.w3.org/TR/vocab-dcat-2/#bib-iana-media-types)].\" ), ) accessUrl : Optional [ HostlessAnyUrl ] = Field ( None , description = ( \"A URL of the resource that gives access to a distribution of \" \"the dataset. E.g. landing page, feed, SPARQL endpoint. \\n\\n Usage: \" \"`accessURL` *SHOULD* be used for the URL of a service or location that \" \"can provide access to this distribution, typically through a Web form, \" \"query or API call. \\n `downloadURL` is preferred for direct links to \" \"downloadable resources.\" ), ) accessService : Optional [ str ] = Field ( None , description = ( \"A data service that gives access to the distribution of the dataset.\" ), ) license : Optional [ str ] = Field ( None , description = ( \"A legal document under which the distribution is made available.\" ), ) accessRights : Optional [ str ] = Field ( None , description = ( \"A rights statement that concerns how the distribution is accessed.\" ), ) publisher : Optional [ str ] = Field ( None , description = \"The entity responsible for making the resource/item available.\" , ) @root_validator def ensure_unique_url_pairs ( # pylint: disable=no-self-use cls , values : \"Dict[str, Any]\" ) -> \"Dict[str, Any]\" : \"\"\"Ensure either downloadUrl/mediaType or accessUrl/accessService are defined. It's fine to define them all, but at least one complete pair MUST be specified. \"\"\" if not ( all ( values . get ( _ ) for _ in [ \"downloadUrl\" , \"mediaType\" ]) or all ( values . get ( _ ) for _ in [ \"accessUrl\" , \"accessService\" ]) ): raise ValueError ( \"Either of the pairs of attributes downloadUrl/mediaType or \" \"accessUrl/accessService MUST be specified.\" ) return values","title":"ResourceConfig"},{"location":"all_models/#oteapi.models.resourceconfig.ResourceConfig.ensure_unique_url_pairs","text":"Ensure either downloadUrl/mediaType or accessUrl/accessService are defined. It's fine to define them all, but at least one complete pair MUST be specified. Source code in oteapi/models/resourceconfig.py 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 @root_validator def ensure_unique_url_pairs ( # pylint: disable=no-self-use cls , values : \"Dict[str, Any]\" ) -> \"Dict[str, Any]\" : \"\"\"Ensure either downloadUrl/mediaType or accessUrl/accessService are defined. It's fine to define them all, but at least one complete pair MUST be specified. \"\"\" if not ( all ( values . get ( _ ) for _ in [ \"downloadUrl\" , \"mediaType\" ]) or all ( values . get ( _ ) for _ in [ \"accessUrl\" , \"accessService\" ]) ): raise ValueError ( \"Either of the pairs of attributes downloadUrl/mediaType or \" \"accessUrl/accessService MUST be specified.\" ) return values","title":"ensure_unique_url_pairs()"},{"location":"all_models/#oteapi.models.SessionUpdate","text":"Bases: AttrDict Session Update Data Model for returning values. Source code in oteapi/models/sessionupdate.py 5 6 class SessionUpdate ( AttrDict ): \"\"\"Session Update Data Model for returning values.\"\"\"","title":"SessionUpdate"},{"location":"all_models/#oteapi.models.TransformationConfig","text":"Bases: GenericConfig Transformation Strategy Data Configuration. Source code in oteapi/models/transformationconfig.py 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 class TransformationConfig ( GenericConfig ): \"\"\"Transformation Strategy Data Configuration.\"\"\" transformationType : str = Field ( ... , description = ( \"Type of registered transformation strategy. E.g., `celery/remote`.\" ), ) name : Optional [ str ] = Field ( None , description = \"Human-readable name of the transformation strategy.\" ) due : Optional [ datetime ] = Field ( None , description = ( \"Optional field to indicate a due data/time for when a transformation \" \"should finish.\" ), ) priority : Optional [ ProcessPriority ] = Field ( ProcessPriority . MEDIUM , description = \"Define the process priority of the transformation execution.\" , ) secret : Optional [ str ] = Field ( None , description = \"Authorization secret given when running a transformation.\" , )","title":"TransformationConfig"},{"location":"all_models/#oteapi.models.TransformationStatus","text":"Bases: BaseModel Return from transformation status. Source code in oteapi/models/transformationconfig.py 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 class TransformationStatus ( BaseModel ): \"\"\"Return from transformation status.\"\"\" id : str = Field ( ... , description = \"ID for the given transformation process.\" ) status : Optional [ str ] = Field ( None , description = \"Status for the transformation process.\" ) messages : Optional [ List [ str ]] = Field ( None , description = \"Messages related to the transformation process.\" ) created : Optional [ datetime ] = Field ( None , description = \"Time of creation for the transformation process. Given in UTC.\" , ) startTime : Optional [ datetime ] = Field ( None , description = \"Time when the transformation process started. Given in UTC.\" ) finishTime : Optional [ datetime ] = Field ( None , description = \"Time when the tranformation process finished. Given in UTC.\" )","title":"TransformationStatus"},{"location":"all_models/#oteapi.models.TripleStoreConfig","text":"Bases: AttrDict TripleStore Configuration. This is a configuration for the TripleStore . This class should not be used directly as a configuration object for a strategy object, but only as a configuration field inside a configuration object. Source code in oteapi/models/triplestoreconfig.py 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 class TripleStoreConfig ( AttrDict ): \"\"\"TripleStore Configuration. This is a configuration for the [`TripleStore`][oteapi.triplestore.triplestore.TripleStore]. This class should not be used directly as a configuration object for a strategy object, but only as a configuration field inside a configuration object. \"\"\" repositoryName : str = Field ( ... , description = \"The repository name, where the mappings are stored.\" ) agraphHost : str = Field ( ... , description = \"AllegroGraph host name.\" , ) agraphPort : int = Field ( ... , description = \"AllegroGraph port number.\" , ) agraphUser : str = Field ( ... , description = \"AllegroGraph user name.\" , ) agraphPassword : SecretStr = Field ( ... , description = \"AllegroGraph user password.\" , )","title":"TripleStoreConfig"},{"location":"all_models/#oteapi.models.datacacheconfig","text":"Pydantic DataCache Configuration Data Model.","title":"datacacheconfig"},{"location":"all_models/#oteapi.models.datacacheconfig.DataCacheConfig","text":"Bases: AttrDict DataCache Configuration. This class should not be used directly as a configuration object for a strategy object, but only as a configuration field inside a configuration object. Source code in oteapi/models/datacacheconfig.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 class DataCacheConfig ( AttrDict ): \"\"\"DataCache Configuration. This class should not be used directly as a configuration object for a strategy object, but only as a configuration field inside a configuration object. \"\"\" cacheDir : Path = Field ( Path ( \"oteapi\" ), description = \"Cache directory.\" ) accessKey : Optional [ str ] = Field ( None , description = \"Key with which the downloaded content can be accessed. \" \"Should preferable be the hash (corresponding to `hashType`) of the \" \"content if it is known.\" , ) hashType : str = Field ( \"md5\" , description = \"Hash algorithm to use for creating hash keys for stored \" \"data. Can be any algorithm supported by hashlib.\" , ) expireTime : int = Field ( 3600 * 24 * 14 , description = \"Number of seconds before the cache entry expires. \" \"Zero means no expiration. Default is two weeks.\" , ) tag : Optional [ str ] = Field ( None , description = \"Tag assigned to the downloaded content, typically \" \"identifying a session. Used with the `evict()` method to clean up a \" \"all cache entries with a given tag.\" , )","title":"DataCacheConfig"},{"location":"all_models/#oteapi.models.filterconfig","text":"Pydantic Filter Configuration Data Model.","title":"filterconfig"},{"location":"all_models/#oteapi.models.filterconfig.FilterConfig","text":"Bases: GenericConfig Filter Strategy Data Configuration. Source code in oteapi/models/filterconfig.py 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class FilterConfig ( GenericConfig ): \"\"\"Filter Strategy Data Configuration.\"\"\" filterType : str = Field ( ... , description = \"Type of registered filter strategy. E.g., `filter/sql`.\" ) query : Optional [ str ] = Field ( None , description = \"Define a query operation.\" ) condition : Optional [ str ] = Field ( None , description = \"Logical statement indicating when a filter should be applied.\" , ) limit : Optional [ int ] = Field ( None , description = \"Number of items remaining after a filter expression.\" )","title":"FilterConfig"},{"location":"all_models/#oteapi.models.functionconfig","text":"Pydantic Function Configuration Data Model.","title":"functionconfig"},{"location":"all_models/#oteapi.models.functionconfig.FunctionConfig","text":"Bases: GenericConfig Function Strategy Data Configuration. Source code in oteapi/models/functionconfig.py 7 8 9 10 11 12 13 class FunctionConfig ( GenericConfig ): \"\"\"Function Strategy Data Configuration.\"\"\" functionType : str = Field ( ... , description = ( \"Type of registered function strategy.\" ), )","title":"FunctionConfig"},{"location":"all_models/#oteapi.models.genericconfig","text":"Generic data model for configuration attributes.","title":"genericconfig"},{"location":"all_models/#oteapi.models.genericconfig.AttrDict","text":"Bases: BaseModel , Mapping An object whose attributes can also be accessed through subscription, like with a dictionary. Source code in oteapi/models/genericconfig.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 class AttrDict ( BaseModel , Mapping ): \"\"\"An object whose attributes can also be accessed through subscription, like with a dictionary.\"\"\" def __contains__ ( self , name : \"Any\" ) -> bool : \"\"\"Enable using the 'in' operator on this object.\"\"\" return self . __dict__ . __contains__ ( name ) def __delitem__ ( self , key : str ) -> None : \"\"\"Enable deletion access through subscription. If the item is a pydantic field, reset it and remove it from the set of set fields. Otherwise, delete the attribute. \"\"\" if key in self . __dict__ : if key in self . __fields__ : # Reset field to default and remove from set of set fields setattr ( self , key , self . __fields__ [ key ] . default ) self . __fields_set__ . remove ( key ) # pylint: disable=no-member else : self . __delattr__ ( key ) else : raise KeyError ( key ) def __getitem__ ( self , key : str ) -> \"Any\" : \"\"\"Enable read access through subscription.\"\"\" if key in self . __dict__ : return getattr ( self , key ) raise KeyError ( key ) def __setitem__ ( self , key : str , value : \"Any\" ) -> None : \"\"\"Enable write access through subscription.\"\"\" setattr ( self , key , value ) def __len__ ( self ): \"\"\"Return number of items.\"\"\" return self . __dict__ . __len__ () def __iter__ ( self ): \"\"\"Enable **unpacking.\"\"\" return self . __dict__ . __iter__ () def items ( self ): \"\"\"Return a view of all (key, value) pairs.\"\"\" return self . __dict__ . items () def keys ( self ): \"\"\"Return a view of all keys.\"\"\" return self . __dict__ . keys () def values ( self ): \"\"\"Return a view of all values.\"\"\" return self . __dict__ . values () def get ( self , key : str , default : \"Optional[Any]\" = None ) -> \"Any\" : \"\"\"Mapping `get`-method.\"\"\" return self . __dict__ . get ( key , default ) def __ne__ ( self , other : \"Any\" ) -> bool : \"\"\"Implement the != operator.\"\"\" if isinstance ( other , BaseModel ): return self . dict () != other . dict () return self . dict () != other def update ( self , other : \"Optional[Union[dict, AttrDict, Iterable[Any]]]\" = None , ** kwargs ) -> None : \"\"\"MutableMapping `update`-method.\"\"\" if other and isinstance ( other , ( dict , Mapping )): for key , value in other . items (): setattr ( self , key , value ) elif other and isinstance ( other , BaseModel ): for key , value in other . dict () . items (): setattr ( self , key , value ) elif other and isinstance ( other , Iterable ): for entry in other : if not len ( entry ) == 2 : raise ValueError ( \"`other` must be an iterable of objects of length two.\" ) for key , value in other : setattr ( self , key , value ) if kwargs : for key , value in kwargs . items (): setattr ( self , key , value ) def pop ( self , key : str , default : \"Optional[Any]\" = Undefined ) -> \"Any\" : \"\"\"MutableMapping `pop`-method.\"\"\" value = self . get ( key , default ) if value == Undefined : raise KeyError ( key ) if key in self : del self [ key ] return value def popitem ( self ) -> \"Tuple[str, Any]\" : \"\"\"MutableMapping `popitem`-method. Important: Unlike the regular `dict.popitem()` method, this one does _not_ respect LIFO (last-in, first-out). This is due to the fact that attributes are stored in a random order when initializing the model. However, it will respect LIFO with respect to the internal `__dict__`. \"\"\" if not self : raise KeyError ( f \"popitem(): { self . __class__ . __name__ } is empty\" ) key = list ( self . __dict__ )[ - 1 ] value = self . pop ( key ) return key , value class Config : \"\"\"Pydantic configuration for `AttrDict`. * **`extra`** Allow any attributes/fields to be defined - this is what makes this pydantic model an attribute dictionary. * **`validate_assignment`** Validate and cast set values. This is mainly relevant for sub-classes of `AttrDict`, where specific attributes have been defined. * **`arbitrary_types_allowed`** If a custom type is used for an attribute that doesn't have a `validate()` method, don't fail setting the attribute. \"\"\" extra = \"allow\" validate_assignment = True arbitrary_types_allowed = True","title":"AttrDict"},{"location":"all_models/#oteapi.models.genericconfig.AttrDict.Config","text":"Pydantic configuration for AttrDict . extra Allow any attributes/fields to be defined - this is what makes this pydantic model an attribute dictionary. validate_assignment Validate and cast set values. This is mainly relevant for sub-classes of AttrDict , where specific attributes have been defined. arbitrary_types_allowed If a custom type is used for an attribute that doesn't have a validate() method, don't fail setting the attribute. Source code in oteapi/models/genericconfig.py 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 class Config : \"\"\"Pydantic configuration for `AttrDict`. * **`extra`** Allow any attributes/fields to be defined - this is what makes this pydantic model an attribute dictionary. * **`validate_assignment`** Validate and cast set values. This is mainly relevant for sub-classes of `AttrDict`, where specific attributes have been defined. * **`arbitrary_types_allowed`** If a custom type is used for an attribute that doesn't have a `validate()` method, don't fail setting the attribute. \"\"\" extra = \"allow\" validate_assignment = True arbitrary_types_allowed = True","title":"Config"},{"location":"all_models/#oteapi.models.genericconfig.AttrDict.__contains__","text":"Enable using the 'in' operator on this object. Source code in oteapi/models/genericconfig.py 15 16 17 def __contains__ ( self , name : \"Any\" ) -> bool : \"\"\"Enable using the 'in' operator on this object.\"\"\" return self . __dict__ . __contains__ ( name )","title":"__contains__()"},{"location":"all_models/#oteapi.models.genericconfig.AttrDict.__delitem__","text":"Enable deletion access through subscription. If the item is a pydantic field, reset it and remove it from the set of set fields. Otherwise, delete the attribute. Source code in oteapi/models/genericconfig.py 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 def __delitem__ ( self , key : str ) -> None : \"\"\"Enable deletion access through subscription. If the item is a pydantic field, reset it and remove it from the set of set fields. Otherwise, delete the attribute. \"\"\" if key in self . __dict__ : if key in self . __fields__ : # Reset field to default and remove from set of set fields setattr ( self , key , self . __fields__ [ key ] . default ) self . __fields_set__ . remove ( key ) # pylint: disable=no-member else : self . __delattr__ ( key ) else : raise KeyError ( key )","title":"__delitem__()"},{"location":"all_models/#oteapi.models.genericconfig.AttrDict.__getitem__","text":"Enable read access through subscription. Source code in oteapi/models/genericconfig.py 36 37 38 39 40 def __getitem__ ( self , key : str ) -> \"Any\" : \"\"\"Enable read access through subscription.\"\"\" if key in self . __dict__ : return getattr ( self , key ) raise KeyError ( key )","title":"__getitem__()"},{"location":"all_models/#oteapi.models.genericconfig.AttrDict.__iter__","text":"Enable **unpacking. Source code in oteapi/models/genericconfig.py 50 51 52 def __iter__ ( self ): \"\"\"Enable **unpacking.\"\"\" return self . __dict__ . __iter__ ()","title":"__iter__()"},{"location":"all_models/#oteapi.models.genericconfig.AttrDict.__len__","text":"Return number of items. Source code in oteapi/models/genericconfig.py 46 47 48 def __len__ ( self ): \"\"\"Return number of items.\"\"\" return self . __dict__ . __len__ ()","title":"__len__()"},{"location":"all_models/#oteapi.models.genericconfig.AttrDict.__ne__","text":"Implement the != operator. Source code in oteapi/models/genericconfig.py 70 71 72 73 74 def __ne__ ( self , other : \"Any\" ) -> bool : \"\"\"Implement the != operator.\"\"\" if isinstance ( other , BaseModel ): return self . dict () != other . dict () return self . dict () != other","title":"__ne__()"},{"location":"all_models/#oteapi.models.genericconfig.AttrDict.__setitem__","text":"Enable write access through subscription. Source code in oteapi/models/genericconfig.py 42 43 44 def __setitem__ ( self , key : str , value : \"Any\" ) -> None : \"\"\"Enable write access through subscription.\"\"\" setattr ( self , key , value )","title":"__setitem__()"},{"location":"all_models/#oteapi.models.genericconfig.AttrDict.get","text":"Mapping get -method. Source code in oteapi/models/genericconfig.py 66 67 68 def get ( self , key : str , default : \"Optional[Any]\" = None ) -> \"Any\" : \"\"\"Mapping `get`-method.\"\"\" return self . __dict__ . get ( key , default )","title":"get()"},{"location":"all_models/#oteapi.models.genericconfig.AttrDict.items","text":"Return a view of all (key, value) pairs. Source code in oteapi/models/genericconfig.py 54 55 56 def items ( self ): \"\"\"Return a view of all (key, value) pairs.\"\"\" return self . __dict__ . items ()","title":"items()"},{"location":"all_models/#oteapi.models.genericconfig.AttrDict.keys","text":"Return a view of all keys. Source code in oteapi/models/genericconfig.py 58 59 60 def keys ( self ): \"\"\"Return a view of all keys.\"\"\" return self . __dict__ . keys ()","title":"keys()"},{"location":"all_models/#oteapi.models.genericconfig.AttrDict.pop","text":"MutableMapping pop -method. Source code in oteapi/models/genericconfig.py 98 99 100 101 102 103 104 105 def pop ( self , key : str , default : \"Optional[Any]\" = Undefined ) -> \"Any\" : \"\"\"MutableMapping `pop`-method.\"\"\" value = self . get ( key , default ) if value == Undefined : raise KeyError ( key ) if key in self : del self [ key ] return value","title":"pop()"},{"location":"all_models/#oteapi.models.genericconfig.AttrDict.popitem","text":"MutableMapping popitem -method. Important Unlike the regular dict.popitem() method, this one does not respect LIFO (last-in, first-out). This is due to the fact that attributes are stored in a random order when initializing the model. However, it will respect LIFO with respect to the internal __dict__ . Source code in oteapi/models/genericconfig.py 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 def popitem ( self ) -> \"Tuple[str, Any]\" : \"\"\"MutableMapping `popitem`-method. Important: Unlike the regular `dict.popitem()` method, this one does _not_ respect LIFO (last-in, first-out). This is due to the fact that attributes are stored in a random order when initializing the model. However, it will respect LIFO with respect to the internal `__dict__`. \"\"\" if not self : raise KeyError ( f \"popitem(): { self . __class__ . __name__ } is empty\" ) key = list ( self . __dict__ )[ - 1 ] value = self . pop ( key ) return key , value","title":"popitem()"},{"location":"all_models/#oteapi.models.genericconfig.AttrDict.update","text":"MutableMapping update -method. Source code in oteapi/models/genericconfig.py 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 def update ( self , other : \"Optional[Union[dict, AttrDict, Iterable[Any]]]\" = None , ** kwargs ) -> None : \"\"\"MutableMapping `update`-method.\"\"\" if other and isinstance ( other , ( dict , Mapping )): for key , value in other . items (): setattr ( self , key , value ) elif other and isinstance ( other , BaseModel ): for key , value in other . dict () . items (): setattr ( self , key , value ) elif other and isinstance ( other , Iterable ): for entry in other : if not len ( entry ) == 2 : raise ValueError ( \"`other` must be an iterable of objects of length two.\" ) for key , value in other : setattr ( self , key , value ) if kwargs : for key , value in kwargs . items (): setattr ( self , key , value )","title":"update()"},{"location":"all_models/#oteapi.models.genericconfig.AttrDict.values","text":"Return a view of all values. Source code in oteapi/models/genericconfig.py 62 63 64 def values ( self ): \"\"\"Return a view of all values.\"\"\" return self . __dict__ . values ()","title":"values()"},{"location":"all_models/#oteapi.models.genericconfig.GenericConfig","text":"Bases: BaseModel Generic class for configuration objects. Source code in oteapi/models/genericconfig.py 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 class GenericConfig ( BaseModel ): \"\"\"Generic class for configuration objects.\"\"\" configuration : AttrDict = Field ( AttrDict (), description = \"Model-specific configuration options which can either \" \"be given as key/value-pairs or set as attributes.\" , ) description : str = Field ( __doc__ , description = \"A description of the configuration model.\" , ) @classmethod def __init_subclass__ ( cls ) -> None : \"\"\"Initialize subclass descriptions with their docstrings.\"\"\" cls . __fields__ [ \"description\" ] . default = cls . __doc__ class Config : \"\"\"Pydantic configuration for `GenericConfig`. * **`validate_assignment`** Validate and cast set values. This is mainly relevant for sub-classes of `AttrDict`, where specific attributes have been defined. * **`arbitrary_types_allowed`** If a custom type is used for an attribute that doesn't have a `validate()` method, don't fail setting the attribute. \"\"\" validate_assignment = True arbitrary_types_allowed = True","title":"GenericConfig"},{"location":"all_models/#oteapi.models.genericconfig.GenericConfig.Config","text":"Pydantic configuration for GenericConfig . validate_assignment Validate and cast set values. This is mainly relevant for sub-classes of AttrDict , where specific attributes have been defined. arbitrary_types_allowed If a custom type is used for an attribute that doesn't have a validate() method, don't fail setting the attribute. Source code in oteapi/models/genericconfig.py 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 class Config : \"\"\"Pydantic configuration for `GenericConfig`. * **`validate_assignment`** Validate and cast set values. This is mainly relevant for sub-classes of `AttrDict`, where specific attributes have been defined. * **`arbitrary_types_allowed`** If a custom type is used for an attribute that doesn't have a `validate()` method, don't fail setting the attribute. \"\"\" validate_assignment = True arbitrary_types_allowed = True","title":"Config"},{"location":"all_models/#oteapi.models.genericconfig.GenericConfig.__init_subclass__","text":"Initialize subclass descriptions with their docstrings. Source code in oteapi/models/genericconfig.py 161 162 163 164 @classmethod def __init_subclass__ ( cls ) -> None : \"\"\"Initialize subclass descriptions with their docstrings.\"\"\" cls . __fields__ [ \"description\" ] . default = cls . __doc__","title":"__init_subclass__()"},{"location":"all_models/#oteapi.models.mappingconfig","text":"Pydantic Mapping Configuration Data Model.","title":"mappingconfig"},{"location":"all_models/#oteapi.models.mappingconfig.MappingConfig","text":"Bases: GenericConfig Mapping Strategy Data Configuration. Source code in oteapi/models/mappingconfig.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class MappingConfig ( GenericConfig ): \"\"\"Mapping Strategy Data Configuration.\"\"\" mappingType : str = Field ( ... , description = \"Type of registered mapping strategy.\" , ) prefixes : Optional [ Dict [ str , str ]] = Field ( None , description = ( \"List of shortnames that expands to an IRI given as local \" \"value/IRI-expansion-pairs.\" ), ) triples : Optional [ List [ RDFTriple ]] = Field ( None , description = \"List of RDF triples given as (subject, predicate, object).\" , )","title":"MappingConfig"},{"location":"all_models/#oteapi.models.resourceconfig","text":"Pydantic Resource Configuration Data Model.","title":"resourceconfig"},{"location":"all_models/#oteapi.models.resourceconfig.HostlessAnyUrl","text":"Bases: AnyUrl AnyUrl, but allow not having a host. Source code in oteapi/models/resourceconfig.py 12 13 14 15 class HostlessAnyUrl ( AnyUrl ): \"\"\"AnyUrl, but allow not having a host.\"\"\" host_required = False","title":"HostlessAnyUrl"},{"location":"all_models/#oteapi.models.resourceconfig.ResourceConfig","text":"Bases: GenericConfig Resource Strategy Data Configuration. Important Either of the pairs of attributes downloadUrl / mediaType or accessUrl / accessService MUST be specified. Source code in oteapi/models/resourceconfig.py 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 class ResourceConfig ( GenericConfig ): \"\"\"Resource Strategy Data Configuration. Important: Either of the pairs of attributes `downloadUrl`/`mediaType` or `accessUrl`/`accessService` MUST be specified. \"\"\" downloadUrl : Optional [ HostlessAnyUrl ] = Field ( None , description = ( \"Definition: The URL of the downloadable file in a given format. E.g. CSV \" \"file or RDF file. \\n\\n Usage: `downloadURL` *SHOULD* be used for the URL at\" \" which this distribution is available directly, typically through a HTTPS\" \" GET request or SFTP.\" ), ) mediaType : Optional [ str ] = Field ( None , description = ( \"The media type of the distribution as defined by IANA \" \"[[IANA-MEDIA-TYPES](https://www.w3.org/TR/vocab-dcat-2/#bib-iana-media-types)]\" \". \\n\\n Usage: This property *SHOULD* be used when the media\" \" type of the distribution is defined in IANA \" \"[[IANA-MEDIA-TYPES](https://www.w3.org/TR/vocab-dcat-2/#bib-iana-media-types)].\" ), ) accessUrl : Optional [ HostlessAnyUrl ] = Field ( None , description = ( \"A URL of the resource that gives access to a distribution of \" \"the dataset. E.g. landing page, feed, SPARQL endpoint. \\n\\n Usage: \" \"`accessURL` *SHOULD* be used for the URL of a service or location that \" \"can provide access to this distribution, typically through a Web form, \" \"query or API call. \\n `downloadURL` is preferred for direct links to \" \"downloadable resources.\" ), ) accessService : Optional [ str ] = Field ( None , description = ( \"A data service that gives access to the distribution of the dataset.\" ), ) license : Optional [ str ] = Field ( None , description = ( \"A legal document under which the distribution is made available.\" ), ) accessRights : Optional [ str ] = Field ( None , description = ( \"A rights statement that concerns how the distribution is accessed.\" ), ) publisher : Optional [ str ] = Field ( None , description = \"The entity responsible for making the resource/item available.\" , ) @root_validator def ensure_unique_url_pairs ( # pylint: disable=no-self-use cls , values : \"Dict[str, Any]\" ) -> \"Dict[str, Any]\" : \"\"\"Ensure either downloadUrl/mediaType or accessUrl/accessService are defined. It's fine to define them all, but at least one complete pair MUST be specified. \"\"\" if not ( all ( values . get ( _ ) for _ in [ \"downloadUrl\" , \"mediaType\" ]) or all ( values . get ( _ ) for _ in [ \"accessUrl\" , \"accessService\" ]) ): raise ValueError ( \"Either of the pairs of attributes downloadUrl/mediaType or \" \"accessUrl/accessService MUST be specified.\" ) return values","title":"ResourceConfig"},{"location":"all_models/#oteapi.models.resourceconfig.ResourceConfig.ensure_unique_url_pairs","text":"Ensure either downloadUrl/mediaType or accessUrl/accessService are defined. It's fine to define them all, but at least one complete pair MUST be specified. Source code in oteapi/models/resourceconfig.py 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 @root_validator def ensure_unique_url_pairs ( # pylint: disable=no-self-use cls , values : \"Dict[str, Any]\" ) -> \"Dict[str, Any]\" : \"\"\"Ensure either downloadUrl/mediaType or accessUrl/accessService are defined. It's fine to define them all, but at least one complete pair MUST be specified. \"\"\" if not ( all ( values . get ( _ ) for _ in [ \"downloadUrl\" , \"mediaType\" ]) or all ( values . get ( _ ) for _ in [ \"accessUrl\" , \"accessService\" ]) ): raise ValueError ( \"Either of the pairs of attributes downloadUrl/mediaType or \" \"accessUrl/accessService MUST be specified.\" ) return values","title":"ensure_unique_url_pairs()"},{"location":"all_models/#oteapi.models.sessionupdate","text":"Pydantic SessionUpdate Data Model.","title":"sessionupdate"},{"location":"all_models/#oteapi.models.sessionupdate.SessionUpdate","text":"Bases: AttrDict Session Update Data Model for returning values. Source code in oteapi/models/sessionupdate.py 5 6 class SessionUpdate ( AttrDict ): \"\"\"Session Update Data Model for returning values.\"\"\"","title":"SessionUpdate"},{"location":"all_models/#oteapi.models.transformationconfig","text":"Pydantic Transformation Configuration Data Model. A transformation status data model is provided as well. This data model represents what should be returned from the strategy's status() method.","title":"transformationconfig"},{"location":"all_models/#oteapi.models.transformationconfig.ProcessPriority","text":"Bases: str , Enum Defining process priority enumerators. Process priorities: Low Medium High Source code in oteapi/models/transformationconfig.py 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class ProcessPriority ( str , Enum ): \"\"\"Defining process priority enumerators. Process priorities: - Low - Medium - High \"\"\" LOW = \"Low\" MEDIUM = \"Medium\" HIGH = \"High\"","title":"ProcessPriority"},{"location":"all_models/#oteapi.models.transformationconfig.TransformationConfig","text":"Bases: GenericConfig Transformation Strategy Data Configuration. Source code in oteapi/models/transformationconfig.py 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 class TransformationConfig ( GenericConfig ): \"\"\"Transformation Strategy Data Configuration.\"\"\" transformationType : str = Field ( ... , description = ( \"Type of registered transformation strategy. E.g., `celery/remote`.\" ), ) name : Optional [ str ] = Field ( None , description = \"Human-readable name of the transformation strategy.\" ) due : Optional [ datetime ] = Field ( None , description = ( \"Optional field to indicate a due data/time for when a transformation \" \"should finish.\" ), ) priority : Optional [ ProcessPriority ] = Field ( ProcessPriority . MEDIUM , description = \"Define the process priority of the transformation execution.\" , ) secret : Optional [ str ] = Field ( None , description = \"Authorization secret given when running a transformation.\" , )","title":"TransformationConfig"},{"location":"all_models/#oteapi.models.transformationconfig.TransformationStatus","text":"Bases: BaseModel Return from transformation status. Source code in oteapi/models/transformationconfig.py 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 class TransformationStatus ( BaseModel ): \"\"\"Return from transformation status.\"\"\" id : str = Field ( ... , description = \"ID for the given transformation process.\" ) status : Optional [ str ] = Field ( None , description = \"Status for the transformation process.\" ) messages : Optional [ List [ str ]] = Field ( None , description = \"Messages related to the transformation process.\" ) created : Optional [ datetime ] = Field ( None , description = \"Time of creation for the transformation process. Given in UTC.\" , ) startTime : Optional [ datetime ] = Field ( None , description = \"Time when the transformation process started. Given in UTC.\" ) finishTime : Optional [ datetime ] = Field ( None , description = \"Time when the tranformation process finished. Given in UTC.\" )","title":"TransformationStatus"},{"location":"all_models/#oteapi.models.triplestoreconfig","text":"Pydantic TripleStore Configuration Data Model.","title":"triplestoreconfig"},{"location":"all_models/#oteapi.models.triplestoreconfig.TripleStoreConfig","text":"Bases: AttrDict TripleStore Configuration. This is a configuration for the TripleStore . This class should not be used directly as a configuration object for a strategy object, but only as a configuration field inside a configuration object. Source code in oteapi/models/triplestoreconfig.py 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 class TripleStoreConfig ( AttrDict ): \"\"\"TripleStore Configuration. This is a configuration for the [`TripleStore`][oteapi.triplestore.triplestore.TripleStore]. This class should not be used directly as a configuration object for a strategy object, but only as a configuration field inside a configuration object. \"\"\" repositoryName : str = Field ( ... , description = \"The repository name, where the mappings are stored.\" ) agraphHost : str = Field ( ... , description = \"AllegroGraph host name.\" , ) agraphPort : int = Field ( ... , description = \"AllegroGraph port number.\" , ) agraphUser : str = Field ( ... , description = \"AllegroGraph user name.\" , ) agraphPassword : SecretStr = Field ( ... , description = \"AllegroGraph user password.\" , )","title":"TripleStoreConfig"},{"location":"all_strategies/","text":"OTE-API Core Strategies \u00b6 This page provides documentation for the oteapi.strategies submodule, where all the core OTE-API strategies are located. These strategies will always be available when setting up a server based on the OTE-API Core package. download \u00b6 file \u00b6 Download strategy class for the file scheme. FileConfig \u00b6 Bases: AttrDict File-specific Configuration Data Model. Source code in oteapi/strategies/download/file.py 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 class FileConfig ( AttrDict ): \"\"\"File-specific Configuration Data Model.\"\"\" text : bool = Field ( False , description = ( \"Whether the file should be opened in text mode. If `False`, the file will\" \" be opened in bytes mode.\" ), ) encoding : Optional [ str ] = Field ( None , description = ( \"Encoding used when opening the file. The default is platform dependent.\" ), ) datacache_config : Optional [ DataCacheConfig ] = Field ( None , description = \"Configurations for the data cache for storing the downloaded file content.\" , ) FileResourceConfig \u00b6 Bases: ResourceConfig File download strategy filter config. Source code in oteapi/strategies/download/file.py 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 class FileResourceConfig ( ResourceConfig ): \"\"\"File download strategy filter config.\"\"\" downloadUrl : FileUrl = Field ( # type: ignore[assignment] ... , description = \"The file URL, which will be downloaded.\" ) configuration : FileConfig = Field ( FileConfig (), description = \"File download strategy-specific configuration.\" ) @validator ( \"downloadUrl\" ) def ensure_path_exists ( cls , value : FileUrl ) -> FileUrl : \"\"\"Ensure `path` is defined in `downloadUrl`.\"\"\" if not value . path : raise ValueError ( \"downloadUrl must contain a `path` part.\" ) return value ensure_path_exists ( value ) \u00b6 Ensure path is defined in downloadUrl . Source code in oteapi/strategies/download/file.py 48 49 50 51 52 53 @validator ( \"downloadUrl\" ) def ensure_path_exists ( cls , value : FileUrl ) -> FileUrl : \"\"\"Ensure `path` is defined in `downloadUrl`.\"\"\" if not value . path : raise ValueError ( \"downloadUrl must contain a `path` part.\" ) return value FileStrategy \u00b6 Strategy for retrieving data from a local file. Registers strategies : (\"scheme\", \"file\") Source code in oteapi/strategies/download/file.py 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 @dataclass class FileStrategy : \"\"\"Strategy for retrieving data from a local file. **Registers strategies**: - `(\"scheme\", \"file\")` \"\"\" download_config : FileResourceConfig def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdate : \"\"\"Initialize.\"\"\" return SessionUpdate () def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdateFile : \"\"\"Read local file.\"\"\" filename = uri_to_path ( self . download_config . downloadUrl ) . resolve () if not filename . exists (): raise FileNotFoundError ( f \"File not found at { filename } \" ) cache = DataCache ( self . download_config . configuration . datacache_config ) if cache . config . accessKey and cache . config . accessKey in cache : key = cache . config . accessKey else : key = cache . add ( filename . read_text ( encoding = self . download_config . configuration . encoding ) if self . download_config . configuration . text else filename . read_bytes () ) return SessionUpdateFile ( key = key ) get ( session = None ) \u00b6 Read local file. Source code in oteapi/strategies/download/file.py 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdateFile : \"\"\"Read local file.\"\"\" filename = uri_to_path ( self . download_config . downloadUrl ) . resolve () if not filename . exists (): raise FileNotFoundError ( f \"File not found at { filename } \" ) cache = DataCache ( self . download_config . configuration . datacache_config ) if cache . config . accessKey and cache . config . accessKey in cache : key = cache . config . accessKey else : key = cache . add ( filename . read_text ( encoding = self . download_config . configuration . encoding ) if self . download_config . configuration . text else filename . read_bytes () ) return SessionUpdateFile ( key = key ) initialize ( session = None ) \u00b6 Initialize. Source code in oteapi/strategies/download/file.py 74 75 76 def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdate : \"\"\"Initialize.\"\"\" return SessionUpdate () SessionUpdateFile \u00b6 Bases: SessionUpdate Class for returning values from Download File strategy. Source code in oteapi/strategies/download/file.py 56 57 58 59 class SessionUpdateFile ( SessionUpdate ): \"\"\"Class for returning values from Download File strategy.\"\"\" key : str = Field ( ... , description = \"Key to access the data in the cache.\" ) https \u00b6 Download strategy class for http/https HTTPSConfig \u00b6 Bases: AttrDict HTTP(S)-specific Configuration Data Model. Source code in oteapi/strategies/download/https.py 16 17 18 19 20 21 22 class HTTPSConfig ( AttrDict ): \"\"\"HTTP(S)-specific Configuration Data Model.\"\"\" datacache_config : Optional [ DataCacheConfig ] = Field ( None , description = \"Configurations for the data cache for storing the downloaded file content.\" , ) HTTPSResourceConfig \u00b6 Bases: ResourceConfig HTTP(S) download strategy filter config. Source code in oteapi/strategies/download/https.py 25 26 27 28 29 30 31 32 33 class HTTPSResourceConfig ( ResourceConfig ): \"\"\"HTTP(S) download strategy filter config.\"\"\" downloadUrl : AnyHttpUrl = Field ( # type: ignore[assignment] ... , description = \"The HTTP(S) URL, which will be downloaded.\" ) configuration : HTTPSConfig = Field ( HTTPSConfig (), description = \"HTTP(S) download strategy-specific configuration.\" ) HTTPSStrategy \u00b6 Strategy for retrieving data via http. Registers strategies : (\"scheme\", \"http\") (\"scheme\", \"https\") Source code in oteapi/strategies/download/https.py 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 @dataclass class HTTPSStrategy : \"\"\"Strategy for retrieving data via http. **Registers strategies**: - `(\"scheme\", \"http\")` - `(\"scheme\", \"https\")` \"\"\" download_config : HTTPSResourceConfig def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdate : \"\"\"Initialize.\"\"\" return SessionUpdate () def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdateHTTPS : \"\"\"Download via http/https and store on local cache.\"\"\" cache = DataCache ( self . download_config . configuration . datacache_config ) if cache . config . accessKey and cache . config . accessKey in cache : key = cache . config . accessKey else : req = requests . get ( self . download_config . downloadUrl , allow_redirects = True ) key = cache . add ( req . content ) return SessionUpdateHTTPS ( key = key ) get ( session = None ) \u00b6 Download via http/https and store on local cache. Source code in oteapi/strategies/download/https.py 59 60 61 62 63 64 65 66 67 68 def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdateHTTPS : \"\"\"Download via http/https and store on local cache.\"\"\" cache = DataCache ( self . download_config . configuration . datacache_config ) if cache . config . accessKey and cache . config . accessKey in cache : key = cache . config . accessKey else : req = requests . get ( self . download_config . downloadUrl , allow_redirects = True ) key = cache . add ( req . content ) return SessionUpdateHTTPS ( key = key ) initialize ( session = None ) \u00b6 Initialize. Source code in oteapi/strategies/download/https.py 55 56 57 def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdate : \"\"\"Initialize.\"\"\" return SessionUpdate () SessionUpdateHTTPS \u00b6 Bases: SessionUpdate Class for returning values from Download HTTPS strategy. Source code in oteapi/strategies/download/https.py 36 37 38 39 class SessionUpdateHTTPS ( SessionUpdate ): \"\"\"Class for returning values from Download HTTPS strategy.\"\"\" key : str = Field ( ... , description = \"Key to access the data in the cache.\" ) sftp \u00b6 Strategy class for sftp/ftp AnyFtpUrl \u00b6 Bases: AnyUrl A (S)FTP URL model. Source code in oteapi/strategies/download/sftp.py 18 19 20 21 class AnyFtpUrl ( AnyUrl ): \"\"\"A (S)FTP URL model.\"\"\" allowed_schemes = { \"ftp\" , \"sftp\" } SFTPConfig \u00b6 Bases: AttrDict (S)FTP-specific Configuration Data Model. Source code in oteapi/strategies/download/sftp.py 24 25 26 27 28 29 30 class SFTPConfig ( AttrDict ): \"\"\"(S)FTP-specific Configuration Data Model.\"\"\" datacache_config : Optional [ DataCacheConfig ] = Field ( None , description = \"Configurations for the data cache for storing the downloaded file content.\" , ) SFTPResourceConfig \u00b6 Bases: ResourceConfig (S)FTP download strategy filter config. Source code in oteapi/strategies/download/sftp.py 33 34 35 36 37 38 39 40 41 class SFTPResourceConfig ( ResourceConfig ): \"\"\"(S)FTP download strategy filter config.\"\"\" downloadUrl : AnyFtpUrl = Field ( # type: ignore[assignment] ... , description = \"The (S)FTP URL, which will be downloaded.\" ) configuration : SFTPConfig = Field ( SFTPConfig (), description = \"(S)FTP download strategy-specific configuration.\" ) SFTPStrategy \u00b6 Strategy for retrieving data via sftp. Registers strategies : (\"scheme\", \"ftp\") (\"scheme\", \"sftp\") Source code in oteapi/strategies/download/sftp.py 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 @dataclass class SFTPStrategy : \"\"\"Strategy for retrieving data via sftp. **Registers strategies**: - `(\"scheme\", \"ftp\")` - `(\"scheme\", \"sftp\")` \"\"\" download_config : SFTPResourceConfig def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdate : \"\"\"Initialize.\"\"\" return SessionUpdate () def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdateSFTP : \"\"\"Download via sftp\"\"\" cache = DataCache ( self . download_config . configuration . datacache_config ) if cache . config . accessKey and cache . config . accessKey in cache : key = cache . config . accessKey else : # Setup connection options cnopts = pysftp . CnOpts () cnopts . hostkeys = None # open connection and store data locally with pysftp . Connection ( host = self . download_config . downloadUrl . host , username = self . download_config . downloadUrl . user , password = self . download_config . downloadUrl . password , port = self . download_config . downloadUrl . port , cnopts = cnopts , ) as sftp : # Because of insane locking on Windows, we have to close # the downloaded file before adding it to the cache with NamedTemporaryFile ( prefix = \"oteapi-sftp-\" , delete = False ) as handle : localpath = Path ( handle . name ) . resolve () try : sftp . get ( self . download_config . downloadUrl . path , localpath = localpath ) key = cache . add ( localpath . read_bytes ()) finally : localpath . unlink () return SessionUpdateSFTP ( key = key ) get ( session = None ) \u00b6 Download via sftp Source code in oteapi/strategies/download/sftp.py 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdateSFTP : \"\"\"Download via sftp\"\"\" cache = DataCache ( self . download_config . configuration . datacache_config ) if cache . config . accessKey and cache . config . accessKey in cache : key = cache . config . accessKey else : # Setup connection options cnopts = pysftp . CnOpts () cnopts . hostkeys = None # open connection and store data locally with pysftp . Connection ( host = self . download_config . downloadUrl . host , username = self . download_config . downloadUrl . user , password = self . download_config . downloadUrl . password , port = self . download_config . downloadUrl . port , cnopts = cnopts , ) as sftp : # Because of insane locking on Windows, we have to close # the downloaded file before adding it to the cache with NamedTemporaryFile ( prefix = \"oteapi-sftp-\" , delete = False ) as handle : localpath = Path ( handle . name ) . resolve () try : sftp . get ( self . download_config . downloadUrl . path , localpath = localpath ) key = cache . add ( localpath . read_bytes ()) finally : localpath . unlink () return SessionUpdateSFTP ( key = key ) initialize ( session = None ) \u00b6 Initialize. Source code in oteapi/strategies/download/sftp.py 63 64 65 def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdate : \"\"\"Initialize.\"\"\" return SessionUpdate () SessionUpdateSFTP \u00b6 Bases: SessionUpdate Class for returning values from Download SFTP strategy. Source code in oteapi/strategies/download/sftp.py 44 45 46 47 class SessionUpdateSFTP ( SessionUpdate ): \"\"\"Class for returning values from Download SFTP strategy.\"\"\" key : str = Field ( ... , description = \"Key to access the data in the cache.\" ) filter \u00b6 crop_filter \u00b6 Demo-filter strategy CropImageConfig \u00b6 Bases: AttrDict Configuration model for crop data. Source code in oteapi/strategies/filter/crop_filter.py 14 15 16 17 18 19 class CropImageConfig ( AttrDict ): \"\"\"Configuration model for crop data.\"\"\" crop : Tuple [ int , int , int , int ] = Field ( ... , description = \"Box cropping parameters (left, top, right, bottom).\" ) CropImageFilter \u00b6 Strategy for cropping an image. Registers strategies : (\"filterType\", \"filter/crop\") Source code in oteapi/strategies/filter/crop_filter.py 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 @dataclass class CropImageFilter : \"\"\"Strategy for cropping an image. **Registers strategies**: - `(\"filterType\", \"filter/crop\")` \"\"\" filter_config : CropImageFilterConfig def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None , ) -> SessionUpdateCropFilter : \"\"\"Initialize strategy and return a dictionary.\"\"\" return SessionUpdateCropFilter ( imagecrop = self . filter_config . configuration . crop , ) def get ( self , session : \"Optional[Dict[str, Any]]\" = None , ) -> SessionUpdate : \"\"\"Execute strategy and return a dictionary\"\"\" return SessionUpdate () get ( session = None ) \u00b6 Execute strategy and return a dictionary Source code in oteapi/strategies/filter/crop_filter.py 64 65 66 67 68 69 def get ( self , session : \"Optional[Dict[str, Any]]\" = None , ) -> SessionUpdate : \"\"\"Execute strategy and return a dictionary\"\"\" return SessionUpdate () initialize ( session = None ) \u00b6 Initialize strategy and return a dictionary. Source code in oteapi/strategies/filter/crop_filter.py 55 56 57 58 59 60 61 62 def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None , ) -> SessionUpdateCropFilter : \"\"\"Initialize strategy and return a dictionary.\"\"\" return SessionUpdateCropFilter ( imagecrop = self . filter_config . configuration . crop , ) CropImageFilterConfig \u00b6 Bases: FilterConfig Crop filter strategy filter config. Source code in oteapi/strategies/filter/crop_filter.py 22 23 24 25 26 27 28 29 30 31 32 class CropImageFilterConfig ( FilterConfig ): \"\"\"Crop filter strategy filter config.\"\"\" filterType : str = Field ( \"filter/crop\" , const = True , description = FilterConfig . __fields__ [ \"filterType\" ] . field_info . description , ) configuration : CropImageConfig = Field ( ... , description = \"Image crop filter strategy-specific configuration.\" ) SessionUpdateCropFilter \u00b6 Bases: SessionUpdate Return model for CropImageFilter . Source code in oteapi/strategies/filter/crop_filter.py 35 36 37 38 39 40 class SessionUpdateCropFilter ( SessionUpdate ): \"\"\"Return model for `CropImageFilter`.\"\"\" imagecrop : Tuple [ int , int , int , int ] = Field ( ... , description = \"Box cropping parameters (left, top, right, bottom).\" ) sql_query_filter \u00b6 SQL query filter strategy. SQLQueryFilter \u00b6 Strategy for a SQL query filter. Registers strategies : (\"filterType\", \"filter/sql\") Source code in oteapi/strategies/filter/sql_query_filter.py 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 @dataclass class SQLQueryFilter : \"\"\"Strategy for a SQL query filter. **Registers strategies**: - `(\"filterType\", \"filter/sql\")` \"\"\" filter_config : SqlQueryFilterConfig def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None , ) -> SessionUpdateSqlQuery : \"\"\"Initialize strategy.\"\"\" return SessionUpdateSqlQuery ( sqlquery = self . filter_config . query ) def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdate : \"\"\"Execute strategy and return a dictionary.\"\"\" return SessionUpdate () get ( session = None ) \u00b6 Execute strategy and return a dictionary. Source code in oteapi/strategies/filter/sql_query_filter.py 50 51 52 def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdate : \"\"\"Execute strategy and return a dictionary.\"\"\" return SessionUpdate () initialize ( session = None ) \u00b6 Initialize strategy. Source code in oteapi/strategies/filter/sql_query_filter.py 43 44 45 46 47 48 def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None , ) -> SessionUpdateSqlQuery : \"\"\"Initialize strategy.\"\"\" return SessionUpdateSqlQuery ( sqlquery = self . filter_config . query ) SessionUpdateSqlQuery \u00b6 Bases: SessionUpdate Class for returning values from SQL Query data model. Source code in oteapi/strategies/filter/sql_query_filter.py 25 26 27 28 class SessionUpdateSqlQuery ( SessionUpdate ): \"\"\"Class for returning values from SQL Query data model.\"\"\" sqlquery : str = Field ( ... , description = \"A SQL query string.\" ) SqlQueryFilterConfig \u00b6 Bases: FilterConfig SQLite query filter strategy filter config. Source code in oteapi/strategies/filter/sql_query_filter.py 14 15 16 17 18 19 20 21 22 class SqlQueryFilterConfig ( FilterConfig ): \"\"\"SQLite query filter strategy filter config.\"\"\" filterType : str = Field ( \"filter/sql\" , const = True , description = FilterConfig . __fields__ [ \"filterType\" ] . field_info . description , ) query : str = Field ( ... , description = \"A SQL query string.\" ) mapping \u00b6 mapping \u00b6 Mapping filter strategy. MappingSessionUpdate \u00b6 Bases: SessionUpdate SessionUpdate model for mappings. Source code in oteapi/strategies/mapping/mapping.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class MappingSessionUpdate ( SessionUpdate ): \"\"\"SessionUpdate model for mappings.\"\"\" prefixes : Dict [ str , str ] = Field ( ... , description = ( \"List of shortnames that expands to an IRI \" \"given as local value/IRI-expansion-pairs.\" ), ) triples : List [ RDFTriple ] = Field ( ... , description = \"List of semantic triples given as (subject, predicate, object).\" , ) MappingStrategy \u00b6 Strategy for a mapping. The mapping strategy simply adds more prefixes and triples to the prefixes and triples fields in the session such that they are available for other strategies, like function strategies that convert between data models. Nothing is returned to avoid deleting existing mappings. Registers strategies : (\"mappingType\", \"triples\") Source code in oteapi/strategies/mapping/mapping.py 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 @dataclass class MappingStrategy : \"\"\"Strategy for a mapping. The mapping strategy simply adds more prefixes and triples to the `prefixes` and `triples` fields in the session such that they are available for other strategies, like function strategies that convert between data models. Nothing is returned to avoid deleting existing mappings. **Registers strategies**: - `(\"mappingType\", \"triples\")` \"\"\" mapping_config : MappingConfig def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> MappingSessionUpdate : \"\"\"Initialize strategy.\"\"\" prefixes = session . get ( \"prefixes\" , {}) if session else {} triples = session . get ( \"triples\" , []) if session else [] if self . mapping_config . prefixes : prefixes . update ( self . mapping_config . prefixes ) if self . mapping_config . triples : triples . extend ( self . mapping_config . triples ) return MappingSessionUpdate ( prefixes = prefixes , triples = triples ) def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdate : \"\"\"Execute strategy and return a dictionary.\"\"\" return SessionUpdate () get ( session = None ) \u00b6 Execute strategy and return a dictionary. Source code in oteapi/strategies/mapping/mapping.py 62 63 64 def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdate : \"\"\"Execute strategy and return a dictionary.\"\"\" return SessionUpdate () initialize ( session = None ) \u00b6 Initialize strategy. Source code in oteapi/strategies/mapping/mapping.py 48 49 50 51 52 53 54 55 56 57 58 59 60 def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> MappingSessionUpdate : \"\"\"Initialize strategy.\"\"\" prefixes = session . get ( \"prefixes\" , {}) if session else {} triples = session . get ( \"triples\" , []) if session else [] if self . mapping_config . prefixes : prefixes . update ( self . mapping_config . prefixes ) if self . mapping_config . triples : triples . extend ( self . mapping_config . triples ) return MappingSessionUpdate ( prefixes = prefixes , triples = triples ) parse \u00b6 application_json \u00b6 Strategy class for application/json. JSONConfig \u00b6 Bases: AttrDict JSON parse-specific Configuration Data Model. Source code in oteapi/strategies/parse/application_json.py 17 18 19 20 21 22 23 class JSONConfig ( AttrDict ): \"\"\"JSON parse-specific Configuration Data Model.\"\"\" datacache_config : Optional [ DataCacheConfig ] = Field ( None , description = \"Configurations for the data cache for storing the downloaded file content.\" , ) JSONDataParseStrategy \u00b6 Parse strategy for JSON. Registers strategies : (\"mediaType\", \"application/json\") Source code in oteapi/strategies/parse/application_json.py 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 @dataclass class JSONDataParseStrategy : \"\"\"Parse strategy for JSON. **Registers strategies**: - `(\"mediaType\", \"application/json\")` \"\"\" parse_config : JSONResourceConfig def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdate : \"\"\"Initialize.\"\"\" return SessionUpdate () def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdateJSONParse : \"\"\"Parse json.\"\"\" downloader = create_strategy ( \"download\" , self . parse_config ) output = downloader . get () cache = DataCache ( self . parse_config . configuration . datacache_config ) content = cache . get ( output [ \"key\" ]) if isinstance ( content , dict ): return SessionUpdateJSONParse ( content = content ) return SessionUpdateJSONParse ( content = json . loads ( content )) get ( session = None ) \u00b6 Parse json. Source code in oteapi/strategies/parse/application_json.py 61 62 63 64 65 66 67 68 69 70 def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdateJSONParse : \"\"\"Parse json.\"\"\" downloader = create_strategy ( \"download\" , self . parse_config ) output = downloader . get () cache = DataCache ( self . parse_config . configuration . datacache_config ) content = cache . get ( output [ \"key\" ]) if isinstance ( content , dict ): return SessionUpdateJSONParse ( content = content ) return SessionUpdateJSONParse ( content = json . loads ( content )) initialize ( session = None ) \u00b6 Initialize. Source code in oteapi/strategies/parse/application_json.py 57 58 59 def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdate : \"\"\"Initialize.\"\"\" return SessionUpdate () JSONResourceConfig \u00b6 Bases: ResourceConfig JSON parse strategy filter config. Source code in oteapi/strategies/parse/application_json.py 26 27 28 29 30 31 32 33 34 35 36 class JSONResourceConfig ( ResourceConfig ): \"\"\"JSON parse strategy filter config.\"\"\" mediaType : str = Field ( \"application/json\" , const = True , description = ResourceConfig . __fields__ [ \"mediaType\" ] . field_info . description , ) configuration : JSONConfig = Field ( JSONConfig (), description = \"JSON parse strategy-specific configuration.\" ) SessionUpdateJSONParse \u00b6 Bases: SessionUpdate Class for returning values from JSON Parse. Source code in oteapi/strategies/parse/application_json.py 39 40 41 42 class SessionUpdateJSONParse ( SessionUpdate ): \"\"\"Class for returning values from JSON Parse.\"\"\" content : dict = Field ( ... , description = \"Content of the JSON document.\" ) application_vnd_sqlite \u00b6 Strategy class for application/vnd.sqlite3. SessionUpdateSqLiteParse \u00b6 Bases: SessionUpdate Configuration model for SqLiteParse. Source code in oteapi/strategies/parse/application_vnd_sqlite.py 61 62 63 64 class SessionUpdateSqLiteParse ( SessionUpdate ): \"\"\"Configuration model for SqLiteParse.\"\"\" result : list = Field ( ... , description = \"List of results from the query.\" ) SqliteParseConfig \u00b6 Bases: AttrDict Configuration data model for SqliteParseStrategy . Source code in oteapi/strategies/parse/application_vnd_sqlite.py 18 19 20 21 22 23 24 25 26 class SqliteParseConfig ( AttrDict ): \"\"\"Configuration data model for [`SqliteParseStrategy`][oteapi.strategies.parse.application_vnd_sqlite.SqliteParseStrategy].\"\"\" sqlquery : str = Field ( \"\" , description = \"A SQL query string.\" ) datacache_config : Optional [ DataCacheConfig ] = Field ( None , description = \"Configuration options for the local data cache.\" , ) SqliteParseStrategy \u00b6 Parse strategy for SQLite. Registers strategies : (\"mediaType\", \"application/vnd.sqlite3\") Purpose of this strategy: Download a SQLite database using downloadUrl and run a SQL query on the database to return all relevant rows. Source code in oteapi/strategies/parse/application_vnd_sqlite.py 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 @dataclass class SqliteParseStrategy : \"\"\"Parse strategy for SQLite. **Registers strategies**: - `(\"mediaType\", \"application/vnd.sqlite3\")` Purpose of this strategy: Download a SQLite database using `downloadUrl` and run a SQL query on the database to return all relevant rows. \"\"\" parse_config : SqliteParserResourceConfig def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdate : \"\"\"Initialize strategy.\"\"\" return SessionUpdate () def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdateSqLiteParse : \"\"\"Parse SQLite query responses.\"\"\" if session : self . _use_filters ( session ) session = session if session else {} # Retrieve SQLite file download_config = self . parse_config . copy () del download_config . configuration downloader = create_strategy ( \"download\" , download_config ) session . update ( downloader . initialize ( session )) cache_key = downloader . get ( session ) . get ( \"key\" , \"\" ) cache = DataCache ( self . parse_config . configuration . datacache_config ) with cache . getfile ( cache_key , suffix = \"db\" ) as filename : connection = create_connection ( filename ) cursor = connection . cursor () result = cursor . execute ( self . parse_config . configuration . sqlquery ) . fetchall () connection . close () return SessionUpdateSqLiteParse ( result = result ) def _use_filters ( self , session : \"Dict[str, Any]\" ) -> None : \"\"\"Update `config` according to filter values found in the session.\"\"\" if \"sqlquery\" in session and not self . parse_config . configuration . sqlquery : # Use SQL query available in session self . parse_config . configuration . sqlquery = session [ \"sqlquery\" ] _use_filters ( session ) \u00b6 Update config according to filter values found in the session. Source code in oteapi/strategies/parse/application_vnd_sqlite.py 109 110 111 112 113 def _use_filters ( self , session : \"Dict[str, Any]\" ) -> None : \"\"\"Update `config` according to filter values found in the session.\"\"\" if \"sqlquery\" in session and not self . parse_config . configuration . sqlquery : # Use SQL query available in session self . parse_config . configuration . sqlquery = session [ \"sqlquery\" ] get ( session = None ) \u00b6 Parse SQLite query responses. Source code in oteapi/strategies/parse/application_vnd_sqlite.py 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdateSqLiteParse : \"\"\"Parse SQLite query responses.\"\"\" if session : self . _use_filters ( session ) session = session if session else {} # Retrieve SQLite file download_config = self . parse_config . copy () del download_config . configuration downloader = create_strategy ( \"download\" , download_config ) session . update ( downloader . initialize ( session )) cache_key = downloader . get ( session ) . get ( \"key\" , \"\" ) cache = DataCache ( self . parse_config . configuration . datacache_config ) with cache . getfile ( cache_key , suffix = \"db\" ) as filename : connection = create_connection ( filename ) cursor = connection . cursor () result = cursor . execute ( self . parse_config . configuration . sqlquery ) . fetchall () connection . close () return SessionUpdateSqLiteParse ( result = result ) initialize ( session = None ) \u00b6 Initialize strategy. Source code in oteapi/strategies/parse/application_vnd_sqlite.py 82 83 84 def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdate : \"\"\"Initialize strategy.\"\"\" return SessionUpdate () SqliteParserResourceConfig \u00b6 Bases: ResourceConfig SQLite parse strategy resource config. Source code in oteapi/strategies/parse/application_vnd_sqlite.py 29 30 31 32 33 34 35 36 37 38 39 class SqliteParserResourceConfig ( ResourceConfig ): \"\"\"SQLite parse strategy resource config.\"\"\" mediaType : str = Field ( \"application/vnd.sqlite3\" , const = True , description = ResourceConfig . __fields__ [ \"mediaType\" ] . field_info . description , ) configuration : SqliteParseConfig = Field ( SqliteParseConfig (), description = \"SQLite parse strategy-specific configuration.\" ) create_connection ( db_file ) \u00b6 Create a database connection to SQLite database. Parameters: Name Type Description Default db_file Path Full path to SQLite database file. required Raises: Type Description sqlite3 . Error If a DB connection cannot be made. Returns: Type Description sqlite3 . Connection Connection object. Source code in oteapi/strategies/parse/application_vnd_sqlite.py 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 def create_connection ( db_file : Path ) -> sqlite3 . Connection : \"\"\"Create a database connection to SQLite database. Parameters: db_file: Full path to SQLite database file. Raises: sqlite3.Error: If a DB connection cannot be made. Returns: Connection object. \"\"\" try : return sqlite3 . connect ( db_file ) except sqlite3 . Error as exc : raise sqlite3 . Error ( \"Could not connect to given SQLite DB.\" ) from exc excel_xlsx \u00b6 Strategy class for workbook/xlsx. SessionUpdateXLSXParse \u00b6 Bases: SessionUpdate Class for returning values from XLSXParse. Source code in oteapi/strategies/parse/excel_xlsx.py 19 20 21 22 23 24 25 class SessionUpdateXLSXParse ( SessionUpdate ): \"\"\"Class for returning values from XLSXParse.\"\"\" data : Dict [ str , list ] = Field ( ... , description = \"A dict with column-name/column-value pairs. The values are lists.\" , ) XLSXParseConfig \u00b6 Bases: AttrDict Data model for retrieving a rectangular section of an Excel sheet. Source code in oteapi/strategies/parse/excel_xlsx.py 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 class XLSXParseConfig ( AttrDict ): \"\"\"Data model for retrieving a rectangular section of an Excel sheet.\"\"\" worksheet : str = Field ( ... , description = \"Name of worksheet to load.\" ) row_from : Optional [ int ] = Field ( None , description = \"Excel row number of first row. Defaults to first assigned row.\" , ) col_from : Optional [ Union [ int , str ]] = Field ( None , description = ( \"Excel column number or label of first column. Defaults to first assigned \" \"column.\" ), ) row_to : Optional [ int ] = Field ( None , description = \"Excel row number of last row. Defaults to last assigned row.\" ) col_to : Optional [ Union [ int , str ]] = Field ( None , description = ( \"Excel column number or label of last column. Defaults to last assigned \" \"column.\" ), ) header_row : Optional [ int ] = Field ( None , description = ( \"Row number with the headers. Defaults to `1` if header is given, \" \"otherwise `None`.\" ), ) header : Optional [ List [ str ]] = Field ( None , description = ( \"Optional list of column names, specifying the columns to return. \" \"These names they should match cells in `header_row`.\" ), ) new_header : Optional [ List [ str ]] = Field ( None , description = ( \"Optional list of new column names replacing `header` in the output.\" ), ) download_config : AttrDict = Field ( AttrDict (), description = \"Configurations provided to a download strategy.\" , ) datacache_config : Optional [ DataCacheConfig ] = Field ( None , description = \"Configurations for the data cache for retrieving the downloaded content.\" , ) XLSXParseResourceConfig \u00b6 Bases: ResourceConfig XLSX parse strategy resource config. Source code in oteapi/strategies/parse/excel_xlsx.py 83 84 85 86 87 88 89 90 91 92 93 class XLSXParseResourceConfig ( ResourceConfig ): \"\"\"XLSX parse strategy resource config.\"\"\" mediaType : str = Field ( \"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\" , const = True , description = ResourceConfig . __fields__ [ \"mediaType\" ] . field_info . description , ) configuration : XLSXParseConfig = Field ( ... , description = \"SQLite parse strategy-specific configuration.\" ) XLSXParseStrategy \u00b6 Parse strategy for Excel XLSX files. Registers strategies : (\"mediaType\", \"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\") Source code in oteapi/strategies/parse/excel_xlsx.py 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 @dataclass class XLSXParseStrategy : \"\"\"Parse strategy for Excel XLSX files. **Registers strategies**: - `(\"mediaType\", \"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\")` \"\"\" parse_config : XLSXParseResourceConfig def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdate : \"\"\"Initialize.\"\"\" return SessionUpdate () def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdateXLSXParse : \"\"\"Parses selected region of an excel file. Returns: A dict with column-name/column-value pairs. The values are lists. \"\"\" cache = DataCache ( self . parse_config . configuration . datacache_config ) if session is None : raise ValueError ( \"Missing session\" ) with cache . getfile ( key = session [ \"key\" ], suffix = \".xlsx\" ) as filename : # Note that we have to set read_only=False to ensure that # load_workbook() properly closes the xlsx file after reading. # Otherwise Windows will fail when the temporary file is removed # when leaving the with statement. workbook = load_workbook ( filename = filename , read_only = False , data_only = True ) worksheet = workbook [ self . parse_config . configuration . worksheet ] set_model_defaults ( self . parse_config . configuration , worksheet ) columns = get_column_indices ( self . parse_config . configuration , worksheet ) data = [] for row in worksheet . iter_rows ( min_row = self . parse_config . configuration . row_from , max_row = self . parse_config . configuration . row_to , min_col = min ( columns ), max_col = max ( columns ), ): data . append ([ row [ c - 1 ] . value for c in columns ]) if self . parse_config . configuration . header_row : row = worksheet . iter_rows ( min_row = self . parse_config . configuration . header_row , max_row = self . parse_config . configuration . header_row , min_col = min ( columns ), max_col = max ( columns ), ) . __next__ () header = [ row [ c - 1 ] . value for c in columns ] else : header = None if self . parse_config . configuration . new_header : nhead = len ( header ) if header else len ( data [ 0 ]) if data else 0 if len ( self . parse_config . configuration . new_header ) != nhead : raise TypeError ( f \"length of `new_header` (= { len ( self . parse_config . configuration . new_header ) } ) \" f \"doesn't match number of columns (= { len ( header ) if header else 0 } )\" ) if header : for i , val in enumerate ( self . parse_config . configuration . new_header ): if val is not None : header [ i ] = val elif data : header = self . parse_config . configuration . new_header if header is None : header = [ get_column_letter ( col + 1 ) for col in range ( len ( data ))] transposed = [ list ( datum ) for datum in zip ( * data )] return SessionUpdateXLSXParse ( data = { key : value for key , value in zip ( header , transposed )} ) get ( session = None ) \u00b6 Parses selected region of an excel file. Returns: Type Description SessionUpdateXLSXParse A dict with column-name/column-value pairs. The values are lists. Source code in oteapi/strategies/parse/excel_xlsx.py 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdateXLSXParse : \"\"\"Parses selected region of an excel file. Returns: A dict with column-name/column-value pairs. The values are lists. \"\"\" cache = DataCache ( self . parse_config . configuration . datacache_config ) if session is None : raise ValueError ( \"Missing session\" ) with cache . getfile ( key = session [ \"key\" ], suffix = \".xlsx\" ) as filename : # Note that we have to set read_only=False to ensure that # load_workbook() properly closes the xlsx file after reading. # Otherwise Windows will fail when the temporary file is removed # when leaving the with statement. workbook = load_workbook ( filename = filename , read_only = False , data_only = True ) worksheet = workbook [ self . parse_config . configuration . worksheet ] set_model_defaults ( self . parse_config . configuration , worksheet ) columns = get_column_indices ( self . parse_config . configuration , worksheet ) data = [] for row in worksheet . iter_rows ( min_row = self . parse_config . configuration . row_from , max_row = self . parse_config . configuration . row_to , min_col = min ( columns ), max_col = max ( columns ), ): data . append ([ row [ c - 1 ] . value for c in columns ]) if self . parse_config . configuration . header_row : row = worksheet . iter_rows ( min_row = self . parse_config . configuration . header_row , max_row = self . parse_config . configuration . header_row , min_col = min ( columns ), max_col = max ( columns ), ) . __next__ () header = [ row [ c - 1 ] . value for c in columns ] else : header = None if self . parse_config . configuration . new_header : nhead = len ( header ) if header else len ( data [ 0 ]) if data else 0 if len ( self . parse_config . configuration . new_header ) != nhead : raise TypeError ( f \"length of `new_header` (= { len ( self . parse_config . configuration . new_header ) } ) \" f \"doesn't match number of columns (= { len ( header ) if header else 0 } )\" ) if header : for i , val in enumerate ( self . parse_config . configuration . new_header ): if val is not None : header [ i ] = val elif data : header = self . parse_config . configuration . new_header if header is None : header = [ get_column_letter ( col + 1 ) for col in range ( len ( data ))] transposed = [ list ( datum ) for datum in zip ( * data )] return SessionUpdateXLSXParse ( data = { key : value for key , value in zip ( header , transposed )} ) initialize ( session = None ) \u00b6 Initialize. Source code in oteapi/strategies/parse/excel_xlsx.py 165 166 167 def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdate : \"\"\"Initialize.\"\"\" return SessionUpdate () get_column_indices ( model , worksheet ) \u00b6 Helper function returning a list of column indices. Parameters: Name Type Description Default model XLSXParseConfig The parsed data model. required worksheet 'Worksheet' Excel worksheet, from which the header values will be retrieved. required Returns: Type Description 'Iterable[int]' A list of column indices. Source code in oteapi/strategies/parse/excel_xlsx.py 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 def get_column_indices ( model : XLSXParseConfig , worksheet : \"Worksheet\" ) -> \"Iterable[int]\" : \"\"\"Helper function returning a list of column indices. Parameters: model: The parsed data model. worksheet: Excel worksheet, from which the header values will be retrieved. Returns: A list of column indices. \"\"\" if not isinstance ( model . col_from , int ) or not isinstance ( model . col_to , int ): raise TypeError ( \"Expected `model.col_from` and `model.col_to` to be integers.\" ) if model . header : header_dict = { worksheet . cell ( model . header_row , col ) . value : col for col in range ( model . col_from , model . col_to + 1 ) } return [ header_dict [ h ] for h in model . header ] return range ( model . col_from , model . col_to + 1 ) set_model_defaults ( model , worksheet ) \u00b6 Update data model model with default values obtained from worksheet . Parameters: Name Type Description Default model XLSXParseConfig The parsed data model. required worksheet 'Worksheet' Excel worksheet, from which the default values will be obtained. required Source code in oteapi/strategies/parse/excel_xlsx.py 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 def set_model_defaults ( model : XLSXParseConfig , worksheet : \"Worksheet\" ) -> None : \"\"\"Update data model `model` with default values obtained from `worksheet`. Parameters: model: The parsed data model. worksheet: Excel worksheet, from which the default values will be obtained. \"\"\" if model . row_from is None : if model . header : # assume that data starts on the first row after the header model . row_from = model . header_row + 1 if model . header_row else 1 else : model . row_from = worksheet . min_row if model . row_to is None : model . row_to = worksheet . max_row if model . col_from is None : model . col_from = worksheet . min_column elif isinstance ( model . col_from , str ): model . col_from = column_index_from_string ( model . col_from ) if model . col_to is None : model . col_to = worksheet . max_column elif isinstance ( model . col_to , str ): model . col_to = column_index_from_string ( model . col_to ) if model . header and not model . header_row : model . header_row = 1 image \u00b6 Strategy class for image/jpg. ImageDataParseStrategy \u00b6 Parse strategy for images. This strategy uses Pillow to read a raw image from the data cache, converts it into a NumPy array and stores the new array in the data cache. It also supports simple cropping and image conversions. The key to the new array and other metadata is stored in the session. See SessionUpdateImageParse for more info. Registers strategies : (\"mediaType\", \"image/jpg\") (\"mediaType\", \"image/jpeg\") (\"mediaType\", \"image/jp2\") (\"mediaType\", \"image/png\") (\"mediaType\", \"image/gif\") (\"mediaType\", \"image/tiff\") (\"mediaType\", \"image/eps\") Source code in oteapi/strategies/parse/image.py 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 @dataclass class ImageDataParseStrategy : \"\"\"Parse strategy for images. This strategy uses Pillow to read a raw image from the data cache, converts it into a NumPy array and stores the new array in the data cache. It also supports simple cropping and image conversions. The key to the new array and other metadata is stored in the session. See [`SessionUpdateImageParse`][oteapi.strategies.parse.image.SessionUpdateImageParse] for more info. **Registers strategies**: - `(\"mediaType\", \"image/jpg\")` - `(\"mediaType\", \"image/jpeg\")` - `(\"mediaType\", \"image/jp2\")` - `(\"mediaType\", \"image/png\")` - `(\"mediaType\", \"image/gif\")` - `(\"mediaType\", \"image/tiff\")` - `(\"mediaType\", \"image/eps\")` \"\"\" parse_config : ImageParserResourceConfig def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdate : \"\"\"Initialize strategy.\"\"\" return SessionUpdate () def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdateImageParse : \"\"\"Execute the strategy.\"\"\" if not session : session = {} config = self . parse_config . configuration crop = config . crop if config . crop else session . get ( \"imagecrop\" ) mime_format = self . parse_config . mediaType . split ( \"/\" )[ 1 ] image_format = SupportedFormat [ mime_format ] . value # Proper download configurations conf = self . parse_config . dict () conf [ \"configuration\" ] = config . download_config or {} download_config = ResourceConfig ( ** conf ) downloader = create_strategy ( \"download\" , download_config ) session . update ( downloader . initialize ( session )) downloader = create_strategy ( \"download\" , download_config ) output = downloader . get ( session ) session . update ( output ) if config . datacache_config and config . datacache_config . accessKey : cache_key = config . datacache_config . accessKey elif \"key\" in output : cache_key = output [ \"key\" ] else : RuntimeError ( \"No data cache key provided to the downloaded content\" ) cache = DataCache ( config . datacache_config ) # Treat image according to filter values with cache . getfile ( cache_key , suffix = mime_format ) as filename : image = Image . open ( filename , formats = [ image_format ]) if crop : image = image . crop ( crop ) if config . image_mode : image = image . convert ( mode = config . image_mode ) if image_format == \"GIF\" : if image . info . get ( \"version\" , b \"\" ) . startswith ( b \"GIF\" ): image . info . update ( { \"version\" : image . info . get ( \"version\" , b \"\" )[ len ( b \"GIF\" ) :]} ) # Use the buffer protocol to store the image in the datacache data = np . asarray ( image ) image_key = cache . add ( data , key = config . image_key , tag = str ( id ( session )), ) if image . mode == \"P\" : image_palette_key = cache . add ( np . asarray ( image . getpalette ()), tag = str ( id ( session )) ) else : image_palette_key = None # The session must be json serialisable - filter out all # non-json serialisable fields in image.info if image . info : image_info = { key : val for key , val in image . info . items () if isinstance ( val , ( str , int , float , type ( None ), bool , tuple , list )) } else : image_info = {} session_update = SessionUpdateImageParse ( image_key = image_key , image_size = image . size , image_mode = image . mode , image_palette_key = image_palette_key , image_info = image_info , ) # Explicitly close the image to avoid crashes on Windows image . close () return session_update get ( session = None ) \u00b6 Execute the strategy. Source code in oteapi/strategies/parse/image.py 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdateImageParse : \"\"\"Execute the strategy.\"\"\" if not session : session = {} config = self . parse_config . configuration crop = config . crop if config . crop else session . get ( \"imagecrop\" ) mime_format = self . parse_config . mediaType . split ( \"/\" )[ 1 ] image_format = SupportedFormat [ mime_format ] . value # Proper download configurations conf = self . parse_config . dict () conf [ \"configuration\" ] = config . download_config or {} download_config = ResourceConfig ( ** conf ) downloader = create_strategy ( \"download\" , download_config ) session . update ( downloader . initialize ( session )) downloader = create_strategy ( \"download\" , download_config ) output = downloader . get ( session ) session . update ( output ) if config . datacache_config and config . datacache_config . accessKey : cache_key = config . datacache_config . accessKey elif \"key\" in output : cache_key = output [ \"key\" ] else : RuntimeError ( \"No data cache key provided to the downloaded content\" ) cache = DataCache ( config . datacache_config ) # Treat image according to filter values with cache . getfile ( cache_key , suffix = mime_format ) as filename : image = Image . open ( filename , formats = [ image_format ]) if crop : image = image . crop ( crop ) if config . image_mode : image = image . convert ( mode = config . image_mode ) if image_format == \"GIF\" : if image . info . get ( \"version\" , b \"\" ) . startswith ( b \"GIF\" ): image . info . update ( { \"version\" : image . info . get ( \"version\" , b \"\" )[ len ( b \"GIF\" ) :]} ) # Use the buffer protocol to store the image in the datacache data = np . asarray ( image ) image_key = cache . add ( data , key = config . image_key , tag = str ( id ( session )), ) if image . mode == \"P\" : image_palette_key = cache . add ( np . asarray ( image . getpalette ()), tag = str ( id ( session )) ) else : image_palette_key = None # The session must be json serialisable - filter out all # non-json serialisable fields in image.info if image . info : image_info = { key : val for key , val in image . info . items () if isinstance ( val , ( str , int , float , type ( None ), bool , tuple , list )) } else : image_info = {} session_update = SessionUpdateImageParse ( image_key = image_key , image_size = image . size , image_mode = image . mode , image_palette_key = image_palette_key , image_info = image_info , ) # Explicitly close the image to avoid crashes on Windows image . close () return session_update initialize ( session = None ) \u00b6 Initialize strategy. Source code in oteapi/strategies/parse/image.py 139 140 141 def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdate : \"\"\"Initialize strategy.\"\"\" return SessionUpdate () ImageParserConfig \u00b6 Bases: AttrDict Configuration data model for ImageDataParseStrategy . Source code in oteapi/strategies/parse/image.py 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 class ImageParserConfig ( AttrDict ): \"\"\"Configuration data model for [`ImageDataParseStrategy`][oteapi.strategies.parse.image.ImageDataParseStrategy].\"\"\" crop : Optional [ Tuple [ int , int , int , int ]] = Field ( None , description = \"Box cropping parameters (left, top, right, bottom).\" , ) datacache_config : Optional [ DataCacheConfig ] = Field ( None , description = \"Configuration options for the local data cache.\" , ) download_config : AttrDict = Field ( AttrDict (), description = \"Configurations passed to the downloader.\" , ) image_key : Optional [ str ] = Field ( None , description = \"Key to use when storing the image data in datacache.\" , ) image_mode : Optional [ str ] = Field ( None , description = ( \"Pillow mode to convert image into. See \" \"https://pillow.readthedocs.io/en/stable/handbook/concepts.html \" \"for details.\" ), ) ImageParserResourceConfig \u00b6 Bases: ResourceConfig Image parse strategy resource config. Source code in oteapi/strategies/parse/image.py 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 class ImageParserResourceConfig ( ResourceConfig ): \"\"\"Image parse strategy resource config.\"\"\" mediaType : Union [ Literal [ \"image/jpg\" ], Literal [ \"image/jpeg\" ], Literal [ \"image/jp2\" ], Literal [ \"image/png\" ], Literal [ \"image/gif\" ], Literal [ \"image/tiff\" ], Literal [ \"image/eps\" ], ] = Field ( ... , description = ResourceConfig . __fields__ [ \"mediaType\" ] . field_info . description , ) configuration : ImageParserConfig = Field ( ImageParserConfig (), description = \"Image parse strategy-specific configuration.\" , ) SessionUpdateImageParse \u00b6 Bases: SessionUpdate Configuration model for ImageParse. See Pillow handbook for more details on image_mode , image_palette , and image_info . Source code in oteapi/strategies/parse/image.py 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 class SessionUpdateImageParse ( SessionUpdate ): \"\"\"Configuration model for ImageParse. See [Pillow handbook](https://pillow.readthedocs.io/en/stable/handbook/concepts.html) for more details on `image_mode`, `image_palette`, and `image_info`. \"\"\" image_key : str = Field ( ... , description = \"Key with which the image content is stored in the data cache.\" , ) image_size : Tuple [ int , int ] = Field ( ... , description = \"Image size (width, height).\" , ) image_mode : str = Field ( ... , description = \"Image mode. Examples: 'L', 'P', 'RGB', 'RGBA'...\" , ) image_palette_key : Optional [ str ] = Field ( None , description = \"Datacache key for colour palette if mode is 'P'.\" , ) image_info : dict = Field ( {}, description = \"Additional information about the image.\" , ) SupportedFormat \u00b6 Bases: Enum Supported formats for ImageDataParseStrategy . Source code in oteapi/strategies/parse/image.py 70 71 72 73 74 75 76 77 78 79 class SupportedFormat ( Enum ): \"\"\"Supported formats for `ImageDataParseStrategy`.\"\"\" jpeg = \"JPEG\" jpg = \"JPEG\" jp2 = \"JPEG2000\" png = \"PNG\" gif = \"GIF\" tiff = \"TIFF\" eps = \"EPS\" text_csv \u00b6 Strategy class for text/csv. CSVParseStrategy \u00b6 Parse strategy for CSV files. Registers strategies : (\"mediaType\", \"text/csv\") Note: This strategy is currently not finished, and is therefore not registered. Source code in oteapi/strategies/parse/text_csv.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 @dataclass class CSVParseStrategy : \"\"\"Parse strategy for CSV files. **Registers strategies**: - `(\"mediaType\", \"text/csv\")` Note: This strategy is currently not finished, and is therefore not registered. \"\"\" parse_config : ResourceConfig def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdate : \"\"\"Parse CSV.\"\"\" return SessionUpdate () def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdate : \"\"\"Initialize.\"\"\" return SessionUpdate () get ( session = None ) \u00b6 Parse CSV. Source code in oteapi/strategies/parse/text_csv.py 27 28 29 def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdate : \"\"\"Parse CSV.\"\"\" return SessionUpdate () initialize ( session = None ) \u00b6 Initialize. Source code in oteapi/strategies/parse/text_csv.py 31 32 33 def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdate : \"\"\"Initialize.\"\"\" return SessionUpdate () transformation \u00b6 celery_remote \u00b6 Transformation Plugin that uses the Celery framework to call remote workers. CeleryConfig \u00b6 Bases: AttrDict Celery configuration. Source code in oteapi/strategies/transformation/celery_remote.py 25 26 27 28 29 class CeleryConfig ( AttrDict ): \"\"\"Celery configuration.\"\"\" task_name : str = Field ( ... , description = \"A task name.\" ) args : list = Field ( ... , description = \"List of arguments for the task.\" ) CeleryRemoteStrategy \u00b6 Submit job to remote Celery runner. Registers strategies : (\"transformationType\", \"celery/remote\") Source code in oteapi/strategies/transformation/celery_remote.py 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 @dataclass class CeleryRemoteStrategy : \"\"\"Submit job to remote Celery runner. **Registers strategies**: - `(\"transformationType\", \"celery/remote\")` \"\"\" transformation_config : CeleryStrategyConfig def run ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> TransformationStatus : \"\"\"Run a job, return a job ID.\"\"\" if session : self . _use_session ( session ) celery_kwargs = session . copy () for field in CeleryConfig . __fields__ : celery_kwargs . pop ( field , None ) result : \"Union[AsyncResult, Any]\" = CELERY . send_task ( name = self . transformation_config . configuration . task_name , args = self . transformation_config . configuration . args , kwargs = celery_kwargs , ) return self . status ( result . task_id ) def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdate : \"\"\"Initialize a job.\"\"\" return SessionUpdate () def status ( self , task_id : str ) -> TransformationStatus : \"\"\"Get job status.\"\"\" result = AsyncResult ( id = task_id , app = CELERY ) return TransformationStatus ( id = task_id , status = result . state ) def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdateCelery : \"\"\"Get transformation.\"\"\" # TODO: update and return global state # pylint: disable=fixme return SessionUpdateCelery ( data = {}) def _use_session ( self , session : \"Dict[str, Any]\" ) -> None : \"\"\"Update the configuration with values from the sesssion.\"\"\" for field in CeleryConfig . __fields__ : if field in session : setattr ( self . transformation_config . configuration , field , session [ field ], ) _use_session ( session ) \u00b6 Update the configuration with values from the sesssion. Source code in oteapi/strategies/transformation/celery_remote.py 97 98 99 100 101 102 103 104 105 def _use_session ( self , session : \"Dict[str, Any]\" ) -> None : \"\"\"Update the configuration with values from the sesssion.\"\"\" for field in CeleryConfig . __fields__ : if field in session : setattr ( self . transformation_config . configuration , field , session [ field ], ) get ( session = None ) \u00b6 Get transformation. Source code in oteapi/strategies/transformation/celery_remote.py 92 93 94 95 def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdateCelery : \"\"\"Get transformation.\"\"\" # TODO: update and return global state # pylint: disable=fixme return SessionUpdateCelery ( data = {}) initialize ( session = None ) \u00b6 Initialize a job. Source code in oteapi/strategies/transformation/celery_remote.py 83 84 85 def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdate : \"\"\"Initialize a job.\"\"\" return SessionUpdate () run ( session = None ) \u00b6 Run a job, return a job ID. Source code in oteapi/strategies/transformation/celery_remote.py 68 69 70 71 72 73 74 75 76 77 78 79 80 81 def run ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> TransformationStatus : \"\"\"Run a job, return a job ID.\"\"\" if session : self . _use_session ( session ) celery_kwargs = session . copy () for field in CeleryConfig . __fields__ : celery_kwargs . pop ( field , None ) result : \"Union[AsyncResult, Any]\" = CELERY . send_task ( name = self . transformation_config . configuration . task_name , args = self . transformation_config . configuration . args , kwargs = celery_kwargs , ) return self . status ( result . task_id ) status ( task_id ) \u00b6 Get job status. Source code in oteapi/strategies/transformation/celery_remote.py 87 88 89 90 def status ( self , task_id : str ) -> TransformationStatus : \"\"\"Get job status.\"\"\" result = AsyncResult ( id = task_id , app = CELERY ) return TransformationStatus ( id = task_id , status = result . state ) CeleryStrategyConfig \u00b6 Bases: TransformationConfig Celery strategy-specific configuration. Source code in oteapi/strategies/transformation/celery_remote.py 41 42 43 44 45 46 47 48 49 50 51 52 53 class CeleryStrategyConfig ( TransformationConfig ): \"\"\"Celery strategy-specific configuration.\"\"\" transformationType : str = Field ( \"celery/remote\" , const = True , description = TransformationConfig . __fields__ [ \"transformationType\" ] . field_info . description , ) configuration : CeleryConfig = Field ( ... , description = \"Celery transformation strategy-specific configuration.\" ) SessionUpdateCelery \u00b6 Bases: SessionUpdate Class for returning values from XLSXParse. Source code in oteapi/strategies/transformation/celery_remote.py 32 33 34 35 36 37 38 class SessionUpdateCelery ( SessionUpdate ): \"\"\"Class for returning values from XLSXParse.\"\"\" data : Dict [ str , list ] = Field ( ... , description = \"A dict with column-name/column-value pairs. The values are lists.\" , )","title":"OTE-API Core Strategies"},{"location":"all_strategies/#ote-api-core-strategies","text":"This page provides documentation for the oteapi.strategies submodule, where all the core OTE-API strategies are located. These strategies will always be available when setting up a server based on the OTE-API Core package.","title":"OTE-API Core Strategies"},{"location":"all_strategies/#oteapi.strategies.download","text":"","title":"download"},{"location":"all_strategies/#oteapi.strategies.download.file","text":"Download strategy class for the file scheme.","title":"file"},{"location":"all_strategies/#oteapi.strategies.download.file.FileConfig","text":"Bases: AttrDict File-specific Configuration Data Model. Source code in oteapi/strategies/download/file.py 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 class FileConfig ( AttrDict ): \"\"\"File-specific Configuration Data Model.\"\"\" text : bool = Field ( False , description = ( \"Whether the file should be opened in text mode. If `False`, the file will\" \" be opened in bytes mode.\" ), ) encoding : Optional [ str ] = Field ( None , description = ( \"Encoding used when opening the file. The default is platform dependent.\" ), ) datacache_config : Optional [ DataCacheConfig ] = Field ( None , description = \"Configurations for the data cache for storing the downloaded file content.\" , )","title":"FileConfig"},{"location":"all_strategies/#oteapi.strategies.download.file.FileResourceConfig","text":"Bases: ResourceConfig File download strategy filter config. Source code in oteapi/strategies/download/file.py 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 class FileResourceConfig ( ResourceConfig ): \"\"\"File download strategy filter config.\"\"\" downloadUrl : FileUrl = Field ( # type: ignore[assignment] ... , description = \"The file URL, which will be downloaded.\" ) configuration : FileConfig = Field ( FileConfig (), description = \"File download strategy-specific configuration.\" ) @validator ( \"downloadUrl\" ) def ensure_path_exists ( cls , value : FileUrl ) -> FileUrl : \"\"\"Ensure `path` is defined in `downloadUrl`.\"\"\" if not value . path : raise ValueError ( \"downloadUrl must contain a `path` part.\" ) return value","title":"FileResourceConfig"},{"location":"all_strategies/#oteapi.strategies.download.file.FileResourceConfig.ensure_path_exists","text":"Ensure path is defined in downloadUrl . Source code in oteapi/strategies/download/file.py 48 49 50 51 52 53 @validator ( \"downloadUrl\" ) def ensure_path_exists ( cls , value : FileUrl ) -> FileUrl : \"\"\"Ensure `path` is defined in `downloadUrl`.\"\"\" if not value . path : raise ValueError ( \"downloadUrl must contain a `path` part.\" ) return value","title":"ensure_path_exists()"},{"location":"all_strategies/#oteapi.strategies.download.file.FileStrategy","text":"Strategy for retrieving data from a local file. Registers strategies : (\"scheme\", \"file\") Source code in oteapi/strategies/download/file.py 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 @dataclass class FileStrategy : \"\"\"Strategy for retrieving data from a local file. **Registers strategies**: - `(\"scheme\", \"file\")` \"\"\" download_config : FileResourceConfig def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdate : \"\"\"Initialize.\"\"\" return SessionUpdate () def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdateFile : \"\"\"Read local file.\"\"\" filename = uri_to_path ( self . download_config . downloadUrl ) . resolve () if not filename . exists (): raise FileNotFoundError ( f \"File not found at { filename } \" ) cache = DataCache ( self . download_config . configuration . datacache_config ) if cache . config . accessKey and cache . config . accessKey in cache : key = cache . config . accessKey else : key = cache . add ( filename . read_text ( encoding = self . download_config . configuration . encoding ) if self . download_config . configuration . text else filename . read_bytes () ) return SessionUpdateFile ( key = key )","title":"FileStrategy"},{"location":"all_strategies/#oteapi.strategies.download.file.FileStrategy.get","text":"Read local file. Source code in oteapi/strategies/download/file.py 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdateFile : \"\"\"Read local file.\"\"\" filename = uri_to_path ( self . download_config . downloadUrl ) . resolve () if not filename . exists (): raise FileNotFoundError ( f \"File not found at { filename } \" ) cache = DataCache ( self . download_config . configuration . datacache_config ) if cache . config . accessKey and cache . config . accessKey in cache : key = cache . config . accessKey else : key = cache . add ( filename . read_text ( encoding = self . download_config . configuration . encoding ) if self . download_config . configuration . text else filename . read_bytes () ) return SessionUpdateFile ( key = key )","title":"get()"},{"location":"all_strategies/#oteapi.strategies.download.file.FileStrategy.initialize","text":"Initialize. Source code in oteapi/strategies/download/file.py 74 75 76 def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdate : \"\"\"Initialize.\"\"\" return SessionUpdate ()","title":"initialize()"},{"location":"all_strategies/#oteapi.strategies.download.file.SessionUpdateFile","text":"Bases: SessionUpdate Class for returning values from Download File strategy. Source code in oteapi/strategies/download/file.py 56 57 58 59 class SessionUpdateFile ( SessionUpdate ): \"\"\"Class for returning values from Download File strategy.\"\"\" key : str = Field ( ... , description = \"Key to access the data in the cache.\" )","title":"SessionUpdateFile"},{"location":"all_strategies/#oteapi.strategies.download.https","text":"Download strategy class for http/https","title":"https"},{"location":"all_strategies/#oteapi.strategies.download.https.HTTPSConfig","text":"Bases: AttrDict HTTP(S)-specific Configuration Data Model. Source code in oteapi/strategies/download/https.py 16 17 18 19 20 21 22 class HTTPSConfig ( AttrDict ): \"\"\"HTTP(S)-specific Configuration Data Model.\"\"\" datacache_config : Optional [ DataCacheConfig ] = Field ( None , description = \"Configurations for the data cache for storing the downloaded file content.\" , )","title":"HTTPSConfig"},{"location":"all_strategies/#oteapi.strategies.download.https.HTTPSResourceConfig","text":"Bases: ResourceConfig HTTP(S) download strategy filter config. Source code in oteapi/strategies/download/https.py 25 26 27 28 29 30 31 32 33 class HTTPSResourceConfig ( ResourceConfig ): \"\"\"HTTP(S) download strategy filter config.\"\"\" downloadUrl : AnyHttpUrl = Field ( # type: ignore[assignment] ... , description = \"The HTTP(S) URL, which will be downloaded.\" ) configuration : HTTPSConfig = Field ( HTTPSConfig (), description = \"HTTP(S) download strategy-specific configuration.\" )","title":"HTTPSResourceConfig"},{"location":"all_strategies/#oteapi.strategies.download.https.HTTPSStrategy","text":"Strategy for retrieving data via http. Registers strategies : (\"scheme\", \"http\") (\"scheme\", \"https\") Source code in oteapi/strategies/download/https.py 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 @dataclass class HTTPSStrategy : \"\"\"Strategy for retrieving data via http. **Registers strategies**: - `(\"scheme\", \"http\")` - `(\"scheme\", \"https\")` \"\"\" download_config : HTTPSResourceConfig def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdate : \"\"\"Initialize.\"\"\" return SessionUpdate () def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdateHTTPS : \"\"\"Download via http/https and store on local cache.\"\"\" cache = DataCache ( self . download_config . configuration . datacache_config ) if cache . config . accessKey and cache . config . accessKey in cache : key = cache . config . accessKey else : req = requests . get ( self . download_config . downloadUrl , allow_redirects = True ) key = cache . add ( req . content ) return SessionUpdateHTTPS ( key = key )","title":"HTTPSStrategy"},{"location":"all_strategies/#oteapi.strategies.download.https.HTTPSStrategy.get","text":"Download via http/https and store on local cache. Source code in oteapi/strategies/download/https.py 59 60 61 62 63 64 65 66 67 68 def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdateHTTPS : \"\"\"Download via http/https and store on local cache.\"\"\" cache = DataCache ( self . download_config . configuration . datacache_config ) if cache . config . accessKey and cache . config . accessKey in cache : key = cache . config . accessKey else : req = requests . get ( self . download_config . downloadUrl , allow_redirects = True ) key = cache . add ( req . content ) return SessionUpdateHTTPS ( key = key )","title":"get()"},{"location":"all_strategies/#oteapi.strategies.download.https.HTTPSStrategy.initialize","text":"Initialize. Source code in oteapi/strategies/download/https.py 55 56 57 def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdate : \"\"\"Initialize.\"\"\" return SessionUpdate ()","title":"initialize()"},{"location":"all_strategies/#oteapi.strategies.download.https.SessionUpdateHTTPS","text":"Bases: SessionUpdate Class for returning values from Download HTTPS strategy. Source code in oteapi/strategies/download/https.py 36 37 38 39 class SessionUpdateHTTPS ( SessionUpdate ): \"\"\"Class for returning values from Download HTTPS strategy.\"\"\" key : str = Field ( ... , description = \"Key to access the data in the cache.\" )","title":"SessionUpdateHTTPS"},{"location":"all_strategies/#oteapi.strategies.download.sftp","text":"Strategy class for sftp/ftp","title":"sftp"},{"location":"all_strategies/#oteapi.strategies.download.sftp.AnyFtpUrl","text":"Bases: AnyUrl A (S)FTP URL model. Source code in oteapi/strategies/download/sftp.py 18 19 20 21 class AnyFtpUrl ( AnyUrl ): \"\"\"A (S)FTP URL model.\"\"\" allowed_schemes = { \"ftp\" , \"sftp\" }","title":"AnyFtpUrl"},{"location":"all_strategies/#oteapi.strategies.download.sftp.SFTPConfig","text":"Bases: AttrDict (S)FTP-specific Configuration Data Model. Source code in oteapi/strategies/download/sftp.py 24 25 26 27 28 29 30 class SFTPConfig ( AttrDict ): \"\"\"(S)FTP-specific Configuration Data Model.\"\"\" datacache_config : Optional [ DataCacheConfig ] = Field ( None , description = \"Configurations for the data cache for storing the downloaded file content.\" , )","title":"SFTPConfig"},{"location":"all_strategies/#oteapi.strategies.download.sftp.SFTPResourceConfig","text":"Bases: ResourceConfig (S)FTP download strategy filter config. Source code in oteapi/strategies/download/sftp.py 33 34 35 36 37 38 39 40 41 class SFTPResourceConfig ( ResourceConfig ): \"\"\"(S)FTP download strategy filter config.\"\"\" downloadUrl : AnyFtpUrl = Field ( # type: ignore[assignment] ... , description = \"The (S)FTP URL, which will be downloaded.\" ) configuration : SFTPConfig = Field ( SFTPConfig (), description = \"(S)FTP download strategy-specific configuration.\" )","title":"SFTPResourceConfig"},{"location":"all_strategies/#oteapi.strategies.download.sftp.SFTPStrategy","text":"Strategy for retrieving data via sftp. Registers strategies : (\"scheme\", \"ftp\") (\"scheme\", \"sftp\") Source code in oteapi/strategies/download/sftp.py 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 @dataclass class SFTPStrategy : \"\"\"Strategy for retrieving data via sftp. **Registers strategies**: - `(\"scheme\", \"ftp\")` - `(\"scheme\", \"sftp\")` \"\"\" download_config : SFTPResourceConfig def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdate : \"\"\"Initialize.\"\"\" return SessionUpdate () def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdateSFTP : \"\"\"Download via sftp\"\"\" cache = DataCache ( self . download_config . configuration . datacache_config ) if cache . config . accessKey and cache . config . accessKey in cache : key = cache . config . accessKey else : # Setup connection options cnopts = pysftp . CnOpts () cnopts . hostkeys = None # open connection and store data locally with pysftp . Connection ( host = self . download_config . downloadUrl . host , username = self . download_config . downloadUrl . user , password = self . download_config . downloadUrl . password , port = self . download_config . downloadUrl . port , cnopts = cnopts , ) as sftp : # Because of insane locking on Windows, we have to close # the downloaded file before adding it to the cache with NamedTemporaryFile ( prefix = \"oteapi-sftp-\" , delete = False ) as handle : localpath = Path ( handle . name ) . resolve () try : sftp . get ( self . download_config . downloadUrl . path , localpath = localpath ) key = cache . add ( localpath . read_bytes ()) finally : localpath . unlink () return SessionUpdateSFTP ( key = key )","title":"SFTPStrategy"},{"location":"all_strategies/#oteapi.strategies.download.sftp.SFTPStrategy.get","text":"Download via sftp Source code in oteapi/strategies/download/sftp.py 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdateSFTP : \"\"\"Download via sftp\"\"\" cache = DataCache ( self . download_config . configuration . datacache_config ) if cache . config . accessKey and cache . config . accessKey in cache : key = cache . config . accessKey else : # Setup connection options cnopts = pysftp . CnOpts () cnopts . hostkeys = None # open connection and store data locally with pysftp . Connection ( host = self . download_config . downloadUrl . host , username = self . download_config . downloadUrl . user , password = self . download_config . downloadUrl . password , port = self . download_config . downloadUrl . port , cnopts = cnopts , ) as sftp : # Because of insane locking on Windows, we have to close # the downloaded file before adding it to the cache with NamedTemporaryFile ( prefix = \"oteapi-sftp-\" , delete = False ) as handle : localpath = Path ( handle . name ) . resolve () try : sftp . get ( self . download_config . downloadUrl . path , localpath = localpath ) key = cache . add ( localpath . read_bytes ()) finally : localpath . unlink () return SessionUpdateSFTP ( key = key )","title":"get()"},{"location":"all_strategies/#oteapi.strategies.download.sftp.SFTPStrategy.initialize","text":"Initialize. Source code in oteapi/strategies/download/sftp.py 63 64 65 def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdate : \"\"\"Initialize.\"\"\" return SessionUpdate ()","title":"initialize()"},{"location":"all_strategies/#oteapi.strategies.download.sftp.SessionUpdateSFTP","text":"Bases: SessionUpdate Class for returning values from Download SFTP strategy. Source code in oteapi/strategies/download/sftp.py 44 45 46 47 class SessionUpdateSFTP ( SessionUpdate ): \"\"\"Class for returning values from Download SFTP strategy.\"\"\" key : str = Field ( ... , description = \"Key to access the data in the cache.\" )","title":"SessionUpdateSFTP"},{"location":"all_strategies/#oteapi.strategies.filter","text":"","title":"filter"},{"location":"all_strategies/#oteapi.strategies.filter.crop_filter","text":"Demo-filter strategy","title":"crop_filter"},{"location":"all_strategies/#oteapi.strategies.filter.crop_filter.CropImageConfig","text":"Bases: AttrDict Configuration model for crop data. Source code in oteapi/strategies/filter/crop_filter.py 14 15 16 17 18 19 class CropImageConfig ( AttrDict ): \"\"\"Configuration model for crop data.\"\"\" crop : Tuple [ int , int , int , int ] = Field ( ... , description = \"Box cropping parameters (left, top, right, bottom).\" )","title":"CropImageConfig"},{"location":"all_strategies/#oteapi.strategies.filter.crop_filter.CropImageFilter","text":"Strategy for cropping an image. Registers strategies : (\"filterType\", \"filter/crop\") Source code in oteapi/strategies/filter/crop_filter.py 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 @dataclass class CropImageFilter : \"\"\"Strategy for cropping an image. **Registers strategies**: - `(\"filterType\", \"filter/crop\")` \"\"\" filter_config : CropImageFilterConfig def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None , ) -> SessionUpdateCropFilter : \"\"\"Initialize strategy and return a dictionary.\"\"\" return SessionUpdateCropFilter ( imagecrop = self . filter_config . configuration . crop , ) def get ( self , session : \"Optional[Dict[str, Any]]\" = None , ) -> SessionUpdate : \"\"\"Execute strategy and return a dictionary\"\"\" return SessionUpdate ()","title":"CropImageFilter"},{"location":"all_strategies/#oteapi.strategies.filter.crop_filter.CropImageFilter.get","text":"Execute strategy and return a dictionary Source code in oteapi/strategies/filter/crop_filter.py 64 65 66 67 68 69 def get ( self , session : \"Optional[Dict[str, Any]]\" = None , ) -> SessionUpdate : \"\"\"Execute strategy and return a dictionary\"\"\" return SessionUpdate ()","title":"get()"},{"location":"all_strategies/#oteapi.strategies.filter.crop_filter.CropImageFilter.initialize","text":"Initialize strategy and return a dictionary. Source code in oteapi/strategies/filter/crop_filter.py 55 56 57 58 59 60 61 62 def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None , ) -> SessionUpdateCropFilter : \"\"\"Initialize strategy and return a dictionary.\"\"\" return SessionUpdateCropFilter ( imagecrop = self . filter_config . configuration . crop , )","title":"initialize()"},{"location":"all_strategies/#oteapi.strategies.filter.crop_filter.CropImageFilterConfig","text":"Bases: FilterConfig Crop filter strategy filter config. Source code in oteapi/strategies/filter/crop_filter.py 22 23 24 25 26 27 28 29 30 31 32 class CropImageFilterConfig ( FilterConfig ): \"\"\"Crop filter strategy filter config.\"\"\" filterType : str = Field ( \"filter/crop\" , const = True , description = FilterConfig . __fields__ [ \"filterType\" ] . field_info . description , ) configuration : CropImageConfig = Field ( ... , description = \"Image crop filter strategy-specific configuration.\" )","title":"CropImageFilterConfig"},{"location":"all_strategies/#oteapi.strategies.filter.crop_filter.SessionUpdateCropFilter","text":"Bases: SessionUpdate Return model for CropImageFilter . Source code in oteapi/strategies/filter/crop_filter.py 35 36 37 38 39 40 class SessionUpdateCropFilter ( SessionUpdate ): \"\"\"Return model for `CropImageFilter`.\"\"\" imagecrop : Tuple [ int , int , int , int ] = Field ( ... , description = \"Box cropping parameters (left, top, right, bottom).\" )","title":"SessionUpdateCropFilter"},{"location":"all_strategies/#oteapi.strategies.filter.sql_query_filter","text":"SQL query filter strategy.","title":"sql_query_filter"},{"location":"all_strategies/#oteapi.strategies.filter.sql_query_filter.SQLQueryFilter","text":"Strategy for a SQL query filter. Registers strategies : (\"filterType\", \"filter/sql\") Source code in oteapi/strategies/filter/sql_query_filter.py 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 @dataclass class SQLQueryFilter : \"\"\"Strategy for a SQL query filter. **Registers strategies**: - `(\"filterType\", \"filter/sql\")` \"\"\" filter_config : SqlQueryFilterConfig def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None , ) -> SessionUpdateSqlQuery : \"\"\"Initialize strategy.\"\"\" return SessionUpdateSqlQuery ( sqlquery = self . filter_config . query ) def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdate : \"\"\"Execute strategy and return a dictionary.\"\"\" return SessionUpdate ()","title":"SQLQueryFilter"},{"location":"all_strategies/#oteapi.strategies.filter.sql_query_filter.SQLQueryFilter.get","text":"Execute strategy and return a dictionary. Source code in oteapi/strategies/filter/sql_query_filter.py 50 51 52 def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdate : \"\"\"Execute strategy and return a dictionary.\"\"\" return SessionUpdate ()","title":"get()"},{"location":"all_strategies/#oteapi.strategies.filter.sql_query_filter.SQLQueryFilter.initialize","text":"Initialize strategy. Source code in oteapi/strategies/filter/sql_query_filter.py 43 44 45 46 47 48 def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None , ) -> SessionUpdateSqlQuery : \"\"\"Initialize strategy.\"\"\" return SessionUpdateSqlQuery ( sqlquery = self . filter_config . query )","title":"initialize()"},{"location":"all_strategies/#oteapi.strategies.filter.sql_query_filter.SessionUpdateSqlQuery","text":"Bases: SessionUpdate Class for returning values from SQL Query data model. Source code in oteapi/strategies/filter/sql_query_filter.py 25 26 27 28 class SessionUpdateSqlQuery ( SessionUpdate ): \"\"\"Class for returning values from SQL Query data model.\"\"\" sqlquery : str = Field ( ... , description = \"A SQL query string.\" )","title":"SessionUpdateSqlQuery"},{"location":"all_strategies/#oteapi.strategies.filter.sql_query_filter.SqlQueryFilterConfig","text":"Bases: FilterConfig SQLite query filter strategy filter config. Source code in oteapi/strategies/filter/sql_query_filter.py 14 15 16 17 18 19 20 21 22 class SqlQueryFilterConfig ( FilterConfig ): \"\"\"SQLite query filter strategy filter config.\"\"\" filterType : str = Field ( \"filter/sql\" , const = True , description = FilterConfig . __fields__ [ \"filterType\" ] . field_info . description , ) query : str = Field ( ... , description = \"A SQL query string.\" )","title":"SqlQueryFilterConfig"},{"location":"all_strategies/#oteapi.strategies.mapping","text":"","title":"mapping"},{"location":"all_strategies/#oteapi.strategies.mapping.mapping","text":"Mapping filter strategy.","title":"mapping"},{"location":"all_strategies/#oteapi.strategies.mapping.mapping.MappingSessionUpdate","text":"Bases: SessionUpdate SessionUpdate model for mappings. Source code in oteapi/strategies/mapping/mapping.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class MappingSessionUpdate ( SessionUpdate ): \"\"\"SessionUpdate model for mappings.\"\"\" prefixes : Dict [ str , str ] = Field ( ... , description = ( \"List of shortnames that expands to an IRI \" \"given as local value/IRI-expansion-pairs.\" ), ) triples : List [ RDFTriple ] = Field ( ... , description = \"List of semantic triples given as (subject, predicate, object).\" , )","title":"MappingSessionUpdate"},{"location":"all_strategies/#oteapi.strategies.mapping.mapping.MappingStrategy","text":"Strategy for a mapping. The mapping strategy simply adds more prefixes and triples to the prefixes and triples fields in the session such that they are available for other strategies, like function strategies that convert between data models. Nothing is returned to avoid deleting existing mappings. Registers strategies : (\"mappingType\", \"triples\") Source code in oteapi/strategies/mapping/mapping.py 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 @dataclass class MappingStrategy : \"\"\"Strategy for a mapping. The mapping strategy simply adds more prefixes and triples to the `prefixes` and `triples` fields in the session such that they are available for other strategies, like function strategies that convert between data models. Nothing is returned to avoid deleting existing mappings. **Registers strategies**: - `(\"mappingType\", \"triples\")` \"\"\" mapping_config : MappingConfig def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> MappingSessionUpdate : \"\"\"Initialize strategy.\"\"\" prefixes = session . get ( \"prefixes\" , {}) if session else {} triples = session . get ( \"triples\" , []) if session else [] if self . mapping_config . prefixes : prefixes . update ( self . mapping_config . prefixes ) if self . mapping_config . triples : triples . extend ( self . mapping_config . triples ) return MappingSessionUpdate ( prefixes = prefixes , triples = triples ) def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdate : \"\"\"Execute strategy and return a dictionary.\"\"\" return SessionUpdate ()","title":"MappingStrategy"},{"location":"all_strategies/#oteapi.strategies.mapping.mapping.MappingStrategy.get","text":"Execute strategy and return a dictionary. Source code in oteapi/strategies/mapping/mapping.py 62 63 64 def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdate : \"\"\"Execute strategy and return a dictionary.\"\"\" return SessionUpdate ()","title":"get()"},{"location":"all_strategies/#oteapi.strategies.mapping.mapping.MappingStrategy.initialize","text":"Initialize strategy. Source code in oteapi/strategies/mapping/mapping.py 48 49 50 51 52 53 54 55 56 57 58 59 60 def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> MappingSessionUpdate : \"\"\"Initialize strategy.\"\"\" prefixes = session . get ( \"prefixes\" , {}) if session else {} triples = session . get ( \"triples\" , []) if session else [] if self . mapping_config . prefixes : prefixes . update ( self . mapping_config . prefixes ) if self . mapping_config . triples : triples . extend ( self . mapping_config . triples ) return MappingSessionUpdate ( prefixes = prefixes , triples = triples )","title":"initialize()"},{"location":"all_strategies/#oteapi.strategies.parse","text":"","title":"parse"},{"location":"all_strategies/#oteapi.strategies.parse.application_json","text":"Strategy class for application/json.","title":"application_json"},{"location":"all_strategies/#oteapi.strategies.parse.application_json.JSONConfig","text":"Bases: AttrDict JSON parse-specific Configuration Data Model. Source code in oteapi/strategies/parse/application_json.py 17 18 19 20 21 22 23 class JSONConfig ( AttrDict ): \"\"\"JSON parse-specific Configuration Data Model.\"\"\" datacache_config : Optional [ DataCacheConfig ] = Field ( None , description = \"Configurations for the data cache for storing the downloaded file content.\" , )","title":"JSONConfig"},{"location":"all_strategies/#oteapi.strategies.parse.application_json.JSONDataParseStrategy","text":"Parse strategy for JSON. Registers strategies : (\"mediaType\", \"application/json\") Source code in oteapi/strategies/parse/application_json.py 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 @dataclass class JSONDataParseStrategy : \"\"\"Parse strategy for JSON. **Registers strategies**: - `(\"mediaType\", \"application/json\")` \"\"\" parse_config : JSONResourceConfig def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdate : \"\"\"Initialize.\"\"\" return SessionUpdate () def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdateJSONParse : \"\"\"Parse json.\"\"\" downloader = create_strategy ( \"download\" , self . parse_config ) output = downloader . get () cache = DataCache ( self . parse_config . configuration . datacache_config ) content = cache . get ( output [ \"key\" ]) if isinstance ( content , dict ): return SessionUpdateJSONParse ( content = content ) return SessionUpdateJSONParse ( content = json . loads ( content ))","title":"JSONDataParseStrategy"},{"location":"all_strategies/#oteapi.strategies.parse.application_json.JSONDataParseStrategy.get","text":"Parse json. Source code in oteapi/strategies/parse/application_json.py 61 62 63 64 65 66 67 68 69 70 def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdateJSONParse : \"\"\"Parse json.\"\"\" downloader = create_strategy ( \"download\" , self . parse_config ) output = downloader . get () cache = DataCache ( self . parse_config . configuration . datacache_config ) content = cache . get ( output [ \"key\" ]) if isinstance ( content , dict ): return SessionUpdateJSONParse ( content = content ) return SessionUpdateJSONParse ( content = json . loads ( content ))","title":"get()"},{"location":"all_strategies/#oteapi.strategies.parse.application_json.JSONDataParseStrategy.initialize","text":"Initialize. Source code in oteapi/strategies/parse/application_json.py 57 58 59 def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdate : \"\"\"Initialize.\"\"\" return SessionUpdate ()","title":"initialize()"},{"location":"all_strategies/#oteapi.strategies.parse.application_json.JSONResourceConfig","text":"Bases: ResourceConfig JSON parse strategy filter config. Source code in oteapi/strategies/parse/application_json.py 26 27 28 29 30 31 32 33 34 35 36 class JSONResourceConfig ( ResourceConfig ): \"\"\"JSON parse strategy filter config.\"\"\" mediaType : str = Field ( \"application/json\" , const = True , description = ResourceConfig . __fields__ [ \"mediaType\" ] . field_info . description , ) configuration : JSONConfig = Field ( JSONConfig (), description = \"JSON parse strategy-specific configuration.\" )","title":"JSONResourceConfig"},{"location":"all_strategies/#oteapi.strategies.parse.application_json.SessionUpdateJSONParse","text":"Bases: SessionUpdate Class for returning values from JSON Parse. Source code in oteapi/strategies/parse/application_json.py 39 40 41 42 class SessionUpdateJSONParse ( SessionUpdate ): \"\"\"Class for returning values from JSON Parse.\"\"\" content : dict = Field ( ... , description = \"Content of the JSON document.\" )","title":"SessionUpdateJSONParse"},{"location":"all_strategies/#oteapi.strategies.parse.application_vnd_sqlite","text":"Strategy class for application/vnd.sqlite3.","title":"application_vnd_sqlite"},{"location":"all_strategies/#oteapi.strategies.parse.application_vnd_sqlite.SessionUpdateSqLiteParse","text":"Bases: SessionUpdate Configuration model for SqLiteParse. Source code in oteapi/strategies/parse/application_vnd_sqlite.py 61 62 63 64 class SessionUpdateSqLiteParse ( SessionUpdate ): \"\"\"Configuration model for SqLiteParse.\"\"\" result : list = Field ( ... , description = \"List of results from the query.\" )","title":"SessionUpdateSqLiteParse"},{"location":"all_strategies/#oteapi.strategies.parse.application_vnd_sqlite.SqliteParseConfig","text":"Bases: AttrDict Configuration data model for SqliteParseStrategy . Source code in oteapi/strategies/parse/application_vnd_sqlite.py 18 19 20 21 22 23 24 25 26 class SqliteParseConfig ( AttrDict ): \"\"\"Configuration data model for [`SqliteParseStrategy`][oteapi.strategies.parse.application_vnd_sqlite.SqliteParseStrategy].\"\"\" sqlquery : str = Field ( \"\" , description = \"A SQL query string.\" ) datacache_config : Optional [ DataCacheConfig ] = Field ( None , description = \"Configuration options for the local data cache.\" , )","title":"SqliteParseConfig"},{"location":"all_strategies/#oteapi.strategies.parse.application_vnd_sqlite.SqliteParseStrategy","text":"Parse strategy for SQLite. Registers strategies : (\"mediaType\", \"application/vnd.sqlite3\") Purpose of this strategy: Download a SQLite database using downloadUrl and run a SQL query on the database to return all relevant rows. Source code in oteapi/strategies/parse/application_vnd_sqlite.py 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 @dataclass class SqliteParseStrategy : \"\"\"Parse strategy for SQLite. **Registers strategies**: - `(\"mediaType\", \"application/vnd.sqlite3\")` Purpose of this strategy: Download a SQLite database using `downloadUrl` and run a SQL query on the database to return all relevant rows. \"\"\" parse_config : SqliteParserResourceConfig def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdate : \"\"\"Initialize strategy.\"\"\" return SessionUpdate () def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdateSqLiteParse : \"\"\"Parse SQLite query responses.\"\"\" if session : self . _use_filters ( session ) session = session if session else {} # Retrieve SQLite file download_config = self . parse_config . copy () del download_config . configuration downloader = create_strategy ( \"download\" , download_config ) session . update ( downloader . initialize ( session )) cache_key = downloader . get ( session ) . get ( \"key\" , \"\" ) cache = DataCache ( self . parse_config . configuration . datacache_config ) with cache . getfile ( cache_key , suffix = \"db\" ) as filename : connection = create_connection ( filename ) cursor = connection . cursor () result = cursor . execute ( self . parse_config . configuration . sqlquery ) . fetchall () connection . close () return SessionUpdateSqLiteParse ( result = result ) def _use_filters ( self , session : \"Dict[str, Any]\" ) -> None : \"\"\"Update `config` according to filter values found in the session.\"\"\" if \"sqlquery\" in session and not self . parse_config . configuration . sqlquery : # Use SQL query available in session self . parse_config . configuration . sqlquery = session [ \"sqlquery\" ]","title":"SqliteParseStrategy"},{"location":"all_strategies/#oteapi.strategies.parse.application_vnd_sqlite.SqliteParseStrategy._use_filters","text":"Update config according to filter values found in the session. Source code in oteapi/strategies/parse/application_vnd_sqlite.py 109 110 111 112 113 def _use_filters ( self , session : \"Dict[str, Any]\" ) -> None : \"\"\"Update `config` according to filter values found in the session.\"\"\" if \"sqlquery\" in session and not self . parse_config . configuration . sqlquery : # Use SQL query available in session self . parse_config . configuration . sqlquery = session [ \"sqlquery\" ]","title":"_use_filters()"},{"location":"all_strategies/#oteapi.strategies.parse.application_vnd_sqlite.SqliteParseStrategy.get","text":"Parse SQLite query responses. Source code in oteapi/strategies/parse/application_vnd_sqlite.py 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdateSqLiteParse : \"\"\"Parse SQLite query responses.\"\"\" if session : self . _use_filters ( session ) session = session if session else {} # Retrieve SQLite file download_config = self . parse_config . copy () del download_config . configuration downloader = create_strategy ( \"download\" , download_config ) session . update ( downloader . initialize ( session )) cache_key = downloader . get ( session ) . get ( \"key\" , \"\" ) cache = DataCache ( self . parse_config . configuration . datacache_config ) with cache . getfile ( cache_key , suffix = \"db\" ) as filename : connection = create_connection ( filename ) cursor = connection . cursor () result = cursor . execute ( self . parse_config . configuration . sqlquery ) . fetchall () connection . close () return SessionUpdateSqLiteParse ( result = result )","title":"get()"},{"location":"all_strategies/#oteapi.strategies.parse.application_vnd_sqlite.SqliteParseStrategy.initialize","text":"Initialize strategy. Source code in oteapi/strategies/parse/application_vnd_sqlite.py 82 83 84 def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdate : \"\"\"Initialize strategy.\"\"\" return SessionUpdate ()","title":"initialize()"},{"location":"all_strategies/#oteapi.strategies.parse.application_vnd_sqlite.SqliteParserResourceConfig","text":"Bases: ResourceConfig SQLite parse strategy resource config. Source code in oteapi/strategies/parse/application_vnd_sqlite.py 29 30 31 32 33 34 35 36 37 38 39 class SqliteParserResourceConfig ( ResourceConfig ): \"\"\"SQLite parse strategy resource config.\"\"\" mediaType : str = Field ( \"application/vnd.sqlite3\" , const = True , description = ResourceConfig . __fields__ [ \"mediaType\" ] . field_info . description , ) configuration : SqliteParseConfig = Field ( SqliteParseConfig (), description = \"SQLite parse strategy-specific configuration.\" )","title":"SqliteParserResourceConfig"},{"location":"all_strategies/#oteapi.strategies.parse.application_vnd_sqlite.create_connection","text":"Create a database connection to SQLite database. Parameters: Name Type Description Default db_file Path Full path to SQLite database file. required Raises: Type Description sqlite3 . Error If a DB connection cannot be made. Returns: Type Description sqlite3 . Connection Connection object. Source code in oteapi/strategies/parse/application_vnd_sqlite.py 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 def create_connection ( db_file : Path ) -> sqlite3 . Connection : \"\"\"Create a database connection to SQLite database. Parameters: db_file: Full path to SQLite database file. Raises: sqlite3.Error: If a DB connection cannot be made. Returns: Connection object. \"\"\" try : return sqlite3 . connect ( db_file ) except sqlite3 . Error as exc : raise sqlite3 . Error ( \"Could not connect to given SQLite DB.\" ) from exc","title":"create_connection()"},{"location":"all_strategies/#oteapi.strategies.parse.excel_xlsx","text":"Strategy class for workbook/xlsx.","title":"excel_xlsx"},{"location":"all_strategies/#oteapi.strategies.parse.excel_xlsx.SessionUpdateXLSXParse","text":"Bases: SessionUpdate Class for returning values from XLSXParse. Source code in oteapi/strategies/parse/excel_xlsx.py 19 20 21 22 23 24 25 class SessionUpdateXLSXParse ( SessionUpdate ): \"\"\"Class for returning values from XLSXParse.\"\"\" data : Dict [ str , list ] = Field ( ... , description = \"A dict with column-name/column-value pairs. The values are lists.\" , )","title":"SessionUpdateXLSXParse"},{"location":"all_strategies/#oteapi.strategies.parse.excel_xlsx.XLSXParseConfig","text":"Bases: AttrDict Data model for retrieving a rectangular section of an Excel sheet. Source code in oteapi/strategies/parse/excel_xlsx.py 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 class XLSXParseConfig ( AttrDict ): \"\"\"Data model for retrieving a rectangular section of an Excel sheet.\"\"\" worksheet : str = Field ( ... , description = \"Name of worksheet to load.\" ) row_from : Optional [ int ] = Field ( None , description = \"Excel row number of first row. Defaults to first assigned row.\" , ) col_from : Optional [ Union [ int , str ]] = Field ( None , description = ( \"Excel column number or label of first column. Defaults to first assigned \" \"column.\" ), ) row_to : Optional [ int ] = Field ( None , description = \"Excel row number of last row. Defaults to last assigned row.\" ) col_to : Optional [ Union [ int , str ]] = Field ( None , description = ( \"Excel column number or label of last column. Defaults to last assigned \" \"column.\" ), ) header_row : Optional [ int ] = Field ( None , description = ( \"Row number with the headers. Defaults to `1` if header is given, \" \"otherwise `None`.\" ), ) header : Optional [ List [ str ]] = Field ( None , description = ( \"Optional list of column names, specifying the columns to return. \" \"These names they should match cells in `header_row`.\" ), ) new_header : Optional [ List [ str ]] = Field ( None , description = ( \"Optional list of new column names replacing `header` in the output.\" ), ) download_config : AttrDict = Field ( AttrDict (), description = \"Configurations provided to a download strategy.\" , ) datacache_config : Optional [ DataCacheConfig ] = Field ( None , description = \"Configurations for the data cache for retrieving the downloaded content.\" , )","title":"XLSXParseConfig"},{"location":"all_strategies/#oteapi.strategies.parse.excel_xlsx.XLSXParseResourceConfig","text":"Bases: ResourceConfig XLSX parse strategy resource config. Source code in oteapi/strategies/parse/excel_xlsx.py 83 84 85 86 87 88 89 90 91 92 93 class XLSXParseResourceConfig ( ResourceConfig ): \"\"\"XLSX parse strategy resource config.\"\"\" mediaType : str = Field ( \"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\" , const = True , description = ResourceConfig . __fields__ [ \"mediaType\" ] . field_info . description , ) configuration : XLSXParseConfig = Field ( ... , description = \"SQLite parse strategy-specific configuration.\" )","title":"XLSXParseResourceConfig"},{"location":"all_strategies/#oteapi.strategies.parse.excel_xlsx.XLSXParseStrategy","text":"Parse strategy for Excel XLSX files. Registers strategies : (\"mediaType\", \"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\") Source code in oteapi/strategies/parse/excel_xlsx.py 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 @dataclass class XLSXParseStrategy : \"\"\"Parse strategy for Excel XLSX files. **Registers strategies**: - `(\"mediaType\", \"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\")` \"\"\" parse_config : XLSXParseResourceConfig def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdate : \"\"\"Initialize.\"\"\" return SessionUpdate () def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdateXLSXParse : \"\"\"Parses selected region of an excel file. Returns: A dict with column-name/column-value pairs. The values are lists. \"\"\" cache = DataCache ( self . parse_config . configuration . datacache_config ) if session is None : raise ValueError ( \"Missing session\" ) with cache . getfile ( key = session [ \"key\" ], suffix = \".xlsx\" ) as filename : # Note that we have to set read_only=False to ensure that # load_workbook() properly closes the xlsx file after reading. # Otherwise Windows will fail when the temporary file is removed # when leaving the with statement. workbook = load_workbook ( filename = filename , read_only = False , data_only = True ) worksheet = workbook [ self . parse_config . configuration . worksheet ] set_model_defaults ( self . parse_config . configuration , worksheet ) columns = get_column_indices ( self . parse_config . configuration , worksheet ) data = [] for row in worksheet . iter_rows ( min_row = self . parse_config . configuration . row_from , max_row = self . parse_config . configuration . row_to , min_col = min ( columns ), max_col = max ( columns ), ): data . append ([ row [ c - 1 ] . value for c in columns ]) if self . parse_config . configuration . header_row : row = worksheet . iter_rows ( min_row = self . parse_config . configuration . header_row , max_row = self . parse_config . configuration . header_row , min_col = min ( columns ), max_col = max ( columns ), ) . __next__ () header = [ row [ c - 1 ] . value for c in columns ] else : header = None if self . parse_config . configuration . new_header : nhead = len ( header ) if header else len ( data [ 0 ]) if data else 0 if len ( self . parse_config . configuration . new_header ) != nhead : raise TypeError ( f \"length of `new_header` (= { len ( self . parse_config . configuration . new_header ) } ) \" f \"doesn't match number of columns (= { len ( header ) if header else 0 } )\" ) if header : for i , val in enumerate ( self . parse_config . configuration . new_header ): if val is not None : header [ i ] = val elif data : header = self . parse_config . configuration . new_header if header is None : header = [ get_column_letter ( col + 1 ) for col in range ( len ( data ))] transposed = [ list ( datum ) for datum in zip ( * data )] return SessionUpdateXLSXParse ( data = { key : value for key , value in zip ( header , transposed )} )","title":"XLSXParseStrategy"},{"location":"all_strategies/#oteapi.strategies.parse.excel_xlsx.XLSXParseStrategy.get","text":"Parses selected region of an excel file. Returns: Type Description SessionUpdateXLSXParse A dict with column-name/column-value pairs. The values are lists. Source code in oteapi/strategies/parse/excel_xlsx.py 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdateXLSXParse : \"\"\"Parses selected region of an excel file. Returns: A dict with column-name/column-value pairs. The values are lists. \"\"\" cache = DataCache ( self . parse_config . configuration . datacache_config ) if session is None : raise ValueError ( \"Missing session\" ) with cache . getfile ( key = session [ \"key\" ], suffix = \".xlsx\" ) as filename : # Note that we have to set read_only=False to ensure that # load_workbook() properly closes the xlsx file after reading. # Otherwise Windows will fail when the temporary file is removed # when leaving the with statement. workbook = load_workbook ( filename = filename , read_only = False , data_only = True ) worksheet = workbook [ self . parse_config . configuration . worksheet ] set_model_defaults ( self . parse_config . configuration , worksheet ) columns = get_column_indices ( self . parse_config . configuration , worksheet ) data = [] for row in worksheet . iter_rows ( min_row = self . parse_config . configuration . row_from , max_row = self . parse_config . configuration . row_to , min_col = min ( columns ), max_col = max ( columns ), ): data . append ([ row [ c - 1 ] . value for c in columns ]) if self . parse_config . configuration . header_row : row = worksheet . iter_rows ( min_row = self . parse_config . configuration . header_row , max_row = self . parse_config . configuration . header_row , min_col = min ( columns ), max_col = max ( columns ), ) . __next__ () header = [ row [ c - 1 ] . value for c in columns ] else : header = None if self . parse_config . configuration . new_header : nhead = len ( header ) if header else len ( data [ 0 ]) if data else 0 if len ( self . parse_config . configuration . new_header ) != nhead : raise TypeError ( f \"length of `new_header` (= { len ( self . parse_config . configuration . new_header ) } ) \" f \"doesn't match number of columns (= { len ( header ) if header else 0 } )\" ) if header : for i , val in enumerate ( self . parse_config . configuration . new_header ): if val is not None : header [ i ] = val elif data : header = self . parse_config . configuration . new_header if header is None : header = [ get_column_letter ( col + 1 ) for col in range ( len ( data ))] transposed = [ list ( datum ) for datum in zip ( * data )] return SessionUpdateXLSXParse ( data = { key : value for key , value in zip ( header , transposed )} )","title":"get()"},{"location":"all_strategies/#oteapi.strategies.parse.excel_xlsx.XLSXParseStrategy.initialize","text":"Initialize. Source code in oteapi/strategies/parse/excel_xlsx.py 165 166 167 def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdate : \"\"\"Initialize.\"\"\" return SessionUpdate ()","title":"initialize()"},{"location":"all_strategies/#oteapi.strategies.parse.excel_xlsx.get_column_indices","text":"Helper function returning a list of column indices. Parameters: Name Type Description Default model XLSXParseConfig The parsed data model. required worksheet 'Worksheet' Excel worksheet, from which the header values will be retrieved. required Returns: Type Description 'Iterable[int]' A list of column indices. Source code in oteapi/strategies/parse/excel_xlsx.py 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 def get_column_indices ( model : XLSXParseConfig , worksheet : \"Worksheet\" ) -> \"Iterable[int]\" : \"\"\"Helper function returning a list of column indices. Parameters: model: The parsed data model. worksheet: Excel worksheet, from which the header values will be retrieved. Returns: A list of column indices. \"\"\" if not isinstance ( model . col_from , int ) or not isinstance ( model . col_to , int ): raise TypeError ( \"Expected `model.col_from` and `model.col_to` to be integers.\" ) if model . header : header_dict = { worksheet . cell ( model . header_row , col ) . value : col for col in range ( model . col_from , model . col_to + 1 ) } return [ header_dict [ h ] for h in model . header ] return range ( model . col_from , model . col_to + 1 )","title":"get_column_indices()"},{"location":"all_strategies/#oteapi.strategies.parse.excel_xlsx.set_model_defaults","text":"Update data model model with default values obtained from worksheet . Parameters: Name Type Description Default model XLSXParseConfig The parsed data model. required worksheet 'Worksheet' Excel worksheet, from which the default values will be obtained. required Source code in oteapi/strategies/parse/excel_xlsx.py 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 def set_model_defaults ( model : XLSXParseConfig , worksheet : \"Worksheet\" ) -> None : \"\"\"Update data model `model` with default values obtained from `worksheet`. Parameters: model: The parsed data model. worksheet: Excel worksheet, from which the default values will be obtained. \"\"\" if model . row_from is None : if model . header : # assume that data starts on the first row after the header model . row_from = model . header_row + 1 if model . header_row else 1 else : model . row_from = worksheet . min_row if model . row_to is None : model . row_to = worksheet . max_row if model . col_from is None : model . col_from = worksheet . min_column elif isinstance ( model . col_from , str ): model . col_from = column_index_from_string ( model . col_from ) if model . col_to is None : model . col_to = worksheet . max_column elif isinstance ( model . col_to , str ): model . col_to = column_index_from_string ( model . col_to ) if model . header and not model . header_row : model . header_row = 1","title":"set_model_defaults()"},{"location":"all_strategies/#oteapi.strategies.parse.image","text":"Strategy class for image/jpg.","title":"image"},{"location":"all_strategies/#oteapi.strategies.parse.image.ImageDataParseStrategy","text":"Parse strategy for images. This strategy uses Pillow to read a raw image from the data cache, converts it into a NumPy array and stores the new array in the data cache. It also supports simple cropping and image conversions. The key to the new array and other metadata is stored in the session. See SessionUpdateImageParse for more info. Registers strategies : (\"mediaType\", \"image/jpg\") (\"mediaType\", \"image/jpeg\") (\"mediaType\", \"image/jp2\") (\"mediaType\", \"image/png\") (\"mediaType\", \"image/gif\") (\"mediaType\", \"image/tiff\") (\"mediaType\", \"image/eps\") Source code in oteapi/strategies/parse/image.py 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 @dataclass class ImageDataParseStrategy : \"\"\"Parse strategy for images. This strategy uses Pillow to read a raw image from the data cache, converts it into a NumPy array and stores the new array in the data cache. It also supports simple cropping and image conversions. The key to the new array and other metadata is stored in the session. See [`SessionUpdateImageParse`][oteapi.strategies.parse.image.SessionUpdateImageParse] for more info. **Registers strategies**: - `(\"mediaType\", \"image/jpg\")` - `(\"mediaType\", \"image/jpeg\")` - `(\"mediaType\", \"image/jp2\")` - `(\"mediaType\", \"image/png\")` - `(\"mediaType\", \"image/gif\")` - `(\"mediaType\", \"image/tiff\")` - `(\"mediaType\", \"image/eps\")` \"\"\" parse_config : ImageParserResourceConfig def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdate : \"\"\"Initialize strategy.\"\"\" return SessionUpdate () def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdateImageParse : \"\"\"Execute the strategy.\"\"\" if not session : session = {} config = self . parse_config . configuration crop = config . crop if config . crop else session . get ( \"imagecrop\" ) mime_format = self . parse_config . mediaType . split ( \"/\" )[ 1 ] image_format = SupportedFormat [ mime_format ] . value # Proper download configurations conf = self . parse_config . dict () conf [ \"configuration\" ] = config . download_config or {} download_config = ResourceConfig ( ** conf ) downloader = create_strategy ( \"download\" , download_config ) session . update ( downloader . initialize ( session )) downloader = create_strategy ( \"download\" , download_config ) output = downloader . get ( session ) session . update ( output ) if config . datacache_config and config . datacache_config . accessKey : cache_key = config . datacache_config . accessKey elif \"key\" in output : cache_key = output [ \"key\" ] else : RuntimeError ( \"No data cache key provided to the downloaded content\" ) cache = DataCache ( config . datacache_config ) # Treat image according to filter values with cache . getfile ( cache_key , suffix = mime_format ) as filename : image = Image . open ( filename , formats = [ image_format ]) if crop : image = image . crop ( crop ) if config . image_mode : image = image . convert ( mode = config . image_mode ) if image_format == \"GIF\" : if image . info . get ( \"version\" , b \"\" ) . startswith ( b \"GIF\" ): image . info . update ( { \"version\" : image . info . get ( \"version\" , b \"\" )[ len ( b \"GIF\" ) :]} ) # Use the buffer protocol to store the image in the datacache data = np . asarray ( image ) image_key = cache . add ( data , key = config . image_key , tag = str ( id ( session )), ) if image . mode == \"P\" : image_palette_key = cache . add ( np . asarray ( image . getpalette ()), tag = str ( id ( session )) ) else : image_palette_key = None # The session must be json serialisable - filter out all # non-json serialisable fields in image.info if image . info : image_info = { key : val for key , val in image . info . items () if isinstance ( val , ( str , int , float , type ( None ), bool , tuple , list )) } else : image_info = {} session_update = SessionUpdateImageParse ( image_key = image_key , image_size = image . size , image_mode = image . mode , image_palette_key = image_palette_key , image_info = image_info , ) # Explicitly close the image to avoid crashes on Windows image . close () return session_update","title":"ImageDataParseStrategy"},{"location":"all_strategies/#oteapi.strategies.parse.image.ImageDataParseStrategy.get","text":"Execute the strategy. Source code in oteapi/strategies/parse/image.py 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdateImageParse : \"\"\"Execute the strategy.\"\"\" if not session : session = {} config = self . parse_config . configuration crop = config . crop if config . crop else session . get ( \"imagecrop\" ) mime_format = self . parse_config . mediaType . split ( \"/\" )[ 1 ] image_format = SupportedFormat [ mime_format ] . value # Proper download configurations conf = self . parse_config . dict () conf [ \"configuration\" ] = config . download_config or {} download_config = ResourceConfig ( ** conf ) downloader = create_strategy ( \"download\" , download_config ) session . update ( downloader . initialize ( session )) downloader = create_strategy ( \"download\" , download_config ) output = downloader . get ( session ) session . update ( output ) if config . datacache_config and config . datacache_config . accessKey : cache_key = config . datacache_config . accessKey elif \"key\" in output : cache_key = output [ \"key\" ] else : RuntimeError ( \"No data cache key provided to the downloaded content\" ) cache = DataCache ( config . datacache_config ) # Treat image according to filter values with cache . getfile ( cache_key , suffix = mime_format ) as filename : image = Image . open ( filename , formats = [ image_format ]) if crop : image = image . crop ( crop ) if config . image_mode : image = image . convert ( mode = config . image_mode ) if image_format == \"GIF\" : if image . info . get ( \"version\" , b \"\" ) . startswith ( b \"GIF\" ): image . info . update ( { \"version\" : image . info . get ( \"version\" , b \"\" )[ len ( b \"GIF\" ) :]} ) # Use the buffer protocol to store the image in the datacache data = np . asarray ( image ) image_key = cache . add ( data , key = config . image_key , tag = str ( id ( session )), ) if image . mode == \"P\" : image_palette_key = cache . add ( np . asarray ( image . getpalette ()), tag = str ( id ( session )) ) else : image_palette_key = None # The session must be json serialisable - filter out all # non-json serialisable fields in image.info if image . info : image_info = { key : val for key , val in image . info . items () if isinstance ( val , ( str , int , float , type ( None ), bool , tuple , list )) } else : image_info = {} session_update = SessionUpdateImageParse ( image_key = image_key , image_size = image . size , image_mode = image . mode , image_palette_key = image_palette_key , image_info = image_info , ) # Explicitly close the image to avoid crashes on Windows image . close () return session_update","title":"get()"},{"location":"all_strategies/#oteapi.strategies.parse.image.ImageDataParseStrategy.initialize","text":"Initialize strategy. Source code in oteapi/strategies/parse/image.py 139 140 141 def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdate : \"\"\"Initialize strategy.\"\"\" return SessionUpdate ()","title":"initialize()"},{"location":"all_strategies/#oteapi.strategies.parse.image.ImageParserConfig","text":"Bases: AttrDict Configuration data model for ImageDataParseStrategy . Source code in oteapi/strategies/parse/image.py 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 class ImageParserConfig ( AttrDict ): \"\"\"Configuration data model for [`ImageDataParseStrategy`][oteapi.strategies.parse.image.ImageDataParseStrategy].\"\"\" crop : Optional [ Tuple [ int , int , int , int ]] = Field ( None , description = \"Box cropping parameters (left, top, right, bottom).\" , ) datacache_config : Optional [ DataCacheConfig ] = Field ( None , description = \"Configuration options for the local data cache.\" , ) download_config : AttrDict = Field ( AttrDict (), description = \"Configurations passed to the downloader.\" , ) image_key : Optional [ str ] = Field ( None , description = \"Key to use when storing the image data in datacache.\" , ) image_mode : Optional [ str ] = Field ( None , description = ( \"Pillow mode to convert image into. See \" \"https://pillow.readthedocs.io/en/stable/handbook/concepts.html \" \"for details.\" ), )","title":"ImageParserConfig"},{"location":"all_strategies/#oteapi.strategies.parse.image.ImageParserResourceConfig","text":"Bases: ResourceConfig Image parse strategy resource config. Source code in oteapi/strategies/parse/image.py 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 class ImageParserResourceConfig ( ResourceConfig ): \"\"\"Image parse strategy resource config.\"\"\" mediaType : Union [ Literal [ \"image/jpg\" ], Literal [ \"image/jpeg\" ], Literal [ \"image/jp2\" ], Literal [ \"image/png\" ], Literal [ \"image/gif\" ], Literal [ \"image/tiff\" ], Literal [ \"image/eps\" ], ] = Field ( ... , description = ResourceConfig . __fields__ [ \"mediaType\" ] . field_info . description , ) configuration : ImageParserConfig = Field ( ImageParserConfig (), description = \"Image parse strategy-specific configuration.\" , )","title":"ImageParserResourceConfig"},{"location":"all_strategies/#oteapi.strategies.parse.image.SessionUpdateImageParse","text":"Bases: SessionUpdate Configuration model for ImageParse. See Pillow handbook for more details on image_mode , image_palette , and image_info . Source code in oteapi/strategies/parse/image.py 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 class SessionUpdateImageParse ( SessionUpdate ): \"\"\"Configuration model for ImageParse. See [Pillow handbook](https://pillow.readthedocs.io/en/stable/handbook/concepts.html) for more details on `image_mode`, `image_palette`, and `image_info`. \"\"\" image_key : str = Field ( ... , description = \"Key with which the image content is stored in the data cache.\" , ) image_size : Tuple [ int , int ] = Field ( ... , description = \"Image size (width, height).\" , ) image_mode : str = Field ( ... , description = \"Image mode. Examples: 'L', 'P', 'RGB', 'RGBA'...\" , ) image_palette_key : Optional [ str ] = Field ( None , description = \"Datacache key for colour palette if mode is 'P'.\" , ) image_info : dict = Field ( {}, description = \"Additional information about the image.\" , )","title":"SessionUpdateImageParse"},{"location":"all_strategies/#oteapi.strategies.parse.image.SupportedFormat","text":"Bases: Enum Supported formats for ImageDataParseStrategy . Source code in oteapi/strategies/parse/image.py 70 71 72 73 74 75 76 77 78 79 class SupportedFormat ( Enum ): \"\"\"Supported formats for `ImageDataParseStrategy`.\"\"\" jpeg = \"JPEG\" jpg = \"JPEG\" jp2 = \"JPEG2000\" png = \"PNG\" gif = \"GIF\" tiff = \"TIFF\" eps = \"EPS\"","title":"SupportedFormat"},{"location":"all_strategies/#oteapi.strategies.parse.text_csv","text":"Strategy class for text/csv.","title":"text_csv"},{"location":"all_strategies/#oteapi.strategies.parse.text_csv.CSVParseStrategy","text":"Parse strategy for CSV files. Registers strategies : (\"mediaType\", \"text/csv\") Note: This strategy is currently not finished, and is therefore not registered. Source code in oteapi/strategies/parse/text_csv.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 @dataclass class CSVParseStrategy : \"\"\"Parse strategy for CSV files. **Registers strategies**: - `(\"mediaType\", \"text/csv\")` Note: This strategy is currently not finished, and is therefore not registered. \"\"\" parse_config : ResourceConfig def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdate : \"\"\"Parse CSV.\"\"\" return SessionUpdate () def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdate : \"\"\"Initialize.\"\"\" return SessionUpdate ()","title":"CSVParseStrategy"},{"location":"all_strategies/#oteapi.strategies.parse.text_csv.CSVParseStrategy.get","text":"Parse CSV. Source code in oteapi/strategies/parse/text_csv.py 27 28 29 def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdate : \"\"\"Parse CSV.\"\"\" return SessionUpdate ()","title":"get()"},{"location":"all_strategies/#oteapi.strategies.parse.text_csv.CSVParseStrategy.initialize","text":"Initialize. Source code in oteapi/strategies/parse/text_csv.py 31 32 33 def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdate : \"\"\"Initialize.\"\"\" return SessionUpdate ()","title":"initialize()"},{"location":"all_strategies/#oteapi.strategies.transformation","text":"","title":"transformation"},{"location":"all_strategies/#oteapi.strategies.transformation.celery_remote","text":"Transformation Plugin that uses the Celery framework to call remote workers.","title":"celery_remote"},{"location":"all_strategies/#oteapi.strategies.transformation.celery_remote.CeleryConfig","text":"Bases: AttrDict Celery configuration. Source code in oteapi/strategies/transformation/celery_remote.py 25 26 27 28 29 class CeleryConfig ( AttrDict ): \"\"\"Celery configuration.\"\"\" task_name : str = Field ( ... , description = \"A task name.\" ) args : list = Field ( ... , description = \"List of arguments for the task.\" )","title":"CeleryConfig"},{"location":"all_strategies/#oteapi.strategies.transformation.celery_remote.CeleryRemoteStrategy","text":"Submit job to remote Celery runner. Registers strategies : (\"transformationType\", \"celery/remote\") Source code in oteapi/strategies/transformation/celery_remote.py 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 @dataclass class CeleryRemoteStrategy : \"\"\"Submit job to remote Celery runner. **Registers strategies**: - `(\"transformationType\", \"celery/remote\")` \"\"\" transformation_config : CeleryStrategyConfig def run ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> TransformationStatus : \"\"\"Run a job, return a job ID.\"\"\" if session : self . _use_session ( session ) celery_kwargs = session . copy () for field in CeleryConfig . __fields__ : celery_kwargs . pop ( field , None ) result : \"Union[AsyncResult, Any]\" = CELERY . send_task ( name = self . transformation_config . configuration . task_name , args = self . transformation_config . configuration . args , kwargs = celery_kwargs , ) return self . status ( result . task_id ) def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdate : \"\"\"Initialize a job.\"\"\" return SessionUpdate () def status ( self , task_id : str ) -> TransformationStatus : \"\"\"Get job status.\"\"\" result = AsyncResult ( id = task_id , app = CELERY ) return TransformationStatus ( id = task_id , status = result . state ) def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdateCelery : \"\"\"Get transformation.\"\"\" # TODO: update and return global state # pylint: disable=fixme return SessionUpdateCelery ( data = {}) def _use_session ( self , session : \"Dict[str, Any]\" ) -> None : \"\"\"Update the configuration with values from the sesssion.\"\"\" for field in CeleryConfig . __fields__ : if field in session : setattr ( self . transformation_config . configuration , field , session [ field ], )","title":"CeleryRemoteStrategy"},{"location":"all_strategies/#oteapi.strategies.transformation.celery_remote.CeleryRemoteStrategy._use_session","text":"Update the configuration with values from the sesssion. Source code in oteapi/strategies/transformation/celery_remote.py 97 98 99 100 101 102 103 104 105 def _use_session ( self , session : \"Dict[str, Any]\" ) -> None : \"\"\"Update the configuration with values from the sesssion.\"\"\" for field in CeleryConfig . __fields__ : if field in session : setattr ( self . transformation_config . configuration , field , session [ field ], )","title":"_use_session()"},{"location":"all_strategies/#oteapi.strategies.transformation.celery_remote.CeleryRemoteStrategy.get","text":"Get transformation. Source code in oteapi/strategies/transformation/celery_remote.py 92 93 94 95 def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdateCelery : \"\"\"Get transformation.\"\"\" # TODO: update and return global state # pylint: disable=fixme return SessionUpdateCelery ( data = {})","title":"get()"},{"location":"all_strategies/#oteapi.strategies.transformation.celery_remote.CeleryRemoteStrategy.initialize","text":"Initialize a job. Source code in oteapi/strategies/transformation/celery_remote.py 83 84 85 def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdate : \"\"\"Initialize a job.\"\"\" return SessionUpdate ()","title":"initialize()"},{"location":"all_strategies/#oteapi.strategies.transformation.celery_remote.CeleryRemoteStrategy.run","text":"Run a job, return a job ID. Source code in oteapi/strategies/transformation/celery_remote.py 68 69 70 71 72 73 74 75 76 77 78 79 80 81 def run ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> TransformationStatus : \"\"\"Run a job, return a job ID.\"\"\" if session : self . _use_session ( session ) celery_kwargs = session . copy () for field in CeleryConfig . __fields__ : celery_kwargs . pop ( field , None ) result : \"Union[AsyncResult, Any]\" = CELERY . send_task ( name = self . transformation_config . configuration . task_name , args = self . transformation_config . configuration . args , kwargs = celery_kwargs , ) return self . status ( result . task_id )","title":"run()"},{"location":"all_strategies/#oteapi.strategies.transformation.celery_remote.CeleryRemoteStrategy.status","text":"Get job status. Source code in oteapi/strategies/transformation/celery_remote.py 87 88 89 90 def status ( self , task_id : str ) -> TransformationStatus : \"\"\"Get job status.\"\"\" result = AsyncResult ( id = task_id , app = CELERY ) return TransformationStatus ( id = task_id , status = result . state )","title":"status()"},{"location":"all_strategies/#oteapi.strategies.transformation.celery_remote.CeleryStrategyConfig","text":"Bases: TransformationConfig Celery strategy-specific configuration. Source code in oteapi/strategies/transformation/celery_remote.py 41 42 43 44 45 46 47 48 49 50 51 52 53 class CeleryStrategyConfig ( TransformationConfig ): \"\"\"Celery strategy-specific configuration.\"\"\" transformationType : str = Field ( \"celery/remote\" , const = True , description = TransformationConfig . __fields__ [ \"transformationType\" ] . field_info . description , ) configuration : CeleryConfig = Field ( ... , description = \"Celery transformation strategy-specific configuration.\" )","title":"CeleryStrategyConfig"},{"location":"all_strategies/#oteapi.strategies.transformation.celery_remote.SessionUpdateCelery","text":"Bases: SessionUpdate Class for returning values from XLSXParse. Source code in oteapi/strategies/transformation/celery_remote.py 32 33 34 35 36 37 38 class SessionUpdateCelery ( SessionUpdate ): \"\"\"Class for returning values from XLSXParse.\"\"\" data : Dict [ str , list ] = Field ( ... , description = \"A dict with column-name/column-value pairs. The values are lists.\" , )","title":"SessionUpdateCelery"},{"location":"api_reference/datacache/datacache/","text":"datacache \u00b6 Data cache based on DiskCache. See Python-DiskCache . Features: Persistent cache between sessions. Default keys are hashes of the stored data. Automatic expiration of cached data. Sessions can selectively be cleaned up via tags. Store small values in SQLite database and large values in files. Underlying library is actively developed and tested on Linux, Mac and Windows. High performance. DataCache \u00b6 Initialize a cache instance with the given download configuration. This class is also available to import from oteapi.datacache , e.g.: from oteapi.datacache import DataCache Parameters: Name Type Description Default config Union [ DataCacheConfig , Dict [ str , Any ]] Download configurations. None cache_dir Optional [ Union [ Path , str ]] Cache directory overriding the config. None Attributes: Name Type Description config DataCacheConfig instance. cache_dir Subdirectory used for the Path to cache directory, e.g., \"my_oteapi\" . Source code in oteapi/datacache/datacache.py 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 class DataCache : \"\"\"Initialize a cache instance with the given download configuration. This class is also available to import from `oteapi.datacache`, e.g.: ```python from oteapi.datacache import DataCache ``` Args: config (Union[DataCacheConfig, Dict[str, Any]]): Download configurations. cache_dir (Optional[Union[Path, str]]): Cache directory overriding the config. Attributes: config: DataCacheConfig instance. cache_dir: Subdirectory used for the Path to cache directory, e.g., `\"my_oteapi\"`. \"\"\" def __init__ ( self , config : \"Union[DataCacheConfig, Dict[str, Any]]\" = None , cache_dir : \"Optional[Union[Path, str]]\" = None , ) -> None : if config is None : self . config = DataCacheConfig () elif isinstance ( config , ( dict , AttrDict )): self . config = DataCacheConfig ( ** config ) elif isinstance ( config , DataCacheConfig ): self . config = config else : raise TypeError ( \"config should be either a `DataCacheConfig` data model or a \" \"dictionary.\" ) if not cache_dir : cache_dir = self . config . cacheDir if isinstance ( cache_dir , str ): cache_dir = Path ( cache_dir ) if cache_dir . is_absolute (): self . cache_dir = cache_dir else : self . cache_dir = Path ( tempfile . gettempdir ()) . resolve () / cache_dir self . diskcache = DiskCache ( directory = self . cache_dir ) def __contains__ ( self , key ) -> bool : return key in self . diskcache def __len__ ( self ) -> int : return len ( self . diskcache ) def __getitem__ ( self , key ) -> \"Any\" : return self . get ( key ) def __setitem__ ( self , key , value ) -> None : self . add ( value , key = key ) def __delitem__ ( self , key ) -> None : del self . diskcache [ key ] def __del__ ( self ) -> None : self . diskcache . expire () self . diskcache . close () def add ( self , value : \"Any\" , key : \"Optional[str]\" = None , expire : \"Optional[int]\" = None , tag : \"Optional[str]\" = None , bind : \"Any\" = None , json_encoder : \"Optional[Type[json.JSONEncoder]]\" = None , ) -> str : \"\"\"Add a value to cache. Existing value is overwritten if `key` is given and it already exists in the cache. Args: value: The value to add to the cache. key: If given, use this as the retrieval key. Otherwise the key is either taken from the `accessKey` configuration or generated as a hash of `value`. expire: If given, the number of seconds before the value expire. Otherwise it is taken from the configuration. tag: Tag used with [`evict()`][oteapi.datacache.datacache.DataCache.evict] for cleaning up a session. bind: Remove `value` from the cache when the object provided with this argument goes out of scope. Note that `bind` must be a weakref'able object. The argument name refers to that we bind `value` to this argument. json_encoder: Customised json encoder forcomplex Python objects. Returns: A key that can be used to retrieve `value` from cache later. \"\"\" key = ( key if key else ( self . config . accessKey if self . config . accessKey else gethash ( value , hashtype = self . config . hashType , json_encoder = json_encoder , ) ) ) if bind is not None : def remover ( key ): del self [ key ] weakref . finalize ( bind , remover , key ) self . diskcache . set ( key , value , expire = expire if expire else self . config . expireTime , tag = tag , ) return key def get ( self , key : str ) -> \"Any\" : \"\"\"Return the value corresponding to `key`. Args: key: The requested cached object to retrieve a value for. Returns: The value corresponding to the `key` value. \"\"\" if key not in self . diskcache : raise KeyError ( key ) return self . diskcache . get ( key ) @contextmanager def getfile ( self , key : str , delete : bool = True , filename : \"Optional[Union[Path, str]]\" = None , prefix : \"Optional[str]\" = None , suffix : \"Optional[str]\" = None , directory : \"Optional[str]\" = None , ) -> \"Iterator[Path]\" : \"\"\"Write the value for `key` to file and return the filename. The file is created in the default directory for temporary files (which can be controlled by the `TEMPDIR`, `TEMP` or `TMP` environment variables). It is readable and writable only for the current user. Example: This method is intended to be used in a `with` statement, to automatically delete the file when leaving the context: ```python cache = DataCache() with cache.getfile('mykey') as filename: # do something with filename... # filename is deleted ``` Args: key: Key of value to write to file. delete: Whether to automatically delete the created file when leaving the context. filename: Full path to created file. If not given, a unique filename will be created. prefix: Prefix to prepend to the returned file name (default is `\"oteapi-download-\"`). suffix: Suffix to append to the returned file name. directory: File directory if `filename` is not provided (is `None`). Yields: Path object, referencing and representing the created file. \"\"\" if filename : filename = Path ( filename ) . resolve () filename . write_bytes ( self . get ( key )) else : prefix = prefix if prefix else \"oteapi-download-\" with tempfile . NamedTemporaryFile ( prefix = prefix , suffix = suffix , dir = directory , delete = False , ) as handle : handle . write ( self . get ( key )) filename = Path ( handle . name ) . resolve () try : yield filename finally : if delete : filename . unlink () def evict ( self , tag : str ) -> None : \"\"\"Remove all cache items with the given tag. Useful for cleaning up a session. Args: tag: Tag identifying objects. \"\"\" self . diskcache . evict ( tag ) def clear ( self ) -> None : \"\"\"Remove all items from cache.\"\"\" self . diskcache . clear () add ( value , key = None , expire = None , tag = None , bind = None , json_encoder = None ) \u00b6 Add a value to cache. Existing value is overwritten if key is given and it already exists in the cache. Parameters: Name Type Description Default value 'Any' The value to add to the cache. required key 'Optional[str]' If given, use this as the retrieval key. Otherwise the key is either taken from the accessKey configuration or generated as a hash of value . None expire 'Optional[int]' If given, the number of seconds before the value expire. Otherwise it is taken from the configuration. None tag 'Optional[str]' Tag used with evict() for cleaning up a session. None bind 'Any' Remove value from the cache when the object provided with this argument goes out of scope. Note that bind must be a weakref'able object. The argument name refers to that we bind value to this argument. None json_encoder 'Optional[Type[json.JSONEncoder]]' Customised json encoder forcomplex Python objects. None Returns: Type Description str A key that can be used to retrieve value from cache later. Source code in oteapi/datacache/datacache.py 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 def add ( self , value : \"Any\" , key : \"Optional[str]\" = None , expire : \"Optional[int]\" = None , tag : \"Optional[str]\" = None , bind : \"Any\" = None , json_encoder : \"Optional[Type[json.JSONEncoder]]\" = None , ) -> str : \"\"\"Add a value to cache. Existing value is overwritten if `key` is given and it already exists in the cache. Args: value: The value to add to the cache. key: If given, use this as the retrieval key. Otherwise the key is either taken from the `accessKey` configuration or generated as a hash of `value`. expire: If given, the number of seconds before the value expire. Otherwise it is taken from the configuration. tag: Tag used with [`evict()`][oteapi.datacache.datacache.DataCache.evict] for cleaning up a session. bind: Remove `value` from the cache when the object provided with this argument goes out of scope. Note that `bind` must be a weakref'able object. The argument name refers to that we bind `value` to this argument. json_encoder: Customised json encoder forcomplex Python objects. Returns: A key that can be used to retrieve `value` from cache later. \"\"\" key = ( key if key else ( self . config . accessKey if self . config . accessKey else gethash ( value , hashtype = self . config . hashType , json_encoder = json_encoder , ) ) ) if bind is not None : def remover ( key ): del self [ key ] weakref . finalize ( bind , remover , key ) self . diskcache . set ( key , value , expire = expire if expire else self . config . expireTime , tag = tag , ) return key clear () \u00b6 Remove all items from cache. Source code in oteapi/datacache/datacache.py 295 296 297 def clear ( self ) -> None : \"\"\"Remove all items from cache.\"\"\" self . diskcache . clear () evict ( tag ) \u00b6 Remove all cache items with the given tag. Useful for cleaning up a session. Parameters: Name Type Description Default tag str Tag identifying objects. required Source code in oteapi/datacache/datacache.py 284 285 286 287 288 289 290 291 292 293 def evict ( self , tag : str ) -> None : \"\"\"Remove all cache items with the given tag. Useful for cleaning up a session. Args: tag: Tag identifying objects. \"\"\" self . diskcache . evict ( tag ) get ( key ) \u00b6 Return the value corresponding to key . Parameters: Name Type Description Default key str The requested cached object to retrieve a value for. required Returns: Type Description 'Any' The value corresponding to the key value. Source code in oteapi/datacache/datacache.py 207 208 209 210 211 212 213 214 215 216 217 218 219 def get ( self , key : str ) -> \"Any\" : \"\"\"Return the value corresponding to `key`. Args: key: The requested cached object to retrieve a value for. Returns: The value corresponding to the `key` value. \"\"\" if key not in self . diskcache : raise KeyError ( key ) return self . diskcache . get ( key ) getfile ( key , delete = True , filename = None , prefix = None , suffix = None , directory = None ) \u00b6 Write the value for key to file and return the filename. The file is created in the default directory for temporary files (which can be controlled by the TEMPDIR , TEMP or TMP environment variables). It is readable and writable only for the current user. Example This method is intended to be used in a with statement, to automatically delete the file when leaving the context: cache = DataCache () with cache . getfile ( 'mykey' ) as filename : # do something with filename... # filename is deleted Parameters: Name Type Description Default key str Key of value to write to file. required delete bool Whether to automatically delete the created file when leaving the context. True filename 'Optional[Union[Path, str]]' Full path to created file. If not given, a unique filename will be created. None prefix 'Optional[str]' Prefix to prepend to the returned file name (default is \"oteapi-download-\" ). None suffix 'Optional[str]' Suffix to append to the returned file name. None directory 'Optional[str]' File directory if filename is not provided (is None ). None Yields: Type Description 'Iterator[Path]' Path object, referencing and representing the created file. Source code in oteapi/datacache/datacache.py 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 @contextmanager def getfile ( self , key : str , delete : bool = True , filename : \"Optional[Union[Path, str]]\" = None , prefix : \"Optional[str]\" = None , suffix : \"Optional[str]\" = None , directory : \"Optional[str]\" = None , ) -> \"Iterator[Path]\" : \"\"\"Write the value for `key` to file and return the filename. The file is created in the default directory for temporary files (which can be controlled by the `TEMPDIR`, `TEMP` or `TMP` environment variables). It is readable and writable only for the current user. Example: This method is intended to be used in a `with` statement, to automatically delete the file when leaving the context: ```python cache = DataCache() with cache.getfile('mykey') as filename: # do something with filename... # filename is deleted ``` Args: key: Key of value to write to file. delete: Whether to automatically delete the created file when leaving the context. filename: Full path to created file. If not given, a unique filename will be created. prefix: Prefix to prepend to the returned file name (default is `\"oteapi-download-\"`). suffix: Suffix to append to the returned file name. directory: File directory if `filename` is not provided (is `None`). Yields: Path object, referencing and representing the created file. \"\"\" if filename : filename = Path ( filename ) . resolve () filename . write_bytes ( self . get ( key )) else : prefix = prefix if prefix else \"oteapi-download-\" with tempfile . NamedTemporaryFile ( prefix = prefix , suffix = suffix , dir = directory , delete = False , ) as handle : handle . write ( self . get ( key )) filename = Path ( handle . name ) . resolve () try : yield filename finally : if delete : filename . unlink () gethash ( value , hashtype = 'sha256' , encoding = 'utf-8' , json_encoder = None ) \u00b6 Return a hash of value . Can hash most python objects. Bytes and bytearrays are hashed directly. Strings are converted to bytes with the given encoding. All other objects are first serialised using json. Parameters: Name Type Description Default value 'Any' Value to hash. required hashtype str Any of the hash algorithms supported by hashlib. 'sha256' encoding str Encoding used to convert strings to bytes before calculating the hash. 'utf-8' json_encoder 'Optional[Type[json.JSONEncoder]]' Customised json encoder for complex Python objects. None Returns: Type Description str A hash of the input value . Source code in oteapi/datacache/datacache.py 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 def gethash ( value : \"Any\" , hashtype : str = \"sha256\" , encoding : str = \"utf-8\" , json_encoder : \"Optional[Type[json.JSONEncoder]]\" = None , ) -> str : \"\"\"Return a hash of `value`. Can hash most python objects. Bytes and bytearrays are hashed directly. Strings are converted to bytes with the given encoding. All other objects are first serialised using json. Args: value: Value to hash. hashtype: Any of the hash algorithms supported by hashlib. encoding: Encoding used to convert strings to bytes before calculating the hash. json_encoder: Customised json encoder for complex Python objects. Returns: A hash of the input `value`. \"\"\" hash_ = hashlib . new ( hashtype ) if isinstance ( value , str ): data = value . encode ( encoding ) else : data = value try : hash_ . update ( data ) except TypeError : # Fallback, try to serialise using json... data = json . dumps ( value , ensure_ascii = False , cls = json_encoder , sort_keys = True , ) . encode ( encoding ) hash_ . update ( data ) return hash_ . hexdigest ()","title":"datacache"},{"location":"api_reference/datacache/datacache/#datacache","text":"Data cache based on DiskCache. See Python-DiskCache . Features: Persistent cache between sessions. Default keys are hashes of the stored data. Automatic expiration of cached data. Sessions can selectively be cleaned up via tags. Store small values in SQLite database and large values in files. Underlying library is actively developed and tested on Linux, Mac and Windows. High performance.","title":"datacache"},{"location":"api_reference/datacache/datacache/#oteapi.datacache.datacache.DataCache","text":"Initialize a cache instance with the given download configuration. This class is also available to import from oteapi.datacache , e.g.: from oteapi.datacache import DataCache Parameters: Name Type Description Default config Union [ DataCacheConfig , Dict [ str , Any ]] Download configurations. None cache_dir Optional [ Union [ Path , str ]] Cache directory overriding the config. None Attributes: Name Type Description config DataCacheConfig instance. cache_dir Subdirectory used for the Path to cache directory, e.g., \"my_oteapi\" . Source code in oteapi/datacache/datacache.py 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 class DataCache : \"\"\"Initialize a cache instance with the given download configuration. This class is also available to import from `oteapi.datacache`, e.g.: ```python from oteapi.datacache import DataCache ``` Args: config (Union[DataCacheConfig, Dict[str, Any]]): Download configurations. cache_dir (Optional[Union[Path, str]]): Cache directory overriding the config. Attributes: config: DataCacheConfig instance. cache_dir: Subdirectory used for the Path to cache directory, e.g., `\"my_oteapi\"`. \"\"\" def __init__ ( self , config : \"Union[DataCacheConfig, Dict[str, Any]]\" = None , cache_dir : \"Optional[Union[Path, str]]\" = None , ) -> None : if config is None : self . config = DataCacheConfig () elif isinstance ( config , ( dict , AttrDict )): self . config = DataCacheConfig ( ** config ) elif isinstance ( config , DataCacheConfig ): self . config = config else : raise TypeError ( \"config should be either a `DataCacheConfig` data model or a \" \"dictionary.\" ) if not cache_dir : cache_dir = self . config . cacheDir if isinstance ( cache_dir , str ): cache_dir = Path ( cache_dir ) if cache_dir . is_absolute (): self . cache_dir = cache_dir else : self . cache_dir = Path ( tempfile . gettempdir ()) . resolve () / cache_dir self . diskcache = DiskCache ( directory = self . cache_dir ) def __contains__ ( self , key ) -> bool : return key in self . diskcache def __len__ ( self ) -> int : return len ( self . diskcache ) def __getitem__ ( self , key ) -> \"Any\" : return self . get ( key ) def __setitem__ ( self , key , value ) -> None : self . add ( value , key = key ) def __delitem__ ( self , key ) -> None : del self . diskcache [ key ] def __del__ ( self ) -> None : self . diskcache . expire () self . diskcache . close () def add ( self , value : \"Any\" , key : \"Optional[str]\" = None , expire : \"Optional[int]\" = None , tag : \"Optional[str]\" = None , bind : \"Any\" = None , json_encoder : \"Optional[Type[json.JSONEncoder]]\" = None , ) -> str : \"\"\"Add a value to cache. Existing value is overwritten if `key` is given and it already exists in the cache. Args: value: The value to add to the cache. key: If given, use this as the retrieval key. Otherwise the key is either taken from the `accessKey` configuration or generated as a hash of `value`. expire: If given, the number of seconds before the value expire. Otherwise it is taken from the configuration. tag: Tag used with [`evict()`][oteapi.datacache.datacache.DataCache.evict] for cleaning up a session. bind: Remove `value` from the cache when the object provided with this argument goes out of scope. Note that `bind` must be a weakref'able object. The argument name refers to that we bind `value` to this argument. json_encoder: Customised json encoder forcomplex Python objects. Returns: A key that can be used to retrieve `value` from cache later. \"\"\" key = ( key if key else ( self . config . accessKey if self . config . accessKey else gethash ( value , hashtype = self . config . hashType , json_encoder = json_encoder , ) ) ) if bind is not None : def remover ( key ): del self [ key ] weakref . finalize ( bind , remover , key ) self . diskcache . set ( key , value , expire = expire if expire else self . config . expireTime , tag = tag , ) return key def get ( self , key : str ) -> \"Any\" : \"\"\"Return the value corresponding to `key`. Args: key: The requested cached object to retrieve a value for. Returns: The value corresponding to the `key` value. \"\"\" if key not in self . diskcache : raise KeyError ( key ) return self . diskcache . get ( key ) @contextmanager def getfile ( self , key : str , delete : bool = True , filename : \"Optional[Union[Path, str]]\" = None , prefix : \"Optional[str]\" = None , suffix : \"Optional[str]\" = None , directory : \"Optional[str]\" = None , ) -> \"Iterator[Path]\" : \"\"\"Write the value for `key` to file and return the filename. The file is created in the default directory for temporary files (which can be controlled by the `TEMPDIR`, `TEMP` or `TMP` environment variables). It is readable and writable only for the current user. Example: This method is intended to be used in a `with` statement, to automatically delete the file when leaving the context: ```python cache = DataCache() with cache.getfile('mykey') as filename: # do something with filename... # filename is deleted ``` Args: key: Key of value to write to file. delete: Whether to automatically delete the created file when leaving the context. filename: Full path to created file. If not given, a unique filename will be created. prefix: Prefix to prepend to the returned file name (default is `\"oteapi-download-\"`). suffix: Suffix to append to the returned file name. directory: File directory if `filename` is not provided (is `None`). Yields: Path object, referencing and representing the created file. \"\"\" if filename : filename = Path ( filename ) . resolve () filename . write_bytes ( self . get ( key )) else : prefix = prefix if prefix else \"oteapi-download-\" with tempfile . NamedTemporaryFile ( prefix = prefix , suffix = suffix , dir = directory , delete = False , ) as handle : handle . write ( self . get ( key )) filename = Path ( handle . name ) . resolve () try : yield filename finally : if delete : filename . unlink () def evict ( self , tag : str ) -> None : \"\"\"Remove all cache items with the given tag. Useful for cleaning up a session. Args: tag: Tag identifying objects. \"\"\" self . diskcache . evict ( tag ) def clear ( self ) -> None : \"\"\"Remove all items from cache.\"\"\" self . diskcache . clear ()","title":"DataCache"},{"location":"api_reference/datacache/datacache/#oteapi.datacache.datacache.DataCache.add","text":"Add a value to cache. Existing value is overwritten if key is given and it already exists in the cache. Parameters: Name Type Description Default value 'Any' The value to add to the cache. required key 'Optional[str]' If given, use this as the retrieval key. Otherwise the key is either taken from the accessKey configuration or generated as a hash of value . None expire 'Optional[int]' If given, the number of seconds before the value expire. Otherwise it is taken from the configuration. None tag 'Optional[str]' Tag used with evict() for cleaning up a session. None bind 'Any' Remove value from the cache when the object provided with this argument goes out of scope. Note that bind must be a weakref'able object. The argument name refers to that we bind value to this argument. None json_encoder 'Optional[Type[json.JSONEncoder]]' Customised json encoder forcomplex Python objects. None Returns: Type Description str A key that can be used to retrieve value from cache later. Source code in oteapi/datacache/datacache.py 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 def add ( self , value : \"Any\" , key : \"Optional[str]\" = None , expire : \"Optional[int]\" = None , tag : \"Optional[str]\" = None , bind : \"Any\" = None , json_encoder : \"Optional[Type[json.JSONEncoder]]\" = None , ) -> str : \"\"\"Add a value to cache. Existing value is overwritten if `key` is given and it already exists in the cache. Args: value: The value to add to the cache. key: If given, use this as the retrieval key. Otherwise the key is either taken from the `accessKey` configuration or generated as a hash of `value`. expire: If given, the number of seconds before the value expire. Otherwise it is taken from the configuration. tag: Tag used with [`evict()`][oteapi.datacache.datacache.DataCache.evict] for cleaning up a session. bind: Remove `value` from the cache when the object provided with this argument goes out of scope. Note that `bind` must be a weakref'able object. The argument name refers to that we bind `value` to this argument. json_encoder: Customised json encoder forcomplex Python objects. Returns: A key that can be used to retrieve `value` from cache later. \"\"\" key = ( key if key else ( self . config . accessKey if self . config . accessKey else gethash ( value , hashtype = self . config . hashType , json_encoder = json_encoder , ) ) ) if bind is not None : def remover ( key ): del self [ key ] weakref . finalize ( bind , remover , key ) self . diskcache . set ( key , value , expire = expire if expire else self . config . expireTime , tag = tag , ) return key","title":"add()"},{"location":"api_reference/datacache/datacache/#oteapi.datacache.datacache.DataCache.clear","text":"Remove all items from cache. Source code in oteapi/datacache/datacache.py 295 296 297 def clear ( self ) -> None : \"\"\"Remove all items from cache.\"\"\" self . diskcache . clear ()","title":"clear()"},{"location":"api_reference/datacache/datacache/#oteapi.datacache.datacache.DataCache.evict","text":"Remove all cache items with the given tag. Useful for cleaning up a session. Parameters: Name Type Description Default tag str Tag identifying objects. required Source code in oteapi/datacache/datacache.py 284 285 286 287 288 289 290 291 292 293 def evict ( self , tag : str ) -> None : \"\"\"Remove all cache items with the given tag. Useful for cleaning up a session. Args: tag: Tag identifying objects. \"\"\" self . diskcache . evict ( tag )","title":"evict()"},{"location":"api_reference/datacache/datacache/#oteapi.datacache.datacache.DataCache.get","text":"Return the value corresponding to key . Parameters: Name Type Description Default key str The requested cached object to retrieve a value for. required Returns: Type Description 'Any' The value corresponding to the key value. Source code in oteapi/datacache/datacache.py 207 208 209 210 211 212 213 214 215 216 217 218 219 def get ( self , key : str ) -> \"Any\" : \"\"\"Return the value corresponding to `key`. Args: key: The requested cached object to retrieve a value for. Returns: The value corresponding to the `key` value. \"\"\" if key not in self . diskcache : raise KeyError ( key ) return self . diskcache . get ( key )","title":"get()"},{"location":"api_reference/datacache/datacache/#oteapi.datacache.datacache.DataCache.getfile","text":"Write the value for key to file and return the filename. The file is created in the default directory for temporary files (which can be controlled by the TEMPDIR , TEMP or TMP environment variables). It is readable and writable only for the current user. Example This method is intended to be used in a with statement, to automatically delete the file when leaving the context: cache = DataCache () with cache . getfile ( 'mykey' ) as filename : # do something with filename... # filename is deleted Parameters: Name Type Description Default key str Key of value to write to file. required delete bool Whether to automatically delete the created file when leaving the context. True filename 'Optional[Union[Path, str]]' Full path to created file. If not given, a unique filename will be created. None prefix 'Optional[str]' Prefix to prepend to the returned file name (default is \"oteapi-download-\" ). None suffix 'Optional[str]' Suffix to append to the returned file name. None directory 'Optional[str]' File directory if filename is not provided (is None ). None Yields: Type Description 'Iterator[Path]' Path object, referencing and representing the created file. Source code in oteapi/datacache/datacache.py 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 @contextmanager def getfile ( self , key : str , delete : bool = True , filename : \"Optional[Union[Path, str]]\" = None , prefix : \"Optional[str]\" = None , suffix : \"Optional[str]\" = None , directory : \"Optional[str]\" = None , ) -> \"Iterator[Path]\" : \"\"\"Write the value for `key` to file and return the filename. The file is created in the default directory for temporary files (which can be controlled by the `TEMPDIR`, `TEMP` or `TMP` environment variables). It is readable and writable only for the current user. Example: This method is intended to be used in a `with` statement, to automatically delete the file when leaving the context: ```python cache = DataCache() with cache.getfile('mykey') as filename: # do something with filename... # filename is deleted ``` Args: key: Key of value to write to file. delete: Whether to automatically delete the created file when leaving the context. filename: Full path to created file. If not given, a unique filename will be created. prefix: Prefix to prepend to the returned file name (default is `\"oteapi-download-\"`). suffix: Suffix to append to the returned file name. directory: File directory if `filename` is not provided (is `None`). Yields: Path object, referencing and representing the created file. \"\"\" if filename : filename = Path ( filename ) . resolve () filename . write_bytes ( self . get ( key )) else : prefix = prefix if prefix else \"oteapi-download-\" with tempfile . NamedTemporaryFile ( prefix = prefix , suffix = suffix , dir = directory , delete = False , ) as handle : handle . write ( self . get ( key )) filename = Path ( handle . name ) . resolve () try : yield filename finally : if delete : filename . unlink ()","title":"getfile()"},{"location":"api_reference/datacache/datacache/#oteapi.datacache.datacache.gethash","text":"Return a hash of value . Can hash most python objects. Bytes and bytearrays are hashed directly. Strings are converted to bytes with the given encoding. All other objects are first serialised using json. Parameters: Name Type Description Default value 'Any' Value to hash. required hashtype str Any of the hash algorithms supported by hashlib. 'sha256' encoding str Encoding used to convert strings to bytes before calculating the hash. 'utf-8' json_encoder 'Optional[Type[json.JSONEncoder]]' Customised json encoder for complex Python objects. None Returns: Type Description str A hash of the input value . Source code in oteapi/datacache/datacache.py 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 def gethash ( value : \"Any\" , hashtype : str = \"sha256\" , encoding : str = \"utf-8\" , json_encoder : \"Optional[Type[json.JSONEncoder]]\" = None , ) -> str : \"\"\"Return a hash of `value`. Can hash most python objects. Bytes and bytearrays are hashed directly. Strings are converted to bytes with the given encoding. All other objects are first serialised using json. Args: value: Value to hash. hashtype: Any of the hash algorithms supported by hashlib. encoding: Encoding used to convert strings to bytes before calculating the hash. json_encoder: Customised json encoder for complex Python objects. Returns: A hash of the input `value`. \"\"\" hash_ = hashlib . new ( hashtype ) if isinstance ( value , str ): data = value . encode ( encoding ) else : data = value try : hash_ . update ( data ) except TypeError : # Fallback, try to serialise using json... data = json . dumps ( value , ensure_ascii = False , cls = json_encoder , sort_keys = True , ) . encode ( encoding ) hash_ . update ( data ) return hash_ . hexdigest ()","title":"gethash()"},{"location":"api_reference/interfaces/idownloadstrategy/","text":"idownloadstrategy \u00b6 Download Strategy Interface IDownloadStrategy \u00b6 Bases: Protocol Download Strategy Interface. Source code in oteapi/interfaces/idownloadstrategy.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 @dataclass # type: ignore[misc] class IDownloadStrategy ( Protocol ): \"\"\"Download Strategy Interface.\"\"\" download_config : \"ResourceConfig\" def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"SessionUpdate\" : \"\"\"Execute the strategy. Parameters: session: A session-specific dictionary context. Returns: An update model of key/value-pairs to be stored in the session-specific context from services. \"\"\" def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"SessionUpdate\" : \"\"\"Initialize data class. This method will be called through the `/initialize` endpoint of the OTE-API Services. Parameters: session: A session-specific dictionary context. Returns: An update model of key/value-pairs to be stored in the session-specific context from services. \"\"\" get ( session = None ) \u00b6 Execute the strategy. Parameters: Name Type Description Default session 'Optional[Dict[str, Any]]' A session-specific dictionary context. None Returns: Type Description 'SessionUpdate' An update model of key/value-pairs to be stored in the 'SessionUpdate' session-specific context from services. Source code in oteapi/interfaces/idownloadstrategy.py 17 18 19 20 21 22 23 24 25 26 27 def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"SessionUpdate\" : \"\"\"Execute the strategy. Parameters: session: A session-specific dictionary context. Returns: An update model of key/value-pairs to be stored in the session-specific context from services. \"\"\" initialize ( session = None ) \u00b6 Initialize data class. This method will be called through the /initialize endpoint of the OTE-API Services. Parameters: Name Type Description Default session 'Optional[Dict[str, Any]]' A session-specific dictionary context. None Returns: Type Description 'SessionUpdate' An update model of key/value-pairs to be stored in the 'SessionUpdate' session-specific context from services. Source code in oteapi/interfaces/idownloadstrategy.py 29 30 31 32 33 34 35 36 37 38 39 40 41 42 def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"SessionUpdate\" : \"\"\"Initialize data class. This method will be called through the `/initialize` endpoint of the OTE-API Services. Parameters: session: A session-specific dictionary context. Returns: An update model of key/value-pairs to be stored in the session-specific context from services. \"\"\"","title":"idownloadstrategy"},{"location":"api_reference/interfaces/idownloadstrategy/#idownloadstrategy","text":"Download Strategy Interface","title":"idownloadstrategy"},{"location":"api_reference/interfaces/idownloadstrategy/#oteapi.interfaces.idownloadstrategy.IDownloadStrategy","text":"Bases: Protocol Download Strategy Interface. Source code in oteapi/interfaces/idownloadstrategy.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 @dataclass # type: ignore[misc] class IDownloadStrategy ( Protocol ): \"\"\"Download Strategy Interface.\"\"\" download_config : \"ResourceConfig\" def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"SessionUpdate\" : \"\"\"Execute the strategy. Parameters: session: A session-specific dictionary context. Returns: An update model of key/value-pairs to be stored in the session-specific context from services. \"\"\" def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"SessionUpdate\" : \"\"\"Initialize data class. This method will be called through the `/initialize` endpoint of the OTE-API Services. Parameters: session: A session-specific dictionary context. Returns: An update model of key/value-pairs to be stored in the session-specific context from services. \"\"\"","title":"IDownloadStrategy"},{"location":"api_reference/interfaces/idownloadstrategy/#oteapi.interfaces.idownloadstrategy.IDownloadStrategy.get","text":"Execute the strategy. Parameters: Name Type Description Default session 'Optional[Dict[str, Any]]' A session-specific dictionary context. None Returns: Type Description 'SessionUpdate' An update model of key/value-pairs to be stored in the 'SessionUpdate' session-specific context from services. Source code in oteapi/interfaces/idownloadstrategy.py 17 18 19 20 21 22 23 24 25 26 27 def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"SessionUpdate\" : \"\"\"Execute the strategy. Parameters: session: A session-specific dictionary context. Returns: An update model of key/value-pairs to be stored in the session-specific context from services. \"\"\"","title":"get()"},{"location":"api_reference/interfaces/idownloadstrategy/#oteapi.interfaces.idownloadstrategy.IDownloadStrategy.initialize","text":"Initialize data class. This method will be called through the /initialize endpoint of the OTE-API Services. Parameters: Name Type Description Default session 'Optional[Dict[str, Any]]' A session-specific dictionary context. None Returns: Type Description 'SessionUpdate' An update model of key/value-pairs to be stored in the 'SessionUpdate' session-specific context from services. Source code in oteapi/interfaces/idownloadstrategy.py 29 30 31 32 33 34 35 36 37 38 39 40 41 42 def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"SessionUpdate\" : \"\"\"Initialize data class. This method will be called through the `/initialize` endpoint of the OTE-API Services. Parameters: session: A session-specific dictionary context. Returns: An update model of key/value-pairs to be stored in the session-specific context from services. \"\"\"","title":"initialize()"},{"location":"api_reference/interfaces/ifilterstrategy/","text":"ifilterstrategy \u00b6 Filter Strategy Interface IFilterStrategy \u00b6 Bases: Protocol Filter Strategy Interface. Source code in oteapi/interfaces/ifilterstrategy.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 @dataclass # type: ignore[misc] class IFilterStrategy ( Protocol ): \"\"\"Filter Strategy Interface.\"\"\" filter_config : \"FilterConfig\" def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"SessionUpdate\" : \"\"\"Execute the strategy. Parameters: session: A session-specific dictionary context. Returns: An update model of key/value-pairs to be stored in the session-specific context from services. \"\"\" def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"SessionUpdate\" : \"\"\"Initialize data class. This method will be called through the `/initialize` endpoint of the OTE-API Services. Parameters: session: A session-specific dictionary context. Returns: An update model of key/value-pairs to be stored in the session-specific context from services. \"\"\" get ( session = None ) \u00b6 Execute the strategy. Parameters: Name Type Description Default session 'Optional[Dict[str, Any]]' A session-specific dictionary context. None Returns: Type Description 'SessionUpdate' An update model of key/value-pairs to be stored in the 'SessionUpdate' session-specific context from services. Source code in oteapi/interfaces/ifilterstrategy.py 17 18 19 20 21 22 23 24 25 26 27 def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"SessionUpdate\" : \"\"\"Execute the strategy. Parameters: session: A session-specific dictionary context. Returns: An update model of key/value-pairs to be stored in the session-specific context from services. \"\"\" initialize ( session = None ) \u00b6 Initialize data class. This method will be called through the /initialize endpoint of the OTE-API Services. Parameters: Name Type Description Default session 'Optional[Dict[str, Any]]' A session-specific dictionary context. None Returns: Type Description 'SessionUpdate' An update model of key/value-pairs to be stored in the 'SessionUpdate' session-specific context from services. Source code in oteapi/interfaces/ifilterstrategy.py 29 30 31 32 33 34 35 36 37 38 39 40 41 42 def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"SessionUpdate\" : \"\"\"Initialize data class. This method will be called through the `/initialize` endpoint of the OTE-API Services. Parameters: session: A session-specific dictionary context. Returns: An update model of key/value-pairs to be stored in the session-specific context from services. \"\"\"","title":"ifilterstrategy"},{"location":"api_reference/interfaces/ifilterstrategy/#ifilterstrategy","text":"Filter Strategy Interface","title":"ifilterstrategy"},{"location":"api_reference/interfaces/ifilterstrategy/#oteapi.interfaces.ifilterstrategy.IFilterStrategy","text":"Bases: Protocol Filter Strategy Interface. Source code in oteapi/interfaces/ifilterstrategy.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 @dataclass # type: ignore[misc] class IFilterStrategy ( Protocol ): \"\"\"Filter Strategy Interface.\"\"\" filter_config : \"FilterConfig\" def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"SessionUpdate\" : \"\"\"Execute the strategy. Parameters: session: A session-specific dictionary context. Returns: An update model of key/value-pairs to be stored in the session-specific context from services. \"\"\" def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"SessionUpdate\" : \"\"\"Initialize data class. This method will be called through the `/initialize` endpoint of the OTE-API Services. Parameters: session: A session-specific dictionary context. Returns: An update model of key/value-pairs to be stored in the session-specific context from services. \"\"\"","title":"IFilterStrategy"},{"location":"api_reference/interfaces/ifilterstrategy/#oteapi.interfaces.ifilterstrategy.IFilterStrategy.get","text":"Execute the strategy. Parameters: Name Type Description Default session 'Optional[Dict[str, Any]]' A session-specific dictionary context. None Returns: Type Description 'SessionUpdate' An update model of key/value-pairs to be stored in the 'SessionUpdate' session-specific context from services. Source code in oteapi/interfaces/ifilterstrategy.py 17 18 19 20 21 22 23 24 25 26 27 def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"SessionUpdate\" : \"\"\"Execute the strategy. Parameters: session: A session-specific dictionary context. Returns: An update model of key/value-pairs to be stored in the session-specific context from services. \"\"\"","title":"get()"},{"location":"api_reference/interfaces/ifilterstrategy/#oteapi.interfaces.ifilterstrategy.IFilterStrategy.initialize","text":"Initialize data class. This method will be called through the /initialize endpoint of the OTE-API Services. Parameters: Name Type Description Default session 'Optional[Dict[str, Any]]' A session-specific dictionary context. None Returns: Type Description 'SessionUpdate' An update model of key/value-pairs to be stored in the 'SessionUpdate' session-specific context from services. Source code in oteapi/interfaces/ifilterstrategy.py 29 30 31 32 33 34 35 36 37 38 39 40 41 42 def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"SessionUpdate\" : \"\"\"Initialize data class. This method will be called through the `/initialize` endpoint of the OTE-API Services. Parameters: session: A session-specific dictionary context. Returns: An update model of key/value-pairs to be stored in the session-specific context from services. \"\"\"","title":"initialize()"},{"location":"api_reference/interfaces/ifunctionstrategy/","text":"ifunctionstrategy \u00b6 Function Strategy Interface IFunctionStrategy \u00b6 Bases: Protocol Function Strategy Interface. Source code in oteapi/interfaces/ifunctionstrategy.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 @dataclass # type: ignore[misc] class IFunctionStrategy ( Protocol ): \"\"\"Function Strategy Interface.\"\"\" function_config : \"FunctionConfig\" def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"SessionUpdate\" : \"\"\"Execute the strategy. Parameters: session: A session-specific dictionary context. Returns: An update model of key/value-pairs to be stored in the session-specific context from services. \"\"\" def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"SessionUpdate\" : \"\"\"Initialize data class. This method will be called through the `/initialize` endpoint of the OTE-API Services. Parameters: session: A session-specific dictionary context. Returns: An update model of key/value-pairs to be stored in the session-specific context from services. \"\"\" get ( session = None ) \u00b6 Execute the strategy. Parameters: Name Type Description Default session 'Optional[Dict[str, Any]]' A session-specific dictionary context. None Returns: Type Description 'SessionUpdate' An update model of key/value-pairs to be stored in the 'SessionUpdate' session-specific context from services. Source code in oteapi/interfaces/ifunctionstrategy.py 17 18 19 20 21 22 23 24 25 26 27 def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"SessionUpdate\" : \"\"\"Execute the strategy. Parameters: session: A session-specific dictionary context. Returns: An update model of key/value-pairs to be stored in the session-specific context from services. \"\"\" initialize ( session = None ) \u00b6 Initialize data class. This method will be called through the /initialize endpoint of the OTE-API Services. Parameters: Name Type Description Default session 'Optional[Dict[str, Any]]' A session-specific dictionary context. None Returns: Type Description 'SessionUpdate' An update model of key/value-pairs to be stored in the 'SessionUpdate' session-specific context from services. Source code in oteapi/interfaces/ifunctionstrategy.py 29 30 31 32 33 34 35 36 37 38 39 40 41 42 def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"SessionUpdate\" : \"\"\"Initialize data class. This method will be called through the `/initialize` endpoint of the OTE-API Services. Parameters: session: A session-specific dictionary context. Returns: An update model of key/value-pairs to be stored in the session-specific context from services. \"\"\"","title":"ifunctionstrategy"},{"location":"api_reference/interfaces/ifunctionstrategy/#ifunctionstrategy","text":"Function Strategy Interface","title":"ifunctionstrategy"},{"location":"api_reference/interfaces/ifunctionstrategy/#oteapi.interfaces.ifunctionstrategy.IFunctionStrategy","text":"Bases: Protocol Function Strategy Interface. Source code in oteapi/interfaces/ifunctionstrategy.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 @dataclass # type: ignore[misc] class IFunctionStrategy ( Protocol ): \"\"\"Function Strategy Interface.\"\"\" function_config : \"FunctionConfig\" def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"SessionUpdate\" : \"\"\"Execute the strategy. Parameters: session: A session-specific dictionary context. Returns: An update model of key/value-pairs to be stored in the session-specific context from services. \"\"\" def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"SessionUpdate\" : \"\"\"Initialize data class. This method will be called through the `/initialize` endpoint of the OTE-API Services. Parameters: session: A session-specific dictionary context. Returns: An update model of key/value-pairs to be stored in the session-specific context from services. \"\"\"","title":"IFunctionStrategy"},{"location":"api_reference/interfaces/ifunctionstrategy/#oteapi.interfaces.ifunctionstrategy.IFunctionStrategy.get","text":"Execute the strategy. Parameters: Name Type Description Default session 'Optional[Dict[str, Any]]' A session-specific dictionary context. None Returns: Type Description 'SessionUpdate' An update model of key/value-pairs to be stored in the 'SessionUpdate' session-specific context from services. Source code in oteapi/interfaces/ifunctionstrategy.py 17 18 19 20 21 22 23 24 25 26 27 def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"SessionUpdate\" : \"\"\"Execute the strategy. Parameters: session: A session-specific dictionary context. Returns: An update model of key/value-pairs to be stored in the session-specific context from services. \"\"\"","title":"get()"},{"location":"api_reference/interfaces/ifunctionstrategy/#oteapi.interfaces.ifunctionstrategy.IFunctionStrategy.initialize","text":"Initialize data class. This method will be called through the /initialize endpoint of the OTE-API Services. Parameters: Name Type Description Default session 'Optional[Dict[str, Any]]' A session-specific dictionary context. None Returns: Type Description 'SessionUpdate' An update model of key/value-pairs to be stored in the 'SessionUpdate' session-specific context from services. Source code in oteapi/interfaces/ifunctionstrategy.py 29 30 31 32 33 34 35 36 37 38 39 40 41 42 def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"SessionUpdate\" : \"\"\"Initialize data class. This method will be called through the `/initialize` endpoint of the OTE-API Services. Parameters: session: A session-specific dictionary context. Returns: An update model of key/value-pairs to be stored in the session-specific context from services. \"\"\"","title":"initialize()"},{"location":"api_reference/interfaces/imappingstrategy/","text":"imappingstrategy \u00b6 Mapping Strategy Interface IMappingStrategy \u00b6 Bases: Protocol Mapping Strategy Interface. Source code in oteapi/interfaces/imappingstrategy.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 @dataclass # type: ignore[misc] class IMappingStrategy ( Protocol ): \"\"\"Mapping Strategy Interface.\"\"\" mapping_config : \"MappingConfig\" def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"SessionUpdate\" : \"\"\"Execute the strategy. Parameters: session: A session-specific dictionary context. Returns: An update model of key/value-pairs to be stored in the session-specific context from services. \"\"\" def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"SessionUpdate\" : \"\"\"Initialize data class. This method will be called through the `/initialize` endpoint of the OTE-API Services. Parameters: session: A session-specific dictionary context. Returns: An update model of key/value-pairs to be stored in the session-specific context from services. \"\"\" get ( session = None ) \u00b6 Execute the strategy. Parameters: Name Type Description Default session 'Optional[Dict[str, Any]]' A session-specific dictionary context. None Returns: Type Description 'SessionUpdate' An update model of key/value-pairs to be stored in the 'SessionUpdate' session-specific context from services. Source code in oteapi/interfaces/imappingstrategy.py 17 18 19 20 21 22 23 24 25 26 27 def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"SessionUpdate\" : \"\"\"Execute the strategy. Parameters: session: A session-specific dictionary context. Returns: An update model of key/value-pairs to be stored in the session-specific context from services. \"\"\" initialize ( session = None ) \u00b6 Initialize data class. This method will be called through the /initialize endpoint of the OTE-API Services. Parameters: Name Type Description Default session 'Optional[Dict[str, Any]]' A session-specific dictionary context. None Returns: Type Description 'SessionUpdate' An update model of key/value-pairs to be stored in the 'SessionUpdate' session-specific context from services. Source code in oteapi/interfaces/imappingstrategy.py 29 30 31 32 33 34 35 36 37 38 39 40 41 42 def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"SessionUpdate\" : \"\"\"Initialize data class. This method will be called through the `/initialize` endpoint of the OTE-API Services. Parameters: session: A session-specific dictionary context. Returns: An update model of key/value-pairs to be stored in the session-specific context from services. \"\"\"","title":"imappingstrategy"},{"location":"api_reference/interfaces/imappingstrategy/#imappingstrategy","text":"Mapping Strategy Interface","title":"imappingstrategy"},{"location":"api_reference/interfaces/imappingstrategy/#oteapi.interfaces.imappingstrategy.IMappingStrategy","text":"Bases: Protocol Mapping Strategy Interface. Source code in oteapi/interfaces/imappingstrategy.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 @dataclass # type: ignore[misc] class IMappingStrategy ( Protocol ): \"\"\"Mapping Strategy Interface.\"\"\" mapping_config : \"MappingConfig\" def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"SessionUpdate\" : \"\"\"Execute the strategy. Parameters: session: A session-specific dictionary context. Returns: An update model of key/value-pairs to be stored in the session-specific context from services. \"\"\" def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"SessionUpdate\" : \"\"\"Initialize data class. This method will be called through the `/initialize` endpoint of the OTE-API Services. Parameters: session: A session-specific dictionary context. Returns: An update model of key/value-pairs to be stored in the session-specific context from services. \"\"\"","title":"IMappingStrategy"},{"location":"api_reference/interfaces/imappingstrategy/#oteapi.interfaces.imappingstrategy.IMappingStrategy.get","text":"Execute the strategy. Parameters: Name Type Description Default session 'Optional[Dict[str, Any]]' A session-specific dictionary context. None Returns: Type Description 'SessionUpdate' An update model of key/value-pairs to be stored in the 'SessionUpdate' session-specific context from services. Source code in oteapi/interfaces/imappingstrategy.py 17 18 19 20 21 22 23 24 25 26 27 def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"SessionUpdate\" : \"\"\"Execute the strategy. Parameters: session: A session-specific dictionary context. Returns: An update model of key/value-pairs to be stored in the session-specific context from services. \"\"\"","title":"get()"},{"location":"api_reference/interfaces/imappingstrategy/#oteapi.interfaces.imappingstrategy.IMappingStrategy.initialize","text":"Initialize data class. This method will be called through the /initialize endpoint of the OTE-API Services. Parameters: Name Type Description Default session 'Optional[Dict[str, Any]]' A session-specific dictionary context. None Returns: Type Description 'SessionUpdate' An update model of key/value-pairs to be stored in the 'SessionUpdate' session-specific context from services. Source code in oteapi/interfaces/imappingstrategy.py 29 30 31 32 33 34 35 36 37 38 39 40 41 42 def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"SessionUpdate\" : \"\"\"Initialize data class. This method will be called through the `/initialize` endpoint of the OTE-API Services. Parameters: session: A session-specific dictionary context. Returns: An update model of key/value-pairs to be stored in the session-specific context from services. \"\"\"","title":"initialize()"},{"location":"api_reference/interfaces/iparsestrategy/","text":"iparsestrategy \u00b6 Parse Strategy Interface IParseStrategy \u00b6 Bases: Protocol Parse Strategy Interface. Source code in oteapi/interfaces/iparsestrategy.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 @dataclass # type: ignore[misc] class IParseStrategy ( Protocol ): \"\"\"Parse Strategy Interface.\"\"\" parse_config : \"ResourceConfig\" def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"SessionUpdate\" : \"\"\"Execute the strategy. Parameters: session: A session-specific dictionary context. Returns: An update model of key/value-pairs to be stored in the session-specific context from services. \"\"\" def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"SessionUpdate\" : \"\"\"Initialize data class. This method will be called through the `/initialize` endpoint of the OTE-API Services. Parameters: session: A session-specific dictionary context. Returns: An update model of key/value-pairs to be stored in the session-specific context from services. \"\"\" get ( session = None ) \u00b6 Execute the strategy. Parameters: Name Type Description Default session 'Optional[Dict[str, Any]]' A session-specific dictionary context. None Returns: Type Description 'SessionUpdate' An update model of key/value-pairs to be stored in the 'SessionUpdate' session-specific context from services. Source code in oteapi/interfaces/iparsestrategy.py 17 18 19 20 21 22 23 24 25 26 27 def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"SessionUpdate\" : \"\"\"Execute the strategy. Parameters: session: A session-specific dictionary context. Returns: An update model of key/value-pairs to be stored in the session-specific context from services. \"\"\" initialize ( session = None ) \u00b6 Initialize data class. This method will be called through the /initialize endpoint of the OTE-API Services. Parameters: Name Type Description Default session 'Optional[Dict[str, Any]]' A session-specific dictionary context. None Returns: Type Description 'SessionUpdate' An update model of key/value-pairs to be stored in the 'SessionUpdate' session-specific context from services. Source code in oteapi/interfaces/iparsestrategy.py 29 30 31 32 33 34 35 36 37 38 39 40 41 42 def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"SessionUpdate\" : \"\"\"Initialize data class. This method will be called through the `/initialize` endpoint of the OTE-API Services. Parameters: session: A session-specific dictionary context. Returns: An update model of key/value-pairs to be stored in the session-specific context from services. \"\"\"","title":"iparsestrategy"},{"location":"api_reference/interfaces/iparsestrategy/#iparsestrategy","text":"Parse Strategy Interface","title":"iparsestrategy"},{"location":"api_reference/interfaces/iparsestrategy/#oteapi.interfaces.iparsestrategy.IParseStrategy","text":"Bases: Protocol Parse Strategy Interface. Source code in oteapi/interfaces/iparsestrategy.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 @dataclass # type: ignore[misc] class IParseStrategy ( Protocol ): \"\"\"Parse Strategy Interface.\"\"\" parse_config : \"ResourceConfig\" def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"SessionUpdate\" : \"\"\"Execute the strategy. Parameters: session: A session-specific dictionary context. Returns: An update model of key/value-pairs to be stored in the session-specific context from services. \"\"\" def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"SessionUpdate\" : \"\"\"Initialize data class. This method will be called through the `/initialize` endpoint of the OTE-API Services. Parameters: session: A session-specific dictionary context. Returns: An update model of key/value-pairs to be stored in the session-specific context from services. \"\"\"","title":"IParseStrategy"},{"location":"api_reference/interfaces/iparsestrategy/#oteapi.interfaces.iparsestrategy.IParseStrategy.get","text":"Execute the strategy. Parameters: Name Type Description Default session 'Optional[Dict[str, Any]]' A session-specific dictionary context. None Returns: Type Description 'SessionUpdate' An update model of key/value-pairs to be stored in the 'SessionUpdate' session-specific context from services. Source code in oteapi/interfaces/iparsestrategy.py 17 18 19 20 21 22 23 24 25 26 27 def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"SessionUpdate\" : \"\"\"Execute the strategy. Parameters: session: A session-specific dictionary context. Returns: An update model of key/value-pairs to be stored in the session-specific context from services. \"\"\"","title":"get()"},{"location":"api_reference/interfaces/iparsestrategy/#oteapi.interfaces.iparsestrategy.IParseStrategy.initialize","text":"Initialize data class. This method will be called through the /initialize endpoint of the OTE-API Services. Parameters: Name Type Description Default session 'Optional[Dict[str, Any]]' A session-specific dictionary context. None Returns: Type Description 'SessionUpdate' An update model of key/value-pairs to be stored in the 'SessionUpdate' session-specific context from services. Source code in oteapi/interfaces/iparsestrategy.py 29 30 31 32 33 34 35 36 37 38 39 40 41 42 def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"SessionUpdate\" : \"\"\"Initialize data class. This method will be called through the `/initialize` endpoint of the OTE-API Services. Parameters: session: A session-specific dictionary context. Returns: An update model of key/value-pairs to be stored in the session-specific context from services. \"\"\"","title":"initialize()"},{"location":"api_reference/interfaces/iresourcestrategy/","text":"iresourcestrategy \u00b6 Resource Strategy Interface IResourceStrategy \u00b6 Bases: Protocol Resource Strategy Interface. Source code in oteapi/interfaces/iresourcestrategy.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 @dataclass # type: ignore[misc] class IResourceStrategy ( Protocol ): \"\"\"Resource Strategy Interface.\"\"\" resource_config : \"ResourceConfig\" def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"SessionUpdate\" : \"\"\"Execute the strategy. Parameters: session: A session-specific dictionary context. Returns: An update model of key/value-pairs to be stored in the session-specific context from services. \"\"\" def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"SessionUpdate\" : \"\"\"Initialize data class. This method will be called through the `/initialize` endpoint of the OTE-API Services. Parameters: session: A session-specific dictionary context. Returns: An update model of key/value-pairs to be stored in the session-specific context from services. \"\"\" get ( session = None ) \u00b6 Execute the strategy. Parameters: Name Type Description Default session 'Optional[Dict[str, Any]]' A session-specific dictionary context. None Returns: Type Description 'SessionUpdate' An update model of key/value-pairs to be stored in the 'SessionUpdate' session-specific context from services. Source code in oteapi/interfaces/iresourcestrategy.py 17 18 19 20 21 22 23 24 25 26 27 def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"SessionUpdate\" : \"\"\"Execute the strategy. Parameters: session: A session-specific dictionary context. Returns: An update model of key/value-pairs to be stored in the session-specific context from services. \"\"\" initialize ( session = None ) \u00b6 Initialize data class. This method will be called through the /initialize endpoint of the OTE-API Services. Parameters: Name Type Description Default session 'Optional[Dict[str, Any]]' A session-specific dictionary context. None Returns: Type Description 'SessionUpdate' An update model of key/value-pairs to be stored in the 'SessionUpdate' session-specific context from services. Source code in oteapi/interfaces/iresourcestrategy.py 29 30 31 32 33 34 35 36 37 38 39 40 41 42 def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"SessionUpdate\" : \"\"\"Initialize data class. This method will be called through the `/initialize` endpoint of the OTE-API Services. Parameters: session: A session-specific dictionary context. Returns: An update model of key/value-pairs to be stored in the session-specific context from services. \"\"\"","title":"iresourcestrategy"},{"location":"api_reference/interfaces/iresourcestrategy/#iresourcestrategy","text":"Resource Strategy Interface","title":"iresourcestrategy"},{"location":"api_reference/interfaces/iresourcestrategy/#oteapi.interfaces.iresourcestrategy.IResourceStrategy","text":"Bases: Protocol Resource Strategy Interface. Source code in oteapi/interfaces/iresourcestrategy.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 @dataclass # type: ignore[misc] class IResourceStrategy ( Protocol ): \"\"\"Resource Strategy Interface.\"\"\" resource_config : \"ResourceConfig\" def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"SessionUpdate\" : \"\"\"Execute the strategy. Parameters: session: A session-specific dictionary context. Returns: An update model of key/value-pairs to be stored in the session-specific context from services. \"\"\" def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"SessionUpdate\" : \"\"\"Initialize data class. This method will be called through the `/initialize` endpoint of the OTE-API Services. Parameters: session: A session-specific dictionary context. Returns: An update model of key/value-pairs to be stored in the session-specific context from services. \"\"\"","title":"IResourceStrategy"},{"location":"api_reference/interfaces/iresourcestrategy/#oteapi.interfaces.iresourcestrategy.IResourceStrategy.get","text":"Execute the strategy. Parameters: Name Type Description Default session 'Optional[Dict[str, Any]]' A session-specific dictionary context. None Returns: Type Description 'SessionUpdate' An update model of key/value-pairs to be stored in the 'SessionUpdate' session-specific context from services. Source code in oteapi/interfaces/iresourcestrategy.py 17 18 19 20 21 22 23 24 25 26 27 def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"SessionUpdate\" : \"\"\"Execute the strategy. Parameters: session: A session-specific dictionary context. Returns: An update model of key/value-pairs to be stored in the session-specific context from services. \"\"\"","title":"get()"},{"location":"api_reference/interfaces/iresourcestrategy/#oteapi.interfaces.iresourcestrategy.IResourceStrategy.initialize","text":"Initialize data class. This method will be called through the /initialize endpoint of the OTE-API Services. Parameters: Name Type Description Default session 'Optional[Dict[str, Any]]' A session-specific dictionary context. None Returns: Type Description 'SessionUpdate' An update model of key/value-pairs to be stored in the 'SessionUpdate' session-specific context from services. Source code in oteapi/interfaces/iresourcestrategy.py 29 30 31 32 33 34 35 36 37 38 39 40 41 42 def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"SessionUpdate\" : \"\"\"Initialize data class. This method will be called through the `/initialize` endpoint of the OTE-API Services. Parameters: session: A session-specific dictionary context. Returns: An update model of key/value-pairs to be stored in the session-specific context from services. \"\"\"","title":"initialize()"},{"location":"api_reference/interfaces/itransformationstrategy/","text":"itransformationstrategy \u00b6 Tranformation Strategy Interface ITransformationStrategy \u00b6 Bases: Protocol Transformation Strategy Interface. Source code in oteapi/interfaces/itransformationstrategy.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 @dataclass # type: ignore[misc] class ITransformationStrategy ( Protocol ): \"\"\"Transformation Strategy Interface.\"\"\" transformation_config : \"TransformationConfig\" def run ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"SessionUpdate\" : \"\"\"Run a transformation job. Parameters: session: A session-specific dictionary context. Returns: An update model of key/value-pairs to be stored in the session-specific context from services. As a minimum, the dictionary will contain the job ID. \"\"\" def status ( self , task_id : str ) -> \"TransformationStatus\" : \"\"\"Get job status. Parameters: task_id: The transformation job ID. Returns: An overview of the transformation job's status, including relevant metadata. \"\"\" def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"SessionUpdate\" : \"\"\"Execute the strategy. Parameters: session: A session-specific dictionary context. Returns: An update model of key/value-pairs to be stored in the session-specific context from services. \"\"\" def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"SessionUpdate\" : \"\"\"Initialize data class. This method will be called through the `/initialize` endpoint of the OTE-API Services. Parameters: session: A session-specific dictionary context. Returns: An update model of key/value-pairs to be stored in the session-specific context from services. \"\"\" get ( session = None ) \u00b6 Execute the strategy. Parameters: Name Type Description Default session 'Optional[Dict[str, Any]]' A session-specific dictionary context. None Returns: Type Description 'SessionUpdate' An update model of key/value-pairs to be stored in the 'SessionUpdate' session-specific context from services. Source code in oteapi/interfaces/itransformationstrategy.py 42 43 44 45 46 47 48 49 50 51 52 def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"SessionUpdate\" : \"\"\"Execute the strategy. Parameters: session: A session-specific dictionary context. Returns: An update model of key/value-pairs to be stored in the session-specific context from services. \"\"\" initialize ( session = None ) \u00b6 Initialize data class. This method will be called through the /initialize endpoint of the OTE-API Services. Parameters: Name Type Description Default session 'Optional[Dict[str, Any]]' A session-specific dictionary context. None Returns: Type Description 'SessionUpdate' An update model of key/value-pairs to be stored in the 'SessionUpdate' session-specific context from services. Source code in oteapi/interfaces/itransformationstrategy.py 54 55 56 57 58 59 60 61 62 63 64 65 66 67 def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"SessionUpdate\" : \"\"\"Initialize data class. This method will be called through the `/initialize` endpoint of the OTE-API Services. Parameters: session: A session-specific dictionary context. Returns: An update model of key/value-pairs to be stored in the session-specific context from services. \"\"\" run ( session = None ) \u00b6 Run a transformation job. Parameters: Name Type Description Default session 'Optional[Dict[str, Any]]' A session-specific dictionary context. None Returns: Type Description 'SessionUpdate' An update model of key/value-pairs to be stored in the 'SessionUpdate' session-specific context from services. 'SessionUpdate' As a minimum, the dictionary will contain the job ID. Source code in oteapi/interfaces/itransformationstrategy.py 17 18 19 20 21 22 23 24 25 26 27 28 def run ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"SessionUpdate\" : \"\"\"Run a transformation job. Parameters: session: A session-specific dictionary context. Returns: An update model of key/value-pairs to be stored in the session-specific context from services. As a minimum, the dictionary will contain the job ID. \"\"\" status ( task_id ) \u00b6 Get job status. Parameters: Name Type Description Default task_id str The transformation job ID. required Returns: Type Description 'TransformationStatus' An overview of the transformation job's status, including relevant 'TransformationStatus' metadata. Source code in oteapi/interfaces/itransformationstrategy.py 30 31 32 33 34 35 36 37 38 39 40 def status ( self , task_id : str ) -> \"TransformationStatus\" : \"\"\"Get job status. Parameters: task_id: The transformation job ID. Returns: An overview of the transformation job's status, including relevant metadata. \"\"\"","title":"itransformationstrategy"},{"location":"api_reference/interfaces/itransformationstrategy/#itransformationstrategy","text":"Tranformation Strategy Interface","title":"itransformationstrategy"},{"location":"api_reference/interfaces/itransformationstrategy/#oteapi.interfaces.itransformationstrategy.ITransformationStrategy","text":"Bases: Protocol Transformation Strategy Interface. Source code in oteapi/interfaces/itransformationstrategy.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 @dataclass # type: ignore[misc] class ITransformationStrategy ( Protocol ): \"\"\"Transformation Strategy Interface.\"\"\" transformation_config : \"TransformationConfig\" def run ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"SessionUpdate\" : \"\"\"Run a transformation job. Parameters: session: A session-specific dictionary context. Returns: An update model of key/value-pairs to be stored in the session-specific context from services. As a minimum, the dictionary will contain the job ID. \"\"\" def status ( self , task_id : str ) -> \"TransformationStatus\" : \"\"\"Get job status. Parameters: task_id: The transformation job ID. Returns: An overview of the transformation job's status, including relevant metadata. \"\"\" def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"SessionUpdate\" : \"\"\"Execute the strategy. Parameters: session: A session-specific dictionary context. Returns: An update model of key/value-pairs to be stored in the session-specific context from services. \"\"\" def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"SessionUpdate\" : \"\"\"Initialize data class. This method will be called through the `/initialize` endpoint of the OTE-API Services. Parameters: session: A session-specific dictionary context. Returns: An update model of key/value-pairs to be stored in the session-specific context from services. \"\"\"","title":"ITransformationStrategy"},{"location":"api_reference/interfaces/itransformationstrategy/#oteapi.interfaces.itransformationstrategy.ITransformationStrategy.get","text":"Execute the strategy. Parameters: Name Type Description Default session 'Optional[Dict[str, Any]]' A session-specific dictionary context. None Returns: Type Description 'SessionUpdate' An update model of key/value-pairs to be stored in the 'SessionUpdate' session-specific context from services. Source code in oteapi/interfaces/itransformationstrategy.py 42 43 44 45 46 47 48 49 50 51 52 def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"SessionUpdate\" : \"\"\"Execute the strategy. Parameters: session: A session-specific dictionary context. Returns: An update model of key/value-pairs to be stored in the session-specific context from services. \"\"\"","title":"get()"},{"location":"api_reference/interfaces/itransformationstrategy/#oteapi.interfaces.itransformationstrategy.ITransformationStrategy.initialize","text":"Initialize data class. This method will be called through the /initialize endpoint of the OTE-API Services. Parameters: Name Type Description Default session 'Optional[Dict[str, Any]]' A session-specific dictionary context. None Returns: Type Description 'SessionUpdate' An update model of key/value-pairs to be stored in the 'SessionUpdate' session-specific context from services. Source code in oteapi/interfaces/itransformationstrategy.py 54 55 56 57 58 59 60 61 62 63 64 65 66 67 def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"SessionUpdate\" : \"\"\"Initialize data class. This method will be called through the `/initialize` endpoint of the OTE-API Services. Parameters: session: A session-specific dictionary context. Returns: An update model of key/value-pairs to be stored in the session-specific context from services. \"\"\"","title":"initialize()"},{"location":"api_reference/interfaces/itransformationstrategy/#oteapi.interfaces.itransformationstrategy.ITransformationStrategy.run","text":"Run a transformation job. Parameters: Name Type Description Default session 'Optional[Dict[str, Any]]' A session-specific dictionary context. None Returns: Type Description 'SessionUpdate' An update model of key/value-pairs to be stored in the 'SessionUpdate' session-specific context from services. 'SessionUpdate' As a minimum, the dictionary will contain the job ID. Source code in oteapi/interfaces/itransformationstrategy.py 17 18 19 20 21 22 23 24 25 26 27 28 def run ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"SessionUpdate\" : \"\"\"Run a transformation job. Parameters: session: A session-specific dictionary context. Returns: An update model of key/value-pairs to be stored in the session-specific context from services. As a minimum, the dictionary will contain the job ID. \"\"\"","title":"run()"},{"location":"api_reference/interfaces/itransformationstrategy/#oteapi.interfaces.itransformationstrategy.ITransformationStrategy.status","text":"Get job status. Parameters: Name Type Description Default task_id str The transformation job ID. required Returns: Type Description 'TransformationStatus' An overview of the transformation job's status, including relevant 'TransformationStatus' metadata. Source code in oteapi/interfaces/itransformationstrategy.py 30 31 32 33 34 35 36 37 38 39 40 def status ( self , task_id : str ) -> \"TransformationStatus\" : \"\"\"Get job status. Parameters: task_id: The transformation job ID. Returns: An overview of the transformation job's status, including relevant metadata. \"\"\"","title":"status()"},{"location":"api_reference/models/datacacheconfig/","text":"datacacheconfig \u00b6 Pydantic DataCache Configuration Data Model. DataCacheConfig \u00b6 Bases: AttrDict DataCache Configuration. This class should not be used directly as a configuration object for a strategy object, but only as a configuration field inside a configuration object. Source code in oteapi/models/datacacheconfig.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 class DataCacheConfig ( AttrDict ): \"\"\"DataCache Configuration. This class should not be used directly as a configuration object for a strategy object, but only as a configuration field inside a configuration object. \"\"\" cacheDir : Path = Field ( Path ( \"oteapi\" ), description = \"Cache directory.\" ) accessKey : Optional [ str ] = Field ( None , description = \"Key with which the downloaded content can be accessed. \" \"Should preferable be the hash (corresponding to `hashType`) of the \" \"content if it is known.\" , ) hashType : str = Field ( \"md5\" , description = \"Hash algorithm to use for creating hash keys for stored \" \"data. Can be any algorithm supported by hashlib.\" , ) expireTime : int = Field ( 3600 * 24 * 14 , description = \"Number of seconds before the cache entry expires. \" \"Zero means no expiration. Default is two weeks.\" , ) tag : Optional [ str ] = Field ( None , description = \"Tag assigned to the downloaded content, typically \" \"identifying a session. Used with the `evict()` method to clean up a \" \"all cache entries with a given tag.\" , ) accessKey : Optional [ str ] = Field ( None , description = 'Key with which the downloaded content can be accessed. Should preferable be the hash (corresponding to `hashType`) of the content if it is known.' ) class-attribute \u00b6 cacheDir : Path = Field ( Path ( 'oteapi' ), description = 'Cache directory.' ) class-attribute \u00b6 expireTime : int = Field ( 3600 * 24 * 14 , description = 'Number of seconds before the cache entry expires. Zero means no expiration. Default is two weeks.' ) class-attribute \u00b6 hashType : str = Field ( 'md5' , description = 'Hash algorithm to use for creating hash keys for stored data. Can be any algorithm supported by hashlib.' ) class-attribute \u00b6 tag : Optional [ str ] = Field ( None , description = 'Tag assigned to the downloaded content, typically identifying a session. Used with the `evict()` method to clean up a all cache entries with a given tag.' ) class-attribute \u00b6","title":"datacacheconfig"},{"location":"api_reference/models/datacacheconfig/#datacacheconfig","text":"Pydantic DataCache Configuration Data Model.","title":"datacacheconfig"},{"location":"api_reference/models/datacacheconfig/#oteapi.models.datacacheconfig.DataCacheConfig","text":"Bases: AttrDict DataCache Configuration. This class should not be used directly as a configuration object for a strategy object, but only as a configuration field inside a configuration object. Source code in oteapi/models/datacacheconfig.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 class DataCacheConfig ( AttrDict ): \"\"\"DataCache Configuration. This class should not be used directly as a configuration object for a strategy object, but only as a configuration field inside a configuration object. \"\"\" cacheDir : Path = Field ( Path ( \"oteapi\" ), description = \"Cache directory.\" ) accessKey : Optional [ str ] = Field ( None , description = \"Key with which the downloaded content can be accessed. \" \"Should preferable be the hash (corresponding to `hashType`) of the \" \"content if it is known.\" , ) hashType : str = Field ( \"md5\" , description = \"Hash algorithm to use for creating hash keys for stored \" \"data. Can be any algorithm supported by hashlib.\" , ) expireTime : int = Field ( 3600 * 24 * 14 , description = \"Number of seconds before the cache entry expires. \" \"Zero means no expiration. Default is two weeks.\" , ) tag : Optional [ str ] = Field ( None , description = \"Tag assigned to the downloaded content, typically \" \"identifying a session. Used with the `evict()` method to clean up a \" \"all cache entries with a given tag.\" , )","title":"DataCacheConfig"},{"location":"api_reference/models/datacacheconfig/#oteapi.models.datacacheconfig.DataCacheConfig.accessKey","text":"","title":"accessKey"},{"location":"api_reference/models/datacacheconfig/#oteapi.models.datacacheconfig.DataCacheConfig.cacheDir","text":"","title":"cacheDir"},{"location":"api_reference/models/datacacheconfig/#oteapi.models.datacacheconfig.DataCacheConfig.expireTime","text":"","title":"expireTime"},{"location":"api_reference/models/datacacheconfig/#oteapi.models.datacacheconfig.DataCacheConfig.hashType","text":"","title":"hashType"},{"location":"api_reference/models/datacacheconfig/#oteapi.models.datacacheconfig.DataCacheConfig.tag","text":"","title":"tag"},{"location":"api_reference/models/filterconfig/","text":"filterconfig \u00b6 Pydantic Filter Configuration Data Model. FilterConfig \u00b6 Bases: GenericConfig Filter Strategy Data Configuration. Source code in oteapi/models/filterconfig.py 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class FilterConfig ( GenericConfig ): \"\"\"Filter Strategy Data Configuration.\"\"\" filterType : str = Field ( ... , description = \"Type of registered filter strategy. E.g., `filter/sql`.\" ) query : Optional [ str ] = Field ( None , description = \"Define a query operation.\" ) condition : Optional [ str ] = Field ( None , description = \"Logical statement indicating when a filter should be applied.\" , ) limit : Optional [ int ] = Field ( None , description = \"Number of items remaining after a filter expression.\" ) condition : Optional [ str ] = Field ( None , description = 'Logical statement indicating when a filter should be applied.' ) class-attribute \u00b6 filterType : str = Field ( Ellipsis , description = 'Type of registered filter strategy. E.g., `filter/sql`.' ) class-attribute \u00b6 limit : Optional [ int ] = Field ( None , description = 'Number of items remaining after a filter expression.' ) class-attribute \u00b6 query : Optional [ str ] = Field ( None , description = 'Define a query operation.' ) class-attribute \u00b6","title":"filterconfig"},{"location":"api_reference/models/filterconfig/#filterconfig","text":"Pydantic Filter Configuration Data Model.","title":"filterconfig"},{"location":"api_reference/models/filterconfig/#oteapi.models.filterconfig.FilterConfig","text":"Bases: GenericConfig Filter Strategy Data Configuration. Source code in oteapi/models/filterconfig.py 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class FilterConfig ( GenericConfig ): \"\"\"Filter Strategy Data Configuration.\"\"\" filterType : str = Field ( ... , description = \"Type of registered filter strategy. E.g., `filter/sql`.\" ) query : Optional [ str ] = Field ( None , description = \"Define a query operation.\" ) condition : Optional [ str ] = Field ( None , description = \"Logical statement indicating when a filter should be applied.\" , ) limit : Optional [ int ] = Field ( None , description = \"Number of items remaining after a filter expression.\" )","title":"FilterConfig"},{"location":"api_reference/models/filterconfig/#oteapi.models.filterconfig.FilterConfig.condition","text":"","title":"condition"},{"location":"api_reference/models/filterconfig/#oteapi.models.filterconfig.FilterConfig.filterType","text":"","title":"filterType"},{"location":"api_reference/models/filterconfig/#oteapi.models.filterconfig.FilterConfig.limit","text":"","title":"limit"},{"location":"api_reference/models/filterconfig/#oteapi.models.filterconfig.FilterConfig.query","text":"","title":"query"},{"location":"api_reference/models/functionconfig/","text":"functionconfig \u00b6 Pydantic Function Configuration Data Model. FunctionConfig \u00b6 Bases: GenericConfig Function Strategy Data Configuration. Source code in oteapi/models/functionconfig.py 7 8 9 10 11 12 13 class FunctionConfig ( GenericConfig ): \"\"\"Function Strategy Data Configuration.\"\"\" functionType : str = Field ( ... , description = ( \"Type of registered function strategy.\" ), ) functionType : str = Field ( Ellipsis , description = 'Type of registered function strategy.' ) class-attribute \u00b6","title":"functionconfig"},{"location":"api_reference/models/functionconfig/#functionconfig","text":"Pydantic Function Configuration Data Model.","title":"functionconfig"},{"location":"api_reference/models/functionconfig/#oteapi.models.functionconfig.FunctionConfig","text":"Bases: GenericConfig Function Strategy Data Configuration. Source code in oteapi/models/functionconfig.py 7 8 9 10 11 12 13 class FunctionConfig ( GenericConfig ): \"\"\"Function Strategy Data Configuration.\"\"\" functionType : str = Field ( ... , description = ( \"Type of registered function strategy.\" ), )","title":"FunctionConfig"},{"location":"api_reference/models/functionconfig/#oteapi.models.functionconfig.FunctionConfig.functionType","text":"","title":"functionType"},{"location":"api_reference/models/genericconfig/","text":"genericconfig \u00b6 Generic data model for configuration attributes. AttrDict \u00b6 Bases: BaseModel , Mapping An object whose attributes can also be accessed through subscription, like with a dictionary. Source code in oteapi/models/genericconfig.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 class AttrDict ( BaseModel , Mapping ): \"\"\"An object whose attributes can also be accessed through subscription, like with a dictionary.\"\"\" def __contains__ ( self , name : \"Any\" ) -> bool : \"\"\"Enable using the 'in' operator on this object.\"\"\" return self . __dict__ . __contains__ ( name ) def __delitem__ ( self , key : str ) -> None : \"\"\"Enable deletion access through subscription. If the item is a pydantic field, reset it and remove it from the set of set fields. Otherwise, delete the attribute. \"\"\" if key in self . __dict__ : if key in self . __fields__ : # Reset field to default and remove from set of set fields setattr ( self , key , self . __fields__ [ key ] . default ) self . __fields_set__ . remove ( key ) # pylint: disable=no-member else : self . __delattr__ ( key ) else : raise KeyError ( key ) def __getitem__ ( self , key : str ) -> \"Any\" : \"\"\"Enable read access through subscription.\"\"\" if key in self . __dict__ : return getattr ( self , key ) raise KeyError ( key ) def __setitem__ ( self , key : str , value : \"Any\" ) -> None : \"\"\"Enable write access through subscription.\"\"\" setattr ( self , key , value ) def __len__ ( self ): \"\"\"Return number of items.\"\"\" return self . __dict__ . __len__ () def __iter__ ( self ): \"\"\"Enable **unpacking.\"\"\" return self . __dict__ . __iter__ () def items ( self ): \"\"\"Return a view of all (key, value) pairs.\"\"\" return self . __dict__ . items () def keys ( self ): \"\"\"Return a view of all keys.\"\"\" return self . __dict__ . keys () def values ( self ): \"\"\"Return a view of all values.\"\"\" return self . __dict__ . values () def get ( self , key : str , default : \"Optional[Any]\" = None ) -> \"Any\" : \"\"\"Mapping `get`-method.\"\"\" return self . __dict__ . get ( key , default ) def __ne__ ( self , other : \"Any\" ) -> bool : \"\"\"Implement the != operator.\"\"\" if isinstance ( other , BaseModel ): return self . dict () != other . dict () return self . dict () != other def update ( self , other : \"Optional[Union[dict, AttrDict, Iterable[Any]]]\" = None , ** kwargs ) -> None : \"\"\"MutableMapping `update`-method.\"\"\" if other and isinstance ( other , ( dict , Mapping )): for key , value in other . items (): setattr ( self , key , value ) elif other and isinstance ( other , BaseModel ): for key , value in other . dict () . items (): setattr ( self , key , value ) elif other and isinstance ( other , Iterable ): for entry in other : if not len ( entry ) == 2 : raise ValueError ( \"`other` must be an iterable of objects of length two.\" ) for key , value in other : setattr ( self , key , value ) if kwargs : for key , value in kwargs . items (): setattr ( self , key , value ) def pop ( self , key : str , default : \"Optional[Any]\" = Undefined ) -> \"Any\" : \"\"\"MutableMapping `pop`-method.\"\"\" value = self . get ( key , default ) if value == Undefined : raise KeyError ( key ) if key in self : del self [ key ] return value def popitem ( self ) -> \"Tuple[str, Any]\" : \"\"\"MutableMapping `popitem`-method. Important: Unlike the regular `dict.popitem()` method, this one does _not_ respect LIFO (last-in, first-out). This is due to the fact that attributes are stored in a random order when initializing the model. However, it will respect LIFO with respect to the internal `__dict__`. \"\"\" if not self : raise KeyError ( f \"popitem(): { self . __class__ . __name__ } is empty\" ) key = list ( self . __dict__ )[ - 1 ] value = self . pop ( key ) return key , value class Config : \"\"\"Pydantic configuration for `AttrDict`. * **`extra`** Allow any attributes/fields to be defined - this is what makes this pydantic model an attribute dictionary. * **`validate_assignment`** Validate and cast set values. This is mainly relevant for sub-classes of `AttrDict`, where specific attributes have been defined. * **`arbitrary_types_allowed`** If a custom type is used for an attribute that doesn't have a `validate()` method, don't fail setting the attribute. \"\"\" extra = \"allow\" validate_assignment = True arbitrary_types_allowed = True Config \u00b6 Pydantic configuration for AttrDict . extra Allow any attributes/fields to be defined - this is what makes this pydantic model an attribute dictionary. validate_assignment Validate and cast set values. This is mainly relevant for sub-classes of AttrDict , where specific attributes have been defined. arbitrary_types_allowed If a custom type is used for an attribute that doesn't have a validate() method, don't fail setting the attribute. Source code in oteapi/models/genericconfig.py 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 class Config : \"\"\"Pydantic configuration for `AttrDict`. * **`extra`** Allow any attributes/fields to be defined - this is what makes this pydantic model an attribute dictionary. * **`validate_assignment`** Validate and cast set values. This is mainly relevant for sub-classes of `AttrDict`, where specific attributes have been defined. * **`arbitrary_types_allowed`** If a custom type is used for an attribute that doesn't have a `validate()` method, don't fail setting the attribute. \"\"\" extra = \"allow\" validate_assignment = True arbitrary_types_allowed = True arbitrary_types_allowed = True class-attribute \u00b6 extra = 'allow' class-attribute \u00b6 validate_assignment = True class-attribute \u00b6 __contains__ ( name ) \u00b6 Enable using the 'in' operator on this object. Source code in oteapi/models/genericconfig.py 15 16 17 def __contains__ ( self , name : \"Any\" ) -> bool : \"\"\"Enable using the 'in' operator on this object.\"\"\" return self . __dict__ . __contains__ ( name ) __delitem__ ( key ) \u00b6 Enable deletion access through subscription. If the item is a pydantic field, reset it and remove it from the set of set fields. Otherwise, delete the attribute. Source code in oteapi/models/genericconfig.py 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 def __delitem__ ( self , key : str ) -> None : \"\"\"Enable deletion access through subscription. If the item is a pydantic field, reset it and remove it from the set of set fields. Otherwise, delete the attribute. \"\"\" if key in self . __dict__ : if key in self . __fields__ : # Reset field to default and remove from set of set fields setattr ( self , key , self . __fields__ [ key ] . default ) self . __fields_set__ . remove ( key ) # pylint: disable=no-member else : self . __delattr__ ( key ) else : raise KeyError ( key ) __getitem__ ( key ) \u00b6 Enable read access through subscription. Source code in oteapi/models/genericconfig.py 36 37 38 39 40 def __getitem__ ( self , key : str ) -> \"Any\" : \"\"\"Enable read access through subscription.\"\"\" if key in self . __dict__ : return getattr ( self , key ) raise KeyError ( key ) __iter__ () \u00b6 Enable **unpacking. Source code in oteapi/models/genericconfig.py 50 51 52 def __iter__ ( self ): \"\"\"Enable **unpacking.\"\"\" return self . __dict__ . __iter__ () __len__ () \u00b6 Return number of items. Source code in oteapi/models/genericconfig.py 46 47 48 def __len__ ( self ): \"\"\"Return number of items.\"\"\" return self . __dict__ . __len__ () __ne__ ( other ) \u00b6 Implement the != operator. Source code in oteapi/models/genericconfig.py 70 71 72 73 74 def __ne__ ( self , other : \"Any\" ) -> bool : \"\"\"Implement the != operator.\"\"\" if isinstance ( other , BaseModel ): return self . dict () != other . dict () return self . dict () != other __setitem__ ( key , value ) \u00b6 Enable write access through subscription. Source code in oteapi/models/genericconfig.py 42 43 44 def __setitem__ ( self , key : str , value : \"Any\" ) -> None : \"\"\"Enable write access through subscription.\"\"\" setattr ( self , key , value ) get ( key , default = None ) \u00b6 Mapping get -method. Source code in oteapi/models/genericconfig.py 66 67 68 def get ( self , key : str , default : \"Optional[Any]\" = None ) -> \"Any\" : \"\"\"Mapping `get`-method.\"\"\" return self . __dict__ . get ( key , default ) items () \u00b6 Return a view of all (key, value) pairs. Source code in oteapi/models/genericconfig.py 54 55 56 def items ( self ): \"\"\"Return a view of all (key, value) pairs.\"\"\" return self . __dict__ . items () keys () \u00b6 Return a view of all keys. Source code in oteapi/models/genericconfig.py 58 59 60 def keys ( self ): \"\"\"Return a view of all keys.\"\"\" return self . __dict__ . keys () pop ( key , default = Undefined ) \u00b6 MutableMapping pop -method. Source code in oteapi/models/genericconfig.py 98 99 100 101 102 103 104 105 def pop ( self , key : str , default : \"Optional[Any]\" = Undefined ) -> \"Any\" : \"\"\"MutableMapping `pop`-method.\"\"\" value = self . get ( key , default ) if value == Undefined : raise KeyError ( key ) if key in self : del self [ key ] return value popitem () \u00b6 MutableMapping popitem -method. Important Unlike the regular dict.popitem() method, this one does not respect LIFO (last-in, first-out). This is due to the fact that attributes are stored in a random order when initializing the model. However, it will respect LIFO with respect to the internal __dict__ . Source code in oteapi/models/genericconfig.py 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 def popitem ( self ) -> \"Tuple[str, Any]\" : \"\"\"MutableMapping `popitem`-method. Important: Unlike the regular `dict.popitem()` method, this one does _not_ respect LIFO (last-in, first-out). This is due to the fact that attributes are stored in a random order when initializing the model. However, it will respect LIFO with respect to the internal `__dict__`. \"\"\" if not self : raise KeyError ( f \"popitem(): { self . __class__ . __name__ } is empty\" ) key = list ( self . __dict__ )[ - 1 ] value = self . pop ( key ) return key , value update ( other = None , ** kwargs ) \u00b6 MutableMapping update -method. Source code in oteapi/models/genericconfig.py 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 def update ( self , other : \"Optional[Union[dict, AttrDict, Iterable[Any]]]\" = None , ** kwargs ) -> None : \"\"\"MutableMapping `update`-method.\"\"\" if other and isinstance ( other , ( dict , Mapping )): for key , value in other . items (): setattr ( self , key , value ) elif other and isinstance ( other , BaseModel ): for key , value in other . dict () . items (): setattr ( self , key , value ) elif other and isinstance ( other , Iterable ): for entry in other : if not len ( entry ) == 2 : raise ValueError ( \"`other` must be an iterable of objects of length two.\" ) for key , value in other : setattr ( self , key , value ) if kwargs : for key , value in kwargs . items (): setattr ( self , key , value ) values () \u00b6 Return a view of all values. Source code in oteapi/models/genericconfig.py 62 63 64 def values ( self ): \"\"\"Return a view of all values.\"\"\" return self . __dict__ . values () GenericConfig \u00b6 Bases: BaseModel Generic class for configuration objects. Source code in oteapi/models/genericconfig.py 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 class GenericConfig ( BaseModel ): \"\"\"Generic class for configuration objects.\"\"\" configuration : AttrDict = Field ( AttrDict (), description = \"Model-specific configuration options which can either \" \"be given as key/value-pairs or set as attributes.\" , ) description : str = Field ( __doc__ , description = \"A description of the configuration model.\" , ) @classmethod def __init_subclass__ ( cls ) -> None : \"\"\"Initialize subclass descriptions with their docstrings.\"\"\" cls . __fields__ [ \"description\" ] . default = cls . __doc__ class Config : \"\"\"Pydantic configuration for `GenericConfig`. * **`validate_assignment`** Validate and cast set values. This is mainly relevant for sub-classes of `AttrDict`, where specific attributes have been defined. * **`arbitrary_types_allowed`** If a custom type is used for an attribute that doesn't have a `validate()` method, don't fail setting the attribute. \"\"\" validate_assignment = True arbitrary_types_allowed = True configuration : AttrDict = Field ( AttrDict (), description = 'Model-specific configuration options which can either be given as key/value-pairs or set as attributes.' ) class-attribute \u00b6 description : str = Field ( __doc__ , description = 'A description of the configuration model.' ) class-attribute \u00b6 Config \u00b6 Pydantic configuration for GenericConfig . validate_assignment Validate and cast set values. This is mainly relevant for sub-classes of AttrDict , where specific attributes have been defined. arbitrary_types_allowed If a custom type is used for an attribute that doesn't have a validate() method, don't fail setting the attribute. Source code in oteapi/models/genericconfig.py 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 class Config : \"\"\"Pydantic configuration for `GenericConfig`. * **`validate_assignment`** Validate and cast set values. This is mainly relevant for sub-classes of `AttrDict`, where specific attributes have been defined. * **`arbitrary_types_allowed`** If a custom type is used for an attribute that doesn't have a `validate()` method, don't fail setting the attribute. \"\"\" validate_assignment = True arbitrary_types_allowed = True arbitrary_types_allowed = True class-attribute \u00b6 validate_assignment = True class-attribute \u00b6 __init_subclass__ () classmethod \u00b6 Initialize subclass descriptions with their docstrings. Source code in oteapi/models/genericconfig.py 161 162 163 164 @classmethod def __init_subclass__ ( cls ) -> None : \"\"\"Initialize subclass descriptions with their docstrings.\"\"\" cls . __fields__ [ \"description\" ] . default = cls . __doc__","title":"genericconfig"},{"location":"api_reference/models/genericconfig/#genericconfig","text":"Generic data model for configuration attributes.","title":"genericconfig"},{"location":"api_reference/models/genericconfig/#oteapi.models.genericconfig.AttrDict","text":"Bases: BaseModel , Mapping An object whose attributes can also be accessed through subscription, like with a dictionary. Source code in oteapi/models/genericconfig.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 class AttrDict ( BaseModel , Mapping ): \"\"\"An object whose attributes can also be accessed through subscription, like with a dictionary.\"\"\" def __contains__ ( self , name : \"Any\" ) -> bool : \"\"\"Enable using the 'in' operator on this object.\"\"\" return self . __dict__ . __contains__ ( name ) def __delitem__ ( self , key : str ) -> None : \"\"\"Enable deletion access through subscription. If the item is a pydantic field, reset it and remove it from the set of set fields. Otherwise, delete the attribute. \"\"\" if key in self . __dict__ : if key in self . __fields__ : # Reset field to default and remove from set of set fields setattr ( self , key , self . __fields__ [ key ] . default ) self . __fields_set__ . remove ( key ) # pylint: disable=no-member else : self . __delattr__ ( key ) else : raise KeyError ( key ) def __getitem__ ( self , key : str ) -> \"Any\" : \"\"\"Enable read access through subscription.\"\"\" if key in self . __dict__ : return getattr ( self , key ) raise KeyError ( key ) def __setitem__ ( self , key : str , value : \"Any\" ) -> None : \"\"\"Enable write access through subscription.\"\"\" setattr ( self , key , value ) def __len__ ( self ): \"\"\"Return number of items.\"\"\" return self . __dict__ . __len__ () def __iter__ ( self ): \"\"\"Enable **unpacking.\"\"\" return self . __dict__ . __iter__ () def items ( self ): \"\"\"Return a view of all (key, value) pairs.\"\"\" return self . __dict__ . items () def keys ( self ): \"\"\"Return a view of all keys.\"\"\" return self . __dict__ . keys () def values ( self ): \"\"\"Return a view of all values.\"\"\" return self . __dict__ . values () def get ( self , key : str , default : \"Optional[Any]\" = None ) -> \"Any\" : \"\"\"Mapping `get`-method.\"\"\" return self . __dict__ . get ( key , default ) def __ne__ ( self , other : \"Any\" ) -> bool : \"\"\"Implement the != operator.\"\"\" if isinstance ( other , BaseModel ): return self . dict () != other . dict () return self . dict () != other def update ( self , other : \"Optional[Union[dict, AttrDict, Iterable[Any]]]\" = None , ** kwargs ) -> None : \"\"\"MutableMapping `update`-method.\"\"\" if other and isinstance ( other , ( dict , Mapping )): for key , value in other . items (): setattr ( self , key , value ) elif other and isinstance ( other , BaseModel ): for key , value in other . dict () . items (): setattr ( self , key , value ) elif other and isinstance ( other , Iterable ): for entry in other : if not len ( entry ) == 2 : raise ValueError ( \"`other` must be an iterable of objects of length two.\" ) for key , value in other : setattr ( self , key , value ) if kwargs : for key , value in kwargs . items (): setattr ( self , key , value ) def pop ( self , key : str , default : \"Optional[Any]\" = Undefined ) -> \"Any\" : \"\"\"MutableMapping `pop`-method.\"\"\" value = self . get ( key , default ) if value == Undefined : raise KeyError ( key ) if key in self : del self [ key ] return value def popitem ( self ) -> \"Tuple[str, Any]\" : \"\"\"MutableMapping `popitem`-method. Important: Unlike the regular `dict.popitem()` method, this one does _not_ respect LIFO (last-in, first-out). This is due to the fact that attributes are stored in a random order when initializing the model. However, it will respect LIFO with respect to the internal `__dict__`. \"\"\" if not self : raise KeyError ( f \"popitem(): { self . __class__ . __name__ } is empty\" ) key = list ( self . __dict__ )[ - 1 ] value = self . pop ( key ) return key , value class Config : \"\"\"Pydantic configuration for `AttrDict`. * **`extra`** Allow any attributes/fields to be defined - this is what makes this pydantic model an attribute dictionary. * **`validate_assignment`** Validate and cast set values. This is mainly relevant for sub-classes of `AttrDict`, where specific attributes have been defined. * **`arbitrary_types_allowed`** If a custom type is used for an attribute that doesn't have a `validate()` method, don't fail setting the attribute. \"\"\" extra = \"allow\" validate_assignment = True arbitrary_types_allowed = True","title":"AttrDict"},{"location":"api_reference/models/genericconfig/#oteapi.models.genericconfig.AttrDict.Config","text":"Pydantic configuration for AttrDict . extra Allow any attributes/fields to be defined - this is what makes this pydantic model an attribute dictionary. validate_assignment Validate and cast set values. This is mainly relevant for sub-classes of AttrDict , where specific attributes have been defined. arbitrary_types_allowed If a custom type is used for an attribute that doesn't have a validate() method, don't fail setting the attribute. Source code in oteapi/models/genericconfig.py 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 class Config : \"\"\"Pydantic configuration for `AttrDict`. * **`extra`** Allow any attributes/fields to be defined - this is what makes this pydantic model an attribute dictionary. * **`validate_assignment`** Validate and cast set values. This is mainly relevant for sub-classes of `AttrDict`, where specific attributes have been defined. * **`arbitrary_types_allowed`** If a custom type is used for an attribute that doesn't have a `validate()` method, don't fail setting the attribute. \"\"\" extra = \"allow\" validate_assignment = True arbitrary_types_allowed = True","title":"Config"},{"location":"api_reference/models/genericconfig/#oteapi.models.genericconfig.AttrDict.Config.arbitrary_types_allowed","text":"","title":"arbitrary_types_allowed"},{"location":"api_reference/models/genericconfig/#oteapi.models.genericconfig.AttrDict.Config.extra","text":"","title":"extra"},{"location":"api_reference/models/genericconfig/#oteapi.models.genericconfig.AttrDict.Config.validate_assignment","text":"","title":"validate_assignment"},{"location":"api_reference/models/genericconfig/#oteapi.models.genericconfig.AttrDict.__contains__","text":"Enable using the 'in' operator on this object. Source code in oteapi/models/genericconfig.py 15 16 17 def __contains__ ( self , name : \"Any\" ) -> bool : \"\"\"Enable using the 'in' operator on this object.\"\"\" return self . __dict__ . __contains__ ( name )","title":"__contains__()"},{"location":"api_reference/models/genericconfig/#oteapi.models.genericconfig.AttrDict.__delitem__","text":"Enable deletion access through subscription. If the item is a pydantic field, reset it and remove it from the set of set fields. Otherwise, delete the attribute. Source code in oteapi/models/genericconfig.py 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 def __delitem__ ( self , key : str ) -> None : \"\"\"Enable deletion access through subscription. If the item is a pydantic field, reset it and remove it from the set of set fields. Otherwise, delete the attribute. \"\"\" if key in self . __dict__ : if key in self . __fields__ : # Reset field to default and remove from set of set fields setattr ( self , key , self . __fields__ [ key ] . default ) self . __fields_set__ . remove ( key ) # pylint: disable=no-member else : self . __delattr__ ( key ) else : raise KeyError ( key )","title":"__delitem__()"},{"location":"api_reference/models/genericconfig/#oteapi.models.genericconfig.AttrDict.__getitem__","text":"Enable read access through subscription. Source code in oteapi/models/genericconfig.py 36 37 38 39 40 def __getitem__ ( self , key : str ) -> \"Any\" : \"\"\"Enable read access through subscription.\"\"\" if key in self . __dict__ : return getattr ( self , key ) raise KeyError ( key )","title":"__getitem__()"},{"location":"api_reference/models/genericconfig/#oteapi.models.genericconfig.AttrDict.__iter__","text":"Enable **unpacking. Source code in oteapi/models/genericconfig.py 50 51 52 def __iter__ ( self ): \"\"\"Enable **unpacking.\"\"\" return self . __dict__ . __iter__ ()","title":"__iter__()"},{"location":"api_reference/models/genericconfig/#oteapi.models.genericconfig.AttrDict.__len__","text":"Return number of items. Source code in oteapi/models/genericconfig.py 46 47 48 def __len__ ( self ): \"\"\"Return number of items.\"\"\" return self . __dict__ . __len__ ()","title":"__len__()"},{"location":"api_reference/models/genericconfig/#oteapi.models.genericconfig.AttrDict.__ne__","text":"Implement the != operator. Source code in oteapi/models/genericconfig.py 70 71 72 73 74 def __ne__ ( self , other : \"Any\" ) -> bool : \"\"\"Implement the != operator.\"\"\" if isinstance ( other , BaseModel ): return self . dict () != other . dict () return self . dict () != other","title":"__ne__()"},{"location":"api_reference/models/genericconfig/#oteapi.models.genericconfig.AttrDict.__setitem__","text":"Enable write access through subscription. Source code in oteapi/models/genericconfig.py 42 43 44 def __setitem__ ( self , key : str , value : \"Any\" ) -> None : \"\"\"Enable write access through subscription.\"\"\" setattr ( self , key , value )","title":"__setitem__()"},{"location":"api_reference/models/genericconfig/#oteapi.models.genericconfig.AttrDict.get","text":"Mapping get -method. Source code in oteapi/models/genericconfig.py 66 67 68 def get ( self , key : str , default : \"Optional[Any]\" = None ) -> \"Any\" : \"\"\"Mapping `get`-method.\"\"\" return self . __dict__ . get ( key , default )","title":"get()"},{"location":"api_reference/models/genericconfig/#oteapi.models.genericconfig.AttrDict.items","text":"Return a view of all (key, value) pairs. Source code in oteapi/models/genericconfig.py 54 55 56 def items ( self ): \"\"\"Return a view of all (key, value) pairs.\"\"\" return self . __dict__ . items ()","title":"items()"},{"location":"api_reference/models/genericconfig/#oteapi.models.genericconfig.AttrDict.keys","text":"Return a view of all keys. Source code in oteapi/models/genericconfig.py 58 59 60 def keys ( self ): \"\"\"Return a view of all keys.\"\"\" return self . __dict__ . keys ()","title":"keys()"},{"location":"api_reference/models/genericconfig/#oteapi.models.genericconfig.AttrDict.pop","text":"MutableMapping pop -method. Source code in oteapi/models/genericconfig.py 98 99 100 101 102 103 104 105 def pop ( self , key : str , default : \"Optional[Any]\" = Undefined ) -> \"Any\" : \"\"\"MutableMapping `pop`-method.\"\"\" value = self . get ( key , default ) if value == Undefined : raise KeyError ( key ) if key in self : del self [ key ] return value","title":"pop()"},{"location":"api_reference/models/genericconfig/#oteapi.models.genericconfig.AttrDict.popitem","text":"MutableMapping popitem -method. Important Unlike the regular dict.popitem() method, this one does not respect LIFO (last-in, first-out). This is due to the fact that attributes are stored in a random order when initializing the model. However, it will respect LIFO with respect to the internal __dict__ . Source code in oteapi/models/genericconfig.py 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 def popitem ( self ) -> \"Tuple[str, Any]\" : \"\"\"MutableMapping `popitem`-method. Important: Unlike the regular `dict.popitem()` method, this one does _not_ respect LIFO (last-in, first-out). This is due to the fact that attributes are stored in a random order when initializing the model. However, it will respect LIFO with respect to the internal `__dict__`. \"\"\" if not self : raise KeyError ( f \"popitem(): { self . __class__ . __name__ } is empty\" ) key = list ( self . __dict__ )[ - 1 ] value = self . pop ( key ) return key , value","title":"popitem()"},{"location":"api_reference/models/genericconfig/#oteapi.models.genericconfig.AttrDict.update","text":"MutableMapping update -method. Source code in oteapi/models/genericconfig.py 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 def update ( self , other : \"Optional[Union[dict, AttrDict, Iterable[Any]]]\" = None , ** kwargs ) -> None : \"\"\"MutableMapping `update`-method.\"\"\" if other and isinstance ( other , ( dict , Mapping )): for key , value in other . items (): setattr ( self , key , value ) elif other and isinstance ( other , BaseModel ): for key , value in other . dict () . items (): setattr ( self , key , value ) elif other and isinstance ( other , Iterable ): for entry in other : if not len ( entry ) == 2 : raise ValueError ( \"`other` must be an iterable of objects of length two.\" ) for key , value in other : setattr ( self , key , value ) if kwargs : for key , value in kwargs . items (): setattr ( self , key , value )","title":"update()"},{"location":"api_reference/models/genericconfig/#oteapi.models.genericconfig.AttrDict.values","text":"Return a view of all values. Source code in oteapi/models/genericconfig.py 62 63 64 def values ( self ): \"\"\"Return a view of all values.\"\"\" return self . __dict__ . values ()","title":"values()"},{"location":"api_reference/models/genericconfig/#oteapi.models.genericconfig.GenericConfig","text":"Bases: BaseModel Generic class for configuration objects. Source code in oteapi/models/genericconfig.py 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 class GenericConfig ( BaseModel ): \"\"\"Generic class for configuration objects.\"\"\" configuration : AttrDict = Field ( AttrDict (), description = \"Model-specific configuration options which can either \" \"be given as key/value-pairs or set as attributes.\" , ) description : str = Field ( __doc__ , description = \"A description of the configuration model.\" , ) @classmethod def __init_subclass__ ( cls ) -> None : \"\"\"Initialize subclass descriptions with their docstrings.\"\"\" cls . __fields__ [ \"description\" ] . default = cls . __doc__ class Config : \"\"\"Pydantic configuration for `GenericConfig`. * **`validate_assignment`** Validate and cast set values. This is mainly relevant for sub-classes of `AttrDict`, where specific attributes have been defined. * **`arbitrary_types_allowed`** If a custom type is used for an attribute that doesn't have a `validate()` method, don't fail setting the attribute. \"\"\" validate_assignment = True arbitrary_types_allowed = True","title":"GenericConfig"},{"location":"api_reference/models/genericconfig/#oteapi.models.genericconfig.GenericConfig.configuration","text":"","title":"configuration"},{"location":"api_reference/models/genericconfig/#oteapi.models.genericconfig.GenericConfig.description","text":"","title":"description"},{"location":"api_reference/models/genericconfig/#oteapi.models.genericconfig.GenericConfig.Config","text":"Pydantic configuration for GenericConfig . validate_assignment Validate and cast set values. This is mainly relevant for sub-classes of AttrDict , where specific attributes have been defined. arbitrary_types_allowed If a custom type is used for an attribute that doesn't have a validate() method, don't fail setting the attribute. Source code in oteapi/models/genericconfig.py 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 class Config : \"\"\"Pydantic configuration for `GenericConfig`. * **`validate_assignment`** Validate and cast set values. This is mainly relevant for sub-classes of `AttrDict`, where specific attributes have been defined. * **`arbitrary_types_allowed`** If a custom type is used for an attribute that doesn't have a `validate()` method, don't fail setting the attribute. \"\"\" validate_assignment = True arbitrary_types_allowed = True","title":"Config"},{"location":"api_reference/models/genericconfig/#oteapi.models.genericconfig.GenericConfig.Config.arbitrary_types_allowed","text":"","title":"arbitrary_types_allowed"},{"location":"api_reference/models/genericconfig/#oteapi.models.genericconfig.GenericConfig.Config.validate_assignment","text":"","title":"validate_assignment"},{"location":"api_reference/models/genericconfig/#oteapi.models.genericconfig.GenericConfig.__init_subclass__","text":"Initialize subclass descriptions with their docstrings. Source code in oteapi/models/genericconfig.py 161 162 163 164 @classmethod def __init_subclass__ ( cls ) -> None : \"\"\"Initialize subclass descriptions with their docstrings.\"\"\" cls . __fields__ [ \"description\" ] . default = cls . __doc__","title":"__init_subclass__()"},{"location":"api_reference/models/mappingconfig/","text":"mappingconfig \u00b6 Pydantic Mapping Configuration Data Model. RDFTriple = Tuple [ str , str , str ] module-attribute \u00b6 MappingConfig \u00b6 Bases: GenericConfig Mapping Strategy Data Configuration. Source code in oteapi/models/mappingconfig.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class MappingConfig ( GenericConfig ): \"\"\"Mapping Strategy Data Configuration.\"\"\" mappingType : str = Field ( ... , description = \"Type of registered mapping strategy.\" , ) prefixes : Optional [ Dict [ str , str ]] = Field ( None , description = ( \"List of shortnames that expands to an IRI given as local \" \"value/IRI-expansion-pairs.\" ), ) triples : Optional [ List [ RDFTriple ]] = Field ( None , description = \"List of RDF triples given as (subject, predicate, object).\" , ) mappingType : str = Field ( Ellipsis , description = 'Type of registered mapping strategy.' ) class-attribute \u00b6 prefixes : Optional [ Dict [ str , str ]] = Field ( None , description = 'List of shortnames that expands to an IRI given as local value/IRI-expansion-pairs.' ) class-attribute \u00b6 triples : Optional [ List [ RDFTriple ]] = Field ( None , description = 'List of RDF triples given as (subject, predicate, object).' ) class-attribute \u00b6","title":"mappingconfig"},{"location":"api_reference/models/mappingconfig/#mappingconfig","text":"Pydantic Mapping Configuration Data Model.","title":"mappingconfig"},{"location":"api_reference/models/mappingconfig/#oteapi.models.mappingconfig.RDFTriple","text":"","title":"RDFTriple"},{"location":"api_reference/models/mappingconfig/#oteapi.models.mappingconfig.MappingConfig","text":"Bases: GenericConfig Mapping Strategy Data Configuration. Source code in oteapi/models/mappingconfig.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class MappingConfig ( GenericConfig ): \"\"\"Mapping Strategy Data Configuration.\"\"\" mappingType : str = Field ( ... , description = \"Type of registered mapping strategy.\" , ) prefixes : Optional [ Dict [ str , str ]] = Field ( None , description = ( \"List of shortnames that expands to an IRI given as local \" \"value/IRI-expansion-pairs.\" ), ) triples : Optional [ List [ RDFTriple ]] = Field ( None , description = \"List of RDF triples given as (subject, predicate, object).\" , )","title":"MappingConfig"},{"location":"api_reference/models/mappingconfig/#oteapi.models.mappingconfig.MappingConfig.mappingType","text":"","title":"mappingType"},{"location":"api_reference/models/mappingconfig/#oteapi.models.mappingconfig.MappingConfig.prefixes","text":"","title":"prefixes"},{"location":"api_reference/models/mappingconfig/#oteapi.models.mappingconfig.MappingConfig.triples","text":"","title":"triples"},{"location":"api_reference/models/resourceconfig/","text":"resourceconfig \u00b6 Pydantic Resource Configuration Data Model. HostlessAnyUrl \u00b6 Bases: AnyUrl AnyUrl, but allow not having a host. Source code in oteapi/models/resourceconfig.py 12 13 14 15 class HostlessAnyUrl ( AnyUrl ): \"\"\"AnyUrl, but allow not having a host.\"\"\" host_required = False host_required = False class-attribute \u00b6 ResourceConfig \u00b6 Bases: GenericConfig Resource Strategy Data Configuration. Important Either of the pairs of attributes downloadUrl / mediaType or accessUrl / accessService MUST be specified. Source code in oteapi/models/resourceconfig.py 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 class ResourceConfig ( GenericConfig ): \"\"\"Resource Strategy Data Configuration. Important: Either of the pairs of attributes `downloadUrl`/`mediaType` or `accessUrl`/`accessService` MUST be specified. \"\"\" downloadUrl : Optional [ HostlessAnyUrl ] = Field ( None , description = ( \"Definition: The URL of the downloadable file in a given format. E.g. CSV \" \"file or RDF file. \\n\\n Usage: `downloadURL` *SHOULD* be used for the URL at\" \" which this distribution is available directly, typically through a HTTPS\" \" GET request or SFTP.\" ), ) mediaType : Optional [ str ] = Field ( None , description = ( \"The media type of the distribution as defined by IANA \" \"[[IANA-MEDIA-TYPES](https://www.w3.org/TR/vocab-dcat-2/#bib-iana-media-types)]\" \". \\n\\n Usage: This property *SHOULD* be used when the media\" \" type of the distribution is defined in IANA \" \"[[IANA-MEDIA-TYPES](https://www.w3.org/TR/vocab-dcat-2/#bib-iana-media-types)].\" ), ) accessUrl : Optional [ HostlessAnyUrl ] = Field ( None , description = ( \"A URL of the resource that gives access to a distribution of \" \"the dataset. E.g. landing page, feed, SPARQL endpoint. \\n\\n Usage: \" \"`accessURL` *SHOULD* be used for the URL of a service or location that \" \"can provide access to this distribution, typically through a Web form, \" \"query or API call. \\n `downloadURL` is preferred for direct links to \" \"downloadable resources.\" ), ) accessService : Optional [ str ] = Field ( None , description = ( \"A data service that gives access to the distribution of the dataset.\" ), ) license : Optional [ str ] = Field ( None , description = ( \"A legal document under which the distribution is made available.\" ), ) accessRights : Optional [ str ] = Field ( None , description = ( \"A rights statement that concerns how the distribution is accessed.\" ), ) publisher : Optional [ str ] = Field ( None , description = \"The entity responsible for making the resource/item available.\" , ) @root_validator def ensure_unique_url_pairs ( # pylint: disable=no-self-use cls , values : \"Dict[str, Any]\" ) -> \"Dict[str, Any]\" : \"\"\"Ensure either downloadUrl/mediaType or accessUrl/accessService are defined. It's fine to define them all, but at least one complete pair MUST be specified. \"\"\" if not ( all ( values . get ( _ ) for _ in [ \"downloadUrl\" , \"mediaType\" ]) or all ( values . get ( _ ) for _ in [ \"accessUrl\" , \"accessService\" ]) ): raise ValueError ( \"Either of the pairs of attributes downloadUrl/mediaType or \" \"accessUrl/accessService MUST be specified.\" ) return values accessRights : Optional [ str ] = Field ( None , description = 'A rights statement that concerns how the distribution is accessed.' ) class-attribute \u00b6 accessService : Optional [ str ] = Field ( None , description = 'A data service that gives access to the distribution of the dataset.' ) class-attribute \u00b6 accessUrl : Optional [ HostlessAnyUrl ] = Field ( None , description = 'A URL of the resource that gives access to a distribution of the dataset. E.g. landing page, feed, SPARQL endpoint. \\n\\n Usage: `accessURL` *SHOULD* be used for the URL of a service or location that can provide access to this distribution, typically through a Web form, query or API call. \\n `downloadURL` is preferred for direct links to downloadable resources.' ) class-attribute \u00b6 downloadUrl : Optional [ HostlessAnyUrl ] = Field ( None , description = 'Definition: The URL of the downloadable file in a given format. E.g. CSV file or RDF file. \\n\\n Usage: `downloadURL` *SHOULD* be used for the URL at which this distribution is available directly, typically through a HTTPS GET request or SFTP.' ) class-attribute \u00b6 license : Optional [ str ] = Field ( None , description = 'A legal document under which the distribution is made available.' ) class-attribute \u00b6 mediaType : Optional [ str ] = Field ( None , description = 'The media type of the distribution as defined by IANA [[IANA-MEDIA-TYPES](https://www.w3.org/TR/vocab-dcat-2/#bib-iana-media-types)]. \\n\\n Usage: This property *SHOULD* be used when the media type of the distribution is defined in IANA [[IANA-MEDIA-TYPES](https://www.w3.org/TR/vocab-dcat-2/#bib-iana-media-types)].' ) class-attribute \u00b6 publisher : Optional [ str ] = Field ( None , description = 'The entity responsible for making the resource/item available.' ) class-attribute \u00b6 ensure_unique_url_pairs ( values ) \u00b6 Ensure either downloadUrl/mediaType or accessUrl/accessService are defined. It's fine to define them all, but at least one complete pair MUST be specified. Source code in oteapi/models/resourceconfig.py 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 @root_validator def ensure_unique_url_pairs ( # pylint: disable=no-self-use cls , values : \"Dict[str, Any]\" ) -> \"Dict[str, Any]\" : \"\"\"Ensure either downloadUrl/mediaType or accessUrl/accessService are defined. It's fine to define them all, but at least one complete pair MUST be specified. \"\"\" if not ( all ( values . get ( _ ) for _ in [ \"downloadUrl\" , \"mediaType\" ]) or all ( values . get ( _ ) for _ in [ \"accessUrl\" , \"accessService\" ]) ): raise ValueError ( \"Either of the pairs of attributes downloadUrl/mediaType or \" \"accessUrl/accessService MUST be specified.\" ) return values","title":"resourceconfig"},{"location":"api_reference/models/resourceconfig/#resourceconfig","text":"Pydantic Resource Configuration Data Model.","title":"resourceconfig"},{"location":"api_reference/models/resourceconfig/#oteapi.models.resourceconfig.HostlessAnyUrl","text":"Bases: AnyUrl AnyUrl, but allow not having a host. Source code in oteapi/models/resourceconfig.py 12 13 14 15 class HostlessAnyUrl ( AnyUrl ): \"\"\"AnyUrl, but allow not having a host.\"\"\" host_required = False","title":"HostlessAnyUrl"},{"location":"api_reference/models/resourceconfig/#oteapi.models.resourceconfig.HostlessAnyUrl.host_required","text":"","title":"host_required"},{"location":"api_reference/models/resourceconfig/#oteapi.models.resourceconfig.ResourceConfig","text":"Bases: GenericConfig Resource Strategy Data Configuration. Important Either of the pairs of attributes downloadUrl / mediaType or accessUrl / accessService MUST be specified. Source code in oteapi/models/resourceconfig.py 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 class ResourceConfig ( GenericConfig ): \"\"\"Resource Strategy Data Configuration. Important: Either of the pairs of attributes `downloadUrl`/`mediaType` or `accessUrl`/`accessService` MUST be specified. \"\"\" downloadUrl : Optional [ HostlessAnyUrl ] = Field ( None , description = ( \"Definition: The URL of the downloadable file in a given format. E.g. CSV \" \"file or RDF file. \\n\\n Usage: `downloadURL` *SHOULD* be used for the URL at\" \" which this distribution is available directly, typically through a HTTPS\" \" GET request or SFTP.\" ), ) mediaType : Optional [ str ] = Field ( None , description = ( \"The media type of the distribution as defined by IANA \" \"[[IANA-MEDIA-TYPES](https://www.w3.org/TR/vocab-dcat-2/#bib-iana-media-types)]\" \". \\n\\n Usage: This property *SHOULD* be used when the media\" \" type of the distribution is defined in IANA \" \"[[IANA-MEDIA-TYPES](https://www.w3.org/TR/vocab-dcat-2/#bib-iana-media-types)].\" ), ) accessUrl : Optional [ HostlessAnyUrl ] = Field ( None , description = ( \"A URL of the resource that gives access to a distribution of \" \"the dataset. E.g. landing page, feed, SPARQL endpoint. \\n\\n Usage: \" \"`accessURL` *SHOULD* be used for the URL of a service or location that \" \"can provide access to this distribution, typically through a Web form, \" \"query or API call. \\n `downloadURL` is preferred for direct links to \" \"downloadable resources.\" ), ) accessService : Optional [ str ] = Field ( None , description = ( \"A data service that gives access to the distribution of the dataset.\" ), ) license : Optional [ str ] = Field ( None , description = ( \"A legal document under which the distribution is made available.\" ), ) accessRights : Optional [ str ] = Field ( None , description = ( \"A rights statement that concerns how the distribution is accessed.\" ), ) publisher : Optional [ str ] = Field ( None , description = \"The entity responsible for making the resource/item available.\" , ) @root_validator def ensure_unique_url_pairs ( # pylint: disable=no-self-use cls , values : \"Dict[str, Any]\" ) -> \"Dict[str, Any]\" : \"\"\"Ensure either downloadUrl/mediaType or accessUrl/accessService are defined. It's fine to define them all, but at least one complete pair MUST be specified. \"\"\" if not ( all ( values . get ( _ ) for _ in [ \"downloadUrl\" , \"mediaType\" ]) or all ( values . get ( _ ) for _ in [ \"accessUrl\" , \"accessService\" ]) ): raise ValueError ( \"Either of the pairs of attributes downloadUrl/mediaType or \" \"accessUrl/accessService MUST be specified.\" ) return values","title":"ResourceConfig"},{"location":"api_reference/models/resourceconfig/#oteapi.models.resourceconfig.ResourceConfig.accessRights","text":"","title":"accessRights"},{"location":"api_reference/models/resourceconfig/#oteapi.models.resourceconfig.ResourceConfig.accessService","text":"","title":"accessService"},{"location":"api_reference/models/resourceconfig/#oteapi.models.resourceconfig.ResourceConfig.accessUrl","text":"","title":"accessUrl"},{"location":"api_reference/models/resourceconfig/#oteapi.models.resourceconfig.ResourceConfig.downloadUrl","text":"","title":"downloadUrl"},{"location":"api_reference/models/resourceconfig/#oteapi.models.resourceconfig.ResourceConfig.license","text":"","title":"license"},{"location":"api_reference/models/resourceconfig/#oteapi.models.resourceconfig.ResourceConfig.mediaType","text":"","title":"mediaType"},{"location":"api_reference/models/resourceconfig/#oteapi.models.resourceconfig.ResourceConfig.publisher","text":"","title":"publisher"},{"location":"api_reference/models/resourceconfig/#oteapi.models.resourceconfig.ResourceConfig.ensure_unique_url_pairs","text":"Ensure either downloadUrl/mediaType or accessUrl/accessService are defined. It's fine to define them all, but at least one complete pair MUST be specified. Source code in oteapi/models/resourceconfig.py 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 @root_validator def ensure_unique_url_pairs ( # pylint: disable=no-self-use cls , values : \"Dict[str, Any]\" ) -> \"Dict[str, Any]\" : \"\"\"Ensure either downloadUrl/mediaType or accessUrl/accessService are defined. It's fine to define them all, but at least one complete pair MUST be specified. \"\"\" if not ( all ( values . get ( _ ) for _ in [ \"downloadUrl\" , \"mediaType\" ]) or all ( values . get ( _ ) for _ in [ \"accessUrl\" , \"accessService\" ]) ): raise ValueError ( \"Either of the pairs of attributes downloadUrl/mediaType or \" \"accessUrl/accessService MUST be specified.\" ) return values","title":"ensure_unique_url_pairs()"},{"location":"api_reference/models/sessionupdate/","text":"sessionupdate \u00b6 Pydantic SessionUpdate Data Model. SessionUpdate \u00b6 Bases: AttrDict Session Update Data Model for returning values. Source code in oteapi/models/sessionupdate.py 5 6 class SessionUpdate ( AttrDict ): \"\"\"Session Update Data Model for returning values.\"\"\"","title":"sessionupdate"},{"location":"api_reference/models/sessionupdate/#sessionupdate","text":"Pydantic SessionUpdate Data Model.","title":"sessionupdate"},{"location":"api_reference/models/sessionupdate/#oteapi.models.sessionupdate.SessionUpdate","text":"Bases: AttrDict Session Update Data Model for returning values. Source code in oteapi/models/sessionupdate.py 5 6 class SessionUpdate ( AttrDict ): \"\"\"Session Update Data Model for returning values.\"\"\"","title":"SessionUpdate"},{"location":"api_reference/models/transformationconfig/","text":"transformationconfig \u00b6 Pydantic Transformation Configuration Data Model. A transformation status data model is provided as well. This data model represents what should be returned from the strategy's status() method. ProcessPriority \u00b6 Bases: str , Enum Defining process priority enumerators. Process priorities: Low Medium High Source code in oteapi/models/transformationconfig.py 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class ProcessPriority ( str , Enum ): \"\"\"Defining process priority enumerators. Process priorities: - Low - Medium - High \"\"\" LOW = \"Low\" MEDIUM = \"Medium\" HIGH = \"High\" HIGH = 'High' class-attribute \u00b6 LOW = 'Low' class-attribute \u00b6 MEDIUM = 'Medium' class-attribute \u00b6 TransformationConfig \u00b6 Bases: GenericConfig Transformation Strategy Data Configuration. Source code in oteapi/models/transformationconfig.py 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 class TransformationConfig ( GenericConfig ): \"\"\"Transformation Strategy Data Configuration.\"\"\" transformationType : str = Field ( ... , description = ( \"Type of registered transformation strategy. E.g., `celery/remote`.\" ), ) name : Optional [ str ] = Field ( None , description = \"Human-readable name of the transformation strategy.\" ) due : Optional [ datetime ] = Field ( None , description = ( \"Optional field to indicate a due data/time for when a transformation \" \"should finish.\" ), ) priority : Optional [ ProcessPriority ] = Field ( ProcessPriority . MEDIUM , description = \"Define the process priority of the transformation execution.\" , ) secret : Optional [ str ] = Field ( None , description = \"Authorization secret given when running a transformation.\" , ) due : Optional [ datetime ] = Field ( None , description = 'Optional field to indicate a due data/time for when a transformation should finish.' ) class-attribute \u00b6 name : Optional [ str ] = Field ( None , description = 'Human-readable name of the transformation strategy.' ) class-attribute \u00b6 priority : Optional [ ProcessPriority ] = Field ( ProcessPriority . MEDIUM , description = 'Define the process priority of the transformation execution.' ) class-attribute \u00b6 secret : Optional [ str ] = Field ( None , description = 'Authorization secret given when running a transformation.' ) class-attribute \u00b6 transformationType : str = Field ( Ellipsis , description = 'Type of registered transformation strategy. E.g., `celery/remote`.' ) class-attribute \u00b6 TransformationStatus \u00b6 Bases: BaseModel Return from transformation status. Source code in oteapi/models/transformationconfig.py 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 class TransformationStatus ( BaseModel ): \"\"\"Return from transformation status.\"\"\" id : str = Field ( ... , description = \"ID for the given transformation process.\" ) status : Optional [ str ] = Field ( None , description = \"Status for the transformation process.\" ) messages : Optional [ List [ str ]] = Field ( None , description = \"Messages related to the transformation process.\" ) created : Optional [ datetime ] = Field ( None , description = \"Time of creation for the transformation process. Given in UTC.\" , ) startTime : Optional [ datetime ] = Field ( None , description = \"Time when the transformation process started. Given in UTC.\" ) finishTime : Optional [ datetime ] = Field ( None , description = \"Time when the tranformation process finished. Given in UTC.\" ) created : Optional [ datetime ] = Field ( None , description = 'Time of creation for the transformation process. Given in UTC.' ) class-attribute \u00b6 finishTime : Optional [ datetime ] = Field ( None , description = 'Time when the tranformation process finished. Given in UTC.' ) class-attribute \u00b6 id : str = Field ( Ellipsis , description = 'ID for the given transformation process.' ) class-attribute \u00b6 messages : Optional [ List [ str ]] = Field ( None , description = 'Messages related to the transformation process.' ) class-attribute \u00b6 startTime : Optional [ datetime ] = Field ( None , description = 'Time when the transformation process started. Given in UTC.' ) class-attribute \u00b6 status : Optional [ str ] = Field ( None , description = 'Status for the transformation process.' ) class-attribute \u00b6","title":"transformationconfig"},{"location":"api_reference/models/transformationconfig/#transformationconfig","text":"Pydantic Transformation Configuration Data Model. A transformation status data model is provided as well. This data model represents what should be returned from the strategy's status() method.","title":"transformationconfig"},{"location":"api_reference/models/transformationconfig/#oteapi.models.transformationconfig.ProcessPriority","text":"Bases: str , Enum Defining process priority enumerators. Process priorities: Low Medium High Source code in oteapi/models/transformationconfig.py 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class ProcessPriority ( str , Enum ): \"\"\"Defining process priority enumerators. Process priorities: - Low - Medium - High \"\"\" LOW = \"Low\" MEDIUM = \"Medium\" HIGH = \"High\"","title":"ProcessPriority"},{"location":"api_reference/models/transformationconfig/#oteapi.models.transformationconfig.ProcessPriority.HIGH","text":"","title":"HIGH"},{"location":"api_reference/models/transformationconfig/#oteapi.models.transformationconfig.ProcessPriority.LOW","text":"","title":"LOW"},{"location":"api_reference/models/transformationconfig/#oteapi.models.transformationconfig.ProcessPriority.MEDIUM","text":"","title":"MEDIUM"},{"location":"api_reference/models/transformationconfig/#oteapi.models.transformationconfig.TransformationConfig","text":"Bases: GenericConfig Transformation Strategy Data Configuration. Source code in oteapi/models/transformationconfig.py 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 class TransformationConfig ( GenericConfig ): \"\"\"Transformation Strategy Data Configuration.\"\"\" transformationType : str = Field ( ... , description = ( \"Type of registered transformation strategy. E.g., `celery/remote`.\" ), ) name : Optional [ str ] = Field ( None , description = \"Human-readable name of the transformation strategy.\" ) due : Optional [ datetime ] = Field ( None , description = ( \"Optional field to indicate a due data/time for when a transformation \" \"should finish.\" ), ) priority : Optional [ ProcessPriority ] = Field ( ProcessPriority . MEDIUM , description = \"Define the process priority of the transformation execution.\" , ) secret : Optional [ str ] = Field ( None , description = \"Authorization secret given when running a transformation.\" , )","title":"TransformationConfig"},{"location":"api_reference/models/transformationconfig/#oteapi.models.transformationconfig.TransformationConfig.due","text":"","title":"due"},{"location":"api_reference/models/transformationconfig/#oteapi.models.transformationconfig.TransformationConfig.name","text":"","title":"name"},{"location":"api_reference/models/transformationconfig/#oteapi.models.transformationconfig.TransformationConfig.priority","text":"","title":"priority"},{"location":"api_reference/models/transformationconfig/#oteapi.models.transformationconfig.TransformationConfig.secret","text":"","title":"secret"},{"location":"api_reference/models/transformationconfig/#oteapi.models.transformationconfig.TransformationConfig.transformationType","text":"","title":"transformationType"},{"location":"api_reference/models/transformationconfig/#oteapi.models.transformationconfig.TransformationStatus","text":"Bases: BaseModel Return from transformation status. Source code in oteapi/models/transformationconfig.py 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 class TransformationStatus ( BaseModel ): \"\"\"Return from transformation status.\"\"\" id : str = Field ( ... , description = \"ID for the given transformation process.\" ) status : Optional [ str ] = Field ( None , description = \"Status for the transformation process.\" ) messages : Optional [ List [ str ]] = Field ( None , description = \"Messages related to the transformation process.\" ) created : Optional [ datetime ] = Field ( None , description = \"Time of creation for the transformation process. Given in UTC.\" , ) startTime : Optional [ datetime ] = Field ( None , description = \"Time when the transformation process started. Given in UTC.\" ) finishTime : Optional [ datetime ] = Field ( None , description = \"Time when the tranformation process finished. Given in UTC.\" )","title":"TransformationStatus"},{"location":"api_reference/models/transformationconfig/#oteapi.models.transformationconfig.TransformationStatus.created","text":"","title":"created"},{"location":"api_reference/models/transformationconfig/#oteapi.models.transformationconfig.TransformationStatus.finishTime","text":"","title":"finishTime"},{"location":"api_reference/models/transformationconfig/#oteapi.models.transformationconfig.TransformationStatus.id","text":"","title":"id"},{"location":"api_reference/models/transformationconfig/#oteapi.models.transformationconfig.TransformationStatus.messages","text":"","title":"messages"},{"location":"api_reference/models/transformationconfig/#oteapi.models.transformationconfig.TransformationStatus.startTime","text":"","title":"startTime"},{"location":"api_reference/models/transformationconfig/#oteapi.models.transformationconfig.TransformationStatus.status","text":"","title":"status"},{"location":"api_reference/models/triplestoreconfig/","text":"triplestoreconfig \u00b6 Pydantic TripleStore Configuration Data Model. TripleStoreConfig \u00b6 Bases: AttrDict TripleStore Configuration. This is a configuration for the TripleStore . This class should not be used directly as a configuration object for a strategy object, but only as a configuration field inside a configuration object. Source code in oteapi/models/triplestoreconfig.py 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 class TripleStoreConfig ( AttrDict ): \"\"\"TripleStore Configuration. This is a configuration for the [`TripleStore`][oteapi.triplestore.triplestore.TripleStore]. This class should not be used directly as a configuration object for a strategy object, but only as a configuration field inside a configuration object. \"\"\" repositoryName : str = Field ( ... , description = \"The repository name, where the mappings are stored.\" ) agraphHost : str = Field ( ... , description = \"AllegroGraph host name.\" , ) agraphPort : int = Field ( ... , description = \"AllegroGraph port number.\" , ) agraphUser : str = Field ( ... , description = \"AllegroGraph user name.\" , ) agraphPassword : SecretStr = Field ( ... , description = \"AllegroGraph user password.\" , ) agraphHost : str = Field ( Ellipsis , description = 'AllegroGraph host name.' ) class-attribute \u00b6 agraphPassword : SecretStr = Field ( Ellipsis , description = 'AllegroGraph user password.' ) class-attribute \u00b6 agraphPort : int = Field ( Ellipsis , description = 'AllegroGraph port number.' ) class-attribute \u00b6 agraphUser : str = Field ( Ellipsis , description = 'AllegroGraph user name.' ) class-attribute \u00b6 repositoryName : str = Field ( Ellipsis , description = 'The repository name, where the mappings are stored.' ) class-attribute \u00b6","title":"triplestoreconfig"},{"location":"api_reference/models/triplestoreconfig/#triplestoreconfig","text":"Pydantic TripleStore Configuration Data Model.","title":"triplestoreconfig"},{"location":"api_reference/models/triplestoreconfig/#oteapi.models.triplestoreconfig.TripleStoreConfig","text":"Bases: AttrDict TripleStore Configuration. This is a configuration for the TripleStore . This class should not be used directly as a configuration object for a strategy object, but only as a configuration field inside a configuration object. Source code in oteapi/models/triplestoreconfig.py 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 class TripleStoreConfig ( AttrDict ): \"\"\"TripleStore Configuration. This is a configuration for the [`TripleStore`][oteapi.triplestore.triplestore.TripleStore]. This class should not be used directly as a configuration object for a strategy object, but only as a configuration field inside a configuration object. \"\"\" repositoryName : str = Field ( ... , description = \"The repository name, where the mappings are stored.\" ) agraphHost : str = Field ( ... , description = \"AllegroGraph host name.\" , ) agraphPort : int = Field ( ... , description = \"AllegroGraph port number.\" , ) agraphUser : str = Field ( ... , description = \"AllegroGraph user name.\" , ) agraphPassword : SecretStr = Field ( ... , description = \"AllegroGraph user password.\" , )","title":"TripleStoreConfig"},{"location":"api_reference/models/triplestoreconfig/#oteapi.models.triplestoreconfig.TripleStoreConfig.agraphHost","text":"","title":"agraphHost"},{"location":"api_reference/models/triplestoreconfig/#oteapi.models.triplestoreconfig.TripleStoreConfig.agraphPassword","text":"","title":"agraphPassword"},{"location":"api_reference/models/triplestoreconfig/#oteapi.models.triplestoreconfig.TripleStoreConfig.agraphPort","text":"","title":"agraphPort"},{"location":"api_reference/models/triplestoreconfig/#oteapi.models.triplestoreconfig.TripleStoreConfig.agraphUser","text":"","title":"agraphUser"},{"location":"api_reference/models/triplestoreconfig/#oteapi.models.triplestoreconfig.TripleStoreConfig.repositoryName","text":"","title":"repositoryName"},{"location":"api_reference/plugins/entry_points/","text":"entry_points \u00b6 Load plugins through entry points. This module deals with handling all plugged in strategies through the entry points API and importlib metadata API. Special functionality is put in place to handle the OTE-API-specific entry points. Since the entry points are information complete in and of themselves, there is no need to import actual strategy classes until they are truly needed. This therefore implements lazy loading of all plugin strategies. EntryPointNotFound \u00b6 Bases: Exception A given strategy implementation (class) cannot be found from the given entry point value. Source code in oteapi/plugins/entry_points.py 35 36 37 class EntryPointNotFound ( Exception ): \"\"\"A given strategy implementation (class) cannot be found from the given entry point value.\"\"\" EntryPointStrategy \u00b6 A strategy realized from an entry point. An entry point strategy is made unique by its \"strategy\", i.e., its (strategy type, strategy name)-tuple, e.g., (\"download\", \"https\") . This tuple can be retrieved from the strategy property, where the strategy type is represented by the StrategyType enumeration. Note It may be that in the future an entry points strategy is made unique by its \"full name\" instead, i.e., the entry point group + the entry points name, e.g., oteapi.download:oteapi.https . This value can be retrieved from the full_name property. This is a condition for uniqueness that is considered to be a superset of the current condition for uniqueness. It adds an extra package-specific uniqueness trait, allowing for different packages to implement the same strategies (which is currently not allowed according to the condition of uniqueness explained above). Currently there is no consensus on the API for handling this added strategy ambiguity. Raises: Type Description ValueError If the entry point name is not properly defined. Source code in oteapi/plugins/entry_points.py 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 class EntryPointStrategy : \"\"\"A strategy realized from an entry point. An entry point strategy is made unique by its \"strategy\", i.e., its (strategy type, strategy name)-tuple, e.g., `(\"download\", \"https\")`. This tuple can be retrieved from the [`strategy`][oteapi.plugins.entry_points.EntryPointStrategy.strategy] property, where the strategy type is represented by the [`StrategyType`][oteapi.plugins.entry_points.StrategyType] enumeration. Note: It may be that in the future an entry points strategy is made unique by its \"full name\" instead, i.e., the entry point group + the entry points name, e.g., `oteapi.download:oteapi.https`. This value can be retrieved from the [`full_name`][oteapi.plugins.entry_points.EntryPointStrategy.full_name] property. This is a condition for uniqueness that is considered to be a superset of the current condition for uniqueness. It adds an extra package-specific uniqueness trait, allowing for different packages to implement the same strategies (which is currently not allowed according to the condition of uniqueness explained above). Currently there is no consensus on the API for handling this added strategy ambiguity. Raises: ValueError: If the entry point name is not properly defined. \"\"\" ENTRY_POINT_NAME_REGEX = re . compile ( r \"^(?P<package_name>[a-z_]+)\\.(?P<strategy_name>.+)$\" ) ENTRY_POINT_NAME_SEPARATOR = \":\" def __init__ ( self , entry_point : \"EntryPoint\" ) -> None : self . _entry_point = entry_point match = self . ENTRY_POINT_NAME_REGEX . match ( self . _entry_point . name ) if match is None : raise ValueError ( \"Could not determine package name and/or strategy name for entry \" f \"point: { self . full_name } \" ) self . _match = match self . _type = StrategyType ( self . _entry_point . group [ len ( \"oteapi.\" ) :]) self . _implementation : \"Optional[Type[IStrategy]]\" = None @property def type ( self ) -> StrategyType : \"\"\"The strategy type. One part of the (strategy type, strategy name)-tuple. \"\"\" return self . _type @property def name ( self ) -> str : \"\"\"The strategy name. One part of the (strategy type, strategy name)-tuple. \"\"\" return self . _match . group ( \"strategy_name\" ) @property def strategy ( self ) -> \"Tuple[StrategyType, str]\" : \"\"\"The unique index identifier for the strategy.\"\"\" return self . type , self . name @property def package ( self ) -> str : \"\"\"The importable base package name for the strategy plugin.\"\"\" return self . _match . group ( \"package_name\" ) @property def module ( self ) -> str : \"\"\"The fully resolved importable module path.\"\"\" return self . _entry_point . module # type: ignore[attr-defined] @property def full_name ( self ) -> str : \"\"\"The full entry point name.\"\"\" return f \" { self . _entry_point . group }{ self . ENTRY_POINT_NAME_SEPARATOR }{ self . _entry_point . name } \" def __str__ ( self ) -> str : return self . full_name def __repr__ ( self ) -> str : return f \" { self . __class__ . __name__ } (entry_point= { self . _entry_point !r} )\" @property def implementation_name ( self ) -> str : \"\"\"The EntryPoint attr, which should be the strategy implementation class name.\"\"\" return self . _entry_point . attr # type: ignore[attr-defined] @property def implementation ( self ) -> \"Type[IStrategy]\" : \"\"\"The actual strategy implementation.\"\"\" if self . _implementation is None : self . _implementation = self . _load_implementation () return self . _implementation def _load_implementation ( self ) -> \"Type[IStrategy]\" : \"\"\"Load the strategy implementation. Because the actual importing of the module does not happen until this method is called, we are lazily loading in the strategy implementation. There is no need to check through the `globals()` built-in for whether the module and class have already been imported, because this caching layer is already implemented in the `importlib` API. Raises: EntryPointNotFound: If the strategy implementation (class) the entry point is pointing to cannot be found in the module or if the module cannot be imported. Returns: The imported strategy implementation (class). \"\"\" try : module = importlib . import_module ( self . module ) except ImportError as exc : raise EntryPointNotFound ( f \" { self . module } cannot be imported. Did you install the \" f \" { self . package !r} package?\" ) from exc if hasattr ( module , self . implementation_name ): return getattr ( module , self . implementation_name ) raise EntryPointNotFound ( f \" { self . implementation_name } cannot be found in { self . module } \" ) def __eq__ ( self , other : \"Any\" ) -> bool : if isinstance ( other , self . __class__ ): return hash ( self ) == hash ( other ) return False def __hash__ ( self ) -> int : return hash ( self . strategy ) def __lt__ ( self , other : \"Any\" ) -> bool : \"\"\"Whether or not `self` is less than (`<`) `other`. This is implemented to allow sorting (using `sorted()`). The inequality is determined on the basis of the following properties: 1. [`type`][oteapi.plugins.entry_points.EntryPointStrategy.type] 2. [`package`][oteapi.plugins.entry_points.EntryPointStrategy.package] 3. [`name`][oteapi.plugins.entry_points.EntryPointStrategy.name] Going from highest priority to lowest and in alphabetical ascending order. \"\"\" if isinstance ( other , self . __class__ ): if self . type == other . type : if self . package == other . package : if self . name == other . name : # Considered equal, i.e., one can by definition not be unequal # with the other. return False return sorted ([ self . name , other . name ])[ 0 ] == self . name return sorted ([ self . package , other . package ])[ 0 ] == self . package return sorted ([ self . type . value , other . type . value ])[ 0 ] == self . type . value raise NotImplementedError ( f \"Less than comparison is not implemented for { type ( other ) } type objects.\" ) __lt__ ( other ) \u00b6 Whether or not self is less than ( < ) other . This is implemented to allow sorting (using sorted() ). The inequality is determined on the basis of the following properties: type package name Going from highest priority to lowest and in alphabetical ascending order. Source code in oteapi/plugins/entry_points.py 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 def __lt__ ( self , other : \"Any\" ) -> bool : \"\"\"Whether or not `self` is less than (`<`) `other`. This is implemented to allow sorting (using `sorted()`). The inequality is determined on the basis of the following properties: 1. [`type`][oteapi.plugins.entry_points.EntryPointStrategy.type] 2. [`package`][oteapi.plugins.entry_points.EntryPointStrategy.package] 3. [`name`][oteapi.plugins.entry_points.EntryPointStrategy.name] Going from highest priority to lowest and in alphabetical ascending order. \"\"\" if isinstance ( other , self . __class__ ): if self . type == other . type : if self . package == other . package : if self . name == other . name : # Considered equal, i.e., one can by definition not be unequal # with the other. return False return sorted ([ self . name , other . name ])[ 0 ] == self . name return sorted ([ self . package , other . package ])[ 0 ] == self . package return sorted ([ self . type . value , other . type . value ])[ 0 ] == self . type . value raise NotImplementedError ( f \"Less than comparison is not implemented for { type ( other ) } type objects.\" ) _load_implementation () \u00b6 Load the strategy implementation. Because the actual importing of the module does not happen until this method is called, we are lazily loading in the strategy implementation. There is no need to check through the globals() built-in for whether the module and class have already been imported, because this caching layer is already implemented in the importlib API. Raises: Type Description EntryPointNotFound If the strategy implementation (class) the entry point is pointing to cannot be found in the module or if the module cannot be imported. Returns: Type Description 'Type[IStrategy]' The imported strategy implementation (class). Source code in oteapi/plugins/entry_points.py 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 def _load_implementation ( self ) -> \"Type[IStrategy]\" : \"\"\"Load the strategy implementation. Because the actual importing of the module does not happen until this method is called, we are lazily loading in the strategy implementation. There is no need to check through the `globals()` built-in for whether the module and class have already been imported, because this caching layer is already implemented in the `importlib` API. Raises: EntryPointNotFound: If the strategy implementation (class) the entry point is pointing to cannot be found in the module or if the module cannot be imported. Returns: The imported strategy implementation (class). \"\"\" try : module = importlib . import_module ( self . module ) except ImportError as exc : raise EntryPointNotFound ( f \" { self . module } cannot be imported. Did you install the \" f \" { self . package !r} package?\" ) from exc if hasattr ( module , self . implementation_name ): return getattr ( module , self . implementation_name ) raise EntryPointNotFound ( f \" { self . implementation_name } cannot be found in { self . module } \" ) full_name () property \u00b6 The full entry point name. Source code in oteapi/plugins/entry_points.py 225 226 227 228 @property def full_name ( self ) -> str : \"\"\"The full entry point name.\"\"\" return f \" { self . _entry_point . group }{ self . ENTRY_POINT_NAME_SEPARATOR }{ self . _entry_point . name } \" implementation () property \u00b6 The actual strategy implementation. Source code in oteapi/plugins/entry_points.py 242 243 244 245 246 247 @property def implementation ( self ) -> \"Type[IStrategy]\" : \"\"\"The actual strategy implementation.\"\"\" if self . _implementation is None : self . _implementation = self . _load_implementation () return self . _implementation implementation_name () property \u00b6 The EntryPoint attr, which should be the strategy implementation class name. Source code in oteapi/plugins/entry_points.py 236 237 238 239 240 @property def implementation_name ( self ) -> str : \"\"\"The EntryPoint attr, which should be the strategy implementation class name.\"\"\" return self . _entry_point . attr # type: ignore[attr-defined] module () property \u00b6 The fully resolved importable module path. Source code in oteapi/plugins/entry_points.py 220 221 222 223 @property def module ( self ) -> str : \"\"\"The fully resolved importable module path.\"\"\" return self . _entry_point . module # type: ignore[attr-defined] name () property \u00b6 The strategy name. One part of the (strategy type, strategy name)-tuple. Source code in oteapi/plugins/entry_points.py 202 203 204 205 206 207 208 @property def name ( self ) -> str : \"\"\"The strategy name. One part of the (strategy type, strategy name)-tuple. \"\"\" return self . _match . group ( \"strategy_name\" ) package () property \u00b6 The importable base package name for the strategy plugin. Source code in oteapi/plugins/entry_points.py 215 216 217 218 @property def package ( self ) -> str : \"\"\"The importable base package name for the strategy plugin.\"\"\" return self . _match . group ( \"package_name\" ) strategy () property \u00b6 The unique index identifier for the strategy. Source code in oteapi/plugins/entry_points.py 210 211 212 213 @property def strategy ( self ) -> \"Tuple[StrategyType, str]\" : \"\"\"The unique index identifier for the strategy.\"\"\" return self . type , self . name type () property \u00b6 The strategy type. One part of the (strategy type, strategy name)-tuple. Source code in oteapi/plugins/entry_points.py 194 195 196 197 198 199 200 @property def type ( self ) -> StrategyType : \"\"\"The strategy type. One part of the (strategy type, strategy name)-tuple. \"\"\" return self . _type EntryPointStrategyCollection \u00b6 Bases: abc . Collection A collection of EntryPointStrategy s. Source code in oteapi/plugins/entry_points.py 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 class EntryPointStrategyCollection ( abc . Collection ): \"\"\"A collection of [`EntryPointStrategy`][oteapi.plugins.entry_points.EntryPointStrategy]s.\"\"\" def __init__ ( self , * entry_points : \"EntryPointStrategy\" ) -> None : self . _entry_points : \"Set[EntryPointStrategy]\" = ( set ( entry_points ) if entry_points else set () ) def add ( self , * entry_points : EntryPointStrategy ) -> None : \"\"\"Add entry points to the collection. Parameters: *entry_points (Iterable[EntryPointStrategy]): Entry points to add to the collection. \"\"\" self . _entry_points |= set ( entry_points ) def remove ( self , * entry_points : EntryPointStrategy ) -> None : \"\"\"Remove entry points from the collection. Parameters: *entry_points (Iterable[EntryPointStrategy]): Entry points to remove from the collection. \"\"\" self . _entry_points -= set ( entry_points ) def exclusive_add ( self , * entry_points : EntryPointStrategy ) -> None : \"\"\"Exclusively add entry points to the collection. Parameters: *entry_points (Iterable[EntryPointStrategy]): Entry points to add to the collection. Raises: KeyError: If an entry point to be added already exists in the collection. \"\"\" for entry_point in entry_points : if entry_point in self : raise KeyError ( f \" { entry_point . strategy } already exists in { self } . \" f \"(Tried adding { entry_point } .)\" ) self . add ( entry_point ) def __len__ ( self ) -> int : return len ( self . _entry_points ) def __contains__ ( self , item : \"Any\" ) -> bool : \"\"\"Whether or not `item` is contained in the collection. One can test with an `EntryPointStrategy`, a string of an entry point strategy's full name, or a tuple of an entry point's strategy type and name. Parameters: item: Item to test whether it is contained in the collection. Returns: Whether or not `item` is contained in the collection. If the `item` is an unrecognized type, `False` will be returned. \"\"\" if isinstance ( item , EntryPointStrategy ): return item in self . _entry_points if isinstance ( item , str ): for entry_point in self . _entry_points : if item == entry_point . full_name : return True if isinstance ( item , tuple ): if len ( item ) != 2 or ( not isinstance ( item [ 0 ], ( StrategyType , str )) or not isinstance ( item [ 1 ], str ) ): # Only tuples of type (Union[StrategyType, str], str) are allowed. return False try : item_ = ( StrategyType . init ( item [ 0 ]), item [ 1 ]) except ValueError : # We only want to return True or False return False for entry_point in self . _entry_points : if item_ == entry_point . strategy : return True # For any other type: return False def __iter__ ( self ) -> \"Iterator[EntryPointStrategy]\" : yield from self . _entry_points def __getitem__ ( self , key : \"Any\" ) -> EntryPointStrategy : return self . get_entry_point ( key ) def get_entry_point ( self , key : \"Union[EntryPointStrategy, str, Tuple[Union[StrategyType, str], str]]\" , ) -> EntryPointStrategy : \"\"\"Retrieve an entry point from the collection. Parameters: key: The key to check for in the collection. Raises: KeyError: If an entry point cannot be found in the collection. TypeError: If the `key` is not of an expected type. See the `key` parameter above for the expected types. Returns: An entry point in the collection representing the key. \"\"\" if isinstance ( key , ( EntryPointStrategy , str , tuple )): if key not in self : raise KeyError ( f \" { key } not found in { self } \" ) return self . _get_entry_point ( key ) raise TypeError ( \"key should either be of type EntryPointStrategy, a string of the full \" \"name or a strategy tuple.\" ) def _get_entry_point ( self , key : \"Union[EntryPointStrategy, str, Tuple[Union[StrategyType, str], str]]\" , ) -> EntryPointStrategy : \"\"\"Helper method for retrieving an entry point from the collection. Important: It is expected that the entry point representing the key exists in the collection. For example through a `key in self` test. Parameters: key: The key to check for in the collection. Raises: RuntimeError: If an entry point cannot be found in the collection, since this is a requirement. Returns: An entry point in the collection representing the key. \"\"\" if isinstance ( key , EntryPointStrategy ): return key if isinstance ( key , str ): for entry_point in self . _entry_points : if key == entry_point . full_name : return entry_point if isinstance ( key , tuple ): key_ = ( StrategyType ( key [ 0 ]), key [ 1 ]) for entry_point in self . _entry_points : if key_ == entry_point . strategy : return entry_point raise RuntimeError ( f \" { key } not found in { self } , which is a requirement for the \" \"_get_entry_point method.\" ) def __eq__ ( self , other : \"Any\" ) -> bool : if isinstance ( other , self . __class__ ): return hash ( self ) == hash ( other ) return False def __hash__ ( self ) -> int : return hash ( tuple ( _ for _ in sorted ( self . _entry_points ))) def __str__ ( self ) -> str : number_of_strategies : \"Dict[str, int]\" = {} for entry_point in self . _entry_points : if entry_point . type . value in number_of_strategies : number_of_strategies [ entry_point . type . value ] += 1 else : number_of_strategies [ entry_point . type . value ] = 1 sorted_list = sorted ( f \" { key } ( { value } )\" for key , value in number_of_strategies . items () ) return f \"< { self . __class__ . __name__ } : \" f \"Strategies= { ', ' . join ( sorted_list ) } >\" def __repr__ ( self ) -> str : return f \" { self . __class__ . __name__ } (* { tuple ( sorted ( self . _entry_points )) !r} )\" __contains__ ( item ) \u00b6 Whether or not item is contained in the collection. One can test with an EntryPointStrategy , a string of an entry point strategy's full name, or a tuple of an entry point's strategy type and name. Parameters: Name Type Description Default item 'Any' Item to test whether it is contained in the collection. required Returns: Type Description bool Whether or not item is contained in the collection. bool If the item is an unrecognized type, False will be returned. Source code in oteapi/plugins/entry_points.py 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 def __contains__ ( self , item : \"Any\" ) -> bool : \"\"\"Whether or not `item` is contained in the collection. One can test with an `EntryPointStrategy`, a string of an entry point strategy's full name, or a tuple of an entry point's strategy type and name. Parameters: item: Item to test whether it is contained in the collection. Returns: Whether or not `item` is contained in the collection. If the `item` is an unrecognized type, `False` will be returned. \"\"\" if isinstance ( item , EntryPointStrategy ): return item in self . _entry_points if isinstance ( item , str ): for entry_point in self . _entry_points : if item == entry_point . full_name : return True if isinstance ( item , tuple ): if len ( item ) != 2 or ( not isinstance ( item [ 0 ], ( StrategyType , str )) or not isinstance ( item [ 1 ], str ) ): # Only tuples of type (Union[StrategyType, str], str) are allowed. return False try : item_ = ( StrategyType . init ( item [ 0 ]), item [ 1 ]) except ValueError : # We only want to return True or False return False for entry_point in self . _entry_points : if item_ == entry_point . strategy : return True # For any other type: return False _get_entry_point ( key ) \u00b6 Helper method for retrieving an entry point from the collection. Important It is expected that the entry point representing the key exists in the collection. For example through a key in self test. Parameters: Name Type Description Default key 'Union[EntryPointStrategy, str, Tuple[Union[StrategyType, str], str]]' The key to check for in the collection. required Raises: Type Description RuntimeError If an entry point cannot be found in the collection, since this is a requirement. Returns: Type Description EntryPointStrategy An entry point in the collection representing the key. Source code in oteapi/plugins/entry_points.py 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 def _get_entry_point ( self , key : \"Union[EntryPointStrategy, str, Tuple[Union[StrategyType, str], str]]\" , ) -> EntryPointStrategy : \"\"\"Helper method for retrieving an entry point from the collection. Important: It is expected that the entry point representing the key exists in the collection. For example through a `key in self` test. Parameters: key: The key to check for in the collection. Raises: RuntimeError: If an entry point cannot be found in the collection, since this is a requirement. Returns: An entry point in the collection representing the key. \"\"\" if isinstance ( key , EntryPointStrategy ): return key if isinstance ( key , str ): for entry_point in self . _entry_points : if key == entry_point . full_name : return entry_point if isinstance ( key , tuple ): key_ = ( StrategyType ( key [ 0 ]), key [ 1 ]) for entry_point in self . _entry_points : if key_ == entry_point . strategy : return entry_point raise RuntimeError ( f \" { key } not found in { self } , which is a requirement for the \" \"_get_entry_point method.\" ) add ( * entry_points ) \u00b6 Add entry points to the collection. Parameters: Name Type Description Default *entry_points Iterable [ EntryPointStrategy ] Entry points to add to the collection. () Source code in oteapi/plugins/entry_points.py 327 328 329 330 331 332 333 334 def add ( self , * entry_points : EntryPointStrategy ) -> None : \"\"\"Add entry points to the collection. Parameters: *entry_points (Iterable[EntryPointStrategy]): Entry points to add to the collection. \"\"\" self . _entry_points |= set ( entry_points ) exclusive_add ( * entry_points ) \u00b6 Exclusively add entry points to the collection. Parameters: Name Type Description Default *entry_points Iterable [ EntryPointStrategy ] Entry points to add to the collection. () Raises: Type Description KeyError If an entry point to be added already exists in the collection. Source code in oteapi/plugins/entry_points.py 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 def exclusive_add ( self , * entry_points : EntryPointStrategy ) -> None : \"\"\"Exclusively add entry points to the collection. Parameters: *entry_points (Iterable[EntryPointStrategy]): Entry points to add to the collection. Raises: KeyError: If an entry point to be added already exists in the collection. \"\"\" for entry_point in entry_points : if entry_point in self : raise KeyError ( f \" { entry_point . strategy } already exists in { self } . \" f \"(Tried adding { entry_point } .)\" ) self . add ( entry_point ) get_entry_point ( key ) \u00b6 Retrieve an entry point from the collection. Parameters: Name Type Description Default key 'Union[EntryPointStrategy, str, Tuple[Union[StrategyType, str], str]]' The key to check for in the collection. required Raises: Type Description KeyError If an entry point cannot be found in the collection. TypeError If the key is not of an expected type. See the key parameter above for the expected types. Returns: Type Description EntryPointStrategy An entry point in the collection representing the key. Source code in oteapi/plugins/entry_points.py 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 def get_entry_point ( self , key : \"Union[EntryPointStrategy, str, Tuple[Union[StrategyType, str], str]]\" , ) -> EntryPointStrategy : \"\"\"Retrieve an entry point from the collection. Parameters: key: The key to check for in the collection. Raises: KeyError: If an entry point cannot be found in the collection. TypeError: If the `key` is not of an expected type. See the `key` parameter above for the expected types. Returns: An entry point in the collection representing the key. \"\"\" if isinstance ( key , ( EntryPointStrategy , str , tuple )): if key not in self : raise KeyError ( f \" { key } not found in { self } \" ) return self . _get_entry_point ( key ) raise TypeError ( \"key should either be of type EntryPointStrategy, a string of the full \" \"name or a strategy tuple.\" ) remove ( * entry_points ) \u00b6 Remove entry points from the collection. Parameters: Name Type Description Default *entry_points Iterable [ EntryPointStrategy ] Entry points to remove from the collection. () Source code in oteapi/plugins/entry_points.py 336 337 338 339 340 341 342 343 344 def remove ( self , * entry_points : EntryPointStrategy ) -> None : \"\"\"Remove entry points from the collection. Parameters: *entry_points (Iterable[EntryPointStrategy]): Entry points to remove from the collection. \"\"\" self . _entry_points -= set ( entry_points ) StrategyType \u00b6 Bases: Enum An enumeration of available strategy types. Available strategy types: download filter function mapping parse resource transformation Source code in oteapi/plugins/entry_points.py 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 class StrategyType ( Enum ): \"\"\"An enumeration of available strategy types. Available strategy types: - download - filter - function - mapping - parse - resource - transformation \"\"\" DOWNLOAD = \"download\" FILTER = \"filter\" FUNCTION = \"function\" MAPPING = \"mapping\" PARSE = \"parse\" RESOURCE = \"resource\" TRANSFORMATION = \"transformation\" def map_to_field ( self ) -> str : \"\"\"Map enumeration value to the strategy type's field.\"\"\" return { \"download\" : \"scheme\" , \"filter\" : \"filterType\" , \"function\" : \"functionType\" , \"mapping\" : \"mappingType\" , \"parse\" : \"mediaType\" , \"resource\" : \"accessService\" , \"transformation\" : \"transformationType\" , }[ self . value ] @classmethod def map_from_field ( cls , strategy_type_field : str ) -> \"StrategyType\" : \"\"\"Map the strategy type's field to enumeration. Parameters: strategy_type_field: The strategy type's field. E.g., `scheme` for `download`. Raises: KeyError: If the `strategy_type_field` is not valid. Returns: An enumeration instance representing the strategy type's field. \"\"\" return { \"scheme\" : cls . DOWNLOAD , \"filterType\" : cls . FILTER , \"functionType\" : cls . FUNCTION , \"mappingType\" : cls . MAPPING , \"mediaType\" : cls . PARSE , \"accessService\" : cls . RESOURCE , \"transformationType\" : cls . TRANSFORMATION , }[ strategy_type_field ] @classmethod def init ( cls , value : \"Union[str, StrategyType]\" ) -> \"StrategyType\" : \"\"\"Initialize a StrategyType with more than just the enumeration value. This method allows one to also initialize a StrategyType with an actual strategy type string, e.g., `scheme`, `mediaType`, etc. Raises: ValueError: As normal if the enumeration value is not valid. \"\"\" if isinstance ( value , str ): try : return cls . map_from_field ( value ) except KeyError : pass return cls ( value ) @classmethod def all_values ( cls ) -> \"Tuple[str, ...]\" : \"\"\"Return all values.\"\"\" return tuple ( strategy_type . value for strategy_type in cls ) def __str__ ( self ) -> str : return str ( self . value ) def __repr__ ( self ) -> str : return repr ( str ( self )) @property def config_cls ( self ) -> \"Type[StrategyConfig]\" : \"\"\"Return the strategy-specific `*Config` class.\"\"\" return { # type: ignore[return-value] \"download\" : ResourceConfig , \"filter\" : FilterConfig , \"function\" : FunctionConfig , \"mapping\" : MappingConfig , \"parse\" : ResourceConfig , \"resource\" : ResourceConfig , \"transformation\" : TransformationConfig , }[ self . value ] all_values () classmethod \u00b6 Return all values. Source code in oteapi/plugins/entry_points.py 118 119 120 121 @classmethod def all_values ( cls ) -> \"Tuple[str, ...]\" : \"\"\"Return all values.\"\"\" return tuple ( strategy_type . value for strategy_type in cls ) config_cls () property \u00b6 Return the strategy-specific *Config class. Source code in oteapi/plugins/entry_points.py 129 130 131 132 133 134 135 136 137 138 139 140 @property def config_cls ( self ) -> \"Type[StrategyConfig]\" : \"\"\"Return the strategy-specific `*Config` class.\"\"\" return { # type: ignore[return-value] \"download\" : ResourceConfig , \"filter\" : FilterConfig , \"function\" : FunctionConfig , \"mapping\" : MappingConfig , \"parse\" : ResourceConfig , \"resource\" : ResourceConfig , \"transformation\" : TransformationConfig , }[ self . value ] init ( value ) classmethod \u00b6 Initialize a StrategyType with more than just the enumeration value. This method allows one to also initialize a StrategyType with an actual strategy type string, e.g., scheme , mediaType , etc. Raises: Type Description ValueError As normal if the enumeration value is not valid. Source code in oteapi/plugins/entry_points.py 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 @classmethod def init ( cls , value : \"Union[str, StrategyType]\" ) -> \"StrategyType\" : \"\"\"Initialize a StrategyType with more than just the enumeration value. This method allows one to also initialize a StrategyType with an actual strategy type string, e.g., `scheme`, `mediaType`, etc. Raises: ValueError: As normal if the enumeration value is not valid. \"\"\" if isinstance ( value , str ): try : return cls . map_from_field ( value ) except KeyError : pass return cls ( value ) map_from_field ( strategy_type_field ) classmethod \u00b6 Map the strategy type's field to enumeration. Parameters: Name Type Description Default strategy_type_field str The strategy type's field. E.g., scheme for download . required Raises: Type Description KeyError If the strategy_type_field is not valid. Returns: Type Description 'StrategyType' An enumeration instance representing the strategy type's field. Source code in oteapi/plugins/entry_points.py 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 @classmethod def map_from_field ( cls , strategy_type_field : str ) -> \"StrategyType\" : \"\"\"Map the strategy type's field to enumeration. Parameters: strategy_type_field: The strategy type's field. E.g., `scheme` for `download`. Raises: KeyError: If the `strategy_type_field` is not valid. Returns: An enumeration instance representing the strategy type's field. \"\"\" return { \"scheme\" : cls . DOWNLOAD , \"filterType\" : cls . FILTER , \"functionType\" : cls . FUNCTION , \"mappingType\" : cls . MAPPING , \"mediaType\" : cls . PARSE , \"accessService\" : cls . RESOURCE , \"transformationType\" : cls . TRANSFORMATION , }[ strategy_type_field ] map_to_field () \u00b6 Map enumeration value to the strategy type's field. Source code in oteapi/plugins/entry_points.py 63 64 65 66 67 68 69 70 71 72 73 def map_to_field ( self ) -> str : \"\"\"Map enumeration value to the strategy type's field.\"\"\" return { \"download\" : \"scheme\" , \"filter\" : \"filterType\" , \"function\" : \"functionType\" , \"mapping\" : \"mappingType\" , \"parse\" : \"mediaType\" , \"resource\" : \"accessService\" , \"transformation\" : \"transformationType\" , }[ self . value ] get_strategy_entry_points ( strategy_type , enforce_uniqueness = True ) \u00b6 Retrieve all entry points from a specific strategy type. Raises: Type Description ValueError If the strategy type is not supported. KeyError If enforce_uniqueness is True and an entry point strategy is duplicated. Parameters: Name Type Description Default strategy_type 'Union[StrategyType, str]' A strategy type for which the entry points will be retrieved. required enforce_uniqueness bool Whether or not duplicate entry point strategies are allowed. Defaults to True , meaning duplicates are not allowed. True Returns: Type Description EntryPointStrategyCollection A collection of entry points for the specific strategy type. Source code in oteapi/plugins/entry_points.py 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 def get_strategy_entry_points ( strategy_type : \"Union[StrategyType, str]\" , enforce_uniqueness : bool = True , ) -> EntryPointStrategyCollection : \"\"\"Retrieve all entry points from a specific strategy type. Raises: ValueError: If the strategy type is not supported. KeyError: If `enforce_uniqueness` is `True` and an entry point strategy is duplicated. Parameters: strategy_type: A strategy type for which the entry points will be retrieved. enforce_uniqueness: Whether or not duplicate entry point strategies are allowed. Defaults to `True`, meaning duplicates are *not* allowed. Returns: A collection of entry points for the specific strategy type. \"\"\" try : strategy_type = StrategyType ( strategy_type ) except ValueError as exc : raise ValueError ( \"Strategy type \" f \" { strategy_type if isinstance ( strategy_type , str ) else str ( strategy_type . value ) !r} \" \" is not supported.\" ) from exc collection = EntryPointStrategyCollection () oteapi_entry_points = sorted ( set ( get_entry_points () . get ( f \"oteapi. { strategy_type . value } \" , [])) ) if enforce_uniqueness : collection . exclusive_add ( * ( EntryPointStrategy ( _ ) for _ in oteapi_entry_points )) else : collection . add ( * ( EntryPointStrategy ( _ ) for _ in oteapi_entry_points )) return collection","title":"entry_points"},{"location":"api_reference/plugins/entry_points/#entry_points","text":"Load plugins through entry points. This module deals with handling all plugged in strategies through the entry points API and importlib metadata API. Special functionality is put in place to handle the OTE-API-specific entry points. Since the entry points are information complete in and of themselves, there is no need to import actual strategy classes until they are truly needed. This therefore implements lazy loading of all plugin strategies.","title":"entry_points"},{"location":"api_reference/plugins/entry_points/#oteapi.plugins.entry_points.EntryPointNotFound","text":"Bases: Exception A given strategy implementation (class) cannot be found from the given entry point value. Source code in oteapi/plugins/entry_points.py 35 36 37 class EntryPointNotFound ( Exception ): \"\"\"A given strategy implementation (class) cannot be found from the given entry point value.\"\"\"","title":"EntryPointNotFound"},{"location":"api_reference/plugins/entry_points/#oteapi.plugins.entry_points.EntryPointStrategy","text":"A strategy realized from an entry point. An entry point strategy is made unique by its \"strategy\", i.e., its (strategy type, strategy name)-tuple, e.g., (\"download\", \"https\") . This tuple can be retrieved from the strategy property, where the strategy type is represented by the StrategyType enumeration. Note It may be that in the future an entry points strategy is made unique by its \"full name\" instead, i.e., the entry point group + the entry points name, e.g., oteapi.download:oteapi.https . This value can be retrieved from the full_name property. This is a condition for uniqueness that is considered to be a superset of the current condition for uniqueness. It adds an extra package-specific uniqueness trait, allowing for different packages to implement the same strategies (which is currently not allowed according to the condition of uniqueness explained above). Currently there is no consensus on the API for handling this added strategy ambiguity. Raises: Type Description ValueError If the entry point name is not properly defined. Source code in oteapi/plugins/entry_points.py 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 class EntryPointStrategy : \"\"\"A strategy realized from an entry point. An entry point strategy is made unique by its \"strategy\", i.e., its (strategy type, strategy name)-tuple, e.g., `(\"download\", \"https\")`. This tuple can be retrieved from the [`strategy`][oteapi.plugins.entry_points.EntryPointStrategy.strategy] property, where the strategy type is represented by the [`StrategyType`][oteapi.plugins.entry_points.StrategyType] enumeration. Note: It may be that in the future an entry points strategy is made unique by its \"full name\" instead, i.e., the entry point group + the entry points name, e.g., `oteapi.download:oteapi.https`. This value can be retrieved from the [`full_name`][oteapi.plugins.entry_points.EntryPointStrategy.full_name] property. This is a condition for uniqueness that is considered to be a superset of the current condition for uniqueness. It adds an extra package-specific uniqueness trait, allowing for different packages to implement the same strategies (which is currently not allowed according to the condition of uniqueness explained above). Currently there is no consensus on the API for handling this added strategy ambiguity. Raises: ValueError: If the entry point name is not properly defined. \"\"\" ENTRY_POINT_NAME_REGEX = re . compile ( r \"^(?P<package_name>[a-z_]+)\\.(?P<strategy_name>.+)$\" ) ENTRY_POINT_NAME_SEPARATOR = \":\" def __init__ ( self , entry_point : \"EntryPoint\" ) -> None : self . _entry_point = entry_point match = self . ENTRY_POINT_NAME_REGEX . match ( self . _entry_point . name ) if match is None : raise ValueError ( \"Could not determine package name and/or strategy name for entry \" f \"point: { self . full_name } \" ) self . _match = match self . _type = StrategyType ( self . _entry_point . group [ len ( \"oteapi.\" ) :]) self . _implementation : \"Optional[Type[IStrategy]]\" = None @property def type ( self ) -> StrategyType : \"\"\"The strategy type. One part of the (strategy type, strategy name)-tuple. \"\"\" return self . _type @property def name ( self ) -> str : \"\"\"The strategy name. One part of the (strategy type, strategy name)-tuple. \"\"\" return self . _match . group ( \"strategy_name\" ) @property def strategy ( self ) -> \"Tuple[StrategyType, str]\" : \"\"\"The unique index identifier for the strategy.\"\"\" return self . type , self . name @property def package ( self ) -> str : \"\"\"The importable base package name for the strategy plugin.\"\"\" return self . _match . group ( \"package_name\" ) @property def module ( self ) -> str : \"\"\"The fully resolved importable module path.\"\"\" return self . _entry_point . module # type: ignore[attr-defined] @property def full_name ( self ) -> str : \"\"\"The full entry point name.\"\"\" return f \" { self . _entry_point . group }{ self . ENTRY_POINT_NAME_SEPARATOR }{ self . _entry_point . name } \" def __str__ ( self ) -> str : return self . full_name def __repr__ ( self ) -> str : return f \" { self . __class__ . __name__ } (entry_point= { self . _entry_point !r} )\" @property def implementation_name ( self ) -> str : \"\"\"The EntryPoint attr, which should be the strategy implementation class name.\"\"\" return self . _entry_point . attr # type: ignore[attr-defined] @property def implementation ( self ) -> \"Type[IStrategy]\" : \"\"\"The actual strategy implementation.\"\"\" if self . _implementation is None : self . _implementation = self . _load_implementation () return self . _implementation def _load_implementation ( self ) -> \"Type[IStrategy]\" : \"\"\"Load the strategy implementation. Because the actual importing of the module does not happen until this method is called, we are lazily loading in the strategy implementation. There is no need to check through the `globals()` built-in for whether the module and class have already been imported, because this caching layer is already implemented in the `importlib` API. Raises: EntryPointNotFound: If the strategy implementation (class) the entry point is pointing to cannot be found in the module or if the module cannot be imported. Returns: The imported strategy implementation (class). \"\"\" try : module = importlib . import_module ( self . module ) except ImportError as exc : raise EntryPointNotFound ( f \" { self . module } cannot be imported. Did you install the \" f \" { self . package !r} package?\" ) from exc if hasattr ( module , self . implementation_name ): return getattr ( module , self . implementation_name ) raise EntryPointNotFound ( f \" { self . implementation_name } cannot be found in { self . module } \" ) def __eq__ ( self , other : \"Any\" ) -> bool : if isinstance ( other , self . __class__ ): return hash ( self ) == hash ( other ) return False def __hash__ ( self ) -> int : return hash ( self . strategy ) def __lt__ ( self , other : \"Any\" ) -> bool : \"\"\"Whether or not `self` is less than (`<`) `other`. This is implemented to allow sorting (using `sorted()`). The inequality is determined on the basis of the following properties: 1. [`type`][oteapi.plugins.entry_points.EntryPointStrategy.type] 2. [`package`][oteapi.plugins.entry_points.EntryPointStrategy.package] 3. [`name`][oteapi.plugins.entry_points.EntryPointStrategy.name] Going from highest priority to lowest and in alphabetical ascending order. \"\"\" if isinstance ( other , self . __class__ ): if self . type == other . type : if self . package == other . package : if self . name == other . name : # Considered equal, i.e., one can by definition not be unequal # with the other. return False return sorted ([ self . name , other . name ])[ 0 ] == self . name return sorted ([ self . package , other . package ])[ 0 ] == self . package return sorted ([ self . type . value , other . type . value ])[ 0 ] == self . type . value raise NotImplementedError ( f \"Less than comparison is not implemented for { type ( other ) } type objects.\" )","title":"EntryPointStrategy"},{"location":"api_reference/plugins/entry_points/#oteapi.plugins.entry_points.EntryPointStrategy.__lt__","text":"Whether or not self is less than ( < ) other . This is implemented to allow sorting (using sorted() ). The inequality is determined on the basis of the following properties: type package name Going from highest priority to lowest and in alphabetical ascending order. Source code in oteapi/plugins/entry_points.py 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 def __lt__ ( self , other : \"Any\" ) -> bool : \"\"\"Whether or not `self` is less than (`<`) `other`. This is implemented to allow sorting (using `sorted()`). The inequality is determined on the basis of the following properties: 1. [`type`][oteapi.plugins.entry_points.EntryPointStrategy.type] 2. [`package`][oteapi.plugins.entry_points.EntryPointStrategy.package] 3. [`name`][oteapi.plugins.entry_points.EntryPointStrategy.name] Going from highest priority to lowest and in alphabetical ascending order. \"\"\" if isinstance ( other , self . __class__ ): if self . type == other . type : if self . package == other . package : if self . name == other . name : # Considered equal, i.e., one can by definition not be unequal # with the other. return False return sorted ([ self . name , other . name ])[ 0 ] == self . name return sorted ([ self . package , other . package ])[ 0 ] == self . package return sorted ([ self . type . value , other . type . value ])[ 0 ] == self . type . value raise NotImplementedError ( f \"Less than comparison is not implemented for { type ( other ) } type objects.\" )","title":"__lt__()"},{"location":"api_reference/plugins/entry_points/#oteapi.plugins.entry_points.EntryPointStrategy._load_implementation","text":"Load the strategy implementation. Because the actual importing of the module does not happen until this method is called, we are lazily loading in the strategy implementation. There is no need to check through the globals() built-in for whether the module and class have already been imported, because this caching layer is already implemented in the importlib API. Raises: Type Description EntryPointNotFound If the strategy implementation (class) the entry point is pointing to cannot be found in the module or if the module cannot be imported. Returns: Type Description 'Type[IStrategy]' The imported strategy implementation (class). Source code in oteapi/plugins/entry_points.py 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 def _load_implementation ( self ) -> \"Type[IStrategy]\" : \"\"\"Load the strategy implementation. Because the actual importing of the module does not happen until this method is called, we are lazily loading in the strategy implementation. There is no need to check through the `globals()` built-in for whether the module and class have already been imported, because this caching layer is already implemented in the `importlib` API. Raises: EntryPointNotFound: If the strategy implementation (class) the entry point is pointing to cannot be found in the module or if the module cannot be imported. Returns: The imported strategy implementation (class). \"\"\" try : module = importlib . import_module ( self . module ) except ImportError as exc : raise EntryPointNotFound ( f \" { self . module } cannot be imported. Did you install the \" f \" { self . package !r} package?\" ) from exc if hasattr ( module , self . implementation_name ): return getattr ( module , self . implementation_name ) raise EntryPointNotFound ( f \" { self . implementation_name } cannot be found in { self . module } \" )","title":"_load_implementation()"},{"location":"api_reference/plugins/entry_points/#oteapi.plugins.entry_points.EntryPointStrategy.full_name","text":"The full entry point name. Source code in oteapi/plugins/entry_points.py 225 226 227 228 @property def full_name ( self ) -> str : \"\"\"The full entry point name.\"\"\" return f \" { self . _entry_point . group }{ self . ENTRY_POINT_NAME_SEPARATOR }{ self . _entry_point . name } \"","title":"full_name()"},{"location":"api_reference/plugins/entry_points/#oteapi.plugins.entry_points.EntryPointStrategy.implementation","text":"The actual strategy implementation. Source code in oteapi/plugins/entry_points.py 242 243 244 245 246 247 @property def implementation ( self ) -> \"Type[IStrategy]\" : \"\"\"The actual strategy implementation.\"\"\" if self . _implementation is None : self . _implementation = self . _load_implementation () return self . _implementation","title":"implementation()"},{"location":"api_reference/plugins/entry_points/#oteapi.plugins.entry_points.EntryPointStrategy.implementation_name","text":"The EntryPoint attr, which should be the strategy implementation class name. Source code in oteapi/plugins/entry_points.py 236 237 238 239 240 @property def implementation_name ( self ) -> str : \"\"\"The EntryPoint attr, which should be the strategy implementation class name.\"\"\" return self . _entry_point . attr # type: ignore[attr-defined]","title":"implementation_name()"},{"location":"api_reference/plugins/entry_points/#oteapi.plugins.entry_points.EntryPointStrategy.module","text":"The fully resolved importable module path. Source code in oteapi/plugins/entry_points.py 220 221 222 223 @property def module ( self ) -> str : \"\"\"The fully resolved importable module path.\"\"\" return self . _entry_point . module # type: ignore[attr-defined]","title":"module()"},{"location":"api_reference/plugins/entry_points/#oteapi.plugins.entry_points.EntryPointStrategy.name","text":"The strategy name. One part of the (strategy type, strategy name)-tuple. Source code in oteapi/plugins/entry_points.py 202 203 204 205 206 207 208 @property def name ( self ) -> str : \"\"\"The strategy name. One part of the (strategy type, strategy name)-tuple. \"\"\" return self . _match . group ( \"strategy_name\" )","title":"name()"},{"location":"api_reference/plugins/entry_points/#oteapi.plugins.entry_points.EntryPointStrategy.package","text":"The importable base package name for the strategy plugin. Source code in oteapi/plugins/entry_points.py 215 216 217 218 @property def package ( self ) -> str : \"\"\"The importable base package name for the strategy plugin.\"\"\" return self . _match . group ( \"package_name\" )","title":"package()"},{"location":"api_reference/plugins/entry_points/#oteapi.plugins.entry_points.EntryPointStrategy.strategy","text":"The unique index identifier for the strategy. Source code in oteapi/plugins/entry_points.py 210 211 212 213 @property def strategy ( self ) -> \"Tuple[StrategyType, str]\" : \"\"\"The unique index identifier for the strategy.\"\"\" return self . type , self . name","title":"strategy()"},{"location":"api_reference/plugins/entry_points/#oteapi.plugins.entry_points.EntryPointStrategy.type","text":"The strategy type. One part of the (strategy type, strategy name)-tuple. Source code in oteapi/plugins/entry_points.py 194 195 196 197 198 199 200 @property def type ( self ) -> StrategyType : \"\"\"The strategy type. One part of the (strategy type, strategy name)-tuple. \"\"\" return self . _type","title":"type()"},{"location":"api_reference/plugins/entry_points/#oteapi.plugins.entry_points.EntryPointStrategyCollection","text":"Bases: abc . Collection A collection of EntryPointStrategy s. Source code in oteapi/plugins/entry_points.py 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 class EntryPointStrategyCollection ( abc . Collection ): \"\"\"A collection of [`EntryPointStrategy`][oteapi.plugins.entry_points.EntryPointStrategy]s.\"\"\" def __init__ ( self , * entry_points : \"EntryPointStrategy\" ) -> None : self . _entry_points : \"Set[EntryPointStrategy]\" = ( set ( entry_points ) if entry_points else set () ) def add ( self , * entry_points : EntryPointStrategy ) -> None : \"\"\"Add entry points to the collection. Parameters: *entry_points (Iterable[EntryPointStrategy]): Entry points to add to the collection. \"\"\" self . _entry_points |= set ( entry_points ) def remove ( self , * entry_points : EntryPointStrategy ) -> None : \"\"\"Remove entry points from the collection. Parameters: *entry_points (Iterable[EntryPointStrategy]): Entry points to remove from the collection. \"\"\" self . _entry_points -= set ( entry_points ) def exclusive_add ( self , * entry_points : EntryPointStrategy ) -> None : \"\"\"Exclusively add entry points to the collection. Parameters: *entry_points (Iterable[EntryPointStrategy]): Entry points to add to the collection. Raises: KeyError: If an entry point to be added already exists in the collection. \"\"\" for entry_point in entry_points : if entry_point in self : raise KeyError ( f \" { entry_point . strategy } already exists in { self } . \" f \"(Tried adding { entry_point } .)\" ) self . add ( entry_point ) def __len__ ( self ) -> int : return len ( self . _entry_points ) def __contains__ ( self , item : \"Any\" ) -> bool : \"\"\"Whether or not `item` is contained in the collection. One can test with an `EntryPointStrategy`, a string of an entry point strategy's full name, or a tuple of an entry point's strategy type and name. Parameters: item: Item to test whether it is contained in the collection. Returns: Whether or not `item` is contained in the collection. If the `item` is an unrecognized type, `False` will be returned. \"\"\" if isinstance ( item , EntryPointStrategy ): return item in self . _entry_points if isinstance ( item , str ): for entry_point in self . _entry_points : if item == entry_point . full_name : return True if isinstance ( item , tuple ): if len ( item ) != 2 or ( not isinstance ( item [ 0 ], ( StrategyType , str )) or not isinstance ( item [ 1 ], str ) ): # Only tuples of type (Union[StrategyType, str], str) are allowed. return False try : item_ = ( StrategyType . init ( item [ 0 ]), item [ 1 ]) except ValueError : # We only want to return True or False return False for entry_point in self . _entry_points : if item_ == entry_point . strategy : return True # For any other type: return False def __iter__ ( self ) -> \"Iterator[EntryPointStrategy]\" : yield from self . _entry_points def __getitem__ ( self , key : \"Any\" ) -> EntryPointStrategy : return self . get_entry_point ( key ) def get_entry_point ( self , key : \"Union[EntryPointStrategy, str, Tuple[Union[StrategyType, str], str]]\" , ) -> EntryPointStrategy : \"\"\"Retrieve an entry point from the collection. Parameters: key: The key to check for in the collection. Raises: KeyError: If an entry point cannot be found in the collection. TypeError: If the `key` is not of an expected type. See the `key` parameter above for the expected types. Returns: An entry point in the collection representing the key. \"\"\" if isinstance ( key , ( EntryPointStrategy , str , tuple )): if key not in self : raise KeyError ( f \" { key } not found in { self } \" ) return self . _get_entry_point ( key ) raise TypeError ( \"key should either be of type EntryPointStrategy, a string of the full \" \"name or a strategy tuple.\" ) def _get_entry_point ( self , key : \"Union[EntryPointStrategy, str, Tuple[Union[StrategyType, str], str]]\" , ) -> EntryPointStrategy : \"\"\"Helper method for retrieving an entry point from the collection. Important: It is expected that the entry point representing the key exists in the collection. For example through a `key in self` test. Parameters: key: The key to check for in the collection. Raises: RuntimeError: If an entry point cannot be found in the collection, since this is a requirement. Returns: An entry point in the collection representing the key. \"\"\" if isinstance ( key , EntryPointStrategy ): return key if isinstance ( key , str ): for entry_point in self . _entry_points : if key == entry_point . full_name : return entry_point if isinstance ( key , tuple ): key_ = ( StrategyType ( key [ 0 ]), key [ 1 ]) for entry_point in self . _entry_points : if key_ == entry_point . strategy : return entry_point raise RuntimeError ( f \" { key } not found in { self } , which is a requirement for the \" \"_get_entry_point method.\" ) def __eq__ ( self , other : \"Any\" ) -> bool : if isinstance ( other , self . __class__ ): return hash ( self ) == hash ( other ) return False def __hash__ ( self ) -> int : return hash ( tuple ( _ for _ in sorted ( self . _entry_points ))) def __str__ ( self ) -> str : number_of_strategies : \"Dict[str, int]\" = {} for entry_point in self . _entry_points : if entry_point . type . value in number_of_strategies : number_of_strategies [ entry_point . type . value ] += 1 else : number_of_strategies [ entry_point . type . value ] = 1 sorted_list = sorted ( f \" { key } ( { value } )\" for key , value in number_of_strategies . items () ) return f \"< { self . __class__ . __name__ } : \" f \"Strategies= { ', ' . join ( sorted_list ) } >\" def __repr__ ( self ) -> str : return f \" { self . __class__ . __name__ } (* { tuple ( sorted ( self . _entry_points )) !r} )\"","title":"EntryPointStrategyCollection"},{"location":"api_reference/plugins/entry_points/#oteapi.plugins.entry_points.EntryPointStrategyCollection.__contains__","text":"Whether or not item is contained in the collection. One can test with an EntryPointStrategy , a string of an entry point strategy's full name, or a tuple of an entry point's strategy type and name. Parameters: Name Type Description Default item 'Any' Item to test whether it is contained in the collection. required Returns: Type Description bool Whether or not item is contained in the collection. bool If the item is an unrecognized type, False will be returned. Source code in oteapi/plugins/entry_points.py 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 def __contains__ ( self , item : \"Any\" ) -> bool : \"\"\"Whether or not `item` is contained in the collection. One can test with an `EntryPointStrategy`, a string of an entry point strategy's full name, or a tuple of an entry point's strategy type and name. Parameters: item: Item to test whether it is contained in the collection. Returns: Whether or not `item` is contained in the collection. If the `item` is an unrecognized type, `False` will be returned. \"\"\" if isinstance ( item , EntryPointStrategy ): return item in self . _entry_points if isinstance ( item , str ): for entry_point in self . _entry_points : if item == entry_point . full_name : return True if isinstance ( item , tuple ): if len ( item ) != 2 or ( not isinstance ( item [ 0 ], ( StrategyType , str )) or not isinstance ( item [ 1 ], str ) ): # Only tuples of type (Union[StrategyType, str], str) are allowed. return False try : item_ = ( StrategyType . init ( item [ 0 ]), item [ 1 ]) except ValueError : # We only want to return True or False return False for entry_point in self . _entry_points : if item_ == entry_point . strategy : return True # For any other type: return False","title":"__contains__()"},{"location":"api_reference/plugins/entry_points/#oteapi.plugins.entry_points.EntryPointStrategyCollection._get_entry_point","text":"Helper method for retrieving an entry point from the collection. Important It is expected that the entry point representing the key exists in the collection. For example through a key in self test. Parameters: Name Type Description Default key 'Union[EntryPointStrategy, str, Tuple[Union[StrategyType, str], str]]' The key to check for in the collection. required Raises: Type Description RuntimeError If an entry point cannot be found in the collection, since this is a requirement. Returns: Type Description EntryPointStrategy An entry point in the collection representing the key. Source code in oteapi/plugins/entry_points.py 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 def _get_entry_point ( self , key : \"Union[EntryPointStrategy, str, Tuple[Union[StrategyType, str], str]]\" , ) -> EntryPointStrategy : \"\"\"Helper method for retrieving an entry point from the collection. Important: It is expected that the entry point representing the key exists in the collection. For example through a `key in self` test. Parameters: key: The key to check for in the collection. Raises: RuntimeError: If an entry point cannot be found in the collection, since this is a requirement. Returns: An entry point in the collection representing the key. \"\"\" if isinstance ( key , EntryPointStrategy ): return key if isinstance ( key , str ): for entry_point in self . _entry_points : if key == entry_point . full_name : return entry_point if isinstance ( key , tuple ): key_ = ( StrategyType ( key [ 0 ]), key [ 1 ]) for entry_point in self . _entry_points : if key_ == entry_point . strategy : return entry_point raise RuntimeError ( f \" { key } not found in { self } , which is a requirement for the \" \"_get_entry_point method.\" )","title":"_get_entry_point()"},{"location":"api_reference/plugins/entry_points/#oteapi.plugins.entry_points.EntryPointStrategyCollection.add","text":"Add entry points to the collection. Parameters: Name Type Description Default *entry_points Iterable [ EntryPointStrategy ] Entry points to add to the collection. () Source code in oteapi/plugins/entry_points.py 327 328 329 330 331 332 333 334 def add ( self , * entry_points : EntryPointStrategy ) -> None : \"\"\"Add entry points to the collection. Parameters: *entry_points (Iterable[EntryPointStrategy]): Entry points to add to the collection. \"\"\" self . _entry_points |= set ( entry_points )","title":"add()"},{"location":"api_reference/plugins/entry_points/#oteapi.plugins.entry_points.EntryPointStrategyCollection.exclusive_add","text":"Exclusively add entry points to the collection. Parameters: Name Type Description Default *entry_points Iterable [ EntryPointStrategy ] Entry points to add to the collection. () Raises: Type Description KeyError If an entry point to be added already exists in the collection. Source code in oteapi/plugins/entry_points.py 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 def exclusive_add ( self , * entry_points : EntryPointStrategy ) -> None : \"\"\"Exclusively add entry points to the collection. Parameters: *entry_points (Iterable[EntryPointStrategy]): Entry points to add to the collection. Raises: KeyError: If an entry point to be added already exists in the collection. \"\"\" for entry_point in entry_points : if entry_point in self : raise KeyError ( f \" { entry_point . strategy } already exists in { self } . \" f \"(Tried adding { entry_point } .)\" ) self . add ( entry_point )","title":"exclusive_add()"},{"location":"api_reference/plugins/entry_points/#oteapi.plugins.entry_points.EntryPointStrategyCollection.get_entry_point","text":"Retrieve an entry point from the collection. Parameters: Name Type Description Default key 'Union[EntryPointStrategy, str, Tuple[Union[StrategyType, str], str]]' The key to check for in the collection. required Raises: Type Description KeyError If an entry point cannot be found in the collection. TypeError If the key is not of an expected type. See the key parameter above for the expected types. Returns: Type Description EntryPointStrategy An entry point in the collection representing the key. Source code in oteapi/plugins/entry_points.py 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 def get_entry_point ( self , key : \"Union[EntryPointStrategy, str, Tuple[Union[StrategyType, str], str]]\" , ) -> EntryPointStrategy : \"\"\"Retrieve an entry point from the collection. Parameters: key: The key to check for in the collection. Raises: KeyError: If an entry point cannot be found in the collection. TypeError: If the `key` is not of an expected type. See the `key` parameter above for the expected types. Returns: An entry point in the collection representing the key. \"\"\" if isinstance ( key , ( EntryPointStrategy , str , tuple )): if key not in self : raise KeyError ( f \" { key } not found in { self } \" ) return self . _get_entry_point ( key ) raise TypeError ( \"key should either be of type EntryPointStrategy, a string of the full \" \"name or a strategy tuple.\" )","title":"get_entry_point()"},{"location":"api_reference/plugins/entry_points/#oteapi.plugins.entry_points.EntryPointStrategyCollection.remove","text":"Remove entry points from the collection. Parameters: Name Type Description Default *entry_points Iterable [ EntryPointStrategy ] Entry points to remove from the collection. () Source code in oteapi/plugins/entry_points.py 336 337 338 339 340 341 342 343 344 def remove ( self , * entry_points : EntryPointStrategy ) -> None : \"\"\"Remove entry points from the collection. Parameters: *entry_points (Iterable[EntryPointStrategy]): Entry points to remove from the collection. \"\"\" self . _entry_points -= set ( entry_points )","title":"remove()"},{"location":"api_reference/plugins/entry_points/#oteapi.plugins.entry_points.StrategyType","text":"Bases: Enum An enumeration of available strategy types. Available strategy types: download filter function mapping parse resource transformation Source code in oteapi/plugins/entry_points.py 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 class StrategyType ( Enum ): \"\"\"An enumeration of available strategy types. Available strategy types: - download - filter - function - mapping - parse - resource - transformation \"\"\" DOWNLOAD = \"download\" FILTER = \"filter\" FUNCTION = \"function\" MAPPING = \"mapping\" PARSE = \"parse\" RESOURCE = \"resource\" TRANSFORMATION = \"transformation\" def map_to_field ( self ) -> str : \"\"\"Map enumeration value to the strategy type's field.\"\"\" return { \"download\" : \"scheme\" , \"filter\" : \"filterType\" , \"function\" : \"functionType\" , \"mapping\" : \"mappingType\" , \"parse\" : \"mediaType\" , \"resource\" : \"accessService\" , \"transformation\" : \"transformationType\" , }[ self . value ] @classmethod def map_from_field ( cls , strategy_type_field : str ) -> \"StrategyType\" : \"\"\"Map the strategy type's field to enumeration. Parameters: strategy_type_field: The strategy type's field. E.g., `scheme` for `download`. Raises: KeyError: If the `strategy_type_field` is not valid. Returns: An enumeration instance representing the strategy type's field. \"\"\" return { \"scheme\" : cls . DOWNLOAD , \"filterType\" : cls . FILTER , \"functionType\" : cls . FUNCTION , \"mappingType\" : cls . MAPPING , \"mediaType\" : cls . PARSE , \"accessService\" : cls . RESOURCE , \"transformationType\" : cls . TRANSFORMATION , }[ strategy_type_field ] @classmethod def init ( cls , value : \"Union[str, StrategyType]\" ) -> \"StrategyType\" : \"\"\"Initialize a StrategyType with more than just the enumeration value. This method allows one to also initialize a StrategyType with an actual strategy type string, e.g., `scheme`, `mediaType`, etc. Raises: ValueError: As normal if the enumeration value is not valid. \"\"\" if isinstance ( value , str ): try : return cls . map_from_field ( value ) except KeyError : pass return cls ( value ) @classmethod def all_values ( cls ) -> \"Tuple[str, ...]\" : \"\"\"Return all values.\"\"\" return tuple ( strategy_type . value for strategy_type in cls ) def __str__ ( self ) -> str : return str ( self . value ) def __repr__ ( self ) -> str : return repr ( str ( self )) @property def config_cls ( self ) -> \"Type[StrategyConfig]\" : \"\"\"Return the strategy-specific `*Config` class.\"\"\" return { # type: ignore[return-value] \"download\" : ResourceConfig , \"filter\" : FilterConfig , \"function\" : FunctionConfig , \"mapping\" : MappingConfig , \"parse\" : ResourceConfig , \"resource\" : ResourceConfig , \"transformation\" : TransformationConfig , }[ self . value ]","title":"StrategyType"},{"location":"api_reference/plugins/entry_points/#oteapi.plugins.entry_points.StrategyType.all_values","text":"Return all values. Source code in oteapi/plugins/entry_points.py 118 119 120 121 @classmethod def all_values ( cls ) -> \"Tuple[str, ...]\" : \"\"\"Return all values.\"\"\" return tuple ( strategy_type . value for strategy_type in cls )","title":"all_values()"},{"location":"api_reference/plugins/entry_points/#oteapi.plugins.entry_points.StrategyType.config_cls","text":"Return the strategy-specific *Config class. Source code in oteapi/plugins/entry_points.py 129 130 131 132 133 134 135 136 137 138 139 140 @property def config_cls ( self ) -> \"Type[StrategyConfig]\" : \"\"\"Return the strategy-specific `*Config` class.\"\"\" return { # type: ignore[return-value] \"download\" : ResourceConfig , \"filter\" : FilterConfig , \"function\" : FunctionConfig , \"mapping\" : MappingConfig , \"parse\" : ResourceConfig , \"resource\" : ResourceConfig , \"transformation\" : TransformationConfig , }[ self . value ]","title":"config_cls()"},{"location":"api_reference/plugins/entry_points/#oteapi.plugins.entry_points.StrategyType.init","text":"Initialize a StrategyType with more than just the enumeration value. This method allows one to also initialize a StrategyType with an actual strategy type string, e.g., scheme , mediaType , etc. Raises: Type Description ValueError As normal if the enumeration value is not valid. Source code in oteapi/plugins/entry_points.py 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 @classmethod def init ( cls , value : \"Union[str, StrategyType]\" ) -> \"StrategyType\" : \"\"\"Initialize a StrategyType with more than just the enumeration value. This method allows one to also initialize a StrategyType with an actual strategy type string, e.g., `scheme`, `mediaType`, etc. Raises: ValueError: As normal if the enumeration value is not valid. \"\"\" if isinstance ( value , str ): try : return cls . map_from_field ( value ) except KeyError : pass return cls ( value )","title":"init()"},{"location":"api_reference/plugins/entry_points/#oteapi.plugins.entry_points.StrategyType.map_from_field","text":"Map the strategy type's field to enumeration. Parameters: Name Type Description Default strategy_type_field str The strategy type's field. E.g., scheme for download . required Raises: Type Description KeyError If the strategy_type_field is not valid. Returns: Type Description 'StrategyType' An enumeration instance representing the strategy type's field. Source code in oteapi/plugins/entry_points.py 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 @classmethod def map_from_field ( cls , strategy_type_field : str ) -> \"StrategyType\" : \"\"\"Map the strategy type's field to enumeration. Parameters: strategy_type_field: The strategy type's field. E.g., `scheme` for `download`. Raises: KeyError: If the `strategy_type_field` is not valid. Returns: An enumeration instance representing the strategy type's field. \"\"\" return { \"scheme\" : cls . DOWNLOAD , \"filterType\" : cls . FILTER , \"functionType\" : cls . FUNCTION , \"mappingType\" : cls . MAPPING , \"mediaType\" : cls . PARSE , \"accessService\" : cls . RESOURCE , \"transformationType\" : cls . TRANSFORMATION , }[ strategy_type_field ]","title":"map_from_field()"},{"location":"api_reference/plugins/entry_points/#oteapi.plugins.entry_points.StrategyType.map_to_field","text":"Map enumeration value to the strategy type's field. Source code in oteapi/plugins/entry_points.py 63 64 65 66 67 68 69 70 71 72 73 def map_to_field ( self ) -> str : \"\"\"Map enumeration value to the strategy type's field.\"\"\" return { \"download\" : \"scheme\" , \"filter\" : \"filterType\" , \"function\" : \"functionType\" , \"mapping\" : \"mappingType\" , \"parse\" : \"mediaType\" , \"resource\" : \"accessService\" , \"transformation\" : \"transformationType\" , }[ self . value ]","title":"map_to_field()"},{"location":"api_reference/plugins/entry_points/#oteapi.plugins.entry_points.get_strategy_entry_points","text":"Retrieve all entry points from a specific strategy type. Raises: Type Description ValueError If the strategy type is not supported. KeyError If enforce_uniqueness is True and an entry point strategy is duplicated. Parameters: Name Type Description Default strategy_type 'Union[StrategyType, str]' A strategy type for which the entry points will be retrieved. required enforce_uniqueness bool Whether or not duplicate entry point strategies are allowed. Defaults to True , meaning duplicates are not allowed. True Returns: Type Description EntryPointStrategyCollection A collection of entry points for the specific strategy type. Source code in oteapi/plugins/entry_points.py 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 def get_strategy_entry_points ( strategy_type : \"Union[StrategyType, str]\" , enforce_uniqueness : bool = True , ) -> EntryPointStrategyCollection : \"\"\"Retrieve all entry points from a specific strategy type. Raises: ValueError: If the strategy type is not supported. KeyError: If `enforce_uniqueness` is `True` and an entry point strategy is duplicated. Parameters: strategy_type: A strategy type for which the entry points will be retrieved. enforce_uniqueness: Whether or not duplicate entry point strategies are allowed. Defaults to `True`, meaning duplicates are *not* allowed. Returns: A collection of entry points for the specific strategy type. \"\"\" try : strategy_type = StrategyType ( strategy_type ) except ValueError as exc : raise ValueError ( \"Strategy type \" f \" { strategy_type if isinstance ( strategy_type , str ) else str ( strategy_type . value ) !r} \" \" is not supported.\" ) from exc collection = EntryPointStrategyCollection () oteapi_entry_points = sorted ( set ( get_entry_points () . get ( f \"oteapi. { strategy_type . value } \" , [])) ) if enforce_uniqueness : collection . exclusive_add ( * ( EntryPointStrategy ( _ ) for _ in oteapi_entry_points )) else : collection . add ( * ( EntryPointStrategy ( _ ) for _ in oteapi_entry_points )) return collection","title":"get_strategy_entry_points()"},{"location":"api_reference/plugins/factories/","text":"factories \u00b6 Factory class for registering and creating strategy instances. Factory wrapper methods for creating the individual strategies. StrategiesNotLoaded \u00b6 Bases: Exception Entry point strategies have not been loaded, run load_strategies() . Source code in oteapi/plugins/factories.py 17 18 19 class StrategiesNotLoaded ( Exception ): \"\"\"Entry point strategies have not been loaded, run [`load_strategies()`][oteapi.plugins.factories.load_strategies].\"\"\" StrategyFactory \u00b6 Decorator-based Factory class. Attributes: Name Type Description strategy_create_func Dict [ StrategyType , EntryPointStrategyCollection ] An in-memory cache of all registered strategies. Source code in oteapi/plugins/factories.py 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 class StrategyFactory : \"\"\"Decorator-based Factory class. Attributes: strategy_create_func (Dict[StrategyType, EntryPointStrategyCollection]): An in-memory cache of all registered strategies. \"\"\" strategy_create_func : \"Dict[StrategyType, EntryPointStrategyCollection]\" @classmethod def make_strategy ( cls , config : \"Union[StrategyConfig, Dict[str, Any]]\" , strategy_type : \"Union[StrategyType, str]\" , ) -> \"IStrategy\" : \"\"\"Instantiate a strategy in a context class. Parameters: config: A strategy configuration. strategy_type: The strategy type, e.g., `\"scheme\"`, `\"mediaType\"`, ... or `\"download\"`, `\"parse\"`, ... See the [`StrategyType`][oteapi.plugins.entry_points.StrategyType] enumeration for a definition of valid strategy types. Raises: NotImplementedError: If the strategy cannot be found. ValueError: If the `strategy_type` is not a valid strategy type. See the [`StrategyType`][oteapi.plugins.entry_points.StrategyType] enumeration for a definition of valid strategy types. StrategiesNotLoaded: If the entry point strategies have not been loaded. Returns: An instantiated strategy. The strategy is instantiated with the provided configuration, through the `config` parameter. \"\"\" if not hasattr ( cls , \"strategy_create_func\" ): raise StrategiesNotLoaded ( \"Strategies have not been loaded, run `load_strategies()` or \" \"`StrategyFactory.load_strategies()`.\" ) if isinstance ( strategy_type , str ): try : strategy_type = StrategyType . init ( strategy_type ) except ValueError as exc : raise ValueError ( f \"Strategy type { strategy_type !r} is not supported.\" ) from exc elif not isinstance ( strategy_type , StrategyType ): raise TypeError ( \"strategy_type should be either of type StrategyType or a string.\" ) if isinstance ( config , dict ): config = strategy_type . config_cls ( ** config ) # type: ignore[call-arg] elif not isinstance ( config , get_args ( StrategyConfig )): raise TypeError ( \"config should be either of type StrategyConfig or a dict.\" ) strategy_name : str = cls . _get_strategy_name ( config , strategy_type ) if ( strategy_type , strategy_name ) in cls . strategy_create_func [ strategy_type ]: return cls . strategy_create_func [ strategy_type ][ ( strategy_type , strategy_name ) ] . implementation ( config # type: ignore[arg-type] ) raise NotImplementedError ( f \"The { strategy_type . value } strategy { strategy_name !r} does not exist.\" ) @classmethod def _get_strategy_name ( cls , config : \"StrategyConfig\" , strategy_type : StrategyType , ) -> str : \"\"\"Return the strategy name through the config. This is a method to accommodate strategy type-specific quirks to retrieve the strategy name. Parameters: config: A strategy configuration. strategy_type: The strategy type as initialized in `make_strategy()`. Returns: The strategy name provided in the configuration. \"\"\" if strategy_type == StrategyType . DOWNLOAD : return config . downloadUrl . scheme if config . downloadUrl is not None else \"\" # type: ignore[union-attr] # pylint: disable=line-too-long return getattr ( config , strategy_type . map_to_field (), \"\" ) @classmethod def load_strategies ( cls , test_for_uniqueness : bool = True ) -> None : \"\"\"Load strategies from entry points and store in class attribute. Important: This is not a cached method. The importlib.metadata API will be re-requested to load the entry points and strategies. Note: This does *not* import the actual strategy implementations (classes). It only loads the strategies from the registerred OTE-API entry points. Raises: KeyError: If `test_for_uniqueness` is `True` and an entry point strategy is duplicated. Parameters: test_for_uniqueness: If `True`, this will raise `KeyError` should an entry point strategy be duplicated. Otherwise, the first loaded entry point strategy will silently become the implementation of choice for the duplicated strategy and the duplicates will be ignored. \"\"\" cls . strategy_create_func = { strategy_type : get_strategy_entry_points ( strategy_type , enforce_uniqueness = test_for_uniqueness ) for strategy_type in StrategyType } _get_strategy_name ( config , strategy_type ) classmethod \u00b6 Return the strategy name through the config. This is a method to accommodate strategy type-specific quirks to retrieve the strategy name. Parameters: Name Type Description Default config 'StrategyConfig' A strategy configuration. required strategy_type StrategyType The strategy type as initialized in make_strategy() . required Returns: Type Description str The strategy name provided in the configuration. Source code in oteapi/plugins/factories.py 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 @classmethod def _get_strategy_name ( cls , config : \"StrategyConfig\" , strategy_type : StrategyType , ) -> str : \"\"\"Return the strategy name through the config. This is a method to accommodate strategy type-specific quirks to retrieve the strategy name. Parameters: config: A strategy configuration. strategy_type: The strategy type as initialized in `make_strategy()`. Returns: The strategy name provided in the configuration. \"\"\" if strategy_type == StrategyType . DOWNLOAD : return config . downloadUrl . scheme if config . downloadUrl is not None else \"\" # type: ignore[union-attr] # pylint: disable=line-too-long return getattr ( config , strategy_type . map_to_field (), \"\" ) load_strategies ( test_for_uniqueness = True ) classmethod \u00b6 Load strategies from entry points and store in class attribute. Important This is not a cached method. The importlib.metadata API will be re-requested to load the entry points and strategies. Note This does not import the actual strategy implementations (classes). It only loads the strategies from the registerred OTE-API entry points. Raises: Type Description KeyError If test_for_uniqueness is True and an entry point strategy is duplicated. Parameters: Name Type Description Default test_for_uniqueness bool If True , this will raise KeyError should an entry point strategy be duplicated. Otherwise, the first loaded entry point strategy will silently become the implementation of choice for the duplicated strategy and the duplicates will be ignored. True Source code in oteapi/plugins/factories.py 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 @classmethod def load_strategies ( cls , test_for_uniqueness : bool = True ) -> None : \"\"\"Load strategies from entry points and store in class attribute. Important: This is not a cached method. The importlib.metadata API will be re-requested to load the entry points and strategies. Note: This does *not* import the actual strategy implementations (classes). It only loads the strategies from the registerred OTE-API entry points. Raises: KeyError: If `test_for_uniqueness` is `True` and an entry point strategy is duplicated. Parameters: test_for_uniqueness: If `True`, this will raise `KeyError` should an entry point strategy be duplicated. Otherwise, the first loaded entry point strategy will silently become the implementation of choice for the duplicated strategy and the duplicates will be ignored. \"\"\" cls . strategy_create_func = { strategy_type : get_strategy_entry_points ( strategy_type , enforce_uniqueness = test_for_uniqueness ) for strategy_type in StrategyType } make_strategy ( config , strategy_type ) classmethod \u00b6 Instantiate a strategy in a context class. Parameters: Name Type Description Default config 'Union[StrategyConfig, Dict[str, Any]]' A strategy configuration. required strategy_type 'Union[StrategyType, str]' The strategy type, e.g., \"scheme\" , \"mediaType\" , ... or \"download\" , \"parse\" , ... See the StrategyType enumeration for a definition of valid strategy types. required Raises: Type Description NotImplementedError If the strategy cannot be found. ValueError If the strategy_type is not a valid strategy type. See the StrategyType enumeration for a definition of valid strategy types. StrategiesNotLoaded If the entry point strategies have not been loaded. Returns: Type Description 'IStrategy' An instantiated strategy. The strategy is instantiated with the provided 'IStrategy' configuration, through the config parameter. Source code in oteapi/plugins/factories.py 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 @classmethod def make_strategy ( cls , config : \"Union[StrategyConfig, Dict[str, Any]]\" , strategy_type : \"Union[StrategyType, str]\" , ) -> \"IStrategy\" : \"\"\"Instantiate a strategy in a context class. Parameters: config: A strategy configuration. strategy_type: The strategy type, e.g., `\"scheme\"`, `\"mediaType\"`, ... or `\"download\"`, `\"parse\"`, ... See the [`StrategyType`][oteapi.plugins.entry_points.StrategyType] enumeration for a definition of valid strategy types. Raises: NotImplementedError: If the strategy cannot be found. ValueError: If the `strategy_type` is not a valid strategy type. See the [`StrategyType`][oteapi.plugins.entry_points.StrategyType] enumeration for a definition of valid strategy types. StrategiesNotLoaded: If the entry point strategies have not been loaded. Returns: An instantiated strategy. The strategy is instantiated with the provided configuration, through the `config` parameter. \"\"\" if not hasattr ( cls , \"strategy_create_func\" ): raise StrategiesNotLoaded ( \"Strategies have not been loaded, run `load_strategies()` or \" \"`StrategyFactory.load_strategies()`.\" ) if isinstance ( strategy_type , str ): try : strategy_type = StrategyType . init ( strategy_type ) except ValueError as exc : raise ValueError ( f \"Strategy type { strategy_type !r} is not supported.\" ) from exc elif not isinstance ( strategy_type , StrategyType ): raise TypeError ( \"strategy_type should be either of type StrategyType or a string.\" ) if isinstance ( config , dict ): config = strategy_type . config_cls ( ** config ) # type: ignore[call-arg] elif not isinstance ( config , get_args ( StrategyConfig )): raise TypeError ( \"config should be either of type StrategyConfig or a dict.\" ) strategy_name : str = cls . _get_strategy_name ( config , strategy_type ) if ( strategy_type , strategy_name ) in cls . strategy_create_func [ strategy_type ]: return cls . strategy_create_func [ strategy_type ][ ( strategy_type , strategy_name ) ] . implementation ( config # type: ignore[arg-type] ) raise NotImplementedError ( f \"The { strategy_type . value } strategy { strategy_name !r} does not exist.\" ) create_strategy ( strategy_type , config ) \u00b6 Proxy function for StrategyFactory.make_strategy() . Parameters: Name Type Description Default strategy_type 'Union[StrategyType, str]' A valid strategy type. See the StrategyType enumeration for a definition of valid strategy types. required config 'Union[StrategyConfig, Dict[str, Any]]' A strategy configuration. required Returns: Type Description 'IStrategy' The created strategy. Source code in oteapi/plugins/factories.py 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 def create_strategy ( strategy_type : \"Union[StrategyType, str]\" , config : \"Union[StrategyConfig, Dict[str, Any]]\" , ) -> \"IStrategy\" : \"\"\"Proxy function for [`StrategyFactory.make_strategy()`][oteapi.plugins.factories.StrategyFactory.make_strategy]. Parameters: strategy_type: A valid strategy type. See the [`StrategyType`][oteapi.plugins.entry_points.StrategyType] enumeration for a definition of valid strategy types. config: A strategy configuration. Returns: The created strategy. \"\"\" return StrategyFactory . make_strategy ( config , strategy_type ) load_strategies ( test_for_uniqueness = True ) \u00b6 Proxy function for StrategyFactory.load_strategies() . Parameters: Name Type Description Default test_for_uniqueness bool If True , this will raise KeyError should an entry point strategy be duplicated. Otherwise, the first loaded entry point strategy will silently become the implementation of choice for the duplicated strategy and the duplicates will be ignored. True Source code in oteapi/plugins/factories.py 150 151 152 153 154 155 156 157 158 159 160 161 162 def load_strategies ( test_for_uniqueness : bool = True ) -> None : # pylint: disable=line-too-long \"\"\"Proxy function for [`StrategyFactory.load_strategies()`][oteapi.plugins.factories.StrategyFactory.load_strategies]. Parameters: test_for_uniqueness: If `True`, this will raise `KeyError` should an entry point strategy be duplicated. Otherwise, the first loaded entry point strategy will silently become the implementation of choice for the duplicated strategy and the duplicates will be ignored. \"\"\" StrategyFactory . load_strategies ( test_for_uniqueness )","title":"factories"},{"location":"api_reference/plugins/factories/#factories","text":"Factory class for registering and creating strategy instances. Factory wrapper methods for creating the individual strategies.","title":"factories"},{"location":"api_reference/plugins/factories/#oteapi.plugins.factories.StrategiesNotLoaded","text":"Bases: Exception Entry point strategies have not been loaded, run load_strategies() . Source code in oteapi/plugins/factories.py 17 18 19 class StrategiesNotLoaded ( Exception ): \"\"\"Entry point strategies have not been loaded, run [`load_strategies()`][oteapi.plugins.factories.load_strategies].\"\"\"","title":"StrategiesNotLoaded"},{"location":"api_reference/plugins/factories/#oteapi.plugins.factories.StrategyFactory","text":"Decorator-based Factory class. Attributes: Name Type Description strategy_create_func Dict [ StrategyType , EntryPointStrategyCollection ] An in-memory cache of all registered strategies. Source code in oteapi/plugins/factories.py 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 class StrategyFactory : \"\"\"Decorator-based Factory class. Attributes: strategy_create_func (Dict[StrategyType, EntryPointStrategyCollection]): An in-memory cache of all registered strategies. \"\"\" strategy_create_func : \"Dict[StrategyType, EntryPointStrategyCollection]\" @classmethod def make_strategy ( cls , config : \"Union[StrategyConfig, Dict[str, Any]]\" , strategy_type : \"Union[StrategyType, str]\" , ) -> \"IStrategy\" : \"\"\"Instantiate a strategy in a context class. Parameters: config: A strategy configuration. strategy_type: The strategy type, e.g., `\"scheme\"`, `\"mediaType\"`, ... or `\"download\"`, `\"parse\"`, ... See the [`StrategyType`][oteapi.plugins.entry_points.StrategyType] enumeration for a definition of valid strategy types. Raises: NotImplementedError: If the strategy cannot be found. ValueError: If the `strategy_type` is not a valid strategy type. See the [`StrategyType`][oteapi.plugins.entry_points.StrategyType] enumeration for a definition of valid strategy types. StrategiesNotLoaded: If the entry point strategies have not been loaded. Returns: An instantiated strategy. The strategy is instantiated with the provided configuration, through the `config` parameter. \"\"\" if not hasattr ( cls , \"strategy_create_func\" ): raise StrategiesNotLoaded ( \"Strategies have not been loaded, run `load_strategies()` or \" \"`StrategyFactory.load_strategies()`.\" ) if isinstance ( strategy_type , str ): try : strategy_type = StrategyType . init ( strategy_type ) except ValueError as exc : raise ValueError ( f \"Strategy type { strategy_type !r} is not supported.\" ) from exc elif not isinstance ( strategy_type , StrategyType ): raise TypeError ( \"strategy_type should be either of type StrategyType or a string.\" ) if isinstance ( config , dict ): config = strategy_type . config_cls ( ** config ) # type: ignore[call-arg] elif not isinstance ( config , get_args ( StrategyConfig )): raise TypeError ( \"config should be either of type StrategyConfig or a dict.\" ) strategy_name : str = cls . _get_strategy_name ( config , strategy_type ) if ( strategy_type , strategy_name ) in cls . strategy_create_func [ strategy_type ]: return cls . strategy_create_func [ strategy_type ][ ( strategy_type , strategy_name ) ] . implementation ( config # type: ignore[arg-type] ) raise NotImplementedError ( f \"The { strategy_type . value } strategy { strategy_name !r} does not exist.\" ) @classmethod def _get_strategy_name ( cls , config : \"StrategyConfig\" , strategy_type : StrategyType , ) -> str : \"\"\"Return the strategy name through the config. This is a method to accommodate strategy type-specific quirks to retrieve the strategy name. Parameters: config: A strategy configuration. strategy_type: The strategy type as initialized in `make_strategy()`. Returns: The strategy name provided in the configuration. \"\"\" if strategy_type == StrategyType . DOWNLOAD : return config . downloadUrl . scheme if config . downloadUrl is not None else \"\" # type: ignore[union-attr] # pylint: disable=line-too-long return getattr ( config , strategy_type . map_to_field (), \"\" ) @classmethod def load_strategies ( cls , test_for_uniqueness : bool = True ) -> None : \"\"\"Load strategies from entry points and store in class attribute. Important: This is not a cached method. The importlib.metadata API will be re-requested to load the entry points and strategies. Note: This does *not* import the actual strategy implementations (classes). It only loads the strategies from the registerred OTE-API entry points. Raises: KeyError: If `test_for_uniqueness` is `True` and an entry point strategy is duplicated. Parameters: test_for_uniqueness: If `True`, this will raise `KeyError` should an entry point strategy be duplicated. Otherwise, the first loaded entry point strategy will silently become the implementation of choice for the duplicated strategy and the duplicates will be ignored. \"\"\" cls . strategy_create_func = { strategy_type : get_strategy_entry_points ( strategy_type , enforce_uniqueness = test_for_uniqueness ) for strategy_type in StrategyType }","title":"StrategyFactory"},{"location":"api_reference/plugins/factories/#oteapi.plugins.factories.StrategyFactory._get_strategy_name","text":"Return the strategy name through the config. This is a method to accommodate strategy type-specific quirks to retrieve the strategy name. Parameters: Name Type Description Default config 'StrategyConfig' A strategy configuration. required strategy_type StrategyType The strategy type as initialized in make_strategy() . required Returns: Type Description str The strategy name provided in the configuration. Source code in oteapi/plugins/factories.py 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 @classmethod def _get_strategy_name ( cls , config : \"StrategyConfig\" , strategy_type : StrategyType , ) -> str : \"\"\"Return the strategy name through the config. This is a method to accommodate strategy type-specific quirks to retrieve the strategy name. Parameters: config: A strategy configuration. strategy_type: The strategy type as initialized in `make_strategy()`. Returns: The strategy name provided in the configuration. \"\"\" if strategy_type == StrategyType . DOWNLOAD : return config . downloadUrl . scheme if config . downloadUrl is not None else \"\" # type: ignore[union-attr] # pylint: disable=line-too-long return getattr ( config , strategy_type . map_to_field (), \"\" )","title":"_get_strategy_name()"},{"location":"api_reference/plugins/factories/#oteapi.plugins.factories.StrategyFactory.load_strategies","text":"Load strategies from entry points and store in class attribute. Important This is not a cached method. The importlib.metadata API will be re-requested to load the entry points and strategies. Note This does not import the actual strategy implementations (classes). It only loads the strategies from the registerred OTE-API entry points. Raises: Type Description KeyError If test_for_uniqueness is True and an entry point strategy is duplicated. Parameters: Name Type Description Default test_for_uniqueness bool If True , this will raise KeyError should an entry point strategy be duplicated. Otherwise, the first loaded entry point strategy will silently become the implementation of choice for the duplicated strategy and the duplicates will be ignored. True Source code in oteapi/plugins/factories.py 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 @classmethod def load_strategies ( cls , test_for_uniqueness : bool = True ) -> None : \"\"\"Load strategies from entry points and store in class attribute. Important: This is not a cached method. The importlib.metadata API will be re-requested to load the entry points and strategies. Note: This does *not* import the actual strategy implementations (classes). It only loads the strategies from the registerred OTE-API entry points. Raises: KeyError: If `test_for_uniqueness` is `True` and an entry point strategy is duplicated. Parameters: test_for_uniqueness: If `True`, this will raise `KeyError` should an entry point strategy be duplicated. Otherwise, the first loaded entry point strategy will silently become the implementation of choice for the duplicated strategy and the duplicates will be ignored. \"\"\" cls . strategy_create_func = { strategy_type : get_strategy_entry_points ( strategy_type , enforce_uniqueness = test_for_uniqueness ) for strategy_type in StrategyType }","title":"load_strategies()"},{"location":"api_reference/plugins/factories/#oteapi.plugins.factories.StrategyFactory.make_strategy","text":"Instantiate a strategy in a context class. Parameters: Name Type Description Default config 'Union[StrategyConfig, Dict[str, Any]]' A strategy configuration. required strategy_type 'Union[StrategyType, str]' The strategy type, e.g., \"scheme\" , \"mediaType\" , ... or \"download\" , \"parse\" , ... See the StrategyType enumeration for a definition of valid strategy types. required Raises: Type Description NotImplementedError If the strategy cannot be found. ValueError If the strategy_type is not a valid strategy type. See the StrategyType enumeration for a definition of valid strategy types. StrategiesNotLoaded If the entry point strategies have not been loaded. Returns: Type Description 'IStrategy' An instantiated strategy. The strategy is instantiated with the provided 'IStrategy' configuration, through the config parameter. Source code in oteapi/plugins/factories.py 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 @classmethod def make_strategy ( cls , config : \"Union[StrategyConfig, Dict[str, Any]]\" , strategy_type : \"Union[StrategyType, str]\" , ) -> \"IStrategy\" : \"\"\"Instantiate a strategy in a context class. Parameters: config: A strategy configuration. strategy_type: The strategy type, e.g., `\"scheme\"`, `\"mediaType\"`, ... or `\"download\"`, `\"parse\"`, ... See the [`StrategyType`][oteapi.plugins.entry_points.StrategyType] enumeration for a definition of valid strategy types. Raises: NotImplementedError: If the strategy cannot be found. ValueError: If the `strategy_type` is not a valid strategy type. See the [`StrategyType`][oteapi.plugins.entry_points.StrategyType] enumeration for a definition of valid strategy types. StrategiesNotLoaded: If the entry point strategies have not been loaded. Returns: An instantiated strategy. The strategy is instantiated with the provided configuration, through the `config` parameter. \"\"\" if not hasattr ( cls , \"strategy_create_func\" ): raise StrategiesNotLoaded ( \"Strategies have not been loaded, run `load_strategies()` or \" \"`StrategyFactory.load_strategies()`.\" ) if isinstance ( strategy_type , str ): try : strategy_type = StrategyType . init ( strategy_type ) except ValueError as exc : raise ValueError ( f \"Strategy type { strategy_type !r} is not supported.\" ) from exc elif not isinstance ( strategy_type , StrategyType ): raise TypeError ( \"strategy_type should be either of type StrategyType or a string.\" ) if isinstance ( config , dict ): config = strategy_type . config_cls ( ** config ) # type: ignore[call-arg] elif not isinstance ( config , get_args ( StrategyConfig )): raise TypeError ( \"config should be either of type StrategyConfig or a dict.\" ) strategy_name : str = cls . _get_strategy_name ( config , strategy_type ) if ( strategy_type , strategy_name ) in cls . strategy_create_func [ strategy_type ]: return cls . strategy_create_func [ strategy_type ][ ( strategy_type , strategy_name ) ] . implementation ( config # type: ignore[arg-type] ) raise NotImplementedError ( f \"The { strategy_type . value } strategy { strategy_name !r} does not exist.\" )","title":"make_strategy()"},{"location":"api_reference/plugins/factories/#oteapi.plugins.factories.create_strategy","text":"Proxy function for StrategyFactory.make_strategy() . Parameters: Name Type Description Default strategy_type 'Union[StrategyType, str]' A valid strategy type. See the StrategyType enumeration for a definition of valid strategy types. required config 'Union[StrategyConfig, Dict[str, Any]]' A strategy configuration. required Returns: Type Description 'IStrategy' The created strategy. Source code in oteapi/plugins/factories.py 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 def create_strategy ( strategy_type : \"Union[StrategyType, str]\" , config : \"Union[StrategyConfig, Dict[str, Any]]\" , ) -> \"IStrategy\" : \"\"\"Proxy function for [`StrategyFactory.make_strategy()`][oteapi.plugins.factories.StrategyFactory.make_strategy]. Parameters: strategy_type: A valid strategy type. See the [`StrategyType`][oteapi.plugins.entry_points.StrategyType] enumeration for a definition of valid strategy types. config: A strategy configuration. Returns: The created strategy. \"\"\" return StrategyFactory . make_strategy ( config , strategy_type )","title":"create_strategy()"},{"location":"api_reference/plugins/factories/#oteapi.plugins.factories.load_strategies","text":"Proxy function for StrategyFactory.load_strategies() . Parameters: Name Type Description Default test_for_uniqueness bool If True , this will raise KeyError should an entry point strategy be duplicated. Otherwise, the first loaded entry point strategy will silently become the implementation of choice for the duplicated strategy and the duplicates will be ignored. True Source code in oteapi/plugins/factories.py 150 151 152 153 154 155 156 157 158 159 160 161 162 def load_strategies ( test_for_uniqueness : bool = True ) -> None : # pylint: disable=line-too-long \"\"\"Proxy function for [`StrategyFactory.load_strategies()`][oteapi.plugins.factories.StrategyFactory.load_strategies]. Parameters: test_for_uniqueness: If `True`, this will raise `KeyError` should an entry point strategy be duplicated. Otherwise, the first loaded entry point strategy will silently become the implementation of choice for the duplicated strategy and the duplicates will be ignored. \"\"\" StrategyFactory . load_strategies ( test_for_uniqueness )","title":"load_strategies()"},{"location":"api_reference/strategies/download/file/","text":"file \u00b6 Download strategy class for the file scheme. FileConfig \u00b6 Bases: AttrDict File-specific Configuration Data Model. Source code in oteapi/strategies/download/file.py 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 class FileConfig ( AttrDict ): \"\"\"File-specific Configuration Data Model.\"\"\" text : bool = Field ( False , description = ( \"Whether the file should be opened in text mode. If `False`, the file will\" \" be opened in bytes mode.\" ), ) encoding : Optional [ str ] = Field ( None , description = ( \"Encoding used when opening the file. The default is platform dependent.\" ), ) datacache_config : Optional [ DataCacheConfig ] = Field ( None , description = \"Configurations for the data cache for storing the downloaded file content.\" , ) FileResourceConfig \u00b6 Bases: ResourceConfig File download strategy filter config. Source code in oteapi/strategies/download/file.py 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 class FileResourceConfig ( ResourceConfig ): \"\"\"File download strategy filter config.\"\"\" downloadUrl : FileUrl = Field ( # type: ignore[assignment] ... , description = \"The file URL, which will be downloaded.\" ) configuration : FileConfig = Field ( FileConfig (), description = \"File download strategy-specific configuration.\" ) @validator ( \"downloadUrl\" ) def ensure_path_exists ( cls , value : FileUrl ) -> FileUrl : \"\"\"Ensure `path` is defined in `downloadUrl`.\"\"\" if not value . path : raise ValueError ( \"downloadUrl must contain a `path` part.\" ) return value ensure_path_exists ( value ) \u00b6 Ensure path is defined in downloadUrl . Source code in oteapi/strategies/download/file.py 48 49 50 51 52 53 @validator ( \"downloadUrl\" ) def ensure_path_exists ( cls , value : FileUrl ) -> FileUrl : \"\"\"Ensure `path` is defined in `downloadUrl`.\"\"\" if not value . path : raise ValueError ( \"downloadUrl must contain a `path` part.\" ) return value FileStrategy \u00b6 Strategy for retrieving data from a local file. Registers strategies : (\"scheme\", \"file\") Source code in oteapi/strategies/download/file.py 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 @dataclass class FileStrategy : \"\"\"Strategy for retrieving data from a local file. **Registers strategies**: - `(\"scheme\", \"file\")` \"\"\" download_config : FileResourceConfig def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdate : \"\"\"Initialize.\"\"\" return SessionUpdate () def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdateFile : \"\"\"Read local file.\"\"\" filename = uri_to_path ( self . download_config . downloadUrl ) . resolve () if not filename . exists (): raise FileNotFoundError ( f \"File not found at { filename } \" ) cache = DataCache ( self . download_config . configuration . datacache_config ) if cache . config . accessKey and cache . config . accessKey in cache : key = cache . config . accessKey else : key = cache . add ( filename . read_text ( encoding = self . download_config . configuration . encoding ) if self . download_config . configuration . text else filename . read_bytes () ) return SessionUpdateFile ( key = key ) get ( session = None ) \u00b6 Read local file. Source code in oteapi/strategies/download/file.py 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdateFile : \"\"\"Read local file.\"\"\" filename = uri_to_path ( self . download_config . downloadUrl ) . resolve () if not filename . exists (): raise FileNotFoundError ( f \"File not found at { filename } \" ) cache = DataCache ( self . download_config . configuration . datacache_config ) if cache . config . accessKey and cache . config . accessKey in cache : key = cache . config . accessKey else : key = cache . add ( filename . read_text ( encoding = self . download_config . configuration . encoding ) if self . download_config . configuration . text else filename . read_bytes () ) return SessionUpdateFile ( key = key ) initialize ( session = None ) \u00b6 Initialize. Source code in oteapi/strategies/download/file.py 74 75 76 def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdate : \"\"\"Initialize.\"\"\" return SessionUpdate () SessionUpdateFile \u00b6 Bases: SessionUpdate Class for returning values from Download File strategy. Source code in oteapi/strategies/download/file.py 56 57 58 59 class SessionUpdateFile ( SessionUpdate ): \"\"\"Class for returning values from Download File strategy.\"\"\" key : str = Field ( ... , description = \"Key to access the data in the cache.\" )","title":"file"},{"location":"api_reference/strategies/download/file/#file","text":"Download strategy class for the file scheme.","title":"file"},{"location":"api_reference/strategies/download/file/#oteapi.strategies.download.file.FileConfig","text":"Bases: AttrDict File-specific Configuration Data Model. Source code in oteapi/strategies/download/file.py 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 class FileConfig ( AttrDict ): \"\"\"File-specific Configuration Data Model.\"\"\" text : bool = Field ( False , description = ( \"Whether the file should be opened in text mode. If `False`, the file will\" \" be opened in bytes mode.\" ), ) encoding : Optional [ str ] = Field ( None , description = ( \"Encoding used when opening the file. The default is platform dependent.\" ), ) datacache_config : Optional [ DataCacheConfig ] = Field ( None , description = \"Configurations for the data cache for storing the downloaded file content.\" , )","title":"FileConfig"},{"location":"api_reference/strategies/download/file/#oteapi.strategies.download.file.FileResourceConfig","text":"Bases: ResourceConfig File download strategy filter config. Source code in oteapi/strategies/download/file.py 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 class FileResourceConfig ( ResourceConfig ): \"\"\"File download strategy filter config.\"\"\" downloadUrl : FileUrl = Field ( # type: ignore[assignment] ... , description = \"The file URL, which will be downloaded.\" ) configuration : FileConfig = Field ( FileConfig (), description = \"File download strategy-specific configuration.\" ) @validator ( \"downloadUrl\" ) def ensure_path_exists ( cls , value : FileUrl ) -> FileUrl : \"\"\"Ensure `path` is defined in `downloadUrl`.\"\"\" if not value . path : raise ValueError ( \"downloadUrl must contain a `path` part.\" ) return value","title":"FileResourceConfig"},{"location":"api_reference/strategies/download/file/#oteapi.strategies.download.file.FileResourceConfig.ensure_path_exists","text":"Ensure path is defined in downloadUrl . Source code in oteapi/strategies/download/file.py 48 49 50 51 52 53 @validator ( \"downloadUrl\" ) def ensure_path_exists ( cls , value : FileUrl ) -> FileUrl : \"\"\"Ensure `path` is defined in `downloadUrl`.\"\"\" if not value . path : raise ValueError ( \"downloadUrl must contain a `path` part.\" ) return value","title":"ensure_path_exists()"},{"location":"api_reference/strategies/download/file/#oteapi.strategies.download.file.FileStrategy","text":"Strategy for retrieving data from a local file. Registers strategies : (\"scheme\", \"file\") Source code in oteapi/strategies/download/file.py 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 @dataclass class FileStrategy : \"\"\"Strategy for retrieving data from a local file. **Registers strategies**: - `(\"scheme\", \"file\")` \"\"\" download_config : FileResourceConfig def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdate : \"\"\"Initialize.\"\"\" return SessionUpdate () def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdateFile : \"\"\"Read local file.\"\"\" filename = uri_to_path ( self . download_config . downloadUrl ) . resolve () if not filename . exists (): raise FileNotFoundError ( f \"File not found at { filename } \" ) cache = DataCache ( self . download_config . configuration . datacache_config ) if cache . config . accessKey and cache . config . accessKey in cache : key = cache . config . accessKey else : key = cache . add ( filename . read_text ( encoding = self . download_config . configuration . encoding ) if self . download_config . configuration . text else filename . read_bytes () ) return SessionUpdateFile ( key = key )","title":"FileStrategy"},{"location":"api_reference/strategies/download/file/#oteapi.strategies.download.file.FileStrategy.get","text":"Read local file. Source code in oteapi/strategies/download/file.py 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdateFile : \"\"\"Read local file.\"\"\" filename = uri_to_path ( self . download_config . downloadUrl ) . resolve () if not filename . exists (): raise FileNotFoundError ( f \"File not found at { filename } \" ) cache = DataCache ( self . download_config . configuration . datacache_config ) if cache . config . accessKey and cache . config . accessKey in cache : key = cache . config . accessKey else : key = cache . add ( filename . read_text ( encoding = self . download_config . configuration . encoding ) if self . download_config . configuration . text else filename . read_bytes () ) return SessionUpdateFile ( key = key )","title":"get()"},{"location":"api_reference/strategies/download/file/#oteapi.strategies.download.file.FileStrategy.initialize","text":"Initialize. Source code in oteapi/strategies/download/file.py 74 75 76 def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdate : \"\"\"Initialize.\"\"\" return SessionUpdate ()","title":"initialize()"},{"location":"api_reference/strategies/download/file/#oteapi.strategies.download.file.SessionUpdateFile","text":"Bases: SessionUpdate Class for returning values from Download File strategy. Source code in oteapi/strategies/download/file.py 56 57 58 59 class SessionUpdateFile ( SessionUpdate ): \"\"\"Class for returning values from Download File strategy.\"\"\" key : str = Field ( ... , description = \"Key to access the data in the cache.\" )","title":"SessionUpdateFile"},{"location":"api_reference/strategies/download/https/","text":"https \u00b6 Download strategy class for http/https HTTPSConfig \u00b6 Bases: AttrDict HTTP(S)-specific Configuration Data Model. Source code in oteapi/strategies/download/https.py 16 17 18 19 20 21 22 class HTTPSConfig ( AttrDict ): \"\"\"HTTP(S)-specific Configuration Data Model.\"\"\" datacache_config : Optional [ DataCacheConfig ] = Field ( None , description = \"Configurations for the data cache for storing the downloaded file content.\" , ) HTTPSResourceConfig \u00b6 Bases: ResourceConfig HTTP(S) download strategy filter config. Source code in oteapi/strategies/download/https.py 25 26 27 28 29 30 31 32 33 class HTTPSResourceConfig ( ResourceConfig ): \"\"\"HTTP(S) download strategy filter config.\"\"\" downloadUrl : AnyHttpUrl = Field ( # type: ignore[assignment] ... , description = \"The HTTP(S) URL, which will be downloaded.\" ) configuration : HTTPSConfig = Field ( HTTPSConfig (), description = \"HTTP(S) download strategy-specific configuration.\" ) HTTPSStrategy \u00b6 Strategy for retrieving data via http. Registers strategies : (\"scheme\", \"http\") (\"scheme\", \"https\") Source code in oteapi/strategies/download/https.py 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 @dataclass class HTTPSStrategy : \"\"\"Strategy for retrieving data via http. **Registers strategies**: - `(\"scheme\", \"http\")` - `(\"scheme\", \"https\")` \"\"\" download_config : HTTPSResourceConfig def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdate : \"\"\"Initialize.\"\"\" return SessionUpdate () def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdateHTTPS : \"\"\"Download via http/https and store on local cache.\"\"\" cache = DataCache ( self . download_config . configuration . datacache_config ) if cache . config . accessKey and cache . config . accessKey in cache : key = cache . config . accessKey else : req = requests . get ( self . download_config . downloadUrl , allow_redirects = True ) key = cache . add ( req . content ) return SessionUpdateHTTPS ( key = key ) get ( session = None ) \u00b6 Download via http/https and store on local cache. Source code in oteapi/strategies/download/https.py 59 60 61 62 63 64 65 66 67 68 def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdateHTTPS : \"\"\"Download via http/https and store on local cache.\"\"\" cache = DataCache ( self . download_config . configuration . datacache_config ) if cache . config . accessKey and cache . config . accessKey in cache : key = cache . config . accessKey else : req = requests . get ( self . download_config . downloadUrl , allow_redirects = True ) key = cache . add ( req . content ) return SessionUpdateHTTPS ( key = key ) initialize ( session = None ) \u00b6 Initialize. Source code in oteapi/strategies/download/https.py 55 56 57 def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdate : \"\"\"Initialize.\"\"\" return SessionUpdate () SessionUpdateHTTPS \u00b6 Bases: SessionUpdate Class for returning values from Download HTTPS strategy. Source code in oteapi/strategies/download/https.py 36 37 38 39 class SessionUpdateHTTPS ( SessionUpdate ): \"\"\"Class for returning values from Download HTTPS strategy.\"\"\" key : str = Field ( ... , description = \"Key to access the data in the cache.\" )","title":"https"},{"location":"api_reference/strategies/download/https/#https","text":"Download strategy class for http/https","title":"https"},{"location":"api_reference/strategies/download/https/#oteapi.strategies.download.https.HTTPSConfig","text":"Bases: AttrDict HTTP(S)-specific Configuration Data Model. Source code in oteapi/strategies/download/https.py 16 17 18 19 20 21 22 class HTTPSConfig ( AttrDict ): \"\"\"HTTP(S)-specific Configuration Data Model.\"\"\" datacache_config : Optional [ DataCacheConfig ] = Field ( None , description = \"Configurations for the data cache for storing the downloaded file content.\" , )","title":"HTTPSConfig"},{"location":"api_reference/strategies/download/https/#oteapi.strategies.download.https.HTTPSResourceConfig","text":"Bases: ResourceConfig HTTP(S) download strategy filter config. Source code in oteapi/strategies/download/https.py 25 26 27 28 29 30 31 32 33 class HTTPSResourceConfig ( ResourceConfig ): \"\"\"HTTP(S) download strategy filter config.\"\"\" downloadUrl : AnyHttpUrl = Field ( # type: ignore[assignment] ... , description = \"The HTTP(S) URL, which will be downloaded.\" ) configuration : HTTPSConfig = Field ( HTTPSConfig (), description = \"HTTP(S) download strategy-specific configuration.\" )","title":"HTTPSResourceConfig"},{"location":"api_reference/strategies/download/https/#oteapi.strategies.download.https.HTTPSStrategy","text":"Strategy for retrieving data via http. Registers strategies : (\"scheme\", \"http\") (\"scheme\", \"https\") Source code in oteapi/strategies/download/https.py 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 @dataclass class HTTPSStrategy : \"\"\"Strategy for retrieving data via http. **Registers strategies**: - `(\"scheme\", \"http\")` - `(\"scheme\", \"https\")` \"\"\" download_config : HTTPSResourceConfig def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdate : \"\"\"Initialize.\"\"\" return SessionUpdate () def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdateHTTPS : \"\"\"Download via http/https and store on local cache.\"\"\" cache = DataCache ( self . download_config . configuration . datacache_config ) if cache . config . accessKey and cache . config . accessKey in cache : key = cache . config . accessKey else : req = requests . get ( self . download_config . downloadUrl , allow_redirects = True ) key = cache . add ( req . content ) return SessionUpdateHTTPS ( key = key )","title":"HTTPSStrategy"},{"location":"api_reference/strategies/download/https/#oteapi.strategies.download.https.HTTPSStrategy.get","text":"Download via http/https and store on local cache. Source code in oteapi/strategies/download/https.py 59 60 61 62 63 64 65 66 67 68 def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdateHTTPS : \"\"\"Download via http/https and store on local cache.\"\"\" cache = DataCache ( self . download_config . configuration . datacache_config ) if cache . config . accessKey and cache . config . accessKey in cache : key = cache . config . accessKey else : req = requests . get ( self . download_config . downloadUrl , allow_redirects = True ) key = cache . add ( req . content ) return SessionUpdateHTTPS ( key = key )","title":"get()"},{"location":"api_reference/strategies/download/https/#oteapi.strategies.download.https.HTTPSStrategy.initialize","text":"Initialize. Source code in oteapi/strategies/download/https.py 55 56 57 def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdate : \"\"\"Initialize.\"\"\" return SessionUpdate ()","title":"initialize()"},{"location":"api_reference/strategies/download/https/#oteapi.strategies.download.https.SessionUpdateHTTPS","text":"Bases: SessionUpdate Class for returning values from Download HTTPS strategy. Source code in oteapi/strategies/download/https.py 36 37 38 39 class SessionUpdateHTTPS ( SessionUpdate ): \"\"\"Class for returning values from Download HTTPS strategy.\"\"\" key : str = Field ( ... , description = \"Key to access the data in the cache.\" )","title":"SessionUpdateHTTPS"},{"location":"api_reference/strategies/download/sftp/","text":"sftp \u00b6 Strategy class for sftp/ftp AnyFtpUrl \u00b6 Bases: AnyUrl A (S)FTP URL model. Source code in oteapi/strategies/download/sftp.py 18 19 20 21 class AnyFtpUrl ( AnyUrl ): \"\"\"A (S)FTP URL model.\"\"\" allowed_schemes = { \"ftp\" , \"sftp\" } SFTPConfig \u00b6 Bases: AttrDict (S)FTP-specific Configuration Data Model. Source code in oteapi/strategies/download/sftp.py 24 25 26 27 28 29 30 class SFTPConfig ( AttrDict ): \"\"\"(S)FTP-specific Configuration Data Model.\"\"\" datacache_config : Optional [ DataCacheConfig ] = Field ( None , description = \"Configurations for the data cache for storing the downloaded file content.\" , ) SFTPResourceConfig \u00b6 Bases: ResourceConfig (S)FTP download strategy filter config. Source code in oteapi/strategies/download/sftp.py 33 34 35 36 37 38 39 40 41 class SFTPResourceConfig ( ResourceConfig ): \"\"\"(S)FTP download strategy filter config.\"\"\" downloadUrl : AnyFtpUrl = Field ( # type: ignore[assignment] ... , description = \"The (S)FTP URL, which will be downloaded.\" ) configuration : SFTPConfig = Field ( SFTPConfig (), description = \"(S)FTP download strategy-specific configuration.\" ) SFTPStrategy \u00b6 Strategy for retrieving data via sftp. Registers strategies : (\"scheme\", \"ftp\") (\"scheme\", \"sftp\") Source code in oteapi/strategies/download/sftp.py 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 @dataclass class SFTPStrategy : \"\"\"Strategy for retrieving data via sftp. **Registers strategies**: - `(\"scheme\", \"ftp\")` - `(\"scheme\", \"sftp\")` \"\"\" download_config : SFTPResourceConfig def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdate : \"\"\"Initialize.\"\"\" return SessionUpdate () def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdateSFTP : \"\"\"Download via sftp\"\"\" cache = DataCache ( self . download_config . configuration . datacache_config ) if cache . config . accessKey and cache . config . accessKey in cache : key = cache . config . accessKey else : # Setup connection options cnopts = pysftp . CnOpts () cnopts . hostkeys = None # open connection and store data locally with pysftp . Connection ( host = self . download_config . downloadUrl . host , username = self . download_config . downloadUrl . user , password = self . download_config . downloadUrl . password , port = self . download_config . downloadUrl . port , cnopts = cnopts , ) as sftp : # Because of insane locking on Windows, we have to close # the downloaded file before adding it to the cache with NamedTemporaryFile ( prefix = \"oteapi-sftp-\" , delete = False ) as handle : localpath = Path ( handle . name ) . resolve () try : sftp . get ( self . download_config . downloadUrl . path , localpath = localpath ) key = cache . add ( localpath . read_bytes ()) finally : localpath . unlink () return SessionUpdateSFTP ( key = key ) get ( session = None ) \u00b6 Download via sftp Source code in oteapi/strategies/download/sftp.py 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdateSFTP : \"\"\"Download via sftp\"\"\" cache = DataCache ( self . download_config . configuration . datacache_config ) if cache . config . accessKey and cache . config . accessKey in cache : key = cache . config . accessKey else : # Setup connection options cnopts = pysftp . CnOpts () cnopts . hostkeys = None # open connection and store data locally with pysftp . Connection ( host = self . download_config . downloadUrl . host , username = self . download_config . downloadUrl . user , password = self . download_config . downloadUrl . password , port = self . download_config . downloadUrl . port , cnopts = cnopts , ) as sftp : # Because of insane locking on Windows, we have to close # the downloaded file before adding it to the cache with NamedTemporaryFile ( prefix = \"oteapi-sftp-\" , delete = False ) as handle : localpath = Path ( handle . name ) . resolve () try : sftp . get ( self . download_config . downloadUrl . path , localpath = localpath ) key = cache . add ( localpath . read_bytes ()) finally : localpath . unlink () return SessionUpdateSFTP ( key = key ) initialize ( session = None ) \u00b6 Initialize. Source code in oteapi/strategies/download/sftp.py 63 64 65 def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdate : \"\"\"Initialize.\"\"\" return SessionUpdate () SessionUpdateSFTP \u00b6 Bases: SessionUpdate Class for returning values from Download SFTP strategy. Source code in oteapi/strategies/download/sftp.py 44 45 46 47 class SessionUpdateSFTP ( SessionUpdate ): \"\"\"Class for returning values from Download SFTP strategy.\"\"\" key : str = Field ( ... , description = \"Key to access the data in the cache.\" )","title":"sftp"},{"location":"api_reference/strategies/download/sftp/#sftp","text":"Strategy class for sftp/ftp","title":"sftp"},{"location":"api_reference/strategies/download/sftp/#oteapi.strategies.download.sftp.AnyFtpUrl","text":"Bases: AnyUrl A (S)FTP URL model. Source code in oteapi/strategies/download/sftp.py 18 19 20 21 class AnyFtpUrl ( AnyUrl ): \"\"\"A (S)FTP URL model.\"\"\" allowed_schemes = { \"ftp\" , \"sftp\" }","title":"AnyFtpUrl"},{"location":"api_reference/strategies/download/sftp/#oteapi.strategies.download.sftp.SFTPConfig","text":"Bases: AttrDict (S)FTP-specific Configuration Data Model. Source code in oteapi/strategies/download/sftp.py 24 25 26 27 28 29 30 class SFTPConfig ( AttrDict ): \"\"\"(S)FTP-specific Configuration Data Model.\"\"\" datacache_config : Optional [ DataCacheConfig ] = Field ( None , description = \"Configurations for the data cache for storing the downloaded file content.\" , )","title":"SFTPConfig"},{"location":"api_reference/strategies/download/sftp/#oteapi.strategies.download.sftp.SFTPResourceConfig","text":"Bases: ResourceConfig (S)FTP download strategy filter config. Source code in oteapi/strategies/download/sftp.py 33 34 35 36 37 38 39 40 41 class SFTPResourceConfig ( ResourceConfig ): \"\"\"(S)FTP download strategy filter config.\"\"\" downloadUrl : AnyFtpUrl = Field ( # type: ignore[assignment] ... , description = \"The (S)FTP URL, which will be downloaded.\" ) configuration : SFTPConfig = Field ( SFTPConfig (), description = \"(S)FTP download strategy-specific configuration.\" )","title":"SFTPResourceConfig"},{"location":"api_reference/strategies/download/sftp/#oteapi.strategies.download.sftp.SFTPStrategy","text":"Strategy for retrieving data via sftp. Registers strategies : (\"scheme\", \"ftp\") (\"scheme\", \"sftp\") Source code in oteapi/strategies/download/sftp.py 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 @dataclass class SFTPStrategy : \"\"\"Strategy for retrieving data via sftp. **Registers strategies**: - `(\"scheme\", \"ftp\")` - `(\"scheme\", \"sftp\")` \"\"\" download_config : SFTPResourceConfig def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdate : \"\"\"Initialize.\"\"\" return SessionUpdate () def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdateSFTP : \"\"\"Download via sftp\"\"\" cache = DataCache ( self . download_config . configuration . datacache_config ) if cache . config . accessKey and cache . config . accessKey in cache : key = cache . config . accessKey else : # Setup connection options cnopts = pysftp . CnOpts () cnopts . hostkeys = None # open connection and store data locally with pysftp . Connection ( host = self . download_config . downloadUrl . host , username = self . download_config . downloadUrl . user , password = self . download_config . downloadUrl . password , port = self . download_config . downloadUrl . port , cnopts = cnopts , ) as sftp : # Because of insane locking on Windows, we have to close # the downloaded file before adding it to the cache with NamedTemporaryFile ( prefix = \"oteapi-sftp-\" , delete = False ) as handle : localpath = Path ( handle . name ) . resolve () try : sftp . get ( self . download_config . downloadUrl . path , localpath = localpath ) key = cache . add ( localpath . read_bytes ()) finally : localpath . unlink () return SessionUpdateSFTP ( key = key )","title":"SFTPStrategy"},{"location":"api_reference/strategies/download/sftp/#oteapi.strategies.download.sftp.SFTPStrategy.get","text":"Download via sftp Source code in oteapi/strategies/download/sftp.py 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdateSFTP : \"\"\"Download via sftp\"\"\" cache = DataCache ( self . download_config . configuration . datacache_config ) if cache . config . accessKey and cache . config . accessKey in cache : key = cache . config . accessKey else : # Setup connection options cnopts = pysftp . CnOpts () cnopts . hostkeys = None # open connection and store data locally with pysftp . Connection ( host = self . download_config . downloadUrl . host , username = self . download_config . downloadUrl . user , password = self . download_config . downloadUrl . password , port = self . download_config . downloadUrl . port , cnopts = cnopts , ) as sftp : # Because of insane locking on Windows, we have to close # the downloaded file before adding it to the cache with NamedTemporaryFile ( prefix = \"oteapi-sftp-\" , delete = False ) as handle : localpath = Path ( handle . name ) . resolve () try : sftp . get ( self . download_config . downloadUrl . path , localpath = localpath ) key = cache . add ( localpath . read_bytes ()) finally : localpath . unlink () return SessionUpdateSFTP ( key = key )","title":"get()"},{"location":"api_reference/strategies/download/sftp/#oteapi.strategies.download.sftp.SFTPStrategy.initialize","text":"Initialize. Source code in oteapi/strategies/download/sftp.py 63 64 65 def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdate : \"\"\"Initialize.\"\"\" return SessionUpdate ()","title":"initialize()"},{"location":"api_reference/strategies/download/sftp/#oteapi.strategies.download.sftp.SessionUpdateSFTP","text":"Bases: SessionUpdate Class for returning values from Download SFTP strategy. Source code in oteapi/strategies/download/sftp.py 44 45 46 47 class SessionUpdateSFTP ( SessionUpdate ): \"\"\"Class for returning values from Download SFTP strategy.\"\"\" key : str = Field ( ... , description = \"Key to access the data in the cache.\" )","title":"SessionUpdateSFTP"},{"location":"api_reference/strategies/filter/crop_filter/","text":"crop_filter \u00b6 Demo-filter strategy CropImageConfig \u00b6 Bases: AttrDict Configuration model for crop data. Source code in oteapi/strategies/filter/crop_filter.py 14 15 16 17 18 19 class CropImageConfig ( AttrDict ): \"\"\"Configuration model for crop data.\"\"\" crop : Tuple [ int , int , int , int ] = Field ( ... , description = \"Box cropping parameters (left, top, right, bottom).\" ) CropImageFilter \u00b6 Strategy for cropping an image. Registers strategies : (\"filterType\", \"filter/crop\") Source code in oteapi/strategies/filter/crop_filter.py 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 @dataclass class CropImageFilter : \"\"\"Strategy for cropping an image. **Registers strategies**: - `(\"filterType\", \"filter/crop\")` \"\"\" filter_config : CropImageFilterConfig def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None , ) -> SessionUpdateCropFilter : \"\"\"Initialize strategy and return a dictionary.\"\"\" return SessionUpdateCropFilter ( imagecrop = self . filter_config . configuration . crop , ) def get ( self , session : \"Optional[Dict[str, Any]]\" = None , ) -> SessionUpdate : \"\"\"Execute strategy and return a dictionary\"\"\" return SessionUpdate () get ( session = None ) \u00b6 Execute strategy and return a dictionary Source code in oteapi/strategies/filter/crop_filter.py 64 65 66 67 68 69 def get ( self , session : \"Optional[Dict[str, Any]]\" = None , ) -> SessionUpdate : \"\"\"Execute strategy and return a dictionary\"\"\" return SessionUpdate () initialize ( session = None ) \u00b6 Initialize strategy and return a dictionary. Source code in oteapi/strategies/filter/crop_filter.py 55 56 57 58 59 60 61 62 def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None , ) -> SessionUpdateCropFilter : \"\"\"Initialize strategy and return a dictionary.\"\"\" return SessionUpdateCropFilter ( imagecrop = self . filter_config . configuration . crop , ) CropImageFilterConfig \u00b6 Bases: FilterConfig Crop filter strategy filter config. Source code in oteapi/strategies/filter/crop_filter.py 22 23 24 25 26 27 28 29 30 31 32 class CropImageFilterConfig ( FilterConfig ): \"\"\"Crop filter strategy filter config.\"\"\" filterType : str = Field ( \"filter/crop\" , const = True , description = FilterConfig . __fields__ [ \"filterType\" ] . field_info . description , ) configuration : CropImageConfig = Field ( ... , description = \"Image crop filter strategy-specific configuration.\" ) SessionUpdateCropFilter \u00b6 Bases: SessionUpdate Return model for CropImageFilter . Source code in oteapi/strategies/filter/crop_filter.py 35 36 37 38 39 40 class SessionUpdateCropFilter ( SessionUpdate ): \"\"\"Return model for `CropImageFilter`.\"\"\" imagecrop : Tuple [ int , int , int , int ] = Field ( ... , description = \"Box cropping parameters (left, top, right, bottom).\" )","title":"crop_filter"},{"location":"api_reference/strategies/filter/crop_filter/#crop_filter","text":"Demo-filter strategy","title":"crop_filter"},{"location":"api_reference/strategies/filter/crop_filter/#oteapi.strategies.filter.crop_filter.CropImageConfig","text":"Bases: AttrDict Configuration model for crop data. Source code in oteapi/strategies/filter/crop_filter.py 14 15 16 17 18 19 class CropImageConfig ( AttrDict ): \"\"\"Configuration model for crop data.\"\"\" crop : Tuple [ int , int , int , int ] = Field ( ... , description = \"Box cropping parameters (left, top, right, bottom).\" )","title":"CropImageConfig"},{"location":"api_reference/strategies/filter/crop_filter/#oteapi.strategies.filter.crop_filter.CropImageFilter","text":"Strategy for cropping an image. Registers strategies : (\"filterType\", \"filter/crop\") Source code in oteapi/strategies/filter/crop_filter.py 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 @dataclass class CropImageFilter : \"\"\"Strategy for cropping an image. **Registers strategies**: - `(\"filterType\", \"filter/crop\")` \"\"\" filter_config : CropImageFilterConfig def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None , ) -> SessionUpdateCropFilter : \"\"\"Initialize strategy and return a dictionary.\"\"\" return SessionUpdateCropFilter ( imagecrop = self . filter_config . configuration . crop , ) def get ( self , session : \"Optional[Dict[str, Any]]\" = None , ) -> SessionUpdate : \"\"\"Execute strategy and return a dictionary\"\"\" return SessionUpdate ()","title":"CropImageFilter"},{"location":"api_reference/strategies/filter/crop_filter/#oteapi.strategies.filter.crop_filter.CropImageFilter.get","text":"Execute strategy and return a dictionary Source code in oteapi/strategies/filter/crop_filter.py 64 65 66 67 68 69 def get ( self , session : \"Optional[Dict[str, Any]]\" = None , ) -> SessionUpdate : \"\"\"Execute strategy and return a dictionary\"\"\" return SessionUpdate ()","title":"get()"},{"location":"api_reference/strategies/filter/crop_filter/#oteapi.strategies.filter.crop_filter.CropImageFilter.initialize","text":"Initialize strategy and return a dictionary. Source code in oteapi/strategies/filter/crop_filter.py 55 56 57 58 59 60 61 62 def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None , ) -> SessionUpdateCropFilter : \"\"\"Initialize strategy and return a dictionary.\"\"\" return SessionUpdateCropFilter ( imagecrop = self . filter_config . configuration . crop , )","title":"initialize()"},{"location":"api_reference/strategies/filter/crop_filter/#oteapi.strategies.filter.crop_filter.CropImageFilterConfig","text":"Bases: FilterConfig Crop filter strategy filter config. Source code in oteapi/strategies/filter/crop_filter.py 22 23 24 25 26 27 28 29 30 31 32 class CropImageFilterConfig ( FilterConfig ): \"\"\"Crop filter strategy filter config.\"\"\" filterType : str = Field ( \"filter/crop\" , const = True , description = FilterConfig . __fields__ [ \"filterType\" ] . field_info . description , ) configuration : CropImageConfig = Field ( ... , description = \"Image crop filter strategy-specific configuration.\" )","title":"CropImageFilterConfig"},{"location":"api_reference/strategies/filter/crop_filter/#oteapi.strategies.filter.crop_filter.SessionUpdateCropFilter","text":"Bases: SessionUpdate Return model for CropImageFilter . Source code in oteapi/strategies/filter/crop_filter.py 35 36 37 38 39 40 class SessionUpdateCropFilter ( SessionUpdate ): \"\"\"Return model for `CropImageFilter`.\"\"\" imagecrop : Tuple [ int , int , int , int ] = Field ( ... , description = \"Box cropping parameters (left, top, right, bottom).\" )","title":"SessionUpdateCropFilter"},{"location":"api_reference/strategies/filter/sql_query_filter/","text":"sql_query_filter \u00b6 SQL query filter strategy. SQLQueryFilter \u00b6 Strategy for a SQL query filter. Registers strategies : (\"filterType\", \"filter/sql\") Source code in oteapi/strategies/filter/sql_query_filter.py 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 @dataclass class SQLQueryFilter : \"\"\"Strategy for a SQL query filter. **Registers strategies**: - `(\"filterType\", \"filter/sql\")` \"\"\" filter_config : SqlQueryFilterConfig def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None , ) -> SessionUpdateSqlQuery : \"\"\"Initialize strategy.\"\"\" return SessionUpdateSqlQuery ( sqlquery = self . filter_config . query ) def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdate : \"\"\"Execute strategy and return a dictionary.\"\"\" return SessionUpdate () get ( session = None ) \u00b6 Execute strategy and return a dictionary. Source code in oteapi/strategies/filter/sql_query_filter.py 50 51 52 def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdate : \"\"\"Execute strategy and return a dictionary.\"\"\" return SessionUpdate () initialize ( session = None ) \u00b6 Initialize strategy. Source code in oteapi/strategies/filter/sql_query_filter.py 43 44 45 46 47 48 def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None , ) -> SessionUpdateSqlQuery : \"\"\"Initialize strategy.\"\"\" return SessionUpdateSqlQuery ( sqlquery = self . filter_config . query ) SessionUpdateSqlQuery \u00b6 Bases: SessionUpdate Class for returning values from SQL Query data model. Source code in oteapi/strategies/filter/sql_query_filter.py 25 26 27 28 class SessionUpdateSqlQuery ( SessionUpdate ): \"\"\"Class for returning values from SQL Query data model.\"\"\" sqlquery : str = Field ( ... , description = \"A SQL query string.\" ) SqlQueryFilterConfig \u00b6 Bases: FilterConfig SQLite query filter strategy filter config. Source code in oteapi/strategies/filter/sql_query_filter.py 14 15 16 17 18 19 20 21 22 class SqlQueryFilterConfig ( FilterConfig ): \"\"\"SQLite query filter strategy filter config.\"\"\" filterType : str = Field ( \"filter/sql\" , const = True , description = FilterConfig . __fields__ [ \"filterType\" ] . field_info . description , ) query : str = Field ( ... , description = \"A SQL query string.\" )","title":"sql_query_filter"},{"location":"api_reference/strategies/filter/sql_query_filter/#sql_query_filter","text":"SQL query filter strategy.","title":"sql_query_filter"},{"location":"api_reference/strategies/filter/sql_query_filter/#oteapi.strategies.filter.sql_query_filter.SQLQueryFilter","text":"Strategy for a SQL query filter. Registers strategies : (\"filterType\", \"filter/sql\") Source code in oteapi/strategies/filter/sql_query_filter.py 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 @dataclass class SQLQueryFilter : \"\"\"Strategy for a SQL query filter. **Registers strategies**: - `(\"filterType\", \"filter/sql\")` \"\"\" filter_config : SqlQueryFilterConfig def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None , ) -> SessionUpdateSqlQuery : \"\"\"Initialize strategy.\"\"\" return SessionUpdateSqlQuery ( sqlquery = self . filter_config . query ) def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdate : \"\"\"Execute strategy and return a dictionary.\"\"\" return SessionUpdate ()","title":"SQLQueryFilter"},{"location":"api_reference/strategies/filter/sql_query_filter/#oteapi.strategies.filter.sql_query_filter.SQLQueryFilter.get","text":"Execute strategy and return a dictionary. Source code in oteapi/strategies/filter/sql_query_filter.py 50 51 52 def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdate : \"\"\"Execute strategy and return a dictionary.\"\"\" return SessionUpdate ()","title":"get()"},{"location":"api_reference/strategies/filter/sql_query_filter/#oteapi.strategies.filter.sql_query_filter.SQLQueryFilter.initialize","text":"Initialize strategy. Source code in oteapi/strategies/filter/sql_query_filter.py 43 44 45 46 47 48 def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None , ) -> SessionUpdateSqlQuery : \"\"\"Initialize strategy.\"\"\" return SessionUpdateSqlQuery ( sqlquery = self . filter_config . query )","title":"initialize()"},{"location":"api_reference/strategies/filter/sql_query_filter/#oteapi.strategies.filter.sql_query_filter.SessionUpdateSqlQuery","text":"Bases: SessionUpdate Class for returning values from SQL Query data model. Source code in oteapi/strategies/filter/sql_query_filter.py 25 26 27 28 class SessionUpdateSqlQuery ( SessionUpdate ): \"\"\"Class for returning values from SQL Query data model.\"\"\" sqlquery : str = Field ( ... , description = \"A SQL query string.\" )","title":"SessionUpdateSqlQuery"},{"location":"api_reference/strategies/filter/sql_query_filter/#oteapi.strategies.filter.sql_query_filter.SqlQueryFilterConfig","text":"Bases: FilterConfig SQLite query filter strategy filter config. Source code in oteapi/strategies/filter/sql_query_filter.py 14 15 16 17 18 19 20 21 22 class SqlQueryFilterConfig ( FilterConfig ): \"\"\"SQLite query filter strategy filter config.\"\"\" filterType : str = Field ( \"filter/sql\" , const = True , description = FilterConfig . __fields__ [ \"filterType\" ] . field_info . description , ) query : str = Field ( ... , description = \"A SQL query string.\" )","title":"SqlQueryFilterConfig"},{"location":"api_reference/strategies/mapping/mapping/","text":"mapping \u00b6 Mapping filter strategy. MappingSessionUpdate \u00b6 Bases: SessionUpdate SessionUpdate model for mappings. Source code in oteapi/strategies/mapping/mapping.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class MappingSessionUpdate ( SessionUpdate ): \"\"\"SessionUpdate model for mappings.\"\"\" prefixes : Dict [ str , str ] = Field ( ... , description = ( \"List of shortnames that expands to an IRI \" \"given as local value/IRI-expansion-pairs.\" ), ) triples : List [ RDFTriple ] = Field ( ... , description = \"List of semantic triples given as (subject, predicate, object).\" , ) MappingStrategy \u00b6 Strategy for a mapping. The mapping strategy simply adds more prefixes and triples to the prefixes and triples fields in the session such that they are available for other strategies, like function strategies that convert between data models. Nothing is returned to avoid deleting existing mappings. Registers strategies : (\"mappingType\", \"triples\") Source code in oteapi/strategies/mapping/mapping.py 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 @dataclass class MappingStrategy : \"\"\"Strategy for a mapping. The mapping strategy simply adds more prefixes and triples to the `prefixes` and `triples` fields in the session such that they are available for other strategies, like function strategies that convert between data models. Nothing is returned to avoid deleting existing mappings. **Registers strategies**: - `(\"mappingType\", \"triples\")` \"\"\" mapping_config : MappingConfig def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> MappingSessionUpdate : \"\"\"Initialize strategy.\"\"\" prefixes = session . get ( \"prefixes\" , {}) if session else {} triples = session . get ( \"triples\" , []) if session else [] if self . mapping_config . prefixes : prefixes . update ( self . mapping_config . prefixes ) if self . mapping_config . triples : triples . extend ( self . mapping_config . triples ) return MappingSessionUpdate ( prefixes = prefixes , triples = triples ) def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdate : \"\"\"Execute strategy and return a dictionary.\"\"\" return SessionUpdate () get ( session = None ) \u00b6 Execute strategy and return a dictionary. Source code in oteapi/strategies/mapping/mapping.py 62 63 64 def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdate : \"\"\"Execute strategy and return a dictionary.\"\"\" return SessionUpdate () initialize ( session = None ) \u00b6 Initialize strategy. Source code in oteapi/strategies/mapping/mapping.py 48 49 50 51 52 53 54 55 56 57 58 59 60 def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> MappingSessionUpdate : \"\"\"Initialize strategy.\"\"\" prefixes = session . get ( \"prefixes\" , {}) if session else {} triples = session . get ( \"triples\" , []) if session else [] if self . mapping_config . prefixes : prefixes . update ( self . mapping_config . prefixes ) if self . mapping_config . triples : triples . extend ( self . mapping_config . triples ) return MappingSessionUpdate ( prefixes = prefixes , triples = triples )","title":"mapping"},{"location":"api_reference/strategies/mapping/mapping/#mapping","text":"Mapping filter strategy.","title":"mapping"},{"location":"api_reference/strategies/mapping/mapping/#oteapi.strategies.mapping.mapping.MappingSessionUpdate","text":"Bases: SessionUpdate SessionUpdate model for mappings. Source code in oteapi/strategies/mapping/mapping.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class MappingSessionUpdate ( SessionUpdate ): \"\"\"SessionUpdate model for mappings.\"\"\" prefixes : Dict [ str , str ] = Field ( ... , description = ( \"List of shortnames that expands to an IRI \" \"given as local value/IRI-expansion-pairs.\" ), ) triples : List [ RDFTriple ] = Field ( ... , description = \"List of semantic triples given as (subject, predicate, object).\" , )","title":"MappingSessionUpdate"},{"location":"api_reference/strategies/mapping/mapping/#oteapi.strategies.mapping.mapping.MappingStrategy","text":"Strategy for a mapping. The mapping strategy simply adds more prefixes and triples to the prefixes and triples fields in the session such that they are available for other strategies, like function strategies that convert between data models. Nothing is returned to avoid deleting existing mappings. Registers strategies : (\"mappingType\", \"triples\") Source code in oteapi/strategies/mapping/mapping.py 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 @dataclass class MappingStrategy : \"\"\"Strategy for a mapping. The mapping strategy simply adds more prefixes and triples to the `prefixes` and `triples` fields in the session such that they are available for other strategies, like function strategies that convert between data models. Nothing is returned to avoid deleting existing mappings. **Registers strategies**: - `(\"mappingType\", \"triples\")` \"\"\" mapping_config : MappingConfig def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> MappingSessionUpdate : \"\"\"Initialize strategy.\"\"\" prefixes = session . get ( \"prefixes\" , {}) if session else {} triples = session . get ( \"triples\" , []) if session else [] if self . mapping_config . prefixes : prefixes . update ( self . mapping_config . prefixes ) if self . mapping_config . triples : triples . extend ( self . mapping_config . triples ) return MappingSessionUpdate ( prefixes = prefixes , triples = triples ) def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdate : \"\"\"Execute strategy and return a dictionary.\"\"\" return SessionUpdate ()","title":"MappingStrategy"},{"location":"api_reference/strategies/mapping/mapping/#oteapi.strategies.mapping.mapping.MappingStrategy.get","text":"Execute strategy and return a dictionary. Source code in oteapi/strategies/mapping/mapping.py 62 63 64 def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdate : \"\"\"Execute strategy and return a dictionary.\"\"\" return SessionUpdate ()","title":"get()"},{"location":"api_reference/strategies/mapping/mapping/#oteapi.strategies.mapping.mapping.MappingStrategy.initialize","text":"Initialize strategy. Source code in oteapi/strategies/mapping/mapping.py 48 49 50 51 52 53 54 55 56 57 58 59 60 def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> MappingSessionUpdate : \"\"\"Initialize strategy.\"\"\" prefixes = session . get ( \"prefixes\" , {}) if session else {} triples = session . get ( \"triples\" , []) if session else [] if self . mapping_config . prefixes : prefixes . update ( self . mapping_config . prefixes ) if self . mapping_config . triples : triples . extend ( self . mapping_config . triples ) return MappingSessionUpdate ( prefixes = prefixes , triples = triples )","title":"initialize()"},{"location":"api_reference/strategies/parse/application_json/","text":"application_json \u00b6 Strategy class for application/json. JSONConfig \u00b6 Bases: AttrDict JSON parse-specific Configuration Data Model. Source code in oteapi/strategies/parse/application_json.py 17 18 19 20 21 22 23 class JSONConfig ( AttrDict ): \"\"\"JSON parse-specific Configuration Data Model.\"\"\" datacache_config : Optional [ DataCacheConfig ] = Field ( None , description = \"Configurations for the data cache for storing the downloaded file content.\" , ) JSONDataParseStrategy \u00b6 Parse strategy for JSON. Registers strategies : (\"mediaType\", \"application/json\") Source code in oteapi/strategies/parse/application_json.py 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 @dataclass class JSONDataParseStrategy : \"\"\"Parse strategy for JSON. **Registers strategies**: - `(\"mediaType\", \"application/json\")` \"\"\" parse_config : JSONResourceConfig def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdate : \"\"\"Initialize.\"\"\" return SessionUpdate () def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdateJSONParse : \"\"\"Parse json.\"\"\" downloader = create_strategy ( \"download\" , self . parse_config ) output = downloader . get () cache = DataCache ( self . parse_config . configuration . datacache_config ) content = cache . get ( output [ \"key\" ]) if isinstance ( content , dict ): return SessionUpdateJSONParse ( content = content ) return SessionUpdateJSONParse ( content = json . loads ( content )) get ( session = None ) \u00b6 Parse json. Source code in oteapi/strategies/parse/application_json.py 61 62 63 64 65 66 67 68 69 70 def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdateJSONParse : \"\"\"Parse json.\"\"\" downloader = create_strategy ( \"download\" , self . parse_config ) output = downloader . get () cache = DataCache ( self . parse_config . configuration . datacache_config ) content = cache . get ( output [ \"key\" ]) if isinstance ( content , dict ): return SessionUpdateJSONParse ( content = content ) return SessionUpdateJSONParse ( content = json . loads ( content )) initialize ( session = None ) \u00b6 Initialize. Source code in oteapi/strategies/parse/application_json.py 57 58 59 def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdate : \"\"\"Initialize.\"\"\" return SessionUpdate () JSONResourceConfig \u00b6 Bases: ResourceConfig JSON parse strategy filter config. Source code in oteapi/strategies/parse/application_json.py 26 27 28 29 30 31 32 33 34 35 36 class JSONResourceConfig ( ResourceConfig ): \"\"\"JSON parse strategy filter config.\"\"\" mediaType : str = Field ( \"application/json\" , const = True , description = ResourceConfig . __fields__ [ \"mediaType\" ] . field_info . description , ) configuration : JSONConfig = Field ( JSONConfig (), description = \"JSON parse strategy-specific configuration.\" ) SessionUpdateJSONParse \u00b6 Bases: SessionUpdate Class for returning values from JSON Parse. Source code in oteapi/strategies/parse/application_json.py 39 40 41 42 class SessionUpdateJSONParse ( SessionUpdate ): \"\"\"Class for returning values from JSON Parse.\"\"\" content : dict = Field ( ... , description = \"Content of the JSON document.\" )","title":"application_json"},{"location":"api_reference/strategies/parse/application_json/#application_json","text":"Strategy class for application/json.","title":"application_json"},{"location":"api_reference/strategies/parse/application_json/#oteapi.strategies.parse.application_json.JSONConfig","text":"Bases: AttrDict JSON parse-specific Configuration Data Model. Source code in oteapi/strategies/parse/application_json.py 17 18 19 20 21 22 23 class JSONConfig ( AttrDict ): \"\"\"JSON parse-specific Configuration Data Model.\"\"\" datacache_config : Optional [ DataCacheConfig ] = Field ( None , description = \"Configurations for the data cache for storing the downloaded file content.\" , )","title":"JSONConfig"},{"location":"api_reference/strategies/parse/application_json/#oteapi.strategies.parse.application_json.JSONDataParseStrategy","text":"Parse strategy for JSON. Registers strategies : (\"mediaType\", \"application/json\") Source code in oteapi/strategies/parse/application_json.py 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 @dataclass class JSONDataParseStrategy : \"\"\"Parse strategy for JSON. **Registers strategies**: - `(\"mediaType\", \"application/json\")` \"\"\" parse_config : JSONResourceConfig def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdate : \"\"\"Initialize.\"\"\" return SessionUpdate () def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdateJSONParse : \"\"\"Parse json.\"\"\" downloader = create_strategy ( \"download\" , self . parse_config ) output = downloader . get () cache = DataCache ( self . parse_config . configuration . datacache_config ) content = cache . get ( output [ \"key\" ]) if isinstance ( content , dict ): return SessionUpdateJSONParse ( content = content ) return SessionUpdateJSONParse ( content = json . loads ( content ))","title":"JSONDataParseStrategy"},{"location":"api_reference/strategies/parse/application_json/#oteapi.strategies.parse.application_json.JSONDataParseStrategy.get","text":"Parse json. Source code in oteapi/strategies/parse/application_json.py 61 62 63 64 65 66 67 68 69 70 def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdateJSONParse : \"\"\"Parse json.\"\"\" downloader = create_strategy ( \"download\" , self . parse_config ) output = downloader . get () cache = DataCache ( self . parse_config . configuration . datacache_config ) content = cache . get ( output [ \"key\" ]) if isinstance ( content , dict ): return SessionUpdateJSONParse ( content = content ) return SessionUpdateJSONParse ( content = json . loads ( content ))","title":"get()"},{"location":"api_reference/strategies/parse/application_json/#oteapi.strategies.parse.application_json.JSONDataParseStrategy.initialize","text":"Initialize. Source code in oteapi/strategies/parse/application_json.py 57 58 59 def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdate : \"\"\"Initialize.\"\"\" return SessionUpdate ()","title":"initialize()"},{"location":"api_reference/strategies/parse/application_json/#oteapi.strategies.parse.application_json.JSONResourceConfig","text":"Bases: ResourceConfig JSON parse strategy filter config. Source code in oteapi/strategies/parse/application_json.py 26 27 28 29 30 31 32 33 34 35 36 class JSONResourceConfig ( ResourceConfig ): \"\"\"JSON parse strategy filter config.\"\"\" mediaType : str = Field ( \"application/json\" , const = True , description = ResourceConfig . __fields__ [ \"mediaType\" ] . field_info . description , ) configuration : JSONConfig = Field ( JSONConfig (), description = \"JSON parse strategy-specific configuration.\" )","title":"JSONResourceConfig"},{"location":"api_reference/strategies/parse/application_json/#oteapi.strategies.parse.application_json.SessionUpdateJSONParse","text":"Bases: SessionUpdate Class for returning values from JSON Parse. Source code in oteapi/strategies/parse/application_json.py 39 40 41 42 class SessionUpdateJSONParse ( SessionUpdate ): \"\"\"Class for returning values from JSON Parse.\"\"\" content : dict = Field ( ... , description = \"Content of the JSON document.\" )","title":"SessionUpdateJSONParse"},{"location":"api_reference/strategies/parse/application_vnd_sqlite/","text":"application_vnd_sqlite \u00b6 Strategy class for application/vnd.sqlite3. SessionUpdateSqLiteParse \u00b6 Bases: SessionUpdate Configuration model for SqLiteParse. Source code in oteapi/strategies/parse/application_vnd_sqlite.py 61 62 63 64 class SessionUpdateSqLiteParse ( SessionUpdate ): \"\"\"Configuration model for SqLiteParse.\"\"\" result : list = Field ( ... , description = \"List of results from the query.\" ) SqliteParseConfig \u00b6 Bases: AttrDict Configuration data model for SqliteParseStrategy . Source code in oteapi/strategies/parse/application_vnd_sqlite.py 18 19 20 21 22 23 24 25 26 class SqliteParseConfig ( AttrDict ): \"\"\"Configuration data model for [`SqliteParseStrategy`][oteapi.strategies.parse.application_vnd_sqlite.SqliteParseStrategy].\"\"\" sqlquery : str = Field ( \"\" , description = \"A SQL query string.\" ) datacache_config : Optional [ DataCacheConfig ] = Field ( None , description = \"Configuration options for the local data cache.\" , ) SqliteParseStrategy \u00b6 Parse strategy for SQLite. Registers strategies : (\"mediaType\", \"application/vnd.sqlite3\") Purpose of this strategy: Download a SQLite database using downloadUrl and run a SQL query on the database to return all relevant rows. Source code in oteapi/strategies/parse/application_vnd_sqlite.py 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 @dataclass class SqliteParseStrategy : \"\"\"Parse strategy for SQLite. **Registers strategies**: - `(\"mediaType\", \"application/vnd.sqlite3\")` Purpose of this strategy: Download a SQLite database using `downloadUrl` and run a SQL query on the database to return all relevant rows. \"\"\" parse_config : SqliteParserResourceConfig def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdate : \"\"\"Initialize strategy.\"\"\" return SessionUpdate () def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdateSqLiteParse : \"\"\"Parse SQLite query responses.\"\"\" if session : self . _use_filters ( session ) session = session if session else {} # Retrieve SQLite file download_config = self . parse_config . copy () del download_config . configuration downloader = create_strategy ( \"download\" , download_config ) session . update ( downloader . initialize ( session )) cache_key = downloader . get ( session ) . get ( \"key\" , \"\" ) cache = DataCache ( self . parse_config . configuration . datacache_config ) with cache . getfile ( cache_key , suffix = \"db\" ) as filename : connection = create_connection ( filename ) cursor = connection . cursor () result = cursor . execute ( self . parse_config . configuration . sqlquery ) . fetchall () connection . close () return SessionUpdateSqLiteParse ( result = result ) def _use_filters ( self , session : \"Dict[str, Any]\" ) -> None : \"\"\"Update `config` according to filter values found in the session.\"\"\" if \"sqlquery\" in session and not self . parse_config . configuration . sqlquery : # Use SQL query available in session self . parse_config . configuration . sqlquery = session [ \"sqlquery\" ] _use_filters ( session ) \u00b6 Update config according to filter values found in the session. Source code in oteapi/strategies/parse/application_vnd_sqlite.py 109 110 111 112 113 def _use_filters ( self , session : \"Dict[str, Any]\" ) -> None : \"\"\"Update `config` according to filter values found in the session.\"\"\" if \"sqlquery\" in session and not self . parse_config . configuration . sqlquery : # Use SQL query available in session self . parse_config . configuration . sqlquery = session [ \"sqlquery\" ] get ( session = None ) \u00b6 Parse SQLite query responses. Source code in oteapi/strategies/parse/application_vnd_sqlite.py 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdateSqLiteParse : \"\"\"Parse SQLite query responses.\"\"\" if session : self . _use_filters ( session ) session = session if session else {} # Retrieve SQLite file download_config = self . parse_config . copy () del download_config . configuration downloader = create_strategy ( \"download\" , download_config ) session . update ( downloader . initialize ( session )) cache_key = downloader . get ( session ) . get ( \"key\" , \"\" ) cache = DataCache ( self . parse_config . configuration . datacache_config ) with cache . getfile ( cache_key , suffix = \"db\" ) as filename : connection = create_connection ( filename ) cursor = connection . cursor () result = cursor . execute ( self . parse_config . configuration . sqlquery ) . fetchall () connection . close () return SessionUpdateSqLiteParse ( result = result ) initialize ( session = None ) \u00b6 Initialize strategy. Source code in oteapi/strategies/parse/application_vnd_sqlite.py 82 83 84 def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdate : \"\"\"Initialize strategy.\"\"\" return SessionUpdate () SqliteParserResourceConfig \u00b6 Bases: ResourceConfig SQLite parse strategy resource config. Source code in oteapi/strategies/parse/application_vnd_sqlite.py 29 30 31 32 33 34 35 36 37 38 39 class SqliteParserResourceConfig ( ResourceConfig ): \"\"\"SQLite parse strategy resource config.\"\"\" mediaType : str = Field ( \"application/vnd.sqlite3\" , const = True , description = ResourceConfig . __fields__ [ \"mediaType\" ] . field_info . description , ) configuration : SqliteParseConfig = Field ( SqliteParseConfig (), description = \"SQLite parse strategy-specific configuration.\" ) create_connection ( db_file ) \u00b6 Create a database connection to SQLite database. Parameters: Name Type Description Default db_file Path Full path to SQLite database file. required Raises: Type Description sqlite3 . Error If a DB connection cannot be made. Returns: Type Description sqlite3 . Connection Connection object. Source code in oteapi/strategies/parse/application_vnd_sqlite.py 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 def create_connection ( db_file : Path ) -> sqlite3 . Connection : \"\"\"Create a database connection to SQLite database. Parameters: db_file: Full path to SQLite database file. Raises: sqlite3.Error: If a DB connection cannot be made. Returns: Connection object. \"\"\" try : return sqlite3 . connect ( db_file ) except sqlite3 . Error as exc : raise sqlite3 . Error ( \"Could not connect to given SQLite DB.\" ) from exc","title":"application_vnd_sqlite"},{"location":"api_reference/strategies/parse/application_vnd_sqlite/#application_vnd_sqlite","text":"Strategy class for application/vnd.sqlite3.","title":"application_vnd_sqlite"},{"location":"api_reference/strategies/parse/application_vnd_sqlite/#oteapi.strategies.parse.application_vnd_sqlite.SessionUpdateSqLiteParse","text":"Bases: SessionUpdate Configuration model for SqLiteParse. Source code in oteapi/strategies/parse/application_vnd_sqlite.py 61 62 63 64 class SessionUpdateSqLiteParse ( SessionUpdate ): \"\"\"Configuration model for SqLiteParse.\"\"\" result : list = Field ( ... , description = \"List of results from the query.\" )","title":"SessionUpdateSqLiteParse"},{"location":"api_reference/strategies/parse/application_vnd_sqlite/#oteapi.strategies.parse.application_vnd_sqlite.SqliteParseConfig","text":"Bases: AttrDict Configuration data model for SqliteParseStrategy . Source code in oteapi/strategies/parse/application_vnd_sqlite.py 18 19 20 21 22 23 24 25 26 class SqliteParseConfig ( AttrDict ): \"\"\"Configuration data model for [`SqliteParseStrategy`][oteapi.strategies.parse.application_vnd_sqlite.SqliteParseStrategy].\"\"\" sqlquery : str = Field ( \"\" , description = \"A SQL query string.\" ) datacache_config : Optional [ DataCacheConfig ] = Field ( None , description = \"Configuration options for the local data cache.\" , )","title":"SqliteParseConfig"},{"location":"api_reference/strategies/parse/application_vnd_sqlite/#oteapi.strategies.parse.application_vnd_sqlite.SqliteParseStrategy","text":"Parse strategy for SQLite. Registers strategies : (\"mediaType\", \"application/vnd.sqlite3\") Purpose of this strategy: Download a SQLite database using downloadUrl and run a SQL query on the database to return all relevant rows. Source code in oteapi/strategies/parse/application_vnd_sqlite.py 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 @dataclass class SqliteParseStrategy : \"\"\"Parse strategy for SQLite. **Registers strategies**: - `(\"mediaType\", \"application/vnd.sqlite3\")` Purpose of this strategy: Download a SQLite database using `downloadUrl` and run a SQL query on the database to return all relevant rows. \"\"\" parse_config : SqliteParserResourceConfig def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdate : \"\"\"Initialize strategy.\"\"\" return SessionUpdate () def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdateSqLiteParse : \"\"\"Parse SQLite query responses.\"\"\" if session : self . _use_filters ( session ) session = session if session else {} # Retrieve SQLite file download_config = self . parse_config . copy () del download_config . configuration downloader = create_strategy ( \"download\" , download_config ) session . update ( downloader . initialize ( session )) cache_key = downloader . get ( session ) . get ( \"key\" , \"\" ) cache = DataCache ( self . parse_config . configuration . datacache_config ) with cache . getfile ( cache_key , suffix = \"db\" ) as filename : connection = create_connection ( filename ) cursor = connection . cursor () result = cursor . execute ( self . parse_config . configuration . sqlquery ) . fetchall () connection . close () return SessionUpdateSqLiteParse ( result = result ) def _use_filters ( self , session : \"Dict[str, Any]\" ) -> None : \"\"\"Update `config` according to filter values found in the session.\"\"\" if \"sqlquery\" in session and not self . parse_config . configuration . sqlquery : # Use SQL query available in session self . parse_config . configuration . sqlquery = session [ \"sqlquery\" ]","title":"SqliteParseStrategy"},{"location":"api_reference/strategies/parse/application_vnd_sqlite/#oteapi.strategies.parse.application_vnd_sqlite.SqliteParseStrategy._use_filters","text":"Update config according to filter values found in the session. Source code in oteapi/strategies/parse/application_vnd_sqlite.py 109 110 111 112 113 def _use_filters ( self , session : \"Dict[str, Any]\" ) -> None : \"\"\"Update `config` according to filter values found in the session.\"\"\" if \"sqlquery\" in session and not self . parse_config . configuration . sqlquery : # Use SQL query available in session self . parse_config . configuration . sqlquery = session [ \"sqlquery\" ]","title":"_use_filters()"},{"location":"api_reference/strategies/parse/application_vnd_sqlite/#oteapi.strategies.parse.application_vnd_sqlite.SqliteParseStrategy.get","text":"Parse SQLite query responses. Source code in oteapi/strategies/parse/application_vnd_sqlite.py 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdateSqLiteParse : \"\"\"Parse SQLite query responses.\"\"\" if session : self . _use_filters ( session ) session = session if session else {} # Retrieve SQLite file download_config = self . parse_config . copy () del download_config . configuration downloader = create_strategy ( \"download\" , download_config ) session . update ( downloader . initialize ( session )) cache_key = downloader . get ( session ) . get ( \"key\" , \"\" ) cache = DataCache ( self . parse_config . configuration . datacache_config ) with cache . getfile ( cache_key , suffix = \"db\" ) as filename : connection = create_connection ( filename ) cursor = connection . cursor () result = cursor . execute ( self . parse_config . configuration . sqlquery ) . fetchall () connection . close () return SessionUpdateSqLiteParse ( result = result )","title":"get()"},{"location":"api_reference/strategies/parse/application_vnd_sqlite/#oteapi.strategies.parse.application_vnd_sqlite.SqliteParseStrategy.initialize","text":"Initialize strategy. Source code in oteapi/strategies/parse/application_vnd_sqlite.py 82 83 84 def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdate : \"\"\"Initialize strategy.\"\"\" return SessionUpdate ()","title":"initialize()"},{"location":"api_reference/strategies/parse/application_vnd_sqlite/#oteapi.strategies.parse.application_vnd_sqlite.SqliteParserResourceConfig","text":"Bases: ResourceConfig SQLite parse strategy resource config. Source code in oteapi/strategies/parse/application_vnd_sqlite.py 29 30 31 32 33 34 35 36 37 38 39 class SqliteParserResourceConfig ( ResourceConfig ): \"\"\"SQLite parse strategy resource config.\"\"\" mediaType : str = Field ( \"application/vnd.sqlite3\" , const = True , description = ResourceConfig . __fields__ [ \"mediaType\" ] . field_info . description , ) configuration : SqliteParseConfig = Field ( SqliteParseConfig (), description = \"SQLite parse strategy-specific configuration.\" )","title":"SqliteParserResourceConfig"},{"location":"api_reference/strategies/parse/application_vnd_sqlite/#oteapi.strategies.parse.application_vnd_sqlite.create_connection","text":"Create a database connection to SQLite database. Parameters: Name Type Description Default db_file Path Full path to SQLite database file. required Raises: Type Description sqlite3 . Error If a DB connection cannot be made. Returns: Type Description sqlite3 . Connection Connection object. Source code in oteapi/strategies/parse/application_vnd_sqlite.py 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 def create_connection ( db_file : Path ) -> sqlite3 . Connection : \"\"\"Create a database connection to SQLite database. Parameters: db_file: Full path to SQLite database file. Raises: sqlite3.Error: If a DB connection cannot be made. Returns: Connection object. \"\"\" try : return sqlite3 . connect ( db_file ) except sqlite3 . Error as exc : raise sqlite3 . Error ( \"Could not connect to given SQLite DB.\" ) from exc","title":"create_connection()"},{"location":"api_reference/strategies/parse/excel_xlsx/","text":"excel_xlsx \u00b6 Strategy class for workbook/xlsx. SessionUpdateXLSXParse \u00b6 Bases: SessionUpdate Class for returning values from XLSXParse. Source code in oteapi/strategies/parse/excel_xlsx.py 19 20 21 22 23 24 25 class SessionUpdateXLSXParse ( SessionUpdate ): \"\"\"Class for returning values from XLSXParse.\"\"\" data : Dict [ str , list ] = Field ( ... , description = \"A dict with column-name/column-value pairs. The values are lists.\" , ) XLSXParseConfig \u00b6 Bases: AttrDict Data model for retrieving a rectangular section of an Excel sheet. Source code in oteapi/strategies/parse/excel_xlsx.py 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 class XLSXParseConfig ( AttrDict ): \"\"\"Data model for retrieving a rectangular section of an Excel sheet.\"\"\" worksheet : str = Field ( ... , description = \"Name of worksheet to load.\" ) row_from : Optional [ int ] = Field ( None , description = \"Excel row number of first row. Defaults to first assigned row.\" , ) col_from : Optional [ Union [ int , str ]] = Field ( None , description = ( \"Excel column number or label of first column. Defaults to first assigned \" \"column.\" ), ) row_to : Optional [ int ] = Field ( None , description = \"Excel row number of last row. Defaults to last assigned row.\" ) col_to : Optional [ Union [ int , str ]] = Field ( None , description = ( \"Excel column number or label of last column. Defaults to last assigned \" \"column.\" ), ) header_row : Optional [ int ] = Field ( None , description = ( \"Row number with the headers. Defaults to `1` if header is given, \" \"otherwise `None`.\" ), ) header : Optional [ List [ str ]] = Field ( None , description = ( \"Optional list of column names, specifying the columns to return. \" \"These names they should match cells in `header_row`.\" ), ) new_header : Optional [ List [ str ]] = Field ( None , description = ( \"Optional list of new column names replacing `header` in the output.\" ), ) download_config : AttrDict = Field ( AttrDict (), description = \"Configurations provided to a download strategy.\" , ) datacache_config : Optional [ DataCacheConfig ] = Field ( None , description = \"Configurations for the data cache for retrieving the downloaded content.\" , ) XLSXParseResourceConfig \u00b6 Bases: ResourceConfig XLSX parse strategy resource config. Source code in oteapi/strategies/parse/excel_xlsx.py 83 84 85 86 87 88 89 90 91 92 93 class XLSXParseResourceConfig ( ResourceConfig ): \"\"\"XLSX parse strategy resource config.\"\"\" mediaType : str = Field ( \"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\" , const = True , description = ResourceConfig . __fields__ [ \"mediaType\" ] . field_info . description , ) configuration : XLSXParseConfig = Field ( ... , description = \"SQLite parse strategy-specific configuration.\" ) XLSXParseStrategy \u00b6 Parse strategy for Excel XLSX files. Registers strategies : (\"mediaType\", \"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\") Source code in oteapi/strategies/parse/excel_xlsx.py 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 @dataclass class XLSXParseStrategy : \"\"\"Parse strategy for Excel XLSX files. **Registers strategies**: - `(\"mediaType\", \"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\")` \"\"\" parse_config : XLSXParseResourceConfig def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdate : \"\"\"Initialize.\"\"\" return SessionUpdate () def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdateXLSXParse : \"\"\"Parses selected region of an excel file. Returns: A dict with column-name/column-value pairs. The values are lists. \"\"\" cache = DataCache ( self . parse_config . configuration . datacache_config ) if session is None : raise ValueError ( \"Missing session\" ) with cache . getfile ( key = session [ \"key\" ], suffix = \".xlsx\" ) as filename : # Note that we have to set read_only=False to ensure that # load_workbook() properly closes the xlsx file after reading. # Otherwise Windows will fail when the temporary file is removed # when leaving the with statement. workbook = load_workbook ( filename = filename , read_only = False , data_only = True ) worksheet = workbook [ self . parse_config . configuration . worksheet ] set_model_defaults ( self . parse_config . configuration , worksheet ) columns = get_column_indices ( self . parse_config . configuration , worksheet ) data = [] for row in worksheet . iter_rows ( min_row = self . parse_config . configuration . row_from , max_row = self . parse_config . configuration . row_to , min_col = min ( columns ), max_col = max ( columns ), ): data . append ([ row [ c - 1 ] . value for c in columns ]) if self . parse_config . configuration . header_row : row = worksheet . iter_rows ( min_row = self . parse_config . configuration . header_row , max_row = self . parse_config . configuration . header_row , min_col = min ( columns ), max_col = max ( columns ), ) . __next__ () header = [ row [ c - 1 ] . value for c in columns ] else : header = None if self . parse_config . configuration . new_header : nhead = len ( header ) if header else len ( data [ 0 ]) if data else 0 if len ( self . parse_config . configuration . new_header ) != nhead : raise TypeError ( f \"length of `new_header` (= { len ( self . parse_config . configuration . new_header ) } ) \" f \"doesn't match number of columns (= { len ( header ) if header else 0 } )\" ) if header : for i , val in enumerate ( self . parse_config . configuration . new_header ): if val is not None : header [ i ] = val elif data : header = self . parse_config . configuration . new_header if header is None : header = [ get_column_letter ( col + 1 ) for col in range ( len ( data ))] transposed = [ list ( datum ) for datum in zip ( * data )] return SessionUpdateXLSXParse ( data = { key : value for key , value in zip ( header , transposed )} ) get ( session = None ) \u00b6 Parses selected region of an excel file. Returns: Type Description SessionUpdateXLSXParse A dict with column-name/column-value pairs. The values are lists. Source code in oteapi/strategies/parse/excel_xlsx.py 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdateXLSXParse : \"\"\"Parses selected region of an excel file. Returns: A dict with column-name/column-value pairs. The values are lists. \"\"\" cache = DataCache ( self . parse_config . configuration . datacache_config ) if session is None : raise ValueError ( \"Missing session\" ) with cache . getfile ( key = session [ \"key\" ], suffix = \".xlsx\" ) as filename : # Note that we have to set read_only=False to ensure that # load_workbook() properly closes the xlsx file after reading. # Otherwise Windows will fail when the temporary file is removed # when leaving the with statement. workbook = load_workbook ( filename = filename , read_only = False , data_only = True ) worksheet = workbook [ self . parse_config . configuration . worksheet ] set_model_defaults ( self . parse_config . configuration , worksheet ) columns = get_column_indices ( self . parse_config . configuration , worksheet ) data = [] for row in worksheet . iter_rows ( min_row = self . parse_config . configuration . row_from , max_row = self . parse_config . configuration . row_to , min_col = min ( columns ), max_col = max ( columns ), ): data . append ([ row [ c - 1 ] . value for c in columns ]) if self . parse_config . configuration . header_row : row = worksheet . iter_rows ( min_row = self . parse_config . configuration . header_row , max_row = self . parse_config . configuration . header_row , min_col = min ( columns ), max_col = max ( columns ), ) . __next__ () header = [ row [ c - 1 ] . value for c in columns ] else : header = None if self . parse_config . configuration . new_header : nhead = len ( header ) if header else len ( data [ 0 ]) if data else 0 if len ( self . parse_config . configuration . new_header ) != nhead : raise TypeError ( f \"length of `new_header` (= { len ( self . parse_config . configuration . new_header ) } ) \" f \"doesn't match number of columns (= { len ( header ) if header else 0 } )\" ) if header : for i , val in enumerate ( self . parse_config . configuration . new_header ): if val is not None : header [ i ] = val elif data : header = self . parse_config . configuration . new_header if header is None : header = [ get_column_letter ( col + 1 ) for col in range ( len ( data ))] transposed = [ list ( datum ) for datum in zip ( * data )] return SessionUpdateXLSXParse ( data = { key : value for key , value in zip ( header , transposed )} ) initialize ( session = None ) \u00b6 Initialize. Source code in oteapi/strategies/parse/excel_xlsx.py 165 166 167 def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdate : \"\"\"Initialize.\"\"\" return SessionUpdate () get_column_indices ( model , worksheet ) \u00b6 Helper function returning a list of column indices. Parameters: Name Type Description Default model XLSXParseConfig The parsed data model. required worksheet 'Worksheet' Excel worksheet, from which the header values will be retrieved. required Returns: Type Description 'Iterable[int]' A list of column indices. Source code in oteapi/strategies/parse/excel_xlsx.py 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 def get_column_indices ( model : XLSXParseConfig , worksheet : \"Worksheet\" ) -> \"Iterable[int]\" : \"\"\"Helper function returning a list of column indices. Parameters: model: The parsed data model. worksheet: Excel worksheet, from which the header values will be retrieved. Returns: A list of column indices. \"\"\" if not isinstance ( model . col_from , int ) or not isinstance ( model . col_to , int ): raise TypeError ( \"Expected `model.col_from` and `model.col_to` to be integers.\" ) if model . header : header_dict = { worksheet . cell ( model . header_row , col ) . value : col for col in range ( model . col_from , model . col_to + 1 ) } return [ header_dict [ h ] for h in model . header ] return range ( model . col_from , model . col_to + 1 ) set_model_defaults ( model , worksheet ) \u00b6 Update data model model with default values obtained from worksheet . Parameters: Name Type Description Default model XLSXParseConfig The parsed data model. required worksheet 'Worksheet' Excel worksheet, from which the default values will be obtained. required Source code in oteapi/strategies/parse/excel_xlsx.py 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 def set_model_defaults ( model : XLSXParseConfig , worksheet : \"Worksheet\" ) -> None : \"\"\"Update data model `model` with default values obtained from `worksheet`. Parameters: model: The parsed data model. worksheet: Excel worksheet, from which the default values will be obtained. \"\"\" if model . row_from is None : if model . header : # assume that data starts on the first row after the header model . row_from = model . header_row + 1 if model . header_row else 1 else : model . row_from = worksheet . min_row if model . row_to is None : model . row_to = worksheet . max_row if model . col_from is None : model . col_from = worksheet . min_column elif isinstance ( model . col_from , str ): model . col_from = column_index_from_string ( model . col_from ) if model . col_to is None : model . col_to = worksheet . max_column elif isinstance ( model . col_to , str ): model . col_to = column_index_from_string ( model . col_to ) if model . header and not model . header_row : model . header_row = 1","title":"excel_xlsx"},{"location":"api_reference/strategies/parse/excel_xlsx/#excel_xlsx","text":"Strategy class for workbook/xlsx.","title":"excel_xlsx"},{"location":"api_reference/strategies/parse/excel_xlsx/#oteapi.strategies.parse.excel_xlsx.SessionUpdateXLSXParse","text":"Bases: SessionUpdate Class for returning values from XLSXParse. Source code in oteapi/strategies/parse/excel_xlsx.py 19 20 21 22 23 24 25 class SessionUpdateXLSXParse ( SessionUpdate ): \"\"\"Class for returning values from XLSXParse.\"\"\" data : Dict [ str , list ] = Field ( ... , description = \"A dict with column-name/column-value pairs. The values are lists.\" , )","title":"SessionUpdateXLSXParse"},{"location":"api_reference/strategies/parse/excel_xlsx/#oteapi.strategies.parse.excel_xlsx.XLSXParseConfig","text":"Bases: AttrDict Data model for retrieving a rectangular section of an Excel sheet. Source code in oteapi/strategies/parse/excel_xlsx.py 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 class XLSXParseConfig ( AttrDict ): \"\"\"Data model for retrieving a rectangular section of an Excel sheet.\"\"\" worksheet : str = Field ( ... , description = \"Name of worksheet to load.\" ) row_from : Optional [ int ] = Field ( None , description = \"Excel row number of first row. Defaults to first assigned row.\" , ) col_from : Optional [ Union [ int , str ]] = Field ( None , description = ( \"Excel column number or label of first column. Defaults to first assigned \" \"column.\" ), ) row_to : Optional [ int ] = Field ( None , description = \"Excel row number of last row. Defaults to last assigned row.\" ) col_to : Optional [ Union [ int , str ]] = Field ( None , description = ( \"Excel column number or label of last column. Defaults to last assigned \" \"column.\" ), ) header_row : Optional [ int ] = Field ( None , description = ( \"Row number with the headers. Defaults to `1` if header is given, \" \"otherwise `None`.\" ), ) header : Optional [ List [ str ]] = Field ( None , description = ( \"Optional list of column names, specifying the columns to return. \" \"These names they should match cells in `header_row`.\" ), ) new_header : Optional [ List [ str ]] = Field ( None , description = ( \"Optional list of new column names replacing `header` in the output.\" ), ) download_config : AttrDict = Field ( AttrDict (), description = \"Configurations provided to a download strategy.\" , ) datacache_config : Optional [ DataCacheConfig ] = Field ( None , description = \"Configurations for the data cache for retrieving the downloaded content.\" , )","title":"XLSXParseConfig"},{"location":"api_reference/strategies/parse/excel_xlsx/#oteapi.strategies.parse.excel_xlsx.XLSXParseResourceConfig","text":"Bases: ResourceConfig XLSX parse strategy resource config. Source code in oteapi/strategies/parse/excel_xlsx.py 83 84 85 86 87 88 89 90 91 92 93 class XLSXParseResourceConfig ( ResourceConfig ): \"\"\"XLSX parse strategy resource config.\"\"\" mediaType : str = Field ( \"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\" , const = True , description = ResourceConfig . __fields__ [ \"mediaType\" ] . field_info . description , ) configuration : XLSXParseConfig = Field ( ... , description = \"SQLite parse strategy-specific configuration.\" )","title":"XLSXParseResourceConfig"},{"location":"api_reference/strategies/parse/excel_xlsx/#oteapi.strategies.parse.excel_xlsx.XLSXParseStrategy","text":"Parse strategy for Excel XLSX files. Registers strategies : (\"mediaType\", \"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\") Source code in oteapi/strategies/parse/excel_xlsx.py 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 @dataclass class XLSXParseStrategy : \"\"\"Parse strategy for Excel XLSX files. **Registers strategies**: - `(\"mediaType\", \"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\")` \"\"\" parse_config : XLSXParseResourceConfig def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdate : \"\"\"Initialize.\"\"\" return SessionUpdate () def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdateXLSXParse : \"\"\"Parses selected region of an excel file. Returns: A dict with column-name/column-value pairs. The values are lists. \"\"\" cache = DataCache ( self . parse_config . configuration . datacache_config ) if session is None : raise ValueError ( \"Missing session\" ) with cache . getfile ( key = session [ \"key\" ], suffix = \".xlsx\" ) as filename : # Note that we have to set read_only=False to ensure that # load_workbook() properly closes the xlsx file after reading. # Otherwise Windows will fail when the temporary file is removed # when leaving the with statement. workbook = load_workbook ( filename = filename , read_only = False , data_only = True ) worksheet = workbook [ self . parse_config . configuration . worksheet ] set_model_defaults ( self . parse_config . configuration , worksheet ) columns = get_column_indices ( self . parse_config . configuration , worksheet ) data = [] for row in worksheet . iter_rows ( min_row = self . parse_config . configuration . row_from , max_row = self . parse_config . configuration . row_to , min_col = min ( columns ), max_col = max ( columns ), ): data . append ([ row [ c - 1 ] . value for c in columns ]) if self . parse_config . configuration . header_row : row = worksheet . iter_rows ( min_row = self . parse_config . configuration . header_row , max_row = self . parse_config . configuration . header_row , min_col = min ( columns ), max_col = max ( columns ), ) . __next__ () header = [ row [ c - 1 ] . value for c in columns ] else : header = None if self . parse_config . configuration . new_header : nhead = len ( header ) if header else len ( data [ 0 ]) if data else 0 if len ( self . parse_config . configuration . new_header ) != nhead : raise TypeError ( f \"length of `new_header` (= { len ( self . parse_config . configuration . new_header ) } ) \" f \"doesn't match number of columns (= { len ( header ) if header else 0 } )\" ) if header : for i , val in enumerate ( self . parse_config . configuration . new_header ): if val is not None : header [ i ] = val elif data : header = self . parse_config . configuration . new_header if header is None : header = [ get_column_letter ( col + 1 ) for col in range ( len ( data ))] transposed = [ list ( datum ) for datum in zip ( * data )] return SessionUpdateXLSXParse ( data = { key : value for key , value in zip ( header , transposed )} )","title":"XLSXParseStrategy"},{"location":"api_reference/strategies/parse/excel_xlsx/#oteapi.strategies.parse.excel_xlsx.XLSXParseStrategy.get","text":"Parses selected region of an excel file. Returns: Type Description SessionUpdateXLSXParse A dict with column-name/column-value pairs. The values are lists. Source code in oteapi/strategies/parse/excel_xlsx.py 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdateXLSXParse : \"\"\"Parses selected region of an excel file. Returns: A dict with column-name/column-value pairs. The values are lists. \"\"\" cache = DataCache ( self . parse_config . configuration . datacache_config ) if session is None : raise ValueError ( \"Missing session\" ) with cache . getfile ( key = session [ \"key\" ], suffix = \".xlsx\" ) as filename : # Note that we have to set read_only=False to ensure that # load_workbook() properly closes the xlsx file after reading. # Otherwise Windows will fail when the temporary file is removed # when leaving the with statement. workbook = load_workbook ( filename = filename , read_only = False , data_only = True ) worksheet = workbook [ self . parse_config . configuration . worksheet ] set_model_defaults ( self . parse_config . configuration , worksheet ) columns = get_column_indices ( self . parse_config . configuration , worksheet ) data = [] for row in worksheet . iter_rows ( min_row = self . parse_config . configuration . row_from , max_row = self . parse_config . configuration . row_to , min_col = min ( columns ), max_col = max ( columns ), ): data . append ([ row [ c - 1 ] . value for c in columns ]) if self . parse_config . configuration . header_row : row = worksheet . iter_rows ( min_row = self . parse_config . configuration . header_row , max_row = self . parse_config . configuration . header_row , min_col = min ( columns ), max_col = max ( columns ), ) . __next__ () header = [ row [ c - 1 ] . value for c in columns ] else : header = None if self . parse_config . configuration . new_header : nhead = len ( header ) if header else len ( data [ 0 ]) if data else 0 if len ( self . parse_config . configuration . new_header ) != nhead : raise TypeError ( f \"length of `new_header` (= { len ( self . parse_config . configuration . new_header ) } ) \" f \"doesn't match number of columns (= { len ( header ) if header else 0 } )\" ) if header : for i , val in enumerate ( self . parse_config . configuration . new_header ): if val is not None : header [ i ] = val elif data : header = self . parse_config . configuration . new_header if header is None : header = [ get_column_letter ( col + 1 ) for col in range ( len ( data ))] transposed = [ list ( datum ) for datum in zip ( * data )] return SessionUpdateXLSXParse ( data = { key : value for key , value in zip ( header , transposed )} )","title":"get()"},{"location":"api_reference/strategies/parse/excel_xlsx/#oteapi.strategies.parse.excel_xlsx.XLSXParseStrategy.initialize","text":"Initialize. Source code in oteapi/strategies/parse/excel_xlsx.py 165 166 167 def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdate : \"\"\"Initialize.\"\"\" return SessionUpdate ()","title":"initialize()"},{"location":"api_reference/strategies/parse/excel_xlsx/#oteapi.strategies.parse.excel_xlsx.get_column_indices","text":"Helper function returning a list of column indices. Parameters: Name Type Description Default model XLSXParseConfig The parsed data model. required worksheet 'Worksheet' Excel worksheet, from which the header values will be retrieved. required Returns: Type Description 'Iterable[int]' A list of column indices. Source code in oteapi/strategies/parse/excel_xlsx.py 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 def get_column_indices ( model : XLSXParseConfig , worksheet : \"Worksheet\" ) -> \"Iterable[int]\" : \"\"\"Helper function returning a list of column indices. Parameters: model: The parsed data model. worksheet: Excel worksheet, from which the header values will be retrieved. Returns: A list of column indices. \"\"\" if not isinstance ( model . col_from , int ) or not isinstance ( model . col_to , int ): raise TypeError ( \"Expected `model.col_from` and `model.col_to` to be integers.\" ) if model . header : header_dict = { worksheet . cell ( model . header_row , col ) . value : col for col in range ( model . col_from , model . col_to + 1 ) } return [ header_dict [ h ] for h in model . header ] return range ( model . col_from , model . col_to + 1 )","title":"get_column_indices()"},{"location":"api_reference/strategies/parse/excel_xlsx/#oteapi.strategies.parse.excel_xlsx.set_model_defaults","text":"Update data model model with default values obtained from worksheet . Parameters: Name Type Description Default model XLSXParseConfig The parsed data model. required worksheet 'Worksheet' Excel worksheet, from which the default values will be obtained. required Source code in oteapi/strategies/parse/excel_xlsx.py 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 def set_model_defaults ( model : XLSXParseConfig , worksheet : \"Worksheet\" ) -> None : \"\"\"Update data model `model` with default values obtained from `worksheet`. Parameters: model: The parsed data model. worksheet: Excel worksheet, from which the default values will be obtained. \"\"\" if model . row_from is None : if model . header : # assume that data starts on the first row after the header model . row_from = model . header_row + 1 if model . header_row else 1 else : model . row_from = worksheet . min_row if model . row_to is None : model . row_to = worksheet . max_row if model . col_from is None : model . col_from = worksheet . min_column elif isinstance ( model . col_from , str ): model . col_from = column_index_from_string ( model . col_from ) if model . col_to is None : model . col_to = worksheet . max_column elif isinstance ( model . col_to , str ): model . col_to = column_index_from_string ( model . col_to ) if model . header and not model . header_row : model . header_row = 1","title":"set_model_defaults()"},{"location":"api_reference/strategies/parse/image/","text":"image \u00b6 Strategy class for image/jpg. ImageDataParseStrategy \u00b6 Parse strategy for images. This strategy uses Pillow to read a raw image from the data cache, converts it into a NumPy array and stores the new array in the data cache. It also supports simple cropping and image conversions. The key to the new array and other metadata is stored in the session. See SessionUpdateImageParse for more info. Registers strategies : (\"mediaType\", \"image/jpg\") (\"mediaType\", \"image/jpeg\") (\"mediaType\", \"image/jp2\") (\"mediaType\", \"image/png\") (\"mediaType\", \"image/gif\") (\"mediaType\", \"image/tiff\") (\"mediaType\", \"image/eps\") Source code in oteapi/strategies/parse/image.py 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 @dataclass class ImageDataParseStrategy : \"\"\"Parse strategy for images. This strategy uses Pillow to read a raw image from the data cache, converts it into a NumPy array and stores the new array in the data cache. It also supports simple cropping and image conversions. The key to the new array and other metadata is stored in the session. See [`SessionUpdateImageParse`][oteapi.strategies.parse.image.SessionUpdateImageParse] for more info. **Registers strategies**: - `(\"mediaType\", \"image/jpg\")` - `(\"mediaType\", \"image/jpeg\")` - `(\"mediaType\", \"image/jp2\")` - `(\"mediaType\", \"image/png\")` - `(\"mediaType\", \"image/gif\")` - `(\"mediaType\", \"image/tiff\")` - `(\"mediaType\", \"image/eps\")` \"\"\" parse_config : ImageParserResourceConfig def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdate : \"\"\"Initialize strategy.\"\"\" return SessionUpdate () def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdateImageParse : \"\"\"Execute the strategy.\"\"\" if not session : session = {} config = self . parse_config . configuration crop = config . crop if config . crop else session . get ( \"imagecrop\" ) mime_format = self . parse_config . mediaType . split ( \"/\" )[ 1 ] image_format = SupportedFormat [ mime_format ] . value # Proper download configurations conf = self . parse_config . dict () conf [ \"configuration\" ] = config . download_config or {} download_config = ResourceConfig ( ** conf ) downloader = create_strategy ( \"download\" , download_config ) session . update ( downloader . initialize ( session )) downloader = create_strategy ( \"download\" , download_config ) output = downloader . get ( session ) session . update ( output ) if config . datacache_config and config . datacache_config . accessKey : cache_key = config . datacache_config . accessKey elif \"key\" in output : cache_key = output [ \"key\" ] else : RuntimeError ( \"No data cache key provided to the downloaded content\" ) cache = DataCache ( config . datacache_config ) # Treat image according to filter values with cache . getfile ( cache_key , suffix = mime_format ) as filename : image = Image . open ( filename , formats = [ image_format ]) if crop : image = image . crop ( crop ) if config . image_mode : image = image . convert ( mode = config . image_mode ) if image_format == \"GIF\" : if image . info . get ( \"version\" , b \"\" ) . startswith ( b \"GIF\" ): image . info . update ( { \"version\" : image . info . get ( \"version\" , b \"\" )[ len ( b \"GIF\" ) :]} ) # Use the buffer protocol to store the image in the datacache data = np . asarray ( image ) image_key = cache . add ( data , key = config . image_key , tag = str ( id ( session )), ) if image . mode == \"P\" : image_palette_key = cache . add ( np . asarray ( image . getpalette ()), tag = str ( id ( session )) ) else : image_palette_key = None # The session must be json serialisable - filter out all # non-json serialisable fields in image.info if image . info : image_info = { key : val for key , val in image . info . items () if isinstance ( val , ( str , int , float , type ( None ), bool , tuple , list )) } else : image_info = {} session_update = SessionUpdateImageParse ( image_key = image_key , image_size = image . size , image_mode = image . mode , image_palette_key = image_palette_key , image_info = image_info , ) # Explicitly close the image to avoid crashes on Windows image . close () return session_update get ( session = None ) \u00b6 Execute the strategy. Source code in oteapi/strategies/parse/image.py 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdateImageParse : \"\"\"Execute the strategy.\"\"\" if not session : session = {} config = self . parse_config . configuration crop = config . crop if config . crop else session . get ( \"imagecrop\" ) mime_format = self . parse_config . mediaType . split ( \"/\" )[ 1 ] image_format = SupportedFormat [ mime_format ] . value # Proper download configurations conf = self . parse_config . dict () conf [ \"configuration\" ] = config . download_config or {} download_config = ResourceConfig ( ** conf ) downloader = create_strategy ( \"download\" , download_config ) session . update ( downloader . initialize ( session )) downloader = create_strategy ( \"download\" , download_config ) output = downloader . get ( session ) session . update ( output ) if config . datacache_config and config . datacache_config . accessKey : cache_key = config . datacache_config . accessKey elif \"key\" in output : cache_key = output [ \"key\" ] else : RuntimeError ( \"No data cache key provided to the downloaded content\" ) cache = DataCache ( config . datacache_config ) # Treat image according to filter values with cache . getfile ( cache_key , suffix = mime_format ) as filename : image = Image . open ( filename , formats = [ image_format ]) if crop : image = image . crop ( crop ) if config . image_mode : image = image . convert ( mode = config . image_mode ) if image_format == \"GIF\" : if image . info . get ( \"version\" , b \"\" ) . startswith ( b \"GIF\" ): image . info . update ( { \"version\" : image . info . get ( \"version\" , b \"\" )[ len ( b \"GIF\" ) :]} ) # Use the buffer protocol to store the image in the datacache data = np . asarray ( image ) image_key = cache . add ( data , key = config . image_key , tag = str ( id ( session )), ) if image . mode == \"P\" : image_palette_key = cache . add ( np . asarray ( image . getpalette ()), tag = str ( id ( session )) ) else : image_palette_key = None # The session must be json serialisable - filter out all # non-json serialisable fields in image.info if image . info : image_info = { key : val for key , val in image . info . items () if isinstance ( val , ( str , int , float , type ( None ), bool , tuple , list )) } else : image_info = {} session_update = SessionUpdateImageParse ( image_key = image_key , image_size = image . size , image_mode = image . mode , image_palette_key = image_palette_key , image_info = image_info , ) # Explicitly close the image to avoid crashes on Windows image . close () return session_update initialize ( session = None ) \u00b6 Initialize strategy. Source code in oteapi/strategies/parse/image.py 139 140 141 def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdate : \"\"\"Initialize strategy.\"\"\" return SessionUpdate () ImageParserConfig \u00b6 Bases: AttrDict Configuration data model for ImageDataParseStrategy . Source code in oteapi/strategies/parse/image.py 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 class ImageParserConfig ( AttrDict ): \"\"\"Configuration data model for [`ImageDataParseStrategy`][oteapi.strategies.parse.image.ImageDataParseStrategy].\"\"\" crop : Optional [ Tuple [ int , int , int , int ]] = Field ( None , description = \"Box cropping parameters (left, top, right, bottom).\" , ) datacache_config : Optional [ DataCacheConfig ] = Field ( None , description = \"Configuration options for the local data cache.\" , ) download_config : AttrDict = Field ( AttrDict (), description = \"Configurations passed to the downloader.\" , ) image_key : Optional [ str ] = Field ( None , description = \"Key to use when storing the image data in datacache.\" , ) image_mode : Optional [ str ] = Field ( None , description = ( \"Pillow mode to convert image into. See \" \"https://pillow.readthedocs.io/en/stable/handbook/concepts.html \" \"for details.\" ), ) ImageParserResourceConfig \u00b6 Bases: ResourceConfig Image parse strategy resource config. Source code in oteapi/strategies/parse/image.py 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 class ImageParserResourceConfig ( ResourceConfig ): \"\"\"Image parse strategy resource config.\"\"\" mediaType : Union [ Literal [ \"image/jpg\" ], Literal [ \"image/jpeg\" ], Literal [ \"image/jp2\" ], Literal [ \"image/png\" ], Literal [ \"image/gif\" ], Literal [ \"image/tiff\" ], Literal [ \"image/eps\" ], ] = Field ( ... , description = ResourceConfig . __fields__ [ \"mediaType\" ] . field_info . description , ) configuration : ImageParserConfig = Field ( ImageParserConfig (), description = \"Image parse strategy-specific configuration.\" , ) SessionUpdateImageParse \u00b6 Bases: SessionUpdate Configuration model for ImageParse. See Pillow handbook for more details on image_mode , image_palette , and image_info . Source code in oteapi/strategies/parse/image.py 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 class SessionUpdateImageParse ( SessionUpdate ): \"\"\"Configuration model for ImageParse. See [Pillow handbook](https://pillow.readthedocs.io/en/stable/handbook/concepts.html) for more details on `image_mode`, `image_palette`, and `image_info`. \"\"\" image_key : str = Field ( ... , description = \"Key with which the image content is stored in the data cache.\" , ) image_size : Tuple [ int , int ] = Field ( ... , description = \"Image size (width, height).\" , ) image_mode : str = Field ( ... , description = \"Image mode. Examples: 'L', 'P', 'RGB', 'RGBA'...\" , ) image_palette_key : Optional [ str ] = Field ( None , description = \"Datacache key for colour palette if mode is 'P'.\" , ) image_info : dict = Field ( {}, description = \"Additional information about the image.\" , ) SupportedFormat \u00b6 Bases: Enum Supported formats for ImageDataParseStrategy . Source code in oteapi/strategies/parse/image.py 70 71 72 73 74 75 76 77 78 79 class SupportedFormat ( Enum ): \"\"\"Supported formats for `ImageDataParseStrategy`.\"\"\" jpeg = \"JPEG\" jpg = \"JPEG\" jp2 = \"JPEG2000\" png = \"PNG\" gif = \"GIF\" tiff = \"TIFF\" eps = \"EPS\"","title":"image"},{"location":"api_reference/strategies/parse/image/#image","text":"Strategy class for image/jpg.","title":"image"},{"location":"api_reference/strategies/parse/image/#oteapi.strategies.parse.image.ImageDataParseStrategy","text":"Parse strategy for images. This strategy uses Pillow to read a raw image from the data cache, converts it into a NumPy array and stores the new array in the data cache. It also supports simple cropping and image conversions. The key to the new array and other metadata is stored in the session. See SessionUpdateImageParse for more info. Registers strategies : (\"mediaType\", \"image/jpg\") (\"mediaType\", \"image/jpeg\") (\"mediaType\", \"image/jp2\") (\"mediaType\", \"image/png\") (\"mediaType\", \"image/gif\") (\"mediaType\", \"image/tiff\") (\"mediaType\", \"image/eps\") Source code in oteapi/strategies/parse/image.py 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 @dataclass class ImageDataParseStrategy : \"\"\"Parse strategy for images. This strategy uses Pillow to read a raw image from the data cache, converts it into a NumPy array and stores the new array in the data cache. It also supports simple cropping and image conversions. The key to the new array and other metadata is stored in the session. See [`SessionUpdateImageParse`][oteapi.strategies.parse.image.SessionUpdateImageParse] for more info. **Registers strategies**: - `(\"mediaType\", \"image/jpg\")` - `(\"mediaType\", \"image/jpeg\")` - `(\"mediaType\", \"image/jp2\")` - `(\"mediaType\", \"image/png\")` - `(\"mediaType\", \"image/gif\")` - `(\"mediaType\", \"image/tiff\")` - `(\"mediaType\", \"image/eps\")` \"\"\" parse_config : ImageParserResourceConfig def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdate : \"\"\"Initialize strategy.\"\"\" return SessionUpdate () def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdateImageParse : \"\"\"Execute the strategy.\"\"\" if not session : session = {} config = self . parse_config . configuration crop = config . crop if config . crop else session . get ( \"imagecrop\" ) mime_format = self . parse_config . mediaType . split ( \"/\" )[ 1 ] image_format = SupportedFormat [ mime_format ] . value # Proper download configurations conf = self . parse_config . dict () conf [ \"configuration\" ] = config . download_config or {} download_config = ResourceConfig ( ** conf ) downloader = create_strategy ( \"download\" , download_config ) session . update ( downloader . initialize ( session )) downloader = create_strategy ( \"download\" , download_config ) output = downloader . get ( session ) session . update ( output ) if config . datacache_config and config . datacache_config . accessKey : cache_key = config . datacache_config . accessKey elif \"key\" in output : cache_key = output [ \"key\" ] else : RuntimeError ( \"No data cache key provided to the downloaded content\" ) cache = DataCache ( config . datacache_config ) # Treat image according to filter values with cache . getfile ( cache_key , suffix = mime_format ) as filename : image = Image . open ( filename , formats = [ image_format ]) if crop : image = image . crop ( crop ) if config . image_mode : image = image . convert ( mode = config . image_mode ) if image_format == \"GIF\" : if image . info . get ( \"version\" , b \"\" ) . startswith ( b \"GIF\" ): image . info . update ( { \"version\" : image . info . get ( \"version\" , b \"\" )[ len ( b \"GIF\" ) :]} ) # Use the buffer protocol to store the image in the datacache data = np . asarray ( image ) image_key = cache . add ( data , key = config . image_key , tag = str ( id ( session )), ) if image . mode == \"P\" : image_palette_key = cache . add ( np . asarray ( image . getpalette ()), tag = str ( id ( session )) ) else : image_palette_key = None # The session must be json serialisable - filter out all # non-json serialisable fields in image.info if image . info : image_info = { key : val for key , val in image . info . items () if isinstance ( val , ( str , int , float , type ( None ), bool , tuple , list )) } else : image_info = {} session_update = SessionUpdateImageParse ( image_key = image_key , image_size = image . size , image_mode = image . mode , image_palette_key = image_palette_key , image_info = image_info , ) # Explicitly close the image to avoid crashes on Windows image . close () return session_update","title":"ImageDataParseStrategy"},{"location":"api_reference/strategies/parse/image/#oteapi.strategies.parse.image.ImageDataParseStrategy.get","text":"Execute the strategy. Source code in oteapi/strategies/parse/image.py 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdateImageParse : \"\"\"Execute the strategy.\"\"\" if not session : session = {} config = self . parse_config . configuration crop = config . crop if config . crop else session . get ( \"imagecrop\" ) mime_format = self . parse_config . mediaType . split ( \"/\" )[ 1 ] image_format = SupportedFormat [ mime_format ] . value # Proper download configurations conf = self . parse_config . dict () conf [ \"configuration\" ] = config . download_config or {} download_config = ResourceConfig ( ** conf ) downloader = create_strategy ( \"download\" , download_config ) session . update ( downloader . initialize ( session )) downloader = create_strategy ( \"download\" , download_config ) output = downloader . get ( session ) session . update ( output ) if config . datacache_config and config . datacache_config . accessKey : cache_key = config . datacache_config . accessKey elif \"key\" in output : cache_key = output [ \"key\" ] else : RuntimeError ( \"No data cache key provided to the downloaded content\" ) cache = DataCache ( config . datacache_config ) # Treat image according to filter values with cache . getfile ( cache_key , suffix = mime_format ) as filename : image = Image . open ( filename , formats = [ image_format ]) if crop : image = image . crop ( crop ) if config . image_mode : image = image . convert ( mode = config . image_mode ) if image_format == \"GIF\" : if image . info . get ( \"version\" , b \"\" ) . startswith ( b \"GIF\" ): image . info . update ( { \"version\" : image . info . get ( \"version\" , b \"\" )[ len ( b \"GIF\" ) :]} ) # Use the buffer protocol to store the image in the datacache data = np . asarray ( image ) image_key = cache . add ( data , key = config . image_key , tag = str ( id ( session )), ) if image . mode == \"P\" : image_palette_key = cache . add ( np . asarray ( image . getpalette ()), tag = str ( id ( session )) ) else : image_palette_key = None # The session must be json serialisable - filter out all # non-json serialisable fields in image.info if image . info : image_info = { key : val for key , val in image . info . items () if isinstance ( val , ( str , int , float , type ( None ), bool , tuple , list )) } else : image_info = {} session_update = SessionUpdateImageParse ( image_key = image_key , image_size = image . size , image_mode = image . mode , image_palette_key = image_palette_key , image_info = image_info , ) # Explicitly close the image to avoid crashes on Windows image . close () return session_update","title":"get()"},{"location":"api_reference/strategies/parse/image/#oteapi.strategies.parse.image.ImageDataParseStrategy.initialize","text":"Initialize strategy. Source code in oteapi/strategies/parse/image.py 139 140 141 def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdate : \"\"\"Initialize strategy.\"\"\" return SessionUpdate ()","title":"initialize()"},{"location":"api_reference/strategies/parse/image/#oteapi.strategies.parse.image.ImageParserConfig","text":"Bases: AttrDict Configuration data model for ImageDataParseStrategy . Source code in oteapi/strategies/parse/image.py 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 class ImageParserConfig ( AttrDict ): \"\"\"Configuration data model for [`ImageDataParseStrategy`][oteapi.strategies.parse.image.ImageDataParseStrategy].\"\"\" crop : Optional [ Tuple [ int , int , int , int ]] = Field ( None , description = \"Box cropping parameters (left, top, right, bottom).\" , ) datacache_config : Optional [ DataCacheConfig ] = Field ( None , description = \"Configuration options for the local data cache.\" , ) download_config : AttrDict = Field ( AttrDict (), description = \"Configurations passed to the downloader.\" , ) image_key : Optional [ str ] = Field ( None , description = \"Key to use when storing the image data in datacache.\" , ) image_mode : Optional [ str ] = Field ( None , description = ( \"Pillow mode to convert image into. See \" \"https://pillow.readthedocs.io/en/stable/handbook/concepts.html \" \"for details.\" ), )","title":"ImageParserConfig"},{"location":"api_reference/strategies/parse/image/#oteapi.strategies.parse.image.ImageParserResourceConfig","text":"Bases: ResourceConfig Image parse strategy resource config. Source code in oteapi/strategies/parse/image.py 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 class ImageParserResourceConfig ( ResourceConfig ): \"\"\"Image parse strategy resource config.\"\"\" mediaType : Union [ Literal [ \"image/jpg\" ], Literal [ \"image/jpeg\" ], Literal [ \"image/jp2\" ], Literal [ \"image/png\" ], Literal [ \"image/gif\" ], Literal [ \"image/tiff\" ], Literal [ \"image/eps\" ], ] = Field ( ... , description = ResourceConfig . __fields__ [ \"mediaType\" ] . field_info . description , ) configuration : ImageParserConfig = Field ( ImageParserConfig (), description = \"Image parse strategy-specific configuration.\" , )","title":"ImageParserResourceConfig"},{"location":"api_reference/strategies/parse/image/#oteapi.strategies.parse.image.SessionUpdateImageParse","text":"Bases: SessionUpdate Configuration model for ImageParse. See Pillow handbook for more details on image_mode , image_palette , and image_info . Source code in oteapi/strategies/parse/image.py 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 class SessionUpdateImageParse ( SessionUpdate ): \"\"\"Configuration model for ImageParse. See [Pillow handbook](https://pillow.readthedocs.io/en/stable/handbook/concepts.html) for more details on `image_mode`, `image_palette`, and `image_info`. \"\"\" image_key : str = Field ( ... , description = \"Key with which the image content is stored in the data cache.\" , ) image_size : Tuple [ int , int ] = Field ( ... , description = \"Image size (width, height).\" , ) image_mode : str = Field ( ... , description = \"Image mode. Examples: 'L', 'P', 'RGB', 'RGBA'...\" , ) image_palette_key : Optional [ str ] = Field ( None , description = \"Datacache key for colour palette if mode is 'P'.\" , ) image_info : dict = Field ( {}, description = \"Additional information about the image.\" , )","title":"SessionUpdateImageParse"},{"location":"api_reference/strategies/parse/image/#oteapi.strategies.parse.image.SupportedFormat","text":"Bases: Enum Supported formats for ImageDataParseStrategy . Source code in oteapi/strategies/parse/image.py 70 71 72 73 74 75 76 77 78 79 class SupportedFormat ( Enum ): \"\"\"Supported formats for `ImageDataParseStrategy`.\"\"\" jpeg = \"JPEG\" jpg = \"JPEG\" jp2 = \"JPEG2000\" png = \"PNG\" gif = \"GIF\" tiff = \"TIFF\" eps = \"EPS\"","title":"SupportedFormat"},{"location":"api_reference/strategies/parse/text_csv/","text":"text_csv \u00b6 Strategy class for text/csv. CSVParseStrategy \u00b6 Parse strategy for CSV files. Registers strategies : (\"mediaType\", \"text/csv\") Note: This strategy is currently not finished, and is therefore not registered. Source code in oteapi/strategies/parse/text_csv.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 @dataclass class CSVParseStrategy : \"\"\"Parse strategy for CSV files. **Registers strategies**: - `(\"mediaType\", \"text/csv\")` Note: This strategy is currently not finished, and is therefore not registered. \"\"\" parse_config : ResourceConfig def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdate : \"\"\"Parse CSV.\"\"\" return SessionUpdate () def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdate : \"\"\"Initialize.\"\"\" return SessionUpdate () get ( session = None ) \u00b6 Parse CSV. Source code in oteapi/strategies/parse/text_csv.py 27 28 29 def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdate : \"\"\"Parse CSV.\"\"\" return SessionUpdate () initialize ( session = None ) \u00b6 Initialize. Source code in oteapi/strategies/parse/text_csv.py 31 32 33 def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdate : \"\"\"Initialize.\"\"\" return SessionUpdate ()","title":"text_csv"},{"location":"api_reference/strategies/parse/text_csv/#text_csv","text":"Strategy class for text/csv.","title":"text_csv"},{"location":"api_reference/strategies/parse/text_csv/#oteapi.strategies.parse.text_csv.CSVParseStrategy","text":"Parse strategy for CSV files. Registers strategies : (\"mediaType\", \"text/csv\") Note: This strategy is currently not finished, and is therefore not registered. Source code in oteapi/strategies/parse/text_csv.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 @dataclass class CSVParseStrategy : \"\"\"Parse strategy for CSV files. **Registers strategies**: - `(\"mediaType\", \"text/csv\")` Note: This strategy is currently not finished, and is therefore not registered. \"\"\" parse_config : ResourceConfig def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdate : \"\"\"Parse CSV.\"\"\" return SessionUpdate () def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdate : \"\"\"Initialize.\"\"\" return SessionUpdate ()","title":"CSVParseStrategy"},{"location":"api_reference/strategies/parse/text_csv/#oteapi.strategies.parse.text_csv.CSVParseStrategy.get","text":"Parse CSV. Source code in oteapi/strategies/parse/text_csv.py 27 28 29 def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdate : \"\"\"Parse CSV.\"\"\" return SessionUpdate ()","title":"get()"},{"location":"api_reference/strategies/parse/text_csv/#oteapi.strategies.parse.text_csv.CSVParseStrategy.initialize","text":"Initialize. Source code in oteapi/strategies/parse/text_csv.py 31 32 33 def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdate : \"\"\"Initialize.\"\"\" return SessionUpdate ()","title":"initialize()"},{"location":"api_reference/strategies/transformation/celery_remote/","text":"celery_remote \u00b6 Transformation Plugin that uses the Celery framework to call remote workers. CeleryConfig \u00b6 Bases: AttrDict Celery configuration. Source code in oteapi/strategies/transformation/celery_remote.py 25 26 27 28 29 class CeleryConfig ( AttrDict ): \"\"\"Celery configuration.\"\"\" task_name : str = Field ( ... , description = \"A task name.\" ) args : list = Field ( ... , description = \"List of arguments for the task.\" ) CeleryRemoteStrategy \u00b6 Submit job to remote Celery runner. Registers strategies : (\"transformationType\", \"celery/remote\") Source code in oteapi/strategies/transformation/celery_remote.py 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 @dataclass class CeleryRemoteStrategy : \"\"\"Submit job to remote Celery runner. **Registers strategies**: - `(\"transformationType\", \"celery/remote\")` \"\"\" transformation_config : CeleryStrategyConfig def run ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> TransformationStatus : \"\"\"Run a job, return a job ID.\"\"\" if session : self . _use_session ( session ) celery_kwargs = session . copy () for field in CeleryConfig . __fields__ : celery_kwargs . pop ( field , None ) result : \"Union[AsyncResult, Any]\" = CELERY . send_task ( name = self . transformation_config . configuration . task_name , args = self . transformation_config . configuration . args , kwargs = celery_kwargs , ) return self . status ( result . task_id ) def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdate : \"\"\"Initialize a job.\"\"\" return SessionUpdate () def status ( self , task_id : str ) -> TransformationStatus : \"\"\"Get job status.\"\"\" result = AsyncResult ( id = task_id , app = CELERY ) return TransformationStatus ( id = task_id , status = result . state ) def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdateCelery : \"\"\"Get transformation.\"\"\" # TODO: update and return global state # pylint: disable=fixme return SessionUpdateCelery ( data = {}) def _use_session ( self , session : \"Dict[str, Any]\" ) -> None : \"\"\"Update the configuration with values from the sesssion.\"\"\" for field in CeleryConfig . __fields__ : if field in session : setattr ( self . transformation_config . configuration , field , session [ field ], ) _use_session ( session ) \u00b6 Update the configuration with values from the sesssion. Source code in oteapi/strategies/transformation/celery_remote.py 97 98 99 100 101 102 103 104 105 def _use_session ( self , session : \"Dict[str, Any]\" ) -> None : \"\"\"Update the configuration with values from the sesssion.\"\"\" for field in CeleryConfig . __fields__ : if field in session : setattr ( self . transformation_config . configuration , field , session [ field ], ) get ( session = None ) \u00b6 Get transformation. Source code in oteapi/strategies/transformation/celery_remote.py 92 93 94 95 def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdateCelery : \"\"\"Get transformation.\"\"\" # TODO: update and return global state # pylint: disable=fixme return SessionUpdateCelery ( data = {}) initialize ( session = None ) \u00b6 Initialize a job. Source code in oteapi/strategies/transformation/celery_remote.py 83 84 85 def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdate : \"\"\"Initialize a job.\"\"\" return SessionUpdate () run ( session = None ) \u00b6 Run a job, return a job ID. Source code in oteapi/strategies/transformation/celery_remote.py 68 69 70 71 72 73 74 75 76 77 78 79 80 81 def run ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> TransformationStatus : \"\"\"Run a job, return a job ID.\"\"\" if session : self . _use_session ( session ) celery_kwargs = session . copy () for field in CeleryConfig . __fields__ : celery_kwargs . pop ( field , None ) result : \"Union[AsyncResult, Any]\" = CELERY . send_task ( name = self . transformation_config . configuration . task_name , args = self . transformation_config . configuration . args , kwargs = celery_kwargs , ) return self . status ( result . task_id ) status ( task_id ) \u00b6 Get job status. Source code in oteapi/strategies/transformation/celery_remote.py 87 88 89 90 def status ( self , task_id : str ) -> TransformationStatus : \"\"\"Get job status.\"\"\" result = AsyncResult ( id = task_id , app = CELERY ) return TransformationStatus ( id = task_id , status = result . state ) CeleryStrategyConfig \u00b6 Bases: TransformationConfig Celery strategy-specific configuration. Source code in oteapi/strategies/transformation/celery_remote.py 41 42 43 44 45 46 47 48 49 50 51 52 53 class CeleryStrategyConfig ( TransformationConfig ): \"\"\"Celery strategy-specific configuration.\"\"\" transformationType : str = Field ( \"celery/remote\" , const = True , description = TransformationConfig . __fields__ [ \"transformationType\" ] . field_info . description , ) configuration : CeleryConfig = Field ( ... , description = \"Celery transformation strategy-specific configuration.\" ) SessionUpdateCelery \u00b6 Bases: SessionUpdate Class for returning values from XLSXParse. Source code in oteapi/strategies/transformation/celery_remote.py 32 33 34 35 36 37 38 class SessionUpdateCelery ( SessionUpdate ): \"\"\"Class for returning values from XLSXParse.\"\"\" data : Dict [ str , list ] = Field ( ... , description = \"A dict with column-name/column-value pairs. The values are lists.\" , )","title":"celery_remote"},{"location":"api_reference/strategies/transformation/celery_remote/#celery_remote","text":"Transformation Plugin that uses the Celery framework to call remote workers.","title":"celery_remote"},{"location":"api_reference/strategies/transformation/celery_remote/#oteapi.strategies.transformation.celery_remote.CeleryConfig","text":"Bases: AttrDict Celery configuration. Source code in oteapi/strategies/transformation/celery_remote.py 25 26 27 28 29 class CeleryConfig ( AttrDict ): \"\"\"Celery configuration.\"\"\" task_name : str = Field ( ... , description = \"A task name.\" ) args : list = Field ( ... , description = \"List of arguments for the task.\" )","title":"CeleryConfig"},{"location":"api_reference/strategies/transformation/celery_remote/#oteapi.strategies.transformation.celery_remote.CeleryRemoteStrategy","text":"Submit job to remote Celery runner. Registers strategies : (\"transformationType\", \"celery/remote\") Source code in oteapi/strategies/transformation/celery_remote.py 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 @dataclass class CeleryRemoteStrategy : \"\"\"Submit job to remote Celery runner. **Registers strategies**: - `(\"transformationType\", \"celery/remote\")` \"\"\" transformation_config : CeleryStrategyConfig def run ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> TransformationStatus : \"\"\"Run a job, return a job ID.\"\"\" if session : self . _use_session ( session ) celery_kwargs = session . copy () for field in CeleryConfig . __fields__ : celery_kwargs . pop ( field , None ) result : \"Union[AsyncResult, Any]\" = CELERY . send_task ( name = self . transformation_config . configuration . task_name , args = self . transformation_config . configuration . args , kwargs = celery_kwargs , ) return self . status ( result . task_id ) def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdate : \"\"\"Initialize a job.\"\"\" return SessionUpdate () def status ( self , task_id : str ) -> TransformationStatus : \"\"\"Get job status.\"\"\" result = AsyncResult ( id = task_id , app = CELERY ) return TransformationStatus ( id = task_id , status = result . state ) def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdateCelery : \"\"\"Get transformation.\"\"\" # TODO: update and return global state # pylint: disable=fixme return SessionUpdateCelery ( data = {}) def _use_session ( self , session : \"Dict[str, Any]\" ) -> None : \"\"\"Update the configuration with values from the sesssion.\"\"\" for field in CeleryConfig . __fields__ : if field in session : setattr ( self . transformation_config . configuration , field , session [ field ], )","title":"CeleryRemoteStrategy"},{"location":"api_reference/strategies/transformation/celery_remote/#oteapi.strategies.transformation.celery_remote.CeleryRemoteStrategy._use_session","text":"Update the configuration with values from the sesssion. Source code in oteapi/strategies/transformation/celery_remote.py 97 98 99 100 101 102 103 104 105 def _use_session ( self , session : \"Dict[str, Any]\" ) -> None : \"\"\"Update the configuration with values from the sesssion.\"\"\" for field in CeleryConfig . __fields__ : if field in session : setattr ( self . transformation_config . configuration , field , session [ field ], )","title":"_use_session()"},{"location":"api_reference/strategies/transformation/celery_remote/#oteapi.strategies.transformation.celery_remote.CeleryRemoteStrategy.get","text":"Get transformation. Source code in oteapi/strategies/transformation/celery_remote.py 92 93 94 95 def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdateCelery : \"\"\"Get transformation.\"\"\" # TODO: update and return global state # pylint: disable=fixme return SessionUpdateCelery ( data = {})","title":"get()"},{"location":"api_reference/strategies/transformation/celery_remote/#oteapi.strategies.transformation.celery_remote.CeleryRemoteStrategy.initialize","text":"Initialize a job. Source code in oteapi/strategies/transformation/celery_remote.py 83 84 85 def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdate : \"\"\"Initialize a job.\"\"\" return SessionUpdate ()","title":"initialize()"},{"location":"api_reference/strategies/transformation/celery_remote/#oteapi.strategies.transformation.celery_remote.CeleryRemoteStrategy.run","text":"Run a job, return a job ID. Source code in oteapi/strategies/transformation/celery_remote.py 68 69 70 71 72 73 74 75 76 77 78 79 80 81 def run ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> TransformationStatus : \"\"\"Run a job, return a job ID.\"\"\" if session : self . _use_session ( session ) celery_kwargs = session . copy () for field in CeleryConfig . __fields__ : celery_kwargs . pop ( field , None ) result : \"Union[AsyncResult, Any]\" = CELERY . send_task ( name = self . transformation_config . configuration . task_name , args = self . transformation_config . configuration . args , kwargs = celery_kwargs , ) return self . status ( result . task_id )","title":"run()"},{"location":"api_reference/strategies/transformation/celery_remote/#oteapi.strategies.transformation.celery_remote.CeleryRemoteStrategy.status","text":"Get job status. Source code in oteapi/strategies/transformation/celery_remote.py 87 88 89 90 def status ( self , task_id : str ) -> TransformationStatus : \"\"\"Get job status.\"\"\" result = AsyncResult ( id = task_id , app = CELERY ) return TransformationStatus ( id = task_id , status = result . state )","title":"status()"},{"location":"api_reference/strategies/transformation/celery_remote/#oteapi.strategies.transformation.celery_remote.CeleryStrategyConfig","text":"Bases: TransformationConfig Celery strategy-specific configuration. Source code in oteapi/strategies/transformation/celery_remote.py 41 42 43 44 45 46 47 48 49 50 51 52 53 class CeleryStrategyConfig ( TransformationConfig ): \"\"\"Celery strategy-specific configuration.\"\"\" transformationType : str = Field ( \"celery/remote\" , const = True , description = TransformationConfig . __fields__ [ \"transformationType\" ] . field_info . description , ) configuration : CeleryConfig = Field ( ... , description = \"Celery transformation strategy-specific configuration.\" )","title":"CeleryStrategyConfig"},{"location":"api_reference/strategies/transformation/celery_remote/#oteapi.strategies.transformation.celery_remote.SessionUpdateCelery","text":"Bases: SessionUpdate Class for returning values from XLSXParse. Source code in oteapi/strategies/transformation/celery_remote.py 32 33 34 35 36 37 38 class SessionUpdateCelery ( SessionUpdate ): \"\"\"Class for returning values from XLSXParse.\"\"\" data : Dict [ str , list ] = Field ( ... , description = \"A dict with column-name/column-value pairs. The values are lists.\" , )","title":"SessionUpdateCelery"},{"location":"api_reference/triplestore/triplestore/","text":"triplestore \u00b6 An RDF triplestore using Allegrograph https://franz.com/agraph/support/documentation/current/python/api.html https://franz.com/agraph/support/documentation/current/agraph-introduction.html Features: Store mapping data (triple format) AllegroGraph has a well documented python API package TripleStore \u00b6 This class is available to import from oteapi.triplestore , e.g.: from oteapi.triplestore import TripleStore Init must initialize the triple store connection Parameters: Name Type Description Default config Union [ TripleStoreConfig , Dict [ str , Any ]] RDF triple-store configuration. required Attributes: Name Type Description config TripleStoreConfig The RDF triple-store configuration. Source code in oteapi/triplestore/triplestore.py 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 class TripleStore : \"\"\" This class is available to import from `oteapi.triplestore`, e.g.: ```python from oteapi.triplestore import TripleStore ``` Init must initialize the triple store connection Args: config (Union[TripleStoreConfig, Dict[str, Any]]): RDF triple-store configuration. Attributes: config (TripleStoreConfig): The RDF triple-store configuration. \"\"\" def __init__ ( self , config : \"Union[TripleStoreConfig, Dict[str, Any]]\" , ) -> None : if isinstance ( config , ( dict , AttrDict )): self . config = TripleStoreConfig ( ** config ) elif isinstance ( config , TripleStoreConfig ): self . config = config else : raise TypeError ( \"config should be either a `TripleStoreConfig` data model or a \" \"dictionary.\" ) self . server = AllegroGraphServer ( self . config . agraphHost , self . config . agraphPort , self . config . agraphUser , self . config . agraphPassword . get_secret_value (), ) def add ( self , triples : RDFTriple ) -> None : \"\"\" Add triples to the triplestore. Args: triples: triples turtle format(<s> <o> <p>.). \"\"\" with ag_connect ( self . config . repositoryName , host = self . config . agraphHost , port = self . config . agraphPort , user = self . config . agraphUser , password = self . config . agraphPassword . get_secret_value (), ) as connection : connection . addData ( triples ) connection . close () def get ( self , sparql_query : str ) -> \"Any\" : \"\"\"Return the query result. Args: sparql_query: The SPARQL search query. Returns: The output of the search query in the form of a list of RDF triples. \"\"\" connection = self . server . openSession ( reason ( \"<\" + str ( self . config . repositoryName ) + \">\" ) ) try : tuple_query = connection . prepareTupleQuery ( query = sparql_query ) response = [] with tuple_query . evaluate ( output_format = TupleFormat . JSON ) as results : for result in results : triple = {} if \"'s': \" in str ( result ): triple [ \"s\" ] = str ( result . getValue ( \"s\" )) if \"'p': \" in str ( result ): triple [ \"p\" ] = str ( result . getValue ( \"p\" )) if \"'o': \" in str ( result ): triple [ \"o\" ] = str ( result . getValue ( \"o\" )) response . append ( triple ) connection . close () return response except RequestError as error : return { \"Error\" : error } def update_delete ( self , sparql_query : str ) -> None : \"\"\"Remove and update triples. Useful for modifying and cleaning up mappings. Args: sparql_query: The sparql update/delete query. Returns: True if update was successful. \"\"\" with ag_connect ( self . config . repositoryName , host = self . config . agraphHost , port = self . config . agraphPort , user = self . config . agraphUser , password = self . config . agraphPassword . get_secret_value (), ) as connection : update_query = connection . prepareUpdate ( query = sparql_query ) update_query . evaluate () connection . close () add ( triples ) \u00b6 Add triples to the triplestore. Parameters: Name Type Description Default triples RDFTriple triples turtle format( .). required Source code in oteapi/triplestore/triplestore.py 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 def add ( self , triples : RDFTriple ) -> None : \"\"\" Add triples to the triplestore. Args: triples: triples turtle format(<s> <o> <p>.). \"\"\" with ag_connect ( self . config . repositoryName , host = self . config . agraphHost , port = self . config . agraphPort , user = self . config . agraphUser , password = self . config . agraphPassword . get_secret_value (), ) as connection : connection . addData ( triples ) connection . close () get ( sparql_query ) \u00b6 Return the query result. Parameters: Name Type Description Default sparql_query str The SPARQL search query. required Returns: Type Description 'Any' The output of the search query in the form of a list of RDF triples. Source code in oteapi/triplestore/triplestore.py 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 def get ( self , sparql_query : str ) -> \"Any\" : \"\"\"Return the query result. Args: sparql_query: The SPARQL search query. Returns: The output of the search query in the form of a list of RDF triples. \"\"\" connection = self . server . openSession ( reason ( \"<\" + str ( self . config . repositoryName ) + \">\" ) ) try : tuple_query = connection . prepareTupleQuery ( query = sparql_query ) response = [] with tuple_query . evaluate ( output_format = TupleFormat . JSON ) as results : for result in results : triple = {} if \"'s': \" in str ( result ): triple [ \"s\" ] = str ( result . getValue ( \"s\" )) if \"'p': \" in str ( result ): triple [ \"p\" ] = str ( result . getValue ( \"p\" )) if \"'o': \" in str ( result ): triple [ \"o\" ] = str ( result . getValue ( \"o\" )) response . append ( triple ) connection . close () return response except RequestError as error : return { \"Error\" : error } update_delete ( sparql_query ) \u00b6 Remove and update triples. Useful for modifying and cleaning up mappings. Parameters: Name Type Description Default sparql_query str The sparql update/delete query. required Returns: Type Description None True if update was successful. Source code in oteapi/triplestore/triplestore.py 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 def update_delete ( self , sparql_query : str ) -> None : \"\"\"Remove and update triples. Useful for modifying and cleaning up mappings. Args: sparql_query: The sparql update/delete query. Returns: True if update was successful. \"\"\" with ag_connect ( self . config . repositoryName , host = self . config . agraphHost , port = self . config . agraphPort , user = self . config . agraphUser , password = self . config . agraphPassword . get_secret_value (), ) as connection : update_query = connection . prepareUpdate ( query = sparql_query ) update_query . evaluate () connection . close ()","title":"triplestore"},{"location":"api_reference/triplestore/triplestore/#triplestore","text":"An RDF triplestore using Allegrograph https://franz.com/agraph/support/documentation/current/python/api.html https://franz.com/agraph/support/documentation/current/agraph-introduction.html Features: Store mapping data (triple format) AllegroGraph has a well documented python API package","title":"triplestore"},{"location":"api_reference/triplestore/triplestore/#oteapi.triplestore.triplestore.TripleStore","text":"This class is available to import from oteapi.triplestore , e.g.: from oteapi.triplestore import TripleStore Init must initialize the triple store connection Parameters: Name Type Description Default config Union [ TripleStoreConfig , Dict [ str , Any ]] RDF triple-store configuration. required Attributes: Name Type Description config TripleStoreConfig The RDF triple-store configuration. Source code in oteapi/triplestore/triplestore.py 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 class TripleStore : \"\"\" This class is available to import from `oteapi.triplestore`, e.g.: ```python from oteapi.triplestore import TripleStore ``` Init must initialize the triple store connection Args: config (Union[TripleStoreConfig, Dict[str, Any]]): RDF triple-store configuration. Attributes: config (TripleStoreConfig): The RDF triple-store configuration. \"\"\" def __init__ ( self , config : \"Union[TripleStoreConfig, Dict[str, Any]]\" , ) -> None : if isinstance ( config , ( dict , AttrDict )): self . config = TripleStoreConfig ( ** config ) elif isinstance ( config , TripleStoreConfig ): self . config = config else : raise TypeError ( \"config should be either a `TripleStoreConfig` data model or a \" \"dictionary.\" ) self . server = AllegroGraphServer ( self . config . agraphHost , self . config . agraphPort , self . config . agraphUser , self . config . agraphPassword . get_secret_value (), ) def add ( self , triples : RDFTriple ) -> None : \"\"\" Add triples to the triplestore. Args: triples: triples turtle format(<s> <o> <p>.). \"\"\" with ag_connect ( self . config . repositoryName , host = self . config . agraphHost , port = self . config . agraphPort , user = self . config . agraphUser , password = self . config . agraphPassword . get_secret_value (), ) as connection : connection . addData ( triples ) connection . close () def get ( self , sparql_query : str ) -> \"Any\" : \"\"\"Return the query result. Args: sparql_query: The SPARQL search query. Returns: The output of the search query in the form of a list of RDF triples. \"\"\" connection = self . server . openSession ( reason ( \"<\" + str ( self . config . repositoryName ) + \">\" ) ) try : tuple_query = connection . prepareTupleQuery ( query = sparql_query ) response = [] with tuple_query . evaluate ( output_format = TupleFormat . JSON ) as results : for result in results : triple = {} if \"'s': \" in str ( result ): triple [ \"s\" ] = str ( result . getValue ( \"s\" )) if \"'p': \" in str ( result ): triple [ \"p\" ] = str ( result . getValue ( \"p\" )) if \"'o': \" in str ( result ): triple [ \"o\" ] = str ( result . getValue ( \"o\" )) response . append ( triple ) connection . close () return response except RequestError as error : return { \"Error\" : error } def update_delete ( self , sparql_query : str ) -> None : \"\"\"Remove and update triples. Useful for modifying and cleaning up mappings. Args: sparql_query: The sparql update/delete query. Returns: True if update was successful. \"\"\" with ag_connect ( self . config . repositoryName , host = self . config . agraphHost , port = self . config . agraphPort , user = self . config . agraphUser , password = self . config . agraphPassword . get_secret_value (), ) as connection : update_query = connection . prepareUpdate ( query = sparql_query ) update_query . evaluate () connection . close ()","title":"TripleStore"},{"location":"api_reference/triplestore/triplestore/#oteapi.triplestore.triplestore.TripleStore.add","text":"Add triples to the triplestore. Parameters: Name Type Description Default triples RDFTriple triples turtle format( .). required Source code in oteapi/triplestore/triplestore.py 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 def add ( self , triples : RDFTriple ) -> None : \"\"\" Add triples to the triplestore. Args: triples: triples turtle format(<s> <o> <p>.). \"\"\" with ag_connect ( self . config . repositoryName , host = self . config . agraphHost , port = self . config . agraphPort , user = self . config . agraphUser , password = self . config . agraphPassword . get_secret_value (), ) as connection : connection . addData ( triples ) connection . close ()","title":"add()"},{"location":"api_reference/triplestore/triplestore/#oteapi.triplestore.triplestore.TripleStore.get","text":"Return the query result. Parameters: Name Type Description Default sparql_query str The SPARQL search query. required Returns: Type Description 'Any' The output of the search query in the form of a list of RDF triples. Source code in oteapi/triplestore/triplestore.py 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 def get ( self , sparql_query : str ) -> \"Any\" : \"\"\"Return the query result. Args: sparql_query: The SPARQL search query. Returns: The output of the search query in the form of a list of RDF triples. \"\"\" connection = self . server . openSession ( reason ( \"<\" + str ( self . config . repositoryName ) + \">\" ) ) try : tuple_query = connection . prepareTupleQuery ( query = sparql_query ) response = [] with tuple_query . evaluate ( output_format = TupleFormat . JSON ) as results : for result in results : triple = {} if \"'s': \" in str ( result ): triple [ \"s\" ] = str ( result . getValue ( \"s\" )) if \"'p': \" in str ( result ): triple [ \"p\" ] = str ( result . getValue ( \"p\" )) if \"'o': \" in str ( result ): triple [ \"o\" ] = str ( result . getValue ( \"o\" )) response . append ( triple ) connection . close () return response except RequestError as error : return { \"Error\" : error }","title":"get()"},{"location":"api_reference/triplestore/triplestore/#oteapi.triplestore.triplestore.TripleStore.update_delete","text":"Remove and update triples. Useful for modifying and cleaning up mappings. Parameters: Name Type Description Default sparql_query str The sparql update/delete query. required Returns: Type Description None True if update was successful. Source code in oteapi/triplestore/triplestore.py 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 def update_delete ( self , sparql_query : str ) -> None : \"\"\"Remove and update triples. Useful for modifying and cleaning up mappings. Args: sparql_query: The sparql update/delete query. Returns: True if update was successful. \"\"\" with ag_connect ( self . config . repositoryName , host = self . config . agraphHost , port = self . config . agraphPort , user = self . config . agraphUser , password = self . config . agraphPassword . get_secret_value (), ) as connection : update_query = connection . prepareUpdate ( query = sparql_query ) update_query . evaluate () connection . close ()","title":"update_delete()"},{"location":"api_reference/utils/paths/","text":"paths \u00b6 Utility functions for handling paths. uri_to_path ( uri ) \u00b6 Convert URI to pathlib.Path. Support both Windows and Posix path types. Information urllib.parse.urlparse() leaves an initial slash in front of the drive letter when parsing a file URL for an absolute path on Windows. Example: urlparse(\"file:///C:/Windows\").path -> \"/C:/Windows\" To solve this, the initial forward slash is removed prior to casting to pathlib.Path . Parameters: Name Type Description Default uri 'Union[str, AnyUrl, ParseResult]' The URI/IRI/URL. Either as a string or a parsed URL. required Returns: Type Description Path A properly converted URI/IRI/URL to pathlib.Path . Source code in oteapi/utils/paths.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 def uri_to_path ( uri : \"Union[str, AnyUrl, ParseResult]\" ) -> Path : \"\"\"Convert URI to pathlib.Path. Support both Windows and Posix path types. Information: `urllib.parse.urlparse()` leaves an initial slash in front of the drive letter when parsing a file URL for an absolute path on Windows. Example: `urlparse(\"file:///C:/Windows\").path` -> `\"/C:/Windows\"` To solve this, the initial forward slash is removed prior to casting to `pathlib.Path`. Parameters: uri: The URI/IRI/URL. Either as a string or a parsed URL. Returns: A properly converted URI/IRI/URL to `pathlib.Path`. \"\"\" if isinstance ( uri , ( AnyUrl , ParseResult )): uri_path = uri . path elif isinstance ( uri , str ): uri = urlparse ( uri ) uri_path = uri . path else : raise TypeError ( \"uri is expected to be either a string or parsed URI/IRI/URL.\" ) if uri . scheme != \"file\" : warnings . warn ( \"A 'file'-scheme was expected for the 'uri' in 'uri_to_path()', instead a \" f \" { uri . scheme !r} was received. Still converting to `pathlib.Path` using \" \"the 'path' of the URI.\" ) path = Path ( uri_path ) if isinstance ( path , PureWindowsPath ): path = Path ( uri_path . lstrip ( \"/\" )) return path","title":"paths"},{"location":"api_reference/utils/paths/#paths","text":"Utility functions for handling paths.","title":"paths"},{"location":"api_reference/utils/paths/#oteapi.utils.paths.uri_to_path","text":"Convert URI to pathlib.Path. Support both Windows and Posix path types. Information urllib.parse.urlparse() leaves an initial slash in front of the drive letter when parsing a file URL for an absolute path on Windows. Example: urlparse(\"file:///C:/Windows\").path -> \"/C:/Windows\" To solve this, the initial forward slash is removed prior to casting to pathlib.Path . Parameters: Name Type Description Default uri 'Union[str, AnyUrl, ParseResult]' The URI/IRI/URL. Either as a string or a parsed URL. required Returns: Type Description Path A properly converted URI/IRI/URL to pathlib.Path . Source code in oteapi/utils/paths.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 def uri_to_path ( uri : \"Union[str, AnyUrl, ParseResult]\" ) -> Path : \"\"\"Convert URI to pathlib.Path. Support both Windows and Posix path types. Information: `urllib.parse.urlparse()` leaves an initial slash in front of the drive letter when parsing a file URL for an absolute path on Windows. Example: `urlparse(\"file:///C:/Windows\").path` -> `\"/C:/Windows\"` To solve this, the initial forward slash is removed prior to casting to `pathlib.Path`. Parameters: uri: The URI/IRI/URL. Either as a string or a parsed URL. Returns: A properly converted URI/IRI/URL to `pathlib.Path`. \"\"\" if isinstance ( uri , ( AnyUrl , ParseResult )): uri_path = uri . path elif isinstance ( uri , str ): uri = urlparse ( uri ) uri_path = uri . path else : raise TypeError ( \"uri is expected to be either a string or parsed URI/IRI/URL.\" ) if uri . scheme != \"file\" : warnings . warn ( \"A 'file'-scheme was expected for the 'uri' in 'uri_to_path()', instead a \" f \" { uri . scheme !r} was received. Still converting to `pathlib.Path` using \" \"the 'path' of the URI.\" ) path = Path ( uri_path ) if isinstance ( path , PureWindowsPath ): path = Path ( uri_path . lstrip ( \"/\" )) return path","title":"uri_to_path()"}]}