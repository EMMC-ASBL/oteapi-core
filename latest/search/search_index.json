{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Open Translation Environment (OTE) API Core \u00b6 Framework for accessing data resources, mapping data models, describing the data to ontologies and perform data transformations We highly recommend reading this page in the official documentation . About OTEAPI Core \u00b6 OTEAPI Core provides the core functionality of OTEAPI, which stands for the Open Translation Environment API . It uses the strategy software design pattern to implement a simple and easy to extend access to a large range of data resources. Semantic interoperability is supported via mapping of data models describing the data to ontologies. Transformations, mainly intended to transform data between representations, are also supported, but transformations can also be used for running simulations in a simple workflow. OTEAPI Core includes: A set of standard strategies; A plugin system for loading the standard strategies, as well as third party strategies; Data models for configuring the strategies; A Python library, through which the data can be accessed; and An efficient data cache module that avoids downloading the same content several times. Types of strategies \u00b6 Download strategy \u00b6 Download strategy patterns use a given protocol to download content into the data cache. They are configured with the ResourceConfig data model, using the scheme of the downloadUrl field for strategy selection. The configuration field can be used to configure how the downloaded content is stored in the cache using the DownloadConfig data model. Standard downloaded strategies: file , https , http , sftp , ftp Parse strategy \u00b6 Parse strategy patterns convert content from the data cache to a Python dict. Like download strategies, they are configured with the ResourceConfig data model, using the mediaType field for strategy selection. Additional strategy-specific configurations can be provided via the configuration field. Standard parse strategies: text_csv , application_json , image , excel_xlsx Resource strategy \u00b6 Resource strategy patterns can retrieve/upload data to external data services. They are configured with the ResourceConfig data model, using the scheme of the accessUrl and accessService fields. The scheme of the accessUrl is used for strategy selection. Mapping strategy \u00b6 Strategies for mapping fields/properties in data models to ontological concepts. Filter strategy \u00b6 Filter strategies can update the configuration of other strategies. They can also update values in the data cache. Transformation strategy \u00b6 Transformation strategies are a special form of a filter strategy intended for long-running transformations. Entry points for plugins \u00b6 Suggestion: Use setuptools entry points to load plugins. The entry point groups could be named as something like this: \"oteapi.download_strategy\" , \"oteapi.filter_strategy\" \"oteapi.download\" , \"oteapi.filter\" \"oteapi.interfaces.download\" , \"oteapi.interfaces.filter\" The value for an entrypoint should then be: setup ( # ..., entry_points = { \"oteapi.download_strategy\" : [ \"my_plugin.p2p = my_plugin.strategies.download.peer_2_peer\" , \"my_plugin.mongo = my_plugin.strategies.download.mongo_get\" , ], }, ) or as part of a YAML/JSON/setup.cfg setup files as such: entry_points : oteapi.download_strategy : - \"my_plugin.p2p = my_plugin.strategies.download.peer_2_peer\" - \"my_plugin.mongo = my_plugin.strategies.download.mongo_get\" { \"entry_points\" : { \"oteapi.download_strategy\" : [ \"my_plugin.p2p = my_plugin.strategies.download.peer_2_peer\" , \"my_plugin.mongo = my_plugin.strategies.download.mongo_get\" ] } } [options.entry_points] oteapi.download_strategy = my_plugin.p2p = my_plugin.strategies.download.peer_2_peer my_plugin.mongo = my_plugin.strategies.download.mongo_get The plugins will then automagically load all installed strategy module plugins, registering the strategies according to the StrategyFactory decorator. Other OTEAPI-related repositories \u00b6 OTEAPI Services - a RESTful interface to OTEAPI Core OTELib - a Python interface to OTEAPI Services OTEAPI Plugin Template - a cookiecutter template for OTEAPI Plugins Installation \u00b6 OTEAPI Core can be installed with: $ pip install oteapi-core License \u00b6 OTEAPI Core is released under the MIT license with copyright \u00a9 SINTEF. Acknowledgment \u00b6 OTEAPI Core has been supported by the following projects: OntoTrans (2020-2024) that receives funding from the European Union\u2019s Horizon 2020 Research and Innovation Programme, under Grant Agreement n. 862136.","title":"Home"},{"location":"#open-translation-environment-ote-api-core","text":"Framework for accessing data resources, mapping data models, describing the data to ontologies and perform data transformations We highly recommend reading this page in the official documentation .","title":"Open Translation Environment (OTE) API Core"},{"location":"#about-oteapi-core","text":"OTEAPI Core provides the core functionality of OTEAPI, which stands for the Open Translation Environment API . It uses the strategy software design pattern to implement a simple and easy to extend access to a large range of data resources. Semantic interoperability is supported via mapping of data models describing the data to ontologies. Transformations, mainly intended to transform data between representations, are also supported, but transformations can also be used for running simulations in a simple workflow. OTEAPI Core includes: A set of standard strategies; A plugin system for loading the standard strategies, as well as third party strategies; Data models for configuring the strategies; A Python library, through which the data can be accessed; and An efficient data cache module that avoids downloading the same content several times.","title":"About OTEAPI Core"},{"location":"#types-of-strategies","text":"","title":"Types of strategies"},{"location":"#download-strategy","text":"Download strategy patterns use a given protocol to download content into the data cache. They are configured with the ResourceConfig data model, using the scheme of the downloadUrl field for strategy selection. The configuration field can be used to configure how the downloaded content is stored in the cache using the DownloadConfig data model. Standard downloaded strategies: file , https , http , sftp , ftp","title":"Download strategy"},{"location":"#parse-strategy","text":"Parse strategy patterns convert content from the data cache to a Python dict. Like download strategies, they are configured with the ResourceConfig data model, using the mediaType field for strategy selection. Additional strategy-specific configurations can be provided via the configuration field. Standard parse strategies: text_csv , application_json , image , excel_xlsx","title":"Parse strategy"},{"location":"#resource-strategy","text":"Resource strategy patterns can retrieve/upload data to external data services. They are configured with the ResourceConfig data model, using the scheme of the accessUrl and accessService fields. The scheme of the accessUrl is used for strategy selection.","title":"Resource strategy"},{"location":"#mapping-strategy","text":"Strategies for mapping fields/properties in data models to ontological concepts.","title":"Mapping strategy"},{"location":"#filter-strategy","text":"Filter strategies can update the configuration of other strategies. They can also update values in the data cache.","title":"Filter strategy"},{"location":"#transformation-strategy","text":"Transformation strategies are a special form of a filter strategy intended for long-running transformations.","title":"Transformation strategy"},{"location":"#entry-points-for-plugins","text":"Suggestion: Use setuptools entry points to load plugins. The entry point groups could be named as something like this: \"oteapi.download_strategy\" , \"oteapi.filter_strategy\" \"oteapi.download\" , \"oteapi.filter\" \"oteapi.interfaces.download\" , \"oteapi.interfaces.filter\" The value for an entrypoint should then be: setup ( # ..., entry_points = { \"oteapi.download_strategy\" : [ \"my_plugin.p2p = my_plugin.strategies.download.peer_2_peer\" , \"my_plugin.mongo = my_plugin.strategies.download.mongo_get\" , ], }, ) or as part of a YAML/JSON/setup.cfg setup files as such: entry_points : oteapi.download_strategy : - \"my_plugin.p2p = my_plugin.strategies.download.peer_2_peer\" - \"my_plugin.mongo = my_plugin.strategies.download.mongo_get\" { \"entry_points\" : { \"oteapi.download_strategy\" : [ \"my_plugin.p2p = my_plugin.strategies.download.peer_2_peer\" , \"my_plugin.mongo = my_plugin.strategies.download.mongo_get\" ] } } [options.entry_points] oteapi.download_strategy = my_plugin.p2p = my_plugin.strategies.download.peer_2_peer my_plugin.mongo = my_plugin.strategies.download.mongo_get The plugins will then automagically load all installed strategy module plugins, registering the strategies according to the StrategyFactory decorator.","title":"Entry points for plugins"},{"location":"#other-oteapi-related-repositories","text":"OTEAPI Services - a RESTful interface to OTEAPI Core OTELib - a Python interface to OTEAPI Services OTEAPI Plugin Template - a cookiecutter template for OTEAPI Plugins","title":"Other OTEAPI-related repositories"},{"location":"#installation","text":"OTEAPI Core can be installed with: $ pip install oteapi-core","title":"Installation"},{"location":"#license","text":"OTEAPI Core is released under the MIT license with copyright \u00a9 SINTEF.","title":"License"},{"location":"#acknowledgment","text":"OTEAPI Core has been supported by the following projects: OntoTrans (2020-2024) that receives funding from the European Union\u2019s Horizon 2020 Research and Innovation Programme, under Grant Agreement n. 862136.","title":"Acknowledgment"},{"location":"CHANGELOG/","text":"Changelog \u00b6 v0.0.6 (2022-02-14) \u00b6 Full Changelog Implemented enhancements: New Function strategy #19 Fixed bugs: ResourceConfig.configuration should be a dict #65 Configuration bug #34 Change mediaType for json to application/json #24 Closed issues: AttrDict cannot be **unpacked #69 Add tests of configuration object subscripting functionality #61 Tests require installation #50 Rename image_jpeg.py #48 Write unit tests #11 Merged pull requests: Sg/session update model #78 ( sygout ) New Function strategy #73 ( CasperWA ) Made ResourceConfig.configuration a dict #67 ( jesper-friis ) [Auto-generated] Update dependencies #66 ( TEAM4-0 ) Add some dictionary functionality to configuration models #53 ( TorgeirUstad ) All new tests #35 ( TorgeirUstad ) v0.0.5 (2022-02-04) \u00b6 Full Changelog Implemented enhancements: Consider removing the create_*_strategy() functions #57 Lazy strategy loading #21 Extend and \"safeguard\" plugin loading through entry points #10 Fixed bugs: Out-of-scope CVE from NumPy makes safety cry #54 pyproject.toml addopts line doesn't work on Windows #51 Ignore ID 44715 for safety #55 ( CasperWA ) Merged pull requests: [Auto-generated] Update dependencies #56 ( TEAM4-0 ) Add Windows pytest CI job #52 ( CasperWA ) Start implementing entry point logic #47 ( CasperWA ) v0.0.4 (2022-01-26) \u00b6 Full Changelog Implemented enhancements: Setup dependency handling via dependabot #31 Attempt simplifying strategy factory function #13 Fixed bugs: Update pytest command in CI to fix codecov #42 Publish workflow failing - invoke not installed #40 Closed issues: Use new TEAM 4.0[bot] email throughout #38 Make datacache safe to call from within a running asyncio event loop #26 Setup documentation framework #9 Merged pull requests: [Auto-generated] Update dependencies #45 ( TEAM4-0 ) Add pytest options to pyproject.toml #43 ( CasperWA ) Install the dev extra in publish workflow #41 ( CasperWA ) Use the updated @TEAM4-0 email address #39 ( CasperWA ) Implement CI/CD for dependabot #33 ( CasperWA ) Remove asyncio from datacache #32 ( jesper-friis ) Setup docs framework and implement creating any strategy function #29 ( CasperWA ) v0.0.3 (2022-01-21) \u00b6 Full Changelog Implemented enhancements: Remove non-\"standard\" strategies #14 Clean up the API #12 Fixed bugs: Update CI/CD to only use Python 3.9 #25 References in README are wrong #18 Closed issues: Bring back pre-commit #16 Publish docker image #15 Merged pull requests: Updated cd_release.yml to python 3.9 #28 ( kriwiik ) Add back pre-commit #22 ( CasperWA ) Fixed README.md References #20 ( anasayb ) Clean up Python API #17 ( CasperWA ) v0.0.2 (2022-01-14) \u00b6 Full Changelog Implemented enhancements: Release and tests CD/CI #1 ( CasperWA ) Fixed bugs: CD publish release workflow not working #4 CD release not working - wrong utils path #2 Merged pull requests: Cleanup #8 ( jesper-friis ) Renamed oteapi/strategy-interfaces to oteapi/interfaces and updated paths in all Python modules #6 ( jesper-friis ) Update workflows to make CD work #5 ( CasperWA ) Fix location of utility files for GH Actions #3 ( CasperWA ) * This Changelog was automatically generated by github_changelog_generator","title":"Changelog"},{"location":"CHANGELOG/#changelog","text":"","title":"Changelog"},{"location":"CHANGELOG/#v006-2022-02-14","text":"Full Changelog Implemented enhancements: New Function strategy #19 Fixed bugs: ResourceConfig.configuration should be a dict #65 Configuration bug #34 Change mediaType for json to application/json #24 Closed issues: AttrDict cannot be **unpacked #69 Add tests of configuration object subscripting functionality #61 Tests require installation #50 Rename image_jpeg.py #48 Write unit tests #11 Merged pull requests: Sg/session update model #78 ( sygout ) New Function strategy #73 ( CasperWA ) Made ResourceConfig.configuration a dict #67 ( jesper-friis ) [Auto-generated] Update dependencies #66 ( TEAM4-0 ) Add some dictionary functionality to configuration models #53 ( TorgeirUstad ) All new tests #35 ( TorgeirUstad )","title":"v0.0.6 (2022-02-14)"},{"location":"CHANGELOG/#v005-2022-02-04","text":"Full Changelog Implemented enhancements: Consider removing the create_*_strategy() functions #57 Lazy strategy loading #21 Extend and \"safeguard\" plugin loading through entry points #10 Fixed bugs: Out-of-scope CVE from NumPy makes safety cry #54 pyproject.toml addopts line doesn't work on Windows #51 Ignore ID 44715 for safety #55 ( CasperWA ) Merged pull requests: [Auto-generated] Update dependencies #56 ( TEAM4-0 ) Add Windows pytest CI job #52 ( CasperWA ) Start implementing entry point logic #47 ( CasperWA )","title":"v0.0.5 (2022-02-04)"},{"location":"CHANGELOG/#v004-2022-01-26","text":"Full Changelog Implemented enhancements: Setup dependency handling via dependabot #31 Attempt simplifying strategy factory function #13 Fixed bugs: Update pytest command in CI to fix codecov #42 Publish workflow failing - invoke not installed #40 Closed issues: Use new TEAM 4.0[bot] email throughout #38 Make datacache safe to call from within a running asyncio event loop #26 Setup documentation framework #9 Merged pull requests: [Auto-generated] Update dependencies #45 ( TEAM4-0 ) Add pytest options to pyproject.toml #43 ( CasperWA ) Install the dev extra in publish workflow #41 ( CasperWA ) Use the updated @TEAM4-0 email address #39 ( CasperWA ) Implement CI/CD for dependabot #33 ( CasperWA ) Remove asyncio from datacache #32 ( jesper-friis ) Setup docs framework and implement creating any strategy function #29 ( CasperWA )","title":"v0.0.4 (2022-01-26)"},{"location":"CHANGELOG/#v003-2022-01-21","text":"Full Changelog Implemented enhancements: Remove non-\"standard\" strategies #14 Clean up the API #12 Fixed bugs: Update CI/CD to only use Python 3.9 #25 References in README are wrong #18 Closed issues: Bring back pre-commit #16 Publish docker image #15 Merged pull requests: Updated cd_release.yml to python 3.9 #28 ( kriwiik ) Add back pre-commit #22 ( CasperWA ) Fixed README.md References #20 ( anasayb ) Clean up Python API #17 ( CasperWA )","title":"v0.0.3 (2022-01-21)"},{"location":"CHANGELOG/#v002-2022-01-14","text":"Full Changelog Implemented enhancements: Release and tests CD/CI #1 ( CasperWA ) Fixed bugs: CD publish release workflow not working #4 CD release not working - wrong utils path #2 Merged pull requests: Cleanup #8 ( jesper-friis ) Renamed oteapi/strategy-interfaces to oteapi/interfaces and updated paths in all Python modules #6 ( jesper-friis ) Update workflows to make CD work #5 ( CasperWA ) Fix location of utility files for GH Actions #3 ( CasperWA ) * This Changelog was automatically generated by github_changelog_generator","title":"v0.0.2 (2022-01-14)"},{"location":"LICENSE/","text":"MIT License Copyright (c) 2020-2022 SINTEF Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"License"},{"location":"all_models/","text":"OTE-API Configuration Models \u00b6 This page provides documentation for the oteapi.models submodule, where all the OTE-API strategy configuration data models are located. When creating instances of these models, the data types are automatically validated. oteapi.models module. This module contains all the pydantic configuration models. datacacheconfig \u00b6 Pydantic DataCache Configuration Data Model. DataCacheConfig ( AttrDict ) pydantic-model \u00b6 DataCache Configuration. This class should not be used directly as a configuration object for a strategy object, but only as a configuration field inside a configuration object. Source code in oteapi/models/datacacheconfig.py class DataCacheConfig ( AttrDict ): \"\"\"DataCache Configuration. This class should not be used directly as a configuration object for a strategy object, but only as a configuration field inside a configuration object. \"\"\" cacheDir : Path = Field ( \"oteapi\" , description = \"Cache directory.\" ) accessKey : str = Field ( None , description = \"Key with which the downloaded content can be accessed. \" \"Should preferable be the hash (corresponding to `hashType`) of the \" \"content if it is known.\" , ) hashType : str = Field ( \"md5\" , description = \"Hash algorithm to use for creating hash keys for stored \" \"data. Can be any algorithm supported by hashlib.\" , ) expireTime : int = Field ( 3600 * 24 * 14 , description = \"Number of seconds before the cache entry expires. \" \"Zero means no expiration. Default is two weeks.\" , ) tag : str = Field ( None , description = \"Tag assigned to the downloaded content, typically \" \"identifying a session. Used with the `evict()` method to clean up a \" \"all cache entries with a given tag.\" , ) accessKey : str pydantic-field \u00b6 Key with which the downloaded content can be accessed. Should preferable be the hash (corresponding to hashType ) of the content if it is known. cacheDir : Path pydantic-field \u00b6 Cache directory. expireTime : int pydantic-field \u00b6 Number of seconds before the cache entry expires. Zero means no expiration. Default is two weeks. hashType : str pydantic-field \u00b6 Hash algorithm to use for creating hash keys for stored data. Can be any algorithm supported by hashlib. tag : str pydantic-field \u00b6 Tag assigned to the downloaded content, typically identifying a session. Used with the evict() method to clean up a all cache entries with a given tag. filterconfig \u00b6 Pydantic Filter Configuration Data Model. FilterConfig ( GenericConfig ) pydantic-model \u00b6 Filter Strategy Data Configuration. Source code in oteapi/models/filterconfig.py class FilterConfig ( GenericConfig ): \"\"\"Filter Strategy Data Configuration.\"\"\" filterType : str = Field ( ... , description = \"Type of registered filter strategy. E.g., `filter/sql`.\" ) query : Optional [ str ] = Field ( None , description = \"Define a query operation.\" ) condition : Optional [ str ] = Field ( None , description = \"Logical statement indicating when a filter should be applied.\" , ) limit : Optional [ int ] = Field ( None , description = \"Number of items remaining after a filter expression.\" ) condition : str pydantic-field \u00b6 Logical statement indicating when a filter should be applied. filterType : str pydantic-field required \u00b6 Type of registered filter strategy. E.g., filter/sql . limit : int pydantic-field \u00b6 Number of items remaining after a filter expression. query : str pydantic-field \u00b6 Define a query operation. functionconfig \u00b6 Pydantic Function Configuration Data Model. FunctionConfig ( GenericConfig ) pydantic-model \u00b6 Function Strategy Data Configuration. Source code in oteapi/models/functionconfig.py class FunctionConfig ( GenericConfig ): \"\"\"Function Strategy Data Configuration.\"\"\" functionType : str = Field ( ... , description = ( \"Type of registered function strategy.\" ), ) functionType : str pydantic-field required \u00b6 Type of registered function strategy. genericconfig \u00b6 Generic data model for configuration attributes. AttrDict ( BaseModel ) pydantic-model \u00b6 An object whose attributes can also be accessed through subscription, like with a dictionary. Source code in oteapi/models/genericconfig.py class AttrDict ( BaseModel ): \"\"\"An object whose attributes can also be accessed through subscription, like with a dictionary.\"\"\" class Config : \"\"\"Class for configuration of pydantic models.\"\"\" extra = \"allow\" def __contains__ ( self , name : Any ) -> bool : \"\"\"Enable using the 'in' operator on this object.\"\"\" return self . __dict__ . __contains__ ( name ) def __delitem__ ( self , key : str ) -> None : \"\"\"Enable deletion access through subscription.\"\"\" if key in dir ( self ): self . __delattr__ ( key ) if key in self . __fields__ : del self . __fields__ [ key ] self . __fields_set__ . remove ( key ) # pylint: disable=no-member else : raise KeyError ( key ) def __getitem__ ( self , key : str ) -> Any : \"\"\"Enable read access through subscription.\"\"\" if key in dir ( self ): return getattr ( self , key ) raise KeyError ( key ) def __setattr__ ( self , name : str , value : Any ) -> None : \"\"\"Extend BaseModel.__setattr__ with type-checking.\"\"\" if name in self . __dict__ and self . __dict__ [ name ]: target_type = type ( self . __dict__ [ name ]) if not isinstance ( value , target_type ): raise TypeError ( \"Mapped value must be subclass of \" + target_type . __name__ ) super () . __setattr__ ( name , value ) def __setitem__ ( self , key : str , value : Any ) -> None : \"\"\"Enable write access through subscription.\"\"\" self . __setattr__ ( key , value ) def __len__ ( self ): \"\"\"Return number of items.\"\"\" return self . __dict__ . __len__ () def __iter__ ( self ): \"\"\"Enable **unpacking.\"\"\" return self . __dict__ . __iter__ () def items ( self ): \"\"\"Return a view of all (key, value) pairs.\"\"\" return self . __dict__ . items () def keys ( self ): \"\"\"Return a view of all keys.\"\"\" return self . __dict__ . keys () def values ( self ): \"\"\"Return a view of all values.\"\"\" return self . __dict__ . values () def get ( self , key : str , default : Optional [ Any ] = None ) -> Any : \"\"\"Mapping `get`-method.\"\"\" return self . __dict__ . get ( key , default ) def __ne__ ( self , other : Any ) -> bool : if isinstance ( other , BaseModel ): return self . dict () != other . dict () return self . dict () != other Config \u00b6 Class for configuration of pydantic models. Source code in oteapi/models/genericconfig.py class Config : \"\"\"Class for configuration of pydantic models.\"\"\" extra = \"allow\" get ( self , key , default = None ) \u00b6 Mapping get -method. Source code in oteapi/models/genericconfig.py def get ( self , key : str , default : Optional [ Any ] = None ) -> Any : \"\"\"Mapping `get`-method.\"\"\" return self . __dict__ . get ( key , default ) items ( self ) \u00b6 Return a view of all (key, value) pairs. Source code in oteapi/models/genericconfig.py def items ( self ): \"\"\"Return a view of all (key, value) pairs.\"\"\" return self . __dict__ . items () keys ( self ) \u00b6 Return a view of all keys. Source code in oteapi/models/genericconfig.py def keys ( self ): \"\"\"Return a view of all keys.\"\"\" return self . __dict__ . keys () values ( self ) \u00b6 Return a view of all values. Source code in oteapi/models/genericconfig.py def values ( self ): \"\"\"Return a view of all values.\"\"\" return self . __dict__ . values () GenericConfig ( BaseModel ) pydantic-model \u00b6 Generic class for configuration objects. Source code in oteapi/models/genericconfig.py class GenericConfig ( BaseModel ): \"\"\"Generic class for configuration objects.\"\"\" configuration : Optional [ AttrDict ] = Field ( None , description = \"Model-specific configuration options which can either \" \"be given as key/value-pairs or set as attributes.\" , ) description : str = Field ( __doc__ , description = \"A description of the configuration model.\" , ) @classmethod def __init_subclass__ ( cls ) -> None : \"\"\"Initialize subclass descriptions with their docstrings.\"\"\" cls . __fields__ [ \"description\" ] . default = cls . __doc__ configuration : AttrDict pydantic-field \u00b6 Model-specific configuration options which can either be given as key/value-pairs or set as attributes. description : str pydantic-field \u00b6 A description of the configuration model. mappingconfig \u00b6 Pydantic Mapping Configuration Data Model. MappingConfig ( GenericConfig ) pydantic-model \u00b6 Mapping Strategy Data Configuration. Source code in oteapi/models/mappingconfig.py class MappingConfig ( GenericConfig ): \"\"\"Mapping Strategy Data Configuration.\"\"\" mappingType : str = Field ( ... , description = \"Type of registered mapping strategy. E.g., `mapping/demo`.\" ) prefixes : Optional [ Dict [ str , str ]] = Field ( None , description = ( \"List of shortnames that expands to an IRI \" \"given as local value/IRI-expansion-pairs.\" ), ) triples : Optional [ List [ SemanticTriple ]] = Field ( # type: ignore[valid-type] None , description = \"List of semantic triples given as (subject, predicate, object).\" , ) mappingType : str pydantic-field required \u00b6 Type of registered mapping strategy. E.g., mapping/demo . prefixes : Dict [ str , str ] pydantic-field \u00b6 List of shortnames that expands to an IRI given as local value/IRI-expansion-pairs. triples : List [ types . ConstrainedListValue ] pydantic-field \u00b6 List of semantic triples given as (subject, predicate, object). resourceconfig \u00b6 Pydantic Resource Configuration Data Model. ResourceConfig ( GenericConfig ) pydantic-model \u00b6 Resource Strategy Data Configuration. Important Either of the pairs of attributes downloadUrl / mediaType or accessUrl / accessService MUST be specified. Source code in oteapi/models/resourceconfig.py class ResourceConfig ( GenericConfig ): \"\"\"Resource Strategy Data Configuration. Important: Either of the pairs of attributes `downloadUrl`/`mediaType` or `accessUrl`/`accessService` MUST be specified. \"\"\" downloadUrl : Optional [ Union [ AnyUrl , FileUrl ]] = Field ( None , description = ( \"Definition: The URL of the downloadable file in a given format. E.g. CSV \" \"file or RDF file. \\n\\n Usage: `downloadURL` *SHOULD* be used for the URL at\" \" which this distribution is available directly, typically through a HTTPS\" \" GET request or SFTP.\" ), ) mediaType : Optional [ str ] = Field ( None , description = ( \"The media type of the distribution as defined by IANA \" \"[[IANA-MEDIA-TYPES](https://www.w3.org/TR/vocab-dcat-2/#bib-iana-media-types)]\" \". \\n\\n Usage: This property *SHOULD* be used when the media\" \" type of the distribution is defined in IANA \" \"[[IANA-MEDIA-TYPES](https://www.w3.org/TR/vocab-dcat-2/#bib-iana-media-types)].\" ), ) accessUrl : Optional [ AnyUrl ] = Field ( None , description = ( \"A URL of the resource that gives access to a distribution of \" \"the dataset. E.g. landing page, feed, SPARQL endpoint. \\n\\n Usage: \" \"`accessURL` *SHOULD* be used for the URL of a service or location that \" \"can provide access to this distribution, typically through a Web form, \" \"query or API call. \\n `downloadURL` is preferred for direct links to \" \"downloadable resources.\" ), ) accessService : Optional [ str ] = Field ( None , description = ( \"A data service that gives access to the distribution of the dataset.\" ), ) license : Optional [ str ] = Field ( None , description = ( \"A legal document under which the distribution is made available.\" ), ) accessRights : Optional [ str ] = Field ( None , description = ( \"A rights statement that concerns how the distribution is accessed.\" ), ) publisher : Optional [ str ] = Field ( None , description = \"The entity responsible for making the resource/item available.\" , ) configuration : DataCacheConfig = Field ( DataCacheConfig (), description = \"Resource-specific configuration options given as key/value-pairs.\" , ) @root_validator def ensure_unique_url_pairs ( # pylint: disable=no-self-use cls , values : Dict [ str , Any ] ) -> Dict [ str , Any ]: \"\"\"Ensure either downloadUrl/mediaType or accessUrl/accessService are defined. It's fine to define them all, but at least one complete pair MUST be specified.\"\"\" if not ( all ( values . get ( _ ) for _ in [ \"downloadUrl\" , \"mediaType\" ]) or all ( values . get ( _ ) for _ in [ \"accessUrl\" , \"accessService\" ]) ): raise ValueError ( \"Either of the pairs of attributes downloadUrl/mediaType or \" \"accessUrl/accessService MUST be specified.\" ) return values accessRights : str pydantic-field \u00b6 A rights statement that concerns how the distribution is accessed. accessService : str pydantic-field \u00b6 A data service that gives access to the distribution of the dataset. accessUrl : AnyUrl pydantic-field \u00b6 A URL of the resource that gives access to a distribution of the dataset. E.g. landing page, feed, SPARQL endpoint. Usage: accessURL SHOULD be used for the URL of a service or location that can provide access to this distribution, typically through a Web form, query or API call. downloadURL is preferred for direct links to downloadable resources. downloadUrl : Union [ pydantic . networks . AnyUrl , pydantic . networks . FileUrl ] pydantic-field \u00b6 Definition: The URL of the downloadable file in a given format. E.g. CSV file or RDF file. Usage: downloadURL SHOULD be used for the URL at which this distribution is available directly, typically through a HTTPS GET request or SFTP. license : str pydantic-field \u00b6 A legal document under which the distribution is made available. mediaType : str pydantic-field \u00b6 The media type of the distribution as defined by IANA [ IANA-MEDIA-TYPES ]. Usage: This property SHOULD be used when the media type of the distribution is defined in IANA [ IANA-MEDIA-TYPES ]. publisher : str pydantic-field \u00b6 The entity responsible for making the resource/item available. ensure_unique_url_pairs ( values ) classmethod \u00b6 Ensure either downloadUrl/mediaType or accessUrl/accessService are defined. It's fine to define them all, but at least one complete pair MUST be specified. Source code in oteapi/models/resourceconfig.py @root_validator def ensure_unique_url_pairs ( # pylint: disable=no-self-use cls , values : Dict [ str , Any ] ) -> Dict [ str , Any ]: \"\"\"Ensure either downloadUrl/mediaType or accessUrl/accessService are defined. It's fine to define them all, but at least one complete pair MUST be specified.\"\"\" if not ( all ( values . get ( _ ) for _ in [ \"downloadUrl\" , \"mediaType\" ]) or all ( values . get ( _ ) for _ in [ \"accessUrl\" , \"accessService\" ]) ): raise ValueError ( \"Either of the pairs of attributes downloadUrl/mediaType or \" \"accessUrl/accessService MUST be specified.\" ) return values sessionupdate \u00b6 Pydantic SessionUpdate Data Model. SessionUpdate ( AttrDict ) pydantic-model \u00b6 Session Update Data Model for returning values. Source code in oteapi/models/sessionupdate.py class SessionUpdate ( AttrDict ): \"\"\"Session Update Data Model for returning values.\"\"\" transformationconfig \u00b6 Pydantic Transformation Configuration Data Model. A transformation status data model is provided as well. This data model represents what should be returned from the strategy's status() method. PriorityEnum ( str , Enum ) \u00b6 Defining process priority enumerators. Process priorities: Low Medium High Source code in oteapi/models/transformationconfig.py class PriorityEnum ( str , Enum ): \"\"\"Defining process priority enumerators. Process priorities: - Low - Medium - High \"\"\" LOW = \"Low\" MEDIUM = \"Medium\" HIGH = \"High\" TransformationConfig ( GenericConfig ) pydantic-model \u00b6 Transformation Strategy Data Configuration. Source code in oteapi/models/transformationconfig.py class TransformationConfig ( GenericConfig ): \"\"\"Transformation Strategy Data Configuration.\"\"\" transformationType : str = Field ( ... , description = ( \"Type of registered transformation strategy. E.g., `celery/remote`.\" ), ) name : Optional [ str ] = Field ( None , description = \"Human-readable name of the transformation strategy.\" ) due : Optional [ datetime ] = Field ( None , description = ( \"Optional field to indicate a due data/time for when a transformation \" \"should finish.\" ), ) priority : Optional [ PriorityEnum ] = Field ( PriorityEnum . MEDIUM , description = \"Define the process priority of the transformation execution.\" , ) secret : Optional [ str ] = Field ( None , description = \"Authorization secret given when running a transformation.\" , ) due : datetime pydantic-field \u00b6 Optional field to indicate a due data/time for when a transformation should finish. name : str pydantic-field \u00b6 Human-readable name of the transformation strategy. priority : PriorityEnum pydantic-field \u00b6 Define the process priority of the transformation execution. secret : str pydantic-field \u00b6 Authorization secret given when running a transformation. transformationType : str pydantic-field required \u00b6 Type of registered transformation strategy. E.g., celery/remote . TransformationStatus ( BaseModel ) pydantic-model \u00b6 Return from transformation status. Source code in oteapi/models/transformationconfig.py class TransformationStatus ( BaseModel ): \"\"\"Return from transformation status.\"\"\" id : str = Field ( ... , description = \"ID for the given transformation process.\" ) status : Optional [ str ] = Field ( None , description = \"Status for the transformation process.\" ) messages : Optional [ List [ str ]] = Field ( None , description = \"Messages related to the transformation process.\" ) created : Optional [ datetime ] = Field ( None , description = \"Time of creation for the transformation process. Given in UTC.\" , ) startTime : Optional [ datetime ] = Field ( None , description = \"Time when the transformation process started. Given in UTC.\" ) finishTime : Optional [ datetime ] = Field ( None , description = \"Time when the tranformation process finished. Given in UTC.\" ) created : datetime pydantic-field \u00b6 Time of creation for the transformation process. Given in UTC. finishTime : datetime pydantic-field \u00b6 Time when the tranformation process finished. Given in UTC. id : str pydantic-field required \u00b6 ID for the given transformation process. messages : List [ str ] pydantic-field \u00b6 Messages related to the transformation process. startTime : datetime pydantic-field \u00b6 Time when the transformation process started. Given in UTC. status : str pydantic-field \u00b6 Status for the transformation process.","title":"OTE-API Configuration Models"},{"location":"all_models/#ote-api-configuration-models","text":"This page provides documentation for the oteapi.models submodule, where all the OTE-API strategy configuration data models are located. When creating instances of these models, the data types are automatically validated. oteapi.models module. This module contains all the pydantic configuration models.","title":"OTE-API Configuration Models"},{"location":"all_models/#oteapi.models.datacacheconfig","text":"Pydantic DataCache Configuration Data Model.","title":"datacacheconfig"},{"location":"all_models/#oteapi.models.datacacheconfig.DataCacheConfig","text":"DataCache Configuration. This class should not be used directly as a configuration object for a strategy object, but only as a configuration field inside a configuration object. Source code in oteapi/models/datacacheconfig.py class DataCacheConfig ( AttrDict ): \"\"\"DataCache Configuration. This class should not be used directly as a configuration object for a strategy object, but only as a configuration field inside a configuration object. \"\"\" cacheDir : Path = Field ( \"oteapi\" , description = \"Cache directory.\" ) accessKey : str = Field ( None , description = \"Key with which the downloaded content can be accessed. \" \"Should preferable be the hash (corresponding to `hashType`) of the \" \"content if it is known.\" , ) hashType : str = Field ( \"md5\" , description = \"Hash algorithm to use for creating hash keys for stored \" \"data. Can be any algorithm supported by hashlib.\" , ) expireTime : int = Field ( 3600 * 24 * 14 , description = \"Number of seconds before the cache entry expires. \" \"Zero means no expiration. Default is two weeks.\" , ) tag : str = Field ( None , description = \"Tag assigned to the downloaded content, typically \" \"identifying a session. Used with the `evict()` method to clean up a \" \"all cache entries with a given tag.\" , )","title":"DataCacheConfig"},{"location":"all_models/#oteapi.models.datacacheconfig.DataCacheConfig.accessKey","text":"Key with which the downloaded content can be accessed. Should preferable be the hash (corresponding to hashType ) of the content if it is known.","title":"accessKey"},{"location":"all_models/#oteapi.models.datacacheconfig.DataCacheConfig.cacheDir","text":"Cache directory.","title":"cacheDir"},{"location":"all_models/#oteapi.models.datacacheconfig.DataCacheConfig.expireTime","text":"Number of seconds before the cache entry expires. Zero means no expiration. Default is two weeks.","title":"expireTime"},{"location":"all_models/#oteapi.models.datacacheconfig.DataCacheConfig.hashType","text":"Hash algorithm to use for creating hash keys for stored data. Can be any algorithm supported by hashlib.","title":"hashType"},{"location":"all_models/#oteapi.models.datacacheconfig.DataCacheConfig.tag","text":"Tag assigned to the downloaded content, typically identifying a session. Used with the evict() method to clean up a all cache entries with a given tag.","title":"tag"},{"location":"all_models/#oteapi.models.filterconfig","text":"Pydantic Filter Configuration Data Model.","title":"filterconfig"},{"location":"all_models/#oteapi.models.filterconfig.FilterConfig","text":"Filter Strategy Data Configuration. Source code in oteapi/models/filterconfig.py class FilterConfig ( GenericConfig ): \"\"\"Filter Strategy Data Configuration.\"\"\" filterType : str = Field ( ... , description = \"Type of registered filter strategy. E.g., `filter/sql`.\" ) query : Optional [ str ] = Field ( None , description = \"Define a query operation.\" ) condition : Optional [ str ] = Field ( None , description = \"Logical statement indicating when a filter should be applied.\" , ) limit : Optional [ int ] = Field ( None , description = \"Number of items remaining after a filter expression.\" )","title":"FilterConfig"},{"location":"all_models/#oteapi.models.filterconfig.FilterConfig.condition","text":"Logical statement indicating when a filter should be applied.","title":"condition"},{"location":"all_models/#oteapi.models.filterconfig.FilterConfig.filterType","text":"Type of registered filter strategy. E.g., filter/sql .","title":"filterType"},{"location":"all_models/#oteapi.models.filterconfig.FilterConfig.limit","text":"Number of items remaining after a filter expression.","title":"limit"},{"location":"all_models/#oteapi.models.filterconfig.FilterConfig.query","text":"Define a query operation.","title":"query"},{"location":"all_models/#oteapi.models.functionconfig","text":"Pydantic Function Configuration Data Model.","title":"functionconfig"},{"location":"all_models/#oteapi.models.functionconfig.FunctionConfig","text":"Function Strategy Data Configuration. Source code in oteapi/models/functionconfig.py class FunctionConfig ( GenericConfig ): \"\"\"Function Strategy Data Configuration.\"\"\" functionType : str = Field ( ... , description = ( \"Type of registered function strategy.\" ), )","title":"FunctionConfig"},{"location":"all_models/#oteapi.models.functionconfig.FunctionConfig.functionType","text":"Type of registered function strategy.","title":"functionType"},{"location":"all_models/#oteapi.models.genericconfig","text":"Generic data model for configuration attributes.","title":"genericconfig"},{"location":"all_models/#oteapi.models.genericconfig.AttrDict","text":"An object whose attributes can also be accessed through subscription, like with a dictionary. Source code in oteapi/models/genericconfig.py class AttrDict ( BaseModel ): \"\"\"An object whose attributes can also be accessed through subscription, like with a dictionary.\"\"\" class Config : \"\"\"Class for configuration of pydantic models.\"\"\" extra = \"allow\" def __contains__ ( self , name : Any ) -> bool : \"\"\"Enable using the 'in' operator on this object.\"\"\" return self . __dict__ . __contains__ ( name ) def __delitem__ ( self , key : str ) -> None : \"\"\"Enable deletion access through subscription.\"\"\" if key in dir ( self ): self . __delattr__ ( key ) if key in self . __fields__ : del self . __fields__ [ key ] self . __fields_set__ . remove ( key ) # pylint: disable=no-member else : raise KeyError ( key ) def __getitem__ ( self , key : str ) -> Any : \"\"\"Enable read access through subscription.\"\"\" if key in dir ( self ): return getattr ( self , key ) raise KeyError ( key ) def __setattr__ ( self , name : str , value : Any ) -> None : \"\"\"Extend BaseModel.__setattr__ with type-checking.\"\"\" if name in self . __dict__ and self . __dict__ [ name ]: target_type = type ( self . __dict__ [ name ]) if not isinstance ( value , target_type ): raise TypeError ( \"Mapped value must be subclass of \" + target_type . __name__ ) super () . __setattr__ ( name , value ) def __setitem__ ( self , key : str , value : Any ) -> None : \"\"\"Enable write access through subscription.\"\"\" self . __setattr__ ( key , value ) def __len__ ( self ): \"\"\"Return number of items.\"\"\" return self . __dict__ . __len__ () def __iter__ ( self ): \"\"\"Enable **unpacking.\"\"\" return self . __dict__ . __iter__ () def items ( self ): \"\"\"Return a view of all (key, value) pairs.\"\"\" return self . __dict__ . items () def keys ( self ): \"\"\"Return a view of all keys.\"\"\" return self . __dict__ . keys () def values ( self ): \"\"\"Return a view of all values.\"\"\" return self . __dict__ . values () def get ( self , key : str , default : Optional [ Any ] = None ) -> Any : \"\"\"Mapping `get`-method.\"\"\" return self . __dict__ . get ( key , default ) def __ne__ ( self , other : Any ) -> bool : if isinstance ( other , BaseModel ): return self . dict () != other . dict () return self . dict () != other","title":"AttrDict"},{"location":"all_models/#oteapi.models.genericconfig.AttrDict.Config","text":"Class for configuration of pydantic models. Source code in oteapi/models/genericconfig.py class Config : \"\"\"Class for configuration of pydantic models.\"\"\" extra = \"allow\"","title":"Config"},{"location":"all_models/#oteapi.models.genericconfig.AttrDict.get","text":"Mapping get -method. Source code in oteapi/models/genericconfig.py def get ( self , key : str , default : Optional [ Any ] = None ) -> Any : \"\"\"Mapping `get`-method.\"\"\" return self . __dict__ . get ( key , default )","title":"get()"},{"location":"all_models/#oteapi.models.genericconfig.AttrDict.items","text":"Return a view of all (key, value) pairs. Source code in oteapi/models/genericconfig.py def items ( self ): \"\"\"Return a view of all (key, value) pairs.\"\"\" return self . __dict__ . items ()","title":"items()"},{"location":"all_models/#oteapi.models.genericconfig.AttrDict.keys","text":"Return a view of all keys. Source code in oteapi/models/genericconfig.py def keys ( self ): \"\"\"Return a view of all keys.\"\"\" return self . __dict__ . keys ()","title":"keys()"},{"location":"all_models/#oteapi.models.genericconfig.AttrDict.values","text":"Return a view of all values. Source code in oteapi/models/genericconfig.py def values ( self ): \"\"\"Return a view of all values.\"\"\" return self . __dict__ . values ()","title":"values()"},{"location":"all_models/#oteapi.models.genericconfig.GenericConfig","text":"Generic class for configuration objects. Source code in oteapi/models/genericconfig.py class GenericConfig ( BaseModel ): \"\"\"Generic class for configuration objects.\"\"\" configuration : Optional [ AttrDict ] = Field ( None , description = \"Model-specific configuration options which can either \" \"be given as key/value-pairs or set as attributes.\" , ) description : str = Field ( __doc__ , description = \"A description of the configuration model.\" , ) @classmethod def __init_subclass__ ( cls ) -> None : \"\"\"Initialize subclass descriptions with their docstrings.\"\"\" cls . __fields__ [ \"description\" ] . default = cls . __doc__","title":"GenericConfig"},{"location":"all_models/#oteapi.models.genericconfig.GenericConfig.configuration","text":"Model-specific configuration options which can either be given as key/value-pairs or set as attributes.","title":"configuration"},{"location":"all_models/#oteapi.models.genericconfig.GenericConfig.description","text":"A description of the configuration model.","title":"description"},{"location":"all_models/#oteapi.models.mappingconfig","text":"Pydantic Mapping Configuration Data Model.","title":"mappingconfig"},{"location":"all_models/#oteapi.models.mappingconfig.MappingConfig","text":"Mapping Strategy Data Configuration. Source code in oteapi/models/mappingconfig.py class MappingConfig ( GenericConfig ): \"\"\"Mapping Strategy Data Configuration.\"\"\" mappingType : str = Field ( ... , description = \"Type of registered mapping strategy. E.g., `mapping/demo`.\" ) prefixes : Optional [ Dict [ str , str ]] = Field ( None , description = ( \"List of shortnames that expands to an IRI \" \"given as local value/IRI-expansion-pairs.\" ), ) triples : Optional [ List [ SemanticTriple ]] = Field ( # type: ignore[valid-type] None , description = \"List of semantic triples given as (subject, predicate, object).\" , )","title":"MappingConfig"},{"location":"all_models/#oteapi.models.mappingconfig.MappingConfig.mappingType","text":"Type of registered mapping strategy. E.g., mapping/demo .","title":"mappingType"},{"location":"all_models/#oteapi.models.mappingconfig.MappingConfig.prefixes","text":"List of shortnames that expands to an IRI given as local value/IRI-expansion-pairs.","title":"prefixes"},{"location":"all_models/#oteapi.models.mappingconfig.MappingConfig.triples","text":"List of semantic triples given as (subject, predicate, object).","title":"triples"},{"location":"all_models/#oteapi.models.resourceconfig","text":"Pydantic Resource Configuration Data Model.","title":"resourceconfig"},{"location":"all_models/#oteapi.models.resourceconfig.ResourceConfig","text":"Resource Strategy Data Configuration. Important Either of the pairs of attributes downloadUrl / mediaType or accessUrl / accessService MUST be specified. Source code in oteapi/models/resourceconfig.py class ResourceConfig ( GenericConfig ): \"\"\"Resource Strategy Data Configuration. Important: Either of the pairs of attributes `downloadUrl`/`mediaType` or `accessUrl`/`accessService` MUST be specified. \"\"\" downloadUrl : Optional [ Union [ AnyUrl , FileUrl ]] = Field ( None , description = ( \"Definition: The URL of the downloadable file in a given format. E.g. CSV \" \"file or RDF file. \\n\\n Usage: `downloadURL` *SHOULD* be used for the URL at\" \" which this distribution is available directly, typically through a HTTPS\" \" GET request or SFTP.\" ), ) mediaType : Optional [ str ] = Field ( None , description = ( \"The media type of the distribution as defined by IANA \" \"[[IANA-MEDIA-TYPES](https://www.w3.org/TR/vocab-dcat-2/#bib-iana-media-types)]\" \". \\n\\n Usage: This property *SHOULD* be used when the media\" \" type of the distribution is defined in IANA \" \"[[IANA-MEDIA-TYPES](https://www.w3.org/TR/vocab-dcat-2/#bib-iana-media-types)].\" ), ) accessUrl : Optional [ AnyUrl ] = Field ( None , description = ( \"A URL of the resource that gives access to a distribution of \" \"the dataset. E.g. landing page, feed, SPARQL endpoint. \\n\\n Usage: \" \"`accessURL` *SHOULD* be used for the URL of a service or location that \" \"can provide access to this distribution, typically through a Web form, \" \"query or API call. \\n `downloadURL` is preferred for direct links to \" \"downloadable resources.\" ), ) accessService : Optional [ str ] = Field ( None , description = ( \"A data service that gives access to the distribution of the dataset.\" ), ) license : Optional [ str ] = Field ( None , description = ( \"A legal document under which the distribution is made available.\" ), ) accessRights : Optional [ str ] = Field ( None , description = ( \"A rights statement that concerns how the distribution is accessed.\" ), ) publisher : Optional [ str ] = Field ( None , description = \"The entity responsible for making the resource/item available.\" , ) configuration : DataCacheConfig = Field ( DataCacheConfig (), description = \"Resource-specific configuration options given as key/value-pairs.\" , ) @root_validator def ensure_unique_url_pairs ( # pylint: disable=no-self-use cls , values : Dict [ str , Any ] ) -> Dict [ str , Any ]: \"\"\"Ensure either downloadUrl/mediaType or accessUrl/accessService are defined. It's fine to define them all, but at least one complete pair MUST be specified.\"\"\" if not ( all ( values . get ( _ ) for _ in [ \"downloadUrl\" , \"mediaType\" ]) or all ( values . get ( _ ) for _ in [ \"accessUrl\" , \"accessService\" ]) ): raise ValueError ( \"Either of the pairs of attributes downloadUrl/mediaType or \" \"accessUrl/accessService MUST be specified.\" ) return values","title":"ResourceConfig"},{"location":"all_models/#oteapi.models.resourceconfig.ResourceConfig.accessRights","text":"A rights statement that concerns how the distribution is accessed.","title":"accessRights"},{"location":"all_models/#oteapi.models.resourceconfig.ResourceConfig.accessService","text":"A data service that gives access to the distribution of the dataset.","title":"accessService"},{"location":"all_models/#oteapi.models.resourceconfig.ResourceConfig.accessUrl","text":"A URL of the resource that gives access to a distribution of the dataset. E.g. landing page, feed, SPARQL endpoint. Usage: accessURL SHOULD be used for the URL of a service or location that can provide access to this distribution, typically through a Web form, query or API call. downloadURL is preferred for direct links to downloadable resources.","title":"accessUrl"},{"location":"all_models/#oteapi.models.resourceconfig.ResourceConfig.downloadUrl","text":"Definition: The URL of the downloadable file in a given format. E.g. CSV file or RDF file. Usage: downloadURL SHOULD be used for the URL at which this distribution is available directly, typically through a HTTPS GET request or SFTP.","title":"downloadUrl"},{"location":"all_models/#oteapi.models.resourceconfig.ResourceConfig.license","text":"A legal document under which the distribution is made available.","title":"license"},{"location":"all_models/#oteapi.models.resourceconfig.ResourceConfig.mediaType","text":"The media type of the distribution as defined by IANA [ IANA-MEDIA-TYPES ]. Usage: This property SHOULD be used when the media type of the distribution is defined in IANA [ IANA-MEDIA-TYPES ].","title":"mediaType"},{"location":"all_models/#oteapi.models.resourceconfig.ResourceConfig.publisher","text":"The entity responsible for making the resource/item available.","title":"publisher"},{"location":"all_models/#oteapi.models.resourceconfig.ResourceConfig.ensure_unique_url_pairs","text":"Ensure either downloadUrl/mediaType or accessUrl/accessService are defined. It's fine to define them all, but at least one complete pair MUST be specified. Source code in oteapi/models/resourceconfig.py @root_validator def ensure_unique_url_pairs ( # pylint: disable=no-self-use cls , values : Dict [ str , Any ] ) -> Dict [ str , Any ]: \"\"\"Ensure either downloadUrl/mediaType or accessUrl/accessService are defined. It's fine to define them all, but at least one complete pair MUST be specified.\"\"\" if not ( all ( values . get ( _ ) for _ in [ \"downloadUrl\" , \"mediaType\" ]) or all ( values . get ( _ ) for _ in [ \"accessUrl\" , \"accessService\" ]) ): raise ValueError ( \"Either of the pairs of attributes downloadUrl/mediaType or \" \"accessUrl/accessService MUST be specified.\" ) return values","title":"ensure_unique_url_pairs()"},{"location":"all_models/#oteapi.models.sessionupdate","text":"Pydantic SessionUpdate Data Model.","title":"sessionupdate"},{"location":"all_models/#oteapi.models.sessionupdate.SessionUpdate","text":"Session Update Data Model for returning values. Source code in oteapi/models/sessionupdate.py class SessionUpdate ( AttrDict ): \"\"\"Session Update Data Model for returning values.\"\"\"","title":"SessionUpdate"},{"location":"all_models/#oteapi.models.transformationconfig","text":"Pydantic Transformation Configuration Data Model. A transformation status data model is provided as well. This data model represents what should be returned from the strategy's status() method.","title":"transformationconfig"},{"location":"all_models/#oteapi.models.transformationconfig.PriorityEnum","text":"Defining process priority enumerators. Process priorities: Low Medium High Source code in oteapi/models/transformationconfig.py class PriorityEnum ( str , Enum ): \"\"\"Defining process priority enumerators. Process priorities: - Low - Medium - High \"\"\" LOW = \"Low\" MEDIUM = \"Medium\" HIGH = \"High\"","title":"PriorityEnum"},{"location":"all_models/#oteapi.models.transformationconfig.TransformationConfig","text":"Transformation Strategy Data Configuration. Source code in oteapi/models/transformationconfig.py class TransformationConfig ( GenericConfig ): \"\"\"Transformation Strategy Data Configuration.\"\"\" transformationType : str = Field ( ... , description = ( \"Type of registered transformation strategy. E.g., `celery/remote`.\" ), ) name : Optional [ str ] = Field ( None , description = \"Human-readable name of the transformation strategy.\" ) due : Optional [ datetime ] = Field ( None , description = ( \"Optional field to indicate a due data/time for when a transformation \" \"should finish.\" ), ) priority : Optional [ PriorityEnum ] = Field ( PriorityEnum . MEDIUM , description = \"Define the process priority of the transformation execution.\" , ) secret : Optional [ str ] = Field ( None , description = \"Authorization secret given when running a transformation.\" , )","title":"TransformationConfig"},{"location":"all_models/#oteapi.models.transformationconfig.TransformationConfig.due","text":"Optional field to indicate a due data/time for when a transformation should finish.","title":"due"},{"location":"all_models/#oteapi.models.transformationconfig.TransformationConfig.name","text":"Human-readable name of the transformation strategy.","title":"name"},{"location":"all_models/#oteapi.models.transformationconfig.TransformationConfig.priority","text":"Define the process priority of the transformation execution.","title":"priority"},{"location":"all_models/#oteapi.models.transformationconfig.TransformationConfig.secret","text":"Authorization secret given when running a transformation.","title":"secret"},{"location":"all_models/#oteapi.models.transformationconfig.TransformationConfig.transformationType","text":"Type of registered transformation strategy. E.g., celery/remote .","title":"transformationType"},{"location":"all_models/#oteapi.models.transformationconfig.TransformationStatus","text":"Return from transformation status. Source code in oteapi/models/transformationconfig.py class TransformationStatus ( BaseModel ): \"\"\"Return from transformation status.\"\"\" id : str = Field ( ... , description = \"ID for the given transformation process.\" ) status : Optional [ str ] = Field ( None , description = \"Status for the transformation process.\" ) messages : Optional [ List [ str ]] = Field ( None , description = \"Messages related to the transformation process.\" ) created : Optional [ datetime ] = Field ( None , description = \"Time of creation for the transformation process. Given in UTC.\" , ) startTime : Optional [ datetime ] = Field ( None , description = \"Time when the transformation process started. Given in UTC.\" ) finishTime : Optional [ datetime ] = Field ( None , description = \"Time when the tranformation process finished. Given in UTC.\" )","title":"TransformationStatus"},{"location":"all_models/#oteapi.models.transformationconfig.TransformationStatus.created","text":"Time of creation for the transformation process. Given in UTC.","title":"created"},{"location":"all_models/#oteapi.models.transformationconfig.TransformationStatus.finishTime","text":"Time when the tranformation process finished. Given in UTC.","title":"finishTime"},{"location":"all_models/#oteapi.models.transformationconfig.TransformationStatus.id","text":"ID for the given transformation process.","title":"id"},{"location":"all_models/#oteapi.models.transformationconfig.TransformationStatus.messages","text":"Messages related to the transformation process.","title":"messages"},{"location":"all_models/#oteapi.models.transformationconfig.TransformationStatus.startTime","text":"Time when the transformation process started. Given in UTC.","title":"startTime"},{"location":"all_models/#oteapi.models.transformationconfig.TransformationStatus.status","text":"Status for the transformation process.","title":"status"},{"location":"all_strategies/","text":"OTE-API Core Strategies \u00b6 This page provides documentation for the oteapi.strategies submodule, where all the core OTE-API strategies are located. These strategies will always be available when setting up a server based on the OTE-API Core package. download special \u00b6 file \u00b6 Download strategy class for the file scheme. FileConfig ( BaseModel ) pydantic-model \u00b6 File-specific Configuration Data Model. Source code in oteapi/strategies/download/file.py class FileConfig ( BaseModel ): \"\"\"File-specific Configuration Data Model.\"\"\" text : bool = Field ( False , description = ( \"Whether the file should be opened in text mode. If `False`, the file will\" \" be opened in bytes mode.\" ), ) encoding : Optional [ str ] = Field ( None , description = ( \"Encoding used when opening the file. The default is platform dependent.\" ), ) encoding : str pydantic-field \u00b6 Encoding used when opening the file. The default is platform dependent. text : bool pydantic-field \u00b6 Whether the file should be opened in text mode. If False , the file will be opened in bytes mode. FileStrategy dataclass \u00b6 Strategy for retrieving data from a local file. Registers strategies : (\"scheme\", \"file\") Source code in oteapi/strategies/download/file.py @dataclass class FileStrategy : \"\"\"Strategy for retrieving data from a local file. **Registers strategies**: - `(\"scheme\", \"file\")` \"\"\" download_config : \"ResourceConfig\" def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdate : \"\"\"Initialize.\"\"\" return SessionUpdate () def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdateFile : \"\"\"Read local file.\"\"\" if ( self . download_config . downloadUrl is None or self . download_config . downloadUrl . scheme != \"file\" ): raise ValueError ( \"Expected 'downloadUrl' to have scheme 'file' in the configuration.\" ) filename = Path ( self . download_config . downloadUrl . path ) . resolve () if isinstance ( filename , PosixPath ): filename = Path ( \"/\" + self . download_config . downloadUrl . host + str ( filename )) cache = DataCache ( self . download_config . configuration ) if cache . config . accessKey and cache . config . accessKey in cache : key = cache . config . accessKey else : config = FileConfig ( ** self . download_config . configuration ) key = cache . add ( filename . read_text ( encoding = config . encoding ) if config . text else filename . read_bytes () ) return SessionUpdateFile ( key = key ) get ( self , session = None ) \u00b6 Read local file. Source code in oteapi/strategies/download/file.py def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdateFile : \"\"\"Read local file.\"\"\" if ( self . download_config . downloadUrl is None or self . download_config . downloadUrl . scheme != \"file\" ): raise ValueError ( \"Expected 'downloadUrl' to have scheme 'file' in the configuration.\" ) filename = Path ( self . download_config . downloadUrl . path ) . resolve () if isinstance ( filename , PosixPath ): filename = Path ( \"/\" + self . download_config . downloadUrl . host + str ( filename )) cache = DataCache ( self . download_config . configuration ) if cache . config . accessKey and cache . config . accessKey in cache : key = cache . config . accessKey else : config = FileConfig ( ** self . download_config . configuration ) key = cache . add ( filename . read_text ( encoding = config . encoding ) if config . text else filename . read_bytes () ) return SessionUpdateFile ( key = key ) initialize ( self , session = None ) \u00b6 Initialize. Source code in oteapi/strategies/download/file.py def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdate : \"\"\"Initialize.\"\"\" return SessionUpdate () SessionUpdateFile ( SessionUpdate ) pydantic-model \u00b6 Class for returning values from Download File strategy. Source code in oteapi/strategies/download/file.py class SessionUpdateFile ( SessionUpdate ): \"\"\"Class for returning values from Download File strategy.\"\"\" key : str = Field ( ... , description = \"Key to access the data in the cache.\" ) key : str pydantic-field required \u00b6 Key to access the data in the cache. https \u00b6 Download strategy class for http/https HTTPSStrategy dataclass \u00b6 Strategy for retrieving data via http. Registers strategies : (\"scheme\", \"http\") (\"scheme\", \"https\") Source code in oteapi/strategies/download/https.py @dataclass class HTTPSStrategy : \"\"\"Strategy for retrieving data via http. **Registers strategies**: - `(\"scheme\", \"http\")` - `(\"scheme\", \"https\")` \"\"\" download_config : \"ResourceConfig\" def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdate : \"\"\"Initialize.\"\"\" return SessionUpdate () def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdateHTTPS : \"\"\"Download via http/https and store on local cache.\"\"\" cache = DataCache ( self . download_config . configuration ) if cache . config . accessKey and cache . config . accessKey in cache : key = cache . config . accessKey else : if not self . download_config . downloadUrl : raise ValueError ( \"downloadUrl not defined in configuration.\" ) req = requests . get ( self . download_config . downloadUrl , allow_redirects = True ) key = cache . add ( req . content ) return SessionUpdateHTTPS ( key = key ) get ( self , session = None ) \u00b6 Download via http/https and store on local cache. Source code in oteapi/strategies/download/https.py def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdateHTTPS : \"\"\"Download via http/https and store on local cache.\"\"\" cache = DataCache ( self . download_config . configuration ) if cache . config . accessKey and cache . config . accessKey in cache : key = cache . config . accessKey else : if not self . download_config . downloadUrl : raise ValueError ( \"downloadUrl not defined in configuration.\" ) req = requests . get ( self . download_config . downloadUrl , allow_redirects = True ) key = cache . add ( req . content ) return SessionUpdateHTTPS ( key = key ) initialize ( self , session = None ) \u00b6 Initialize. Source code in oteapi/strategies/download/https.py def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdate : \"\"\"Initialize.\"\"\" return SessionUpdate () SessionUpdateHTTPS ( SessionUpdate ) pydantic-model \u00b6 Class for returning values from Download HTTPS strategy. Source code in oteapi/strategies/download/https.py class SessionUpdateHTTPS ( SessionUpdate ): \"\"\"Class for returning values from Download HTTPS strategy.\"\"\" key : str = Field ( ... , description = \"Key to access the data in the cache.\" ) key : str pydantic-field required \u00b6 Key to access the data in the cache. sftp \u00b6 Strategy class for sftp/ftp SFTPStrategy dataclass \u00b6 Strategy for retrieving data via sftp. Registers strategies : (\"scheme\", \"ftp\") (\"scheme\", \"sftp\") Source code in oteapi/strategies/download/sftp.py @dataclass class SFTPStrategy : \"\"\"Strategy for retrieving data via sftp. **Registers strategies**: - `(\"scheme\", \"ftp\")` - `(\"scheme\", \"sftp\")` \"\"\" download_config : \"ResourceConfig\" def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdate : \"\"\"Initialize.\"\"\" return SessionUpdate () def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdateSFTP : \"\"\"Download via sftp\"\"\" cache = DataCache ( self . download_config . configuration ) if cache . config . accessKey and cache . config . accessKey in cache : key = cache . config . accessKey else : # Setup connection options cnopts = pysftp . CnOpts () cnopts . hostkeys = None if not self . download_config . downloadUrl : raise ValueError ( \"downloadUrl is not defined in configuration.\" ) # open connection and store data locally with pysftp . Connection ( host = self . download_config . downloadUrl . host , username = self . download_config . downloadUrl . user , password = self . download_config . downloadUrl . password , port = self . download_config . downloadUrl . port , cnopts = cnopts , ) as sftp : # Because of insane locking on Windows, we have to close # the downloaded file before adding it to the cache with NamedTemporaryFile ( prefix = \"oteapi-sftp-\" , delete = False ) as handle : localpath = Path ( handle . name ) . resolve () try : sftp . get ( self . download_config . downloadUrl . path , localpath = localpath ) key = cache . add ( localpath . read_bytes ()) finally : localpath . unlink () return SessionUpdateSFTP ( key = key ) get ( self , session = None ) \u00b6 Download via sftp Source code in oteapi/strategies/download/sftp.py def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdateSFTP : \"\"\"Download via sftp\"\"\" cache = DataCache ( self . download_config . configuration ) if cache . config . accessKey and cache . config . accessKey in cache : key = cache . config . accessKey else : # Setup connection options cnopts = pysftp . CnOpts () cnopts . hostkeys = None if not self . download_config . downloadUrl : raise ValueError ( \"downloadUrl is not defined in configuration.\" ) # open connection and store data locally with pysftp . Connection ( host = self . download_config . downloadUrl . host , username = self . download_config . downloadUrl . user , password = self . download_config . downloadUrl . password , port = self . download_config . downloadUrl . port , cnopts = cnopts , ) as sftp : # Because of insane locking on Windows, we have to close # the downloaded file before adding it to the cache with NamedTemporaryFile ( prefix = \"oteapi-sftp-\" , delete = False ) as handle : localpath = Path ( handle . name ) . resolve () try : sftp . get ( self . download_config . downloadUrl . path , localpath = localpath ) key = cache . add ( localpath . read_bytes ()) finally : localpath . unlink () return SessionUpdateSFTP ( key = key ) initialize ( self , session = None ) \u00b6 Initialize. Source code in oteapi/strategies/download/sftp.py def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdate : \"\"\"Initialize.\"\"\" return SessionUpdate () SessionUpdateSFTP ( SessionUpdate ) pydantic-model \u00b6 Class for returning values from Download SFTP strategy. Source code in oteapi/strategies/download/sftp.py class SessionUpdateSFTP ( SessionUpdate ): \"\"\"Class for returning values from Download SFTP strategy.\"\"\" key : str = Field ( ... , description = \"Key to access the data in the cache.\" ) key : str pydantic-field required \u00b6 Key to access the data in the cache. filter special \u00b6 crop_filter \u00b6 Demo-filter strategy CropFilter dataclass \u00b6 Strategy for cropping an image. Registers strategies : (\"filterType\", \"filter/crop\") Source code in oteapi/strategies/filter/crop_filter.py @dataclass class CropFilter : \"\"\"Strategy for cropping an image. **Registers strategies**: - `(\"filterType\", \"filter/crop\")` \"\"\" filter_config : \"FilterConfig\" def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdate : \"\"\"Initialize strategy and return a dictionary.\"\"\" return SessionUpdate () def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdateCrop : \"\"\"Execute strategy and return a dictionary\"\"\" cropData = ( SessionUpdateCrop ( ** self . filter_config . configuration ) if self . filter_config . configuration else SessionUpdateCrop () ) return cropData get ( self , session = None ) \u00b6 Execute strategy and return a dictionary Source code in oteapi/strategies/filter/crop_filter.py def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdateCrop : \"\"\"Execute strategy and return a dictionary\"\"\" cropData = ( SessionUpdateCrop ( ** self . filter_config . configuration ) if self . filter_config . configuration else SessionUpdateCrop () ) return cropData initialize ( self , session = None ) \u00b6 Initialize strategy and return a dictionary. Source code in oteapi/strategies/filter/crop_filter.py def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdate : \"\"\"Initialize strategy and return a dictionary.\"\"\" return SessionUpdate () SessionUpdateCrop ( SessionUpdate ) pydantic-model \u00b6 Class for returning values from crop data. Source code in oteapi/strategies/filter/crop_filter.py class SessionUpdateCrop ( SessionUpdate ): \"\"\"Class for returning values from crop data.\"\"\" crop : List [ int ] = Field ( ... , description = \"List of image cropping details.\" ) crop : List [ int ] pydantic-field required \u00b6 List of image cropping details. sql_query_filter \u00b6 SQL query filter strategy. SQLQueryFilter dataclass \u00b6 Strategy for a SQL query filter. Registers strategies : (\"filterType\", \"filter/sql\") Source code in oteapi/strategies/filter/sql_query_filter.py @dataclass class SQLQueryFilter : \"\"\"Strategy for a SQL query filter. **Registers strategies**: - `(\"filterType\", \"filter/sql\")` \"\"\" filter_config : \"FilterConfig\" def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdateSqlQuery : \"\"\"Initialize strategy and return a dictionary\"\"\" return SessionUpdateSqlQuery ( ** { \"query\" : self . filter_config . query }) def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdate : \"\"\"Execute strategy and return a dictionary\"\"\" return SessionUpdate () get ( self , session = None ) \u00b6 Execute strategy and return a dictionary Source code in oteapi/strategies/filter/sql_query_filter.py def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdate : \"\"\"Execute strategy and return a dictionary\"\"\" return SessionUpdate () initialize ( self , session = None ) \u00b6 Initialize strategy and return a dictionary Source code in oteapi/strategies/filter/sql_query_filter.py def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdateSqlQuery : \"\"\"Initialize strategy and return a dictionary\"\"\" return SessionUpdateSqlQuery ( ** { \"query\" : self . filter_config . query }) SessionUpdateSqlQuery ( SessionUpdate ) pydantic-model \u00b6 Class for returning values from SQL Query data model. Source code in oteapi/strategies/filter/sql_query_filter.py class SessionUpdateSqlQuery ( SessionUpdate ): \"\"\"Class for returning values from SQL Query data model.\"\"\" query : str = Field ( ... , description = \"A SQL query string.\" ) query : str pydantic-field required \u00b6 A SQL query string. parse special \u00b6 application_json \u00b6 Strategy class for application/json. JSONDataParseStrategy dataclass \u00b6 Parse strategy for JSON. Registers strategies : (\"mediaType\", \"application/json\") Source code in oteapi/strategies/parse/application_json.py @dataclass class JSONDataParseStrategy : \"\"\"Parse strategy for JSON. **Registers strategies**: - `(\"mediaType\", \"application/json\")` \"\"\" parse_config : \"ResourceConfig\" def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdate : \"\"\"Initialize.\"\"\" return SessionUpdate () def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdateJSONParse : \"\"\"Parse json.\"\"\" downloader = create_strategy ( \"download\" , self . parse_config ) output = downloader . get () cache = DataCache ( self . parse_config . configuration ) content = cache . get ( output [ \"key\" ]) if isinstance ( content , dict ): return SessionUpdateJSONParse ( content = content ) return SessionUpdateJSONParse ( content = json . loads ( content )) get ( self , session = None ) \u00b6 Parse json. Source code in oteapi/strategies/parse/application_json.py def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdateJSONParse : \"\"\"Parse json.\"\"\" downloader = create_strategy ( \"download\" , self . parse_config ) output = downloader . get () cache = DataCache ( self . parse_config . configuration ) content = cache . get ( output [ \"key\" ]) if isinstance ( content , dict ): return SessionUpdateJSONParse ( content = content ) return SessionUpdateJSONParse ( content = json . loads ( content )) initialize ( self , session = None ) \u00b6 Initialize. Source code in oteapi/strategies/parse/application_json.py def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdate : \"\"\"Initialize.\"\"\" return SessionUpdate () SessionUpdateJSONParse ( SessionUpdate ) pydantic-model \u00b6 Class for returning values from JSON Parse. Source code in oteapi/strategies/parse/application_json.py class SessionUpdateJSONParse ( SessionUpdate ): \"\"\"Class for returning values from JSON Parse.\"\"\" content : dict = Field ( ... , description = \"Content of the JSON document.\" ) content : dict pydantic-field required \u00b6 Content of the JSON document. application_vnd_sqlite \u00b6 Strategy class for application/vnd.sqlite3. SessionUpdateSqLiteParse ( SessionUpdate ) pydantic-model \u00b6 Configuration model for SqLiteParse. Source code in oteapi/strategies/parse/application_vnd_sqlite.py class SessionUpdateSqLiteParse ( SessionUpdate ): \"\"\"Configuration model for SqLiteParse.\"\"\" result : Optional [ list ] = Field ( None , description = \"List of results from the query.\" ) msg : str = Field ( ... , description = \"Messsage concerning the execution of the query.\" ) msg : str pydantic-field required \u00b6 Messsage concerning the execution of the query. result : list pydantic-field \u00b6 List of results from the query. SqliteParseStrategy dataclass \u00b6 Parse strategy for SQLite. Registers strategies : (\"mediaType\", \"application/vnd.sqlite3\") Source code in oteapi/strategies/parse/application_vnd_sqlite.py @dataclass class SqliteParseStrategy : \"\"\"Parse strategy for SQLite. **Registers strategies**: - `(\"mediaType\", \"application/vnd.sqlite3\")` \"\"\" parse_config : \"ResourceConfig\" def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdateSqLiteParse : \"\"\"Parse SQLite query responses.\"\"\" if session is None : raise ValueError ( \"Missing session\" ) if \"sqlquery\" in session : cn = create_connection ( session [ \"filename\" ]) cur = cn . cursor () rows = cur . execute ( session [ \"sqlquery\" ]) . fetchall () return SessionUpdateSqLiteParse ( result = rows , msg = \"Query executed\" ) return SessionUpdateSqLiteParse ( msg = \"No query given\" ) def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdate : \"\"\"Initialize.\"\"\" return SessionUpdate () get ( self , session = None ) \u00b6 Parse SQLite query responses. Source code in oteapi/strategies/parse/application_vnd_sqlite.py def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdateSqLiteParse : \"\"\"Parse SQLite query responses.\"\"\" if session is None : raise ValueError ( \"Missing session\" ) if \"sqlquery\" in session : cn = create_connection ( session [ \"filename\" ]) cur = cn . cursor () rows = cur . execute ( session [ \"sqlquery\" ]) . fetchall () return SessionUpdateSqLiteParse ( result = rows , msg = \"Query executed\" ) return SessionUpdateSqLiteParse ( msg = \"No query given\" ) initialize ( self , session = None ) \u00b6 Initialize. Source code in oteapi/strategies/parse/application_vnd_sqlite.py def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdate : \"\"\"Initialize.\"\"\" return SessionUpdate () create_connection ( db_file ) \u00b6 create a database connection to the SQLite database specified by db_file :param db_file: database file :return: Connection object or None Source code in oteapi/strategies/parse/application_vnd_sqlite.py def create_connection ( db_file ): \"\"\"create a database connection to the SQLite database specified by db_file :param db_file: database file :return: Connection object or None \"\"\" conn = None try : conn = sqlite3 . connect ( db_file ) return conn except sqlite3 . Error as exc : print ( exc ) return conn excel_xlsx \u00b6 Strategy class for workbook/xlsx. SessionUpdateXLSXParse ( SessionUpdate ) pydantic-model \u00b6 Class for returning values from XLSXParse. Source code in oteapi/strategies/parse/excel_xlsx.py class SessionUpdateXLSXParse ( SessionUpdate ): \"\"\"Class for returning values from XLSXParse.\"\"\" data : Dict [ str , list ] = Field ( ... , description = \"A dict with column-name/column-value pairs. The values are lists.\" , ) data : Dict [ str , list ] pydantic-field required \u00b6 A dict with column-name/column-value pairs. The values are lists. XLSXParseDataModel ( BaseModel ) pydantic-model \u00b6 Data model for retrieving a rectangular section of an Excel sheet. Source code in oteapi/strategies/parse/excel_xlsx.py class XLSXParseDataModel ( BaseModel ): \"\"\"Data model for retrieving a rectangular section of an Excel sheet.\"\"\" worksheet : str = Field ( ... , description = \"Name of worksheet to load.\" ) row_from : Optional [ int ] = Field ( None , description = \"Excel row number of first row. Defaults to first assigned row.\" , ) col_from : Optional [ Union [ int , str ]] = Field ( None , description = ( \"Excel column number or label of first column. Defaults to first assigned \" \"column.\" ), ) row_to : Optional [ int ] = Field ( None , description = \"Excel row number of last row. Defaults to last assigned row.\" ) col_to : Optional [ Union [ int , str ]] = Field ( None , description = ( \"Excel column number or label of last column. Defaults to last assigned \" \"column.\" ), ) header_row : Optional [ int ] = Field ( None , description = ( \"Row number with the headers. Defaults to `1` if header is given, \" \"otherwise `None`.\" ), ) header : Optional [ List [ str ]] = Field ( None , description = ( \"Optional list of column names, specifying the columns to return. \" \"These names they should match cells in `header_row`.\" ), ) new_header : Optional [ List [ str ]] = Field ( None , description = ( \"Optional list of new column names replacing `header` in the output.\" ), ) download_config : AttrDict = Field ( AttrDict (), description = \"Configurations provided to a download strategy.\" , ) col_from : Union [ int , str ] pydantic-field \u00b6 Excel column number or label of first column. Defaults to first assigned column. col_to : Union [ int , str ] pydantic-field \u00b6 Excel column number or label of last column. Defaults to last assigned column. download_config : AttrDict pydantic-field \u00b6 Configurations provided to a download strategy. header : List [ str ] pydantic-field \u00b6 Optional list of column names, specifying the columns to return. These names they should match cells in header_row . header_row : int pydantic-field \u00b6 Row number with the headers. Defaults to 1 if header is given, otherwise None . new_header : List [ str ] pydantic-field \u00b6 Optional list of new column names replacing header in the output. row_from : int pydantic-field \u00b6 Excel row number of first row. Defaults to first assigned row. row_to : int pydantic-field \u00b6 Excel row number of last row. Defaults to last assigned row. worksheet : str pydantic-field required \u00b6 Name of worksheet to load. XLSXParseStrategy dataclass \u00b6 Parse strategy for Excel XLSX files. Registers strategies : (\"mediaType\", \"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\") Source code in oteapi/strategies/parse/excel_xlsx.py @dataclass class XLSXParseStrategy : \"\"\"Parse strategy for Excel XLSX files. **Registers strategies**: - `(\"mediaType\", \"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\")` \"\"\" parse_config : \"ResourceConfig\" def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdate : \"\"\"Initialize.\"\"\" return SessionUpdate () def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdateXLSXParse : \"\"\"Parses selected region of an excel file. Returns: A dict with column-name/column-value pairs. The values are lists. \"\"\" model = XLSXParseDataModel ( ** self . parse_config . configuration ) download_config = self . parse_config . copy () download_config . configuration = model . download_config downloader = create_strategy ( \"download\" , download_config ) output = downloader . get () cache = DataCache ( self . parse_config . configuration ) with cache . getfile ( key = output [ \"key\" ], suffix = \".xlsx\" ) as filename : workbook = load_workbook ( filename = filename , read_only = True , data_only = True ) worksheet = workbook [ model . worksheet ] set_model_defaults ( model , worksheet ) columns = get_column_indices ( model , worksheet ) data = [] for row in worksheet . iter_rows ( min_row = model . row_from , max_row = model . row_to , min_col = min ( columns ), max_col = max ( columns ), ): data . append ([ row [ c - 1 ] . value for c in columns ]) if model . header_row : row = worksheet . iter_rows ( min_row = model . header_row , max_row = model . header_row , min_col = min ( columns ), max_col = max ( columns ), ) . __next__ () header = [ row [ c - 1 ] . value for c in columns ] else : header = None if model . new_header : nhead = len ( header ) if header else len ( data [ 0 ]) if data else 0 if len ( model . new_header ) != nhead : raise TypeError ( f \"length of `new_header` (= { len ( model . new_header ) } ) \" f \"doesn't match number of columns (= { len ( header ) if header else 0 } )\" ) if header : for i , val in enumerate ( model . new_header ): if val is not None : header [ i ] = val elif data : header = model . new_header if header is None : header = [ get_column_letter ( col + 1 ) for col in range ( len ( data ))] transposed = [ list ( datum ) for datum in zip ( * data )] return SessionUpdateXLSXParse ( data = { key : value for key , value in zip ( header , transposed )} ) get ( self , session = None ) \u00b6 Parses selected region of an excel file. Returns: Type Description SessionUpdateXLSXParse A dict with column-name/column-value pairs. The values are lists. Source code in oteapi/strategies/parse/excel_xlsx.py def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdateXLSXParse : \"\"\"Parses selected region of an excel file. Returns: A dict with column-name/column-value pairs. The values are lists. \"\"\" model = XLSXParseDataModel ( ** self . parse_config . configuration ) download_config = self . parse_config . copy () download_config . configuration = model . download_config downloader = create_strategy ( \"download\" , download_config ) output = downloader . get () cache = DataCache ( self . parse_config . configuration ) with cache . getfile ( key = output [ \"key\" ], suffix = \".xlsx\" ) as filename : workbook = load_workbook ( filename = filename , read_only = True , data_only = True ) worksheet = workbook [ model . worksheet ] set_model_defaults ( model , worksheet ) columns = get_column_indices ( model , worksheet ) data = [] for row in worksheet . iter_rows ( min_row = model . row_from , max_row = model . row_to , min_col = min ( columns ), max_col = max ( columns ), ): data . append ([ row [ c - 1 ] . value for c in columns ]) if model . header_row : row = worksheet . iter_rows ( min_row = model . header_row , max_row = model . header_row , min_col = min ( columns ), max_col = max ( columns ), ) . __next__ () header = [ row [ c - 1 ] . value for c in columns ] else : header = None if model . new_header : nhead = len ( header ) if header else len ( data [ 0 ]) if data else 0 if len ( model . new_header ) != nhead : raise TypeError ( f \"length of `new_header` (= { len ( model . new_header ) } ) \" f \"doesn't match number of columns (= { len ( header ) if header else 0 } )\" ) if header : for i , val in enumerate ( model . new_header ): if val is not None : header [ i ] = val elif data : header = model . new_header if header is None : header = [ get_column_letter ( col + 1 ) for col in range ( len ( data ))] transposed = [ list ( datum ) for datum in zip ( * data )] return SessionUpdateXLSXParse ( data = { key : value for key , value in zip ( header , transposed )} ) initialize ( self , session = None ) \u00b6 Initialize. Source code in oteapi/strategies/parse/excel_xlsx.py def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdate : \"\"\"Initialize.\"\"\" return SessionUpdate () get_column_indices ( model , worksheet ) \u00b6 Helper function returning a list of column indices. Parameters: Name Type Description Default model XLSXParseDataModel The parsed data model. required worksheet Worksheet Excel worksheet, from which the header values will be retrieved. required Returns: Type Description Iterable[int] A list of column indices. Source code in oteapi/strategies/parse/excel_xlsx.py def get_column_indices ( model : XLSXParseDataModel , worksheet : \"Worksheet\" ) -> \"Iterable[int]\" : \"\"\"Helper function returning a list of column indices. Parameters: model: The parsed data model. worksheet: Excel worksheet, from which the header values will be retrieved. Returns: A list of column indices. \"\"\" if not isinstance ( model . col_from , int ) or not isinstance ( model . col_to , int ): raise TypeError ( \"Expected `model.col_from` and `model.col_to` to be integers.\" ) if model . header : header_dict = { worksheet . cell ( model . header_row , col ) . value : col for col in range ( model . col_from , model . col_to + 1 ) } return [ header_dict [ h ] for h in model . header ] return range ( model . col_from , model . col_to + 1 ) set_model_defaults ( model , worksheet ) \u00b6 Update data model model with default values obtained from worksheet . Parameters: Name Type Description Default model XLSXParseDataModel The parsed data model. required worksheet Worksheet Excel worksheet, from which the default values will be obtained. required Source code in oteapi/strategies/parse/excel_xlsx.py def set_model_defaults ( model : XLSXParseDataModel , worksheet : \"Worksheet\" ) -> None : \"\"\"Update data model `model` with default values obtained from `worksheet`. Parameters: model: The parsed data model. worksheet: Excel worksheet, from which the default values will be obtained. \"\"\" if model . row_from is None : if model . header : # assume that data starts on the first row after the header model . row_from = model . header_row + 1 if model . header_row else 1 else : model . row_from = worksheet . min_row if model . row_to is None : model . row_to = worksheet . max_row if model . col_from is None : model . col_from = worksheet . min_column elif isinstance ( model . col_from , str ): model . col_from = column_index_from_string ( model . col_from ) if model . col_to is None : model . col_to = worksheet . max_column elif isinstance ( model . col_to , str ): model . col_to = column_index_from_string ( model . col_to ) if model . header and not model . header_row : model . header_row = 1 image \u00b6 Strategy class for image/jpg. ImageDataParseStrategy dataclass \u00b6 Parse strategy for images. Registers strategies : (\"mediaType\", \"image/jpg\") (\"mediaType\", \"image/jpeg\") (\"mediaType\", \"image/jp2\") (\"mediaType\", \"image/png\") (\"mediaType\", \"image/gif\") (\"mediaType\", \"image/tiff\") (\"mediaType\", \"image/eps\") Source code in oteapi/strategies/parse/image.py @dataclass class ImageDataParseStrategy : \"\"\"Parse strategy for images. **Registers strategies**: - `(\"mediaType\", \"image/jpg\")` - `(\"mediaType\", \"image/jpeg\")` - `(\"mediaType\", \"image/jp2\")` - `(\"mediaType\", \"image/png\")` - `(\"mediaType\", \"image/gif\")` - `(\"mediaType\", \"image/tiff\")` - `(\"mediaType\", \"image/eps\")` \"\"\" parse_config : \"ResourceConfig\" def __post_init__ ( self ): self . localpath = \"/ote-data\" self . filename = self . parse_config . configuration [ \"filename\" ] self . conf = self . parse_config . configuration if \"localpath\" in self . conf : self . localpath = self . conf [ \"localpath\" ] def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdate : \"\"\"Initialize.\"\"\" return SessionUpdate () def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdateImageParse : if session is not None : self . conf . update ( session ) parsedOutput = {} if \"crop\" in self . conf : print ( \"cropping!\" ) im = Image . open ( f \" { self . localpath } / { self . filename } \" ) crop = self . conf [ \"crop\" ] im_cropped = im . crop ( tuple ( crop )) cropped_filename = f \" { self . localpath } /cropped_ { self . filename } \" im_cropped . save ( cropped_filename ) parsedOutput [ \"cropped_filename\" ] = cropped_filename parsedOutput [ \"parseImage\" ] = \"Done\" return SessionUpdateImageParse ( parsedOutput = parsedOutput ) initialize ( self , session = None ) \u00b6 Initialize. Source code in oteapi/strategies/parse/image.py def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdate : \"\"\"Initialize.\"\"\" return SessionUpdate () SessionUpdateImageParse ( SessionUpdate ) pydantic-model \u00b6 Configuration model for ImageParse. Source code in oteapi/strategies/parse/image.py class SessionUpdateImageParse ( SessionUpdate ): \"\"\"Configuration model for ImageParse.\"\"\" parsedOutput : Dict [ str , str ] = Field ( ... , description = \"Parsed output from ImageParse.\" ) parsedOutput : Dict [ str , str ] pydantic-field required \u00b6 Parsed output from ImageParse. text_csv \u00b6 Strategy class for text/csv. CSVParseStrategy dataclass \u00b6 Parse strategy for CSV files. Registers strategies : (\"mediaType\", \"text/csv\") Source code in oteapi/strategies/parse/text_csv.py @dataclass class CSVParseStrategy : \"\"\"Parse strategy for CSV files. **Registers strategies**: - `(\"mediaType\", \"text/csv\")` \"\"\" parse_config : \"ResourceConfig\" def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdate : \"\"\"Parse CSV.\"\"\" return SessionUpdate () def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdate : \"\"\"Initialize.\"\"\" return SessionUpdate () get ( self , session = None ) \u00b6 Parse CSV. Source code in oteapi/strategies/parse/text_csv.py def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdate : \"\"\"Parse CSV.\"\"\" return SessionUpdate () initialize ( self , session = None ) \u00b6 Initialize. Source code in oteapi/strategies/parse/text_csv.py def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdate : \"\"\"Initialize.\"\"\" return SessionUpdate () transformation special \u00b6 celery_remote \u00b6 Transformation Plugin that uses the Celery framework to call remote workers. CeleryConfig ( BaseModel ) pydantic-model \u00b6 Celery configuration. Source code in oteapi/strategies/transformation/celery_remote.py class CeleryConfig ( BaseModel ): \"\"\"Celery configuration.\"\"\" task_name : str = Field ( ... , description = \"A task name.\" ) args : list = Field ( ... , description = \"List of arguments for the task.\" ) args : list pydantic-field required \u00b6 List of arguments for the task. task_name : str pydantic-field required \u00b6 A task name. CeleryRemoteStrategy dataclass \u00b6 Submit job to remote Celery runner. Registers strategies : (\"transformationType\", \"celery/remote\") Source code in oteapi/strategies/transformation/celery_remote.py @dataclass class CeleryRemoteStrategy : \"\"\"Submit job to remote Celery runner. **Registers strategies**: - `(\"transformationType\", \"celery/remote\")` \"\"\" transformation_config : \"TransformationConfig\" def run ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> TransformationStatus : \"\"\"Run a job, return a job ID.\"\"\" config = self . transformation_config . configuration celery_config = CeleryConfig () if config is None else CeleryConfig ( ** config ) result : \"Union[AsyncResult, Any]\" = app . send_task ( celery_config . task_name , celery_config . args , kwargs = session ) status = AsyncResult ( id = result . task_id , app = app ) return TransformationStatus ( id = result . task_id , status = status . status ) def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdate : \"\"\"Initialize a job.\"\"\" return SessionUpdate () def status ( self , task_id : str ) -> TransformationStatus : \"\"\"Get job status.\"\"\" result = AsyncResult ( id = task_id , app = app ) return TransformationStatus ( id = task_id , status = result . state ) def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"SessionUpdateCelery\" : \"\"\"Get transformation.\"\"\" # TODO: update and return global state # pylint: disable=fixme return SessionUpdateCelery ( data = {}) get ( self , session = None ) \u00b6 Get transformation. Source code in oteapi/strategies/transformation/celery_remote.py def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"SessionUpdateCelery\" : \"\"\"Get transformation.\"\"\" # TODO: update and return global state # pylint: disable=fixme return SessionUpdateCelery ( data = {}) initialize ( self , session = None ) \u00b6 Initialize a job. Source code in oteapi/strategies/transformation/celery_remote.py def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdate : \"\"\"Initialize a job.\"\"\" return SessionUpdate () run ( self , session = None ) \u00b6 Run a job, return a job ID. Source code in oteapi/strategies/transformation/celery_remote.py def run ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> TransformationStatus : \"\"\"Run a job, return a job ID.\"\"\" config = self . transformation_config . configuration celery_config = CeleryConfig () if config is None else CeleryConfig ( ** config ) result : \"Union[AsyncResult, Any]\" = app . send_task ( celery_config . task_name , celery_config . args , kwargs = session ) status = AsyncResult ( id = result . task_id , app = app ) return TransformationStatus ( id = result . task_id , status = status . status ) status ( self , task_id ) \u00b6 Get job status. Source code in oteapi/strategies/transformation/celery_remote.py def status ( self , task_id : str ) -> TransformationStatus : \"\"\"Get job status.\"\"\" result = AsyncResult ( id = task_id , app = app ) return TransformationStatus ( id = task_id , status = result . state ) SessionUpdateCelery ( SessionUpdate ) pydantic-model \u00b6 Class for returning values from XLSXParse. Source code in oteapi/strategies/transformation/celery_remote.py class SessionUpdateCelery ( SessionUpdate ): \"\"\"Class for returning values from XLSXParse.\"\"\" data : Dict [ str , list ] = Field ( ... , description = \"A dict with column-name/column-value pairs. The values are lists.\" , ) data : Dict [ str , list ] pydantic-field required \u00b6 A dict with column-name/column-value pairs. The values are lists.","title":"OTE-API Core Strategies"},{"location":"all_strategies/#ote-api-core-strategies","text":"This page provides documentation for the oteapi.strategies submodule, where all the core OTE-API strategies are located. These strategies will always be available when setting up a server based on the OTE-API Core package.","title":"OTE-API Core Strategies"},{"location":"all_strategies/#oteapi.strategies.download","text":"","title":"download"},{"location":"all_strategies/#oteapi.strategies.download.file","text":"Download strategy class for the file scheme.","title":"file"},{"location":"all_strategies/#oteapi.strategies.download.file.FileConfig","text":"File-specific Configuration Data Model. Source code in oteapi/strategies/download/file.py class FileConfig ( BaseModel ): \"\"\"File-specific Configuration Data Model.\"\"\" text : bool = Field ( False , description = ( \"Whether the file should be opened in text mode. If `False`, the file will\" \" be opened in bytes mode.\" ), ) encoding : Optional [ str ] = Field ( None , description = ( \"Encoding used when opening the file. The default is platform dependent.\" ), )","title":"FileConfig"},{"location":"all_strategies/#oteapi.strategies.download.file.FileConfig.encoding","text":"Encoding used when opening the file. The default is platform dependent.","title":"encoding"},{"location":"all_strategies/#oteapi.strategies.download.file.FileConfig.text","text":"Whether the file should be opened in text mode. If False , the file will be opened in bytes mode.","title":"text"},{"location":"all_strategies/#oteapi.strategies.download.file.FileStrategy","text":"Strategy for retrieving data from a local file. Registers strategies : (\"scheme\", \"file\") Source code in oteapi/strategies/download/file.py @dataclass class FileStrategy : \"\"\"Strategy for retrieving data from a local file. **Registers strategies**: - `(\"scheme\", \"file\")` \"\"\" download_config : \"ResourceConfig\" def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdate : \"\"\"Initialize.\"\"\" return SessionUpdate () def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdateFile : \"\"\"Read local file.\"\"\" if ( self . download_config . downloadUrl is None or self . download_config . downloadUrl . scheme != \"file\" ): raise ValueError ( \"Expected 'downloadUrl' to have scheme 'file' in the configuration.\" ) filename = Path ( self . download_config . downloadUrl . path ) . resolve () if isinstance ( filename , PosixPath ): filename = Path ( \"/\" + self . download_config . downloadUrl . host + str ( filename )) cache = DataCache ( self . download_config . configuration ) if cache . config . accessKey and cache . config . accessKey in cache : key = cache . config . accessKey else : config = FileConfig ( ** self . download_config . configuration ) key = cache . add ( filename . read_text ( encoding = config . encoding ) if config . text else filename . read_bytes () ) return SessionUpdateFile ( key = key )","title":"FileStrategy"},{"location":"all_strategies/#oteapi.strategies.download.file.FileStrategy.get","text":"Read local file. Source code in oteapi/strategies/download/file.py def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdateFile : \"\"\"Read local file.\"\"\" if ( self . download_config . downloadUrl is None or self . download_config . downloadUrl . scheme != \"file\" ): raise ValueError ( \"Expected 'downloadUrl' to have scheme 'file' in the configuration.\" ) filename = Path ( self . download_config . downloadUrl . path ) . resolve () if isinstance ( filename , PosixPath ): filename = Path ( \"/\" + self . download_config . downloadUrl . host + str ( filename )) cache = DataCache ( self . download_config . configuration ) if cache . config . accessKey and cache . config . accessKey in cache : key = cache . config . accessKey else : config = FileConfig ( ** self . download_config . configuration ) key = cache . add ( filename . read_text ( encoding = config . encoding ) if config . text else filename . read_bytes () ) return SessionUpdateFile ( key = key )","title":"get()"},{"location":"all_strategies/#oteapi.strategies.download.file.FileStrategy.initialize","text":"Initialize. Source code in oteapi/strategies/download/file.py def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdate : \"\"\"Initialize.\"\"\" return SessionUpdate ()","title":"initialize()"},{"location":"all_strategies/#oteapi.strategies.download.file.SessionUpdateFile","text":"Class for returning values from Download File strategy. Source code in oteapi/strategies/download/file.py class SessionUpdateFile ( SessionUpdate ): \"\"\"Class for returning values from Download File strategy.\"\"\" key : str = Field ( ... , description = \"Key to access the data in the cache.\" )","title":"SessionUpdateFile"},{"location":"all_strategies/#oteapi.strategies.download.file.SessionUpdateFile.key","text":"Key to access the data in the cache.","title":"key"},{"location":"all_strategies/#oteapi.strategies.download.https","text":"Download strategy class for http/https","title":"https"},{"location":"all_strategies/#oteapi.strategies.download.https.HTTPSStrategy","text":"Strategy for retrieving data via http. Registers strategies : (\"scheme\", \"http\") (\"scheme\", \"https\") Source code in oteapi/strategies/download/https.py @dataclass class HTTPSStrategy : \"\"\"Strategy for retrieving data via http. **Registers strategies**: - `(\"scheme\", \"http\")` - `(\"scheme\", \"https\")` \"\"\" download_config : \"ResourceConfig\" def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdate : \"\"\"Initialize.\"\"\" return SessionUpdate () def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdateHTTPS : \"\"\"Download via http/https and store on local cache.\"\"\" cache = DataCache ( self . download_config . configuration ) if cache . config . accessKey and cache . config . accessKey in cache : key = cache . config . accessKey else : if not self . download_config . downloadUrl : raise ValueError ( \"downloadUrl not defined in configuration.\" ) req = requests . get ( self . download_config . downloadUrl , allow_redirects = True ) key = cache . add ( req . content ) return SessionUpdateHTTPS ( key = key )","title":"HTTPSStrategy"},{"location":"all_strategies/#oteapi.strategies.download.https.HTTPSStrategy.get","text":"Download via http/https and store on local cache. Source code in oteapi/strategies/download/https.py def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdateHTTPS : \"\"\"Download via http/https and store on local cache.\"\"\" cache = DataCache ( self . download_config . configuration ) if cache . config . accessKey and cache . config . accessKey in cache : key = cache . config . accessKey else : if not self . download_config . downloadUrl : raise ValueError ( \"downloadUrl not defined in configuration.\" ) req = requests . get ( self . download_config . downloadUrl , allow_redirects = True ) key = cache . add ( req . content ) return SessionUpdateHTTPS ( key = key )","title":"get()"},{"location":"all_strategies/#oteapi.strategies.download.https.HTTPSStrategy.initialize","text":"Initialize. Source code in oteapi/strategies/download/https.py def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdate : \"\"\"Initialize.\"\"\" return SessionUpdate ()","title":"initialize()"},{"location":"all_strategies/#oteapi.strategies.download.https.SessionUpdateHTTPS","text":"Class for returning values from Download HTTPS strategy. Source code in oteapi/strategies/download/https.py class SessionUpdateHTTPS ( SessionUpdate ): \"\"\"Class for returning values from Download HTTPS strategy.\"\"\" key : str = Field ( ... , description = \"Key to access the data in the cache.\" )","title":"SessionUpdateHTTPS"},{"location":"all_strategies/#oteapi.strategies.download.https.SessionUpdateHTTPS.key","text":"Key to access the data in the cache.","title":"key"},{"location":"all_strategies/#oteapi.strategies.download.sftp","text":"Strategy class for sftp/ftp","title":"sftp"},{"location":"all_strategies/#oteapi.strategies.download.sftp.SFTPStrategy","text":"Strategy for retrieving data via sftp. Registers strategies : (\"scheme\", \"ftp\") (\"scheme\", \"sftp\") Source code in oteapi/strategies/download/sftp.py @dataclass class SFTPStrategy : \"\"\"Strategy for retrieving data via sftp. **Registers strategies**: - `(\"scheme\", \"ftp\")` - `(\"scheme\", \"sftp\")` \"\"\" download_config : \"ResourceConfig\" def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdate : \"\"\"Initialize.\"\"\" return SessionUpdate () def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdateSFTP : \"\"\"Download via sftp\"\"\" cache = DataCache ( self . download_config . configuration ) if cache . config . accessKey and cache . config . accessKey in cache : key = cache . config . accessKey else : # Setup connection options cnopts = pysftp . CnOpts () cnopts . hostkeys = None if not self . download_config . downloadUrl : raise ValueError ( \"downloadUrl is not defined in configuration.\" ) # open connection and store data locally with pysftp . Connection ( host = self . download_config . downloadUrl . host , username = self . download_config . downloadUrl . user , password = self . download_config . downloadUrl . password , port = self . download_config . downloadUrl . port , cnopts = cnopts , ) as sftp : # Because of insane locking on Windows, we have to close # the downloaded file before adding it to the cache with NamedTemporaryFile ( prefix = \"oteapi-sftp-\" , delete = False ) as handle : localpath = Path ( handle . name ) . resolve () try : sftp . get ( self . download_config . downloadUrl . path , localpath = localpath ) key = cache . add ( localpath . read_bytes ()) finally : localpath . unlink () return SessionUpdateSFTP ( key = key )","title":"SFTPStrategy"},{"location":"all_strategies/#oteapi.strategies.download.sftp.SFTPStrategy.get","text":"Download via sftp Source code in oteapi/strategies/download/sftp.py def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdateSFTP : \"\"\"Download via sftp\"\"\" cache = DataCache ( self . download_config . configuration ) if cache . config . accessKey and cache . config . accessKey in cache : key = cache . config . accessKey else : # Setup connection options cnopts = pysftp . CnOpts () cnopts . hostkeys = None if not self . download_config . downloadUrl : raise ValueError ( \"downloadUrl is not defined in configuration.\" ) # open connection and store data locally with pysftp . Connection ( host = self . download_config . downloadUrl . host , username = self . download_config . downloadUrl . user , password = self . download_config . downloadUrl . password , port = self . download_config . downloadUrl . port , cnopts = cnopts , ) as sftp : # Because of insane locking on Windows, we have to close # the downloaded file before adding it to the cache with NamedTemporaryFile ( prefix = \"oteapi-sftp-\" , delete = False ) as handle : localpath = Path ( handle . name ) . resolve () try : sftp . get ( self . download_config . downloadUrl . path , localpath = localpath ) key = cache . add ( localpath . read_bytes ()) finally : localpath . unlink () return SessionUpdateSFTP ( key = key )","title":"get()"},{"location":"all_strategies/#oteapi.strategies.download.sftp.SFTPStrategy.initialize","text":"Initialize. Source code in oteapi/strategies/download/sftp.py def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdate : \"\"\"Initialize.\"\"\" return SessionUpdate ()","title":"initialize()"},{"location":"all_strategies/#oteapi.strategies.download.sftp.SessionUpdateSFTP","text":"Class for returning values from Download SFTP strategy. Source code in oteapi/strategies/download/sftp.py class SessionUpdateSFTP ( SessionUpdate ): \"\"\"Class for returning values from Download SFTP strategy.\"\"\" key : str = Field ( ... , description = \"Key to access the data in the cache.\" )","title":"SessionUpdateSFTP"},{"location":"all_strategies/#oteapi.strategies.download.sftp.SessionUpdateSFTP.key","text":"Key to access the data in the cache.","title":"key"},{"location":"all_strategies/#oteapi.strategies.filter","text":"","title":"filter"},{"location":"all_strategies/#oteapi.strategies.filter.crop_filter","text":"Demo-filter strategy","title":"crop_filter"},{"location":"all_strategies/#oteapi.strategies.filter.crop_filter.CropFilter","text":"Strategy for cropping an image. Registers strategies : (\"filterType\", \"filter/crop\") Source code in oteapi/strategies/filter/crop_filter.py @dataclass class CropFilter : \"\"\"Strategy for cropping an image. **Registers strategies**: - `(\"filterType\", \"filter/crop\")` \"\"\" filter_config : \"FilterConfig\" def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdate : \"\"\"Initialize strategy and return a dictionary.\"\"\" return SessionUpdate () def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdateCrop : \"\"\"Execute strategy and return a dictionary\"\"\" cropData = ( SessionUpdateCrop ( ** self . filter_config . configuration ) if self . filter_config . configuration else SessionUpdateCrop () ) return cropData","title":"CropFilter"},{"location":"all_strategies/#oteapi.strategies.filter.crop_filter.CropFilter.get","text":"Execute strategy and return a dictionary Source code in oteapi/strategies/filter/crop_filter.py def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdateCrop : \"\"\"Execute strategy and return a dictionary\"\"\" cropData = ( SessionUpdateCrop ( ** self . filter_config . configuration ) if self . filter_config . configuration else SessionUpdateCrop () ) return cropData","title":"get()"},{"location":"all_strategies/#oteapi.strategies.filter.crop_filter.CropFilter.initialize","text":"Initialize strategy and return a dictionary. Source code in oteapi/strategies/filter/crop_filter.py def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdate : \"\"\"Initialize strategy and return a dictionary.\"\"\" return SessionUpdate ()","title":"initialize()"},{"location":"all_strategies/#oteapi.strategies.filter.crop_filter.SessionUpdateCrop","text":"Class for returning values from crop data. Source code in oteapi/strategies/filter/crop_filter.py class SessionUpdateCrop ( SessionUpdate ): \"\"\"Class for returning values from crop data.\"\"\" crop : List [ int ] = Field ( ... , description = \"List of image cropping details.\" )","title":"SessionUpdateCrop"},{"location":"all_strategies/#oteapi.strategies.filter.crop_filter.SessionUpdateCrop.crop","text":"List of image cropping details.","title":"crop"},{"location":"all_strategies/#oteapi.strategies.filter.sql_query_filter","text":"SQL query filter strategy.","title":"sql_query_filter"},{"location":"all_strategies/#oteapi.strategies.filter.sql_query_filter.SQLQueryFilter","text":"Strategy for a SQL query filter. Registers strategies : (\"filterType\", \"filter/sql\") Source code in oteapi/strategies/filter/sql_query_filter.py @dataclass class SQLQueryFilter : \"\"\"Strategy for a SQL query filter. **Registers strategies**: - `(\"filterType\", \"filter/sql\")` \"\"\" filter_config : \"FilterConfig\" def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdateSqlQuery : \"\"\"Initialize strategy and return a dictionary\"\"\" return SessionUpdateSqlQuery ( ** { \"query\" : self . filter_config . query }) def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdate : \"\"\"Execute strategy and return a dictionary\"\"\" return SessionUpdate ()","title":"SQLQueryFilter"},{"location":"all_strategies/#oteapi.strategies.filter.sql_query_filter.SQLQueryFilter.get","text":"Execute strategy and return a dictionary Source code in oteapi/strategies/filter/sql_query_filter.py def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdate : \"\"\"Execute strategy and return a dictionary\"\"\" return SessionUpdate ()","title":"get()"},{"location":"all_strategies/#oteapi.strategies.filter.sql_query_filter.SQLQueryFilter.initialize","text":"Initialize strategy and return a dictionary Source code in oteapi/strategies/filter/sql_query_filter.py def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdateSqlQuery : \"\"\"Initialize strategy and return a dictionary\"\"\" return SessionUpdateSqlQuery ( ** { \"query\" : self . filter_config . query })","title":"initialize()"},{"location":"all_strategies/#oteapi.strategies.filter.sql_query_filter.SessionUpdateSqlQuery","text":"Class for returning values from SQL Query data model. Source code in oteapi/strategies/filter/sql_query_filter.py class SessionUpdateSqlQuery ( SessionUpdate ): \"\"\"Class for returning values from SQL Query data model.\"\"\" query : str = Field ( ... , description = \"A SQL query string.\" )","title":"SessionUpdateSqlQuery"},{"location":"all_strategies/#oteapi.strategies.filter.sql_query_filter.SessionUpdateSqlQuery.query","text":"A SQL query string.","title":"query"},{"location":"all_strategies/#oteapi.strategies.parse","text":"","title":"parse"},{"location":"all_strategies/#oteapi.strategies.parse.application_json","text":"Strategy class for application/json.","title":"application_json"},{"location":"all_strategies/#oteapi.strategies.parse.application_json.JSONDataParseStrategy","text":"Parse strategy for JSON. Registers strategies : (\"mediaType\", \"application/json\") Source code in oteapi/strategies/parse/application_json.py @dataclass class JSONDataParseStrategy : \"\"\"Parse strategy for JSON. **Registers strategies**: - `(\"mediaType\", \"application/json\")` \"\"\" parse_config : \"ResourceConfig\" def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdate : \"\"\"Initialize.\"\"\" return SessionUpdate () def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdateJSONParse : \"\"\"Parse json.\"\"\" downloader = create_strategy ( \"download\" , self . parse_config ) output = downloader . get () cache = DataCache ( self . parse_config . configuration ) content = cache . get ( output [ \"key\" ]) if isinstance ( content , dict ): return SessionUpdateJSONParse ( content = content ) return SessionUpdateJSONParse ( content = json . loads ( content ))","title":"JSONDataParseStrategy"},{"location":"all_strategies/#oteapi.strategies.parse.application_json.JSONDataParseStrategy.get","text":"Parse json. Source code in oteapi/strategies/parse/application_json.py def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdateJSONParse : \"\"\"Parse json.\"\"\" downloader = create_strategy ( \"download\" , self . parse_config ) output = downloader . get () cache = DataCache ( self . parse_config . configuration ) content = cache . get ( output [ \"key\" ]) if isinstance ( content , dict ): return SessionUpdateJSONParse ( content = content ) return SessionUpdateJSONParse ( content = json . loads ( content ))","title":"get()"},{"location":"all_strategies/#oteapi.strategies.parse.application_json.JSONDataParseStrategy.initialize","text":"Initialize. Source code in oteapi/strategies/parse/application_json.py def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdate : \"\"\"Initialize.\"\"\" return SessionUpdate ()","title":"initialize()"},{"location":"all_strategies/#oteapi.strategies.parse.application_json.SessionUpdateJSONParse","text":"Class for returning values from JSON Parse. Source code in oteapi/strategies/parse/application_json.py class SessionUpdateJSONParse ( SessionUpdate ): \"\"\"Class for returning values from JSON Parse.\"\"\" content : dict = Field ( ... , description = \"Content of the JSON document.\" )","title":"SessionUpdateJSONParse"},{"location":"all_strategies/#oteapi.strategies.parse.application_json.SessionUpdateJSONParse.content","text":"Content of the JSON document.","title":"content"},{"location":"all_strategies/#oteapi.strategies.parse.application_vnd_sqlite","text":"Strategy class for application/vnd.sqlite3.","title":"application_vnd_sqlite"},{"location":"all_strategies/#oteapi.strategies.parse.application_vnd_sqlite.SessionUpdateSqLiteParse","text":"Configuration model for SqLiteParse. Source code in oteapi/strategies/parse/application_vnd_sqlite.py class SessionUpdateSqLiteParse ( SessionUpdate ): \"\"\"Configuration model for SqLiteParse.\"\"\" result : Optional [ list ] = Field ( None , description = \"List of results from the query.\" ) msg : str = Field ( ... , description = \"Messsage concerning the execution of the query.\" )","title":"SessionUpdateSqLiteParse"},{"location":"all_strategies/#oteapi.strategies.parse.application_vnd_sqlite.SessionUpdateSqLiteParse.msg","text":"Messsage concerning the execution of the query.","title":"msg"},{"location":"all_strategies/#oteapi.strategies.parse.application_vnd_sqlite.SessionUpdateSqLiteParse.result","text":"List of results from the query.","title":"result"},{"location":"all_strategies/#oteapi.strategies.parse.application_vnd_sqlite.SqliteParseStrategy","text":"Parse strategy for SQLite. Registers strategies : (\"mediaType\", \"application/vnd.sqlite3\") Source code in oteapi/strategies/parse/application_vnd_sqlite.py @dataclass class SqliteParseStrategy : \"\"\"Parse strategy for SQLite. **Registers strategies**: - `(\"mediaType\", \"application/vnd.sqlite3\")` \"\"\" parse_config : \"ResourceConfig\" def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdateSqLiteParse : \"\"\"Parse SQLite query responses.\"\"\" if session is None : raise ValueError ( \"Missing session\" ) if \"sqlquery\" in session : cn = create_connection ( session [ \"filename\" ]) cur = cn . cursor () rows = cur . execute ( session [ \"sqlquery\" ]) . fetchall () return SessionUpdateSqLiteParse ( result = rows , msg = \"Query executed\" ) return SessionUpdateSqLiteParse ( msg = \"No query given\" ) def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdate : \"\"\"Initialize.\"\"\" return SessionUpdate ()","title":"SqliteParseStrategy"},{"location":"all_strategies/#oteapi.strategies.parse.application_vnd_sqlite.SqliteParseStrategy.get","text":"Parse SQLite query responses. Source code in oteapi/strategies/parse/application_vnd_sqlite.py def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdateSqLiteParse : \"\"\"Parse SQLite query responses.\"\"\" if session is None : raise ValueError ( \"Missing session\" ) if \"sqlquery\" in session : cn = create_connection ( session [ \"filename\" ]) cur = cn . cursor () rows = cur . execute ( session [ \"sqlquery\" ]) . fetchall () return SessionUpdateSqLiteParse ( result = rows , msg = \"Query executed\" ) return SessionUpdateSqLiteParse ( msg = \"No query given\" )","title":"get()"},{"location":"all_strategies/#oteapi.strategies.parse.application_vnd_sqlite.SqliteParseStrategy.initialize","text":"Initialize. Source code in oteapi/strategies/parse/application_vnd_sqlite.py def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdate : \"\"\"Initialize.\"\"\" return SessionUpdate ()","title":"initialize()"},{"location":"all_strategies/#oteapi.strategies.parse.application_vnd_sqlite.create_connection","text":"create a database connection to the SQLite database specified by db_file :param db_file: database file :return: Connection object or None Source code in oteapi/strategies/parse/application_vnd_sqlite.py def create_connection ( db_file ): \"\"\"create a database connection to the SQLite database specified by db_file :param db_file: database file :return: Connection object or None \"\"\" conn = None try : conn = sqlite3 . connect ( db_file ) return conn except sqlite3 . Error as exc : print ( exc ) return conn","title":"create_connection()"},{"location":"all_strategies/#oteapi.strategies.parse.excel_xlsx","text":"Strategy class for workbook/xlsx.","title":"excel_xlsx"},{"location":"all_strategies/#oteapi.strategies.parse.excel_xlsx.SessionUpdateXLSXParse","text":"Class for returning values from XLSXParse. Source code in oteapi/strategies/parse/excel_xlsx.py class SessionUpdateXLSXParse ( SessionUpdate ): \"\"\"Class for returning values from XLSXParse.\"\"\" data : Dict [ str , list ] = Field ( ... , description = \"A dict with column-name/column-value pairs. The values are lists.\" , )","title":"SessionUpdateXLSXParse"},{"location":"all_strategies/#oteapi.strategies.parse.excel_xlsx.SessionUpdateXLSXParse.data","text":"A dict with column-name/column-value pairs. The values are lists.","title":"data"},{"location":"all_strategies/#oteapi.strategies.parse.excel_xlsx.XLSXParseDataModel","text":"Data model for retrieving a rectangular section of an Excel sheet. Source code in oteapi/strategies/parse/excel_xlsx.py class XLSXParseDataModel ( BaseModel ): \"\"\"Data model for retrieving a rectangular section of an Excel sheet.\"\"\" worksheet : str = Field ( ... , description = \"Name of worksheet to load.\" ) row_from : Optional [ int ] = Field ( None , description = \"Excel row number of first row. Defaults to first assigned row.\" , ) col_from : Optional [ Union [ int , str ]] = Field ( None , description = ( \"Excel column number or label of first column. Defaults to first assigned \" \"column.\" ), ) row_to : Optional [ int ] = Field ( None , description = \"Excel row number of last row. Defaults to last assigned row.\" ) col_to : Optional [ Union [ int , str ]] = Field ( None , description = ( \"Excel column number or label of last column. Defaults to last assigned \" \"column.\" ), ) header_row : Optional [ int ] = Field ( None , description = ( \"Row number with the headers. Defaults to `1` if header is given, \" \"otherwise `None`.\" ), ) header : Optional [ List [ str ]] = Field ( None , description = ( \"Optional list of column names, specifying the columns to return. \" \"These names they should match cells in `header_row`.\" ), ) new_header : Optional [ List [ str ]] = Field ( None , description = ( \"Optional list of new column names replacing `header` in the output.\" ), ) download_config : AttrDict = Field ( AttrDict (), description = \"Configurations provided to a download strategy.\" , )","title":"XLSXParseDataModel"},{"location":"all_strategies/#oteapi.strategies.parse.excel_xlsx.XLSXParseDataModel.col_from","text":"Excel column number or label of first column. Defaults to first assigned column.","title":"col_from"},{"location":"all_strategies/#oteapi.strategies.parse.excel_xlsx.XLSXParseDataModel.col_to","text":"Excel column number or label of last column. Defaults to last assigned column.","title":"col_to"},{"location":"all_strategies/#oteapi.strategies.parse.excel_xlsx.XLSXParseDataModel.download_config","text":"Configurations provided to a download strategy.","title":"download_config"},{"location":"all_strategies/#oteapi.strategies.parse.excel_xlsx.XLSXParseDataModel.header","text":"Optional list of column names, specifying the columns to return. These names they should match cells in header_row .","title":"header"},{"location":"all_strategies/#oteapi.strategies.parse.excel_xlsx.XLSXParseDataModel.header_row","text":"Row number with the headers. Defaults to 1 if header is given, otherwise None .","title":"header_row"},{"location":"all_strategies/#oteapi.strategies.parse.excel_xlsx.XLSXParseDataModel.new_header","text":"Optional list of new column names replacing header in the output.","title":"new_header"},{"location":"all_strategies/#oteapi.strategies.parse.excel_xlsx.XLSXParseDataModel.row_from","text":"Excel row number of first row. Defaults to first assigned row.","title":"row_from"},{"location":"all_strategies/#oteapi.strategies.parse.excel_xlsx.XLSXParseDataModel.row_to","text":"Excel row number of last row. Defaults to last assigned row.","title":"row_to"},{"location":"all_strategies/#oteapi.strategies.parse.excel_xlsx.XLSXParseDataModel.worksheet","text":"Name of worksheet to load.","title":"worksheet"},{"location":"all_strategies/#oteapi.strategies.parse.excel_xlsx.XLSXParseStrategy","text":"Parse strategy for Excel XLSX files. Registers strategies : (\"mediaType\", \"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\") Source code in oteapi/strategies/parse/excel_xlsx.py @dataclass class XLSXParseStrategy : \"\"\"Parse strategy for Excel XLSX files. **Registers strategies**: - `(\"mediaType\", \"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\")` \"\"\" parse_config : \"ResourceConfig\" def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdate : \"\"\"Initialize.\"\"\" return SessionUpdate () def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdateXLSXParse : \"\"\"Parses selected region of an excel file. Returns: A dict with column-name/column-value pairs. The values are lists. \"\"\" model = XLSXParseDataModel ( ** self . parse_config . configuration ) download_config = self . parse_config . copy () download_config . configuration = model . download_config downloader = create_strategy ( \"download\" , download_config ) output = downloader . get () cache = DataCache ( self . parse_config . configuration ) with cache . getfile ( key = output [ \"key\" ], suffix = \".xlsx\" ) as filename : workbook = load_workbook ( filename = filename , read_only = True , data_only = True ) worksheet = workbook [ model . worksheet ] set_model_defaults ( model , worksheet ) columns = get_column_indices ( model , worksheet ) data = [] for row in worksheet . iter_rows ( min_row = model . row_from , max_row = model . row_to , min_col = min ( columns ), max_col = max ( columns ), ): data . append ([ row [ c - 1 ] . value for c in columns ]) if model . header_row : row = worksheet . iter_rows ( min_row = model . header_row , max_row = model . header_row , min_col = min ( columns ), max_col = max ( columns ), ) . __next__ () header = [ row [ c - 1 ] . value for c in columns ] else : header = None if model . new_header : nhead = len ( header ) if header else len ( data [ 0 ]) if data else 0 if len ( model . new_header ) != nhead : raise TypeError ( f \"length of `new_header` (= { len ( model . new_header ) } ) \" f \"doesn't match number of columns (= { len ( header ) if header else 0 } )\" ) if header : for i , val in enumerate ( model . new_header ): if val is not None : header [ i ] = val elif data : header = model . new_header if header is None : header = [ get_column_letter ( col + 1 ) for col in range ( len ( data ))] transposed = [ list ( datum ) for datum in zip ( * data )] return SessionUpdateXLSXParse ( data = { key : value for key , value in zip ( header , transposed )} )","title":"XLSXParseStrategy"},{"location":"all_strategies/#oteapi.strategies.parse.excel_xlsx.XLSXParseStrategy.get","text":"Parses selected region of an excel file. Returns: Type Description SessionUpdateXLSXParse A dict with column-name/column-value pairs. The values are lists. Source code in oteapi/strategies/parse/excel_xlsx.py def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdateXLSXParse : \"\"\"Parses selected region of an excel file. Returns: A dict with column-name/column-value pairs. The values are lists. \"\"\" model = XLSXParseDataModel ( ** self . parse_config . configuration ) download_config = self . parse_config . copy () download_config . configuration = model . download_config downloader = create_strategy ( \"download\" , download_config ) output = downloader . get () cache = DataCache ( self . parse_config . configuration ) with cache . getfile ( key = output [ \"key\" ], suffix = \".xlsx\" ) as filename : workbook = load_workbook ( filename = filename , read_only = True , data_only = True ) worksheet = workbook [ model . worksheet ] set_model_defaults ( model , worksheet ) columns = get_column_indices ( model , worksheet ) data = [] for row in worksheet . iter_rows ( min_row = model . row_from , max_row = model . row_to , min_col = min ( columns ), max_col = max ( columns ), ): data . append ([ row [ c - 1 ] . value for c in columns ]) if model . header_row : row = worksheet . iter_rows ( min_row = model . header_row , max_row = model . header_row , min_col = min ( columns ), max_col = max ( columns ), ) . __next__ () header = [ row [ c - 1 ] . value for c in columns ] else : header = None if model . new_header : nhead = len ( header ) if header else len ( data [ 0 ]) if data else 0 if len ( model . new_header ) != nhead : raise TypeError ( f \"length of `new_header` (= { len ( model . new_header ) } ) \" f \"doesn't match number of columns (= { len ( header ) if header else 0 } )\" ) if header : for i , val in enumerate ( model . new_header ): if val is not None : header [ i ] = val elif data : header = model . new_header if header is None : header = [ get_column_letter ( col + 1 ) for col in range ( len ( data ))] transposed = [ list ( datum ) for datum in zip ( * data )] return SessionUpdateXLSXParse ( data = { key : value for key , value in zip ( header , transposed )} )","title":"get()"},{"location":"all_strategies/#oteapi.strategies.parse.excel_xlsx.XLSXParseStrategy.initialize","text":"Initialize. Source code in oteapi/strategies/parse/excel_xlsx.py def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdate : \"\"\"Initialize.\"\"\" return SessionUpdate ()","title":"initialize()"},{"location":"all_strategies/#oteapi.strategies.parse.excel_xlsx.get_column_indices","text":"Helper function returning a list of column indices. Parameters: Name Type Description Default model XLSXParseDataModel The parsed data model. required worksheet Worksheet Excel worksheet, from which the header values will be retrieved. required Returns: Type Description Iterable[int] A list of column indices. Source code in oteapi/strategies/parse/excel_xlsx.py def get_column_indices ( model : XLSXParseDataModel , worksheet : \"Worksheet\" ) -> \"Iterable[int]\" : \"\"\"Helper function returning a list of column indices. Parameters: model: The parsed data model. worksheet: Excel worksheet, from which the header values will be retrieved. Returns: A list of column indices. \"\"\" if not isinstance ( model . col_from , int ) or not isinstance ( model . col_to , int ): raise TypeError ( \"Expected `model.col_from` and `model.col_to` to be integers.\" ) if model . header : header_dict = { worksheet . cell ( model . header_row , col ) . value : col for col in range ( model . col_from , model . col_to + 1 ) } return [ header_dict [ h ] for h in model . header ] return range ( model . col_from , model . col_to + 1 )","title":"get_column_indices()"},{"location":"all_strategies/#oteapi.strategies.parse.excel_xlsx.set_model_defaults","text":"Update data model model with default values obtained from worksheet . Parameters: Name Type Description Default model XLSXParseDataModel The parsed data model. required worksheet Worksheet Excel worksheet, from which the default values will be obtained. required Source code in oteapi/strategies/parse/excel_xlsx.py def set_model_defaults ( model : XLSXParseDataModel , worksheet : \"Worksheet\" ) -> None : \"\"\"Update data model `model` with default values obtained from `worksheet`. Parameters: model: The parsed data model. worksheet: Excel worksheet, from which the default values will be obtained. \"\"\" if model . row_from is None : if model . header : # assume that data starts on the first row after the header model . row_from = model . header_row + 1 if model . header_row else 1 else : model . row_from = worksheet . min_row if model . row_to is None : model . row_to = worksheet . max_row if model . col_from is None : model . col_from = worksheet . min_column elif isinstance ( model . col_from , str ): model . col_from = column_index_from_string ( model . col_from ) if model . col_to is None : model . col_to = worksheet . max_column elif isinstance ( model . col_to , str ): model . col_to = column_index_from_string ( model . col_to ) if model . header and not model . header_row : model . header_row = 1","title":"set_model_defaults()"},{"location":"all_strategies/#oteapi.strategies.parse.image","text":"Strategy class for image/jpg.","title":"image"},{"location":"all_strategies/#oteapi.strategies.parse.image.ImageDataParseStrategy","text":"Parse strategy for images. Registers strategies : (\"mediaType\", \"image/jpg\") (\"mediaType\", \"image/jpeg\") (\"mediaType\", \"image/jp2\") (\"mediaType\", \"image/png\") (\"mediaType\", \"image/gif\") (\"mediaType\", \"image/tiff\") (\"mediaType\", \"image/eps\") Source code in oteapi/strategies/parse/image.py @dataclass class ImageDataParseStrategy : \"\"\"Parse strategy for images. **Registers strategies**: - `(\"mediaType\", \"image/jpg\")` - `(\"mediaType\", \"image/jpeg\")` - `(\"mediaType\", \"image/jp2\")` - `(\"mediaType\", \"image/png\")` - `(\"mediaType\", \"image/gif\")` - `(\"mediaType\", \"image/tiff\")` - `(\"mediaType\", \"image/eps\")` \"\"\" parse_config : \"ResourceConfig\" def __post_init__ ( self ): self . localpath = \"/ote-data\" self . filename = self . parse_config . configuration [ \"filename\" ] self . conf = self . parse_config . configuration if \"localpath\" in self . conf : self . localpath = self . conf [ \"localpath\" ] def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdate : \"\"\"Initialize.\"\"\" return SessionUpdate () def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdateImageParse : if session is not None : self . conf . update ( session ) parsedOutput = {} if \"crop\" in self . conf : print ( \"cropping!\" ) im = Image . open ( f \" { self . localpath } / { self . filename } \" ) crop = self . conf [ \"crop\" ] im_cropped = im . crop ( tuple ( crop )) cropped_filename = f \" { self . localpath } /cropped_ { self . filename } \" im_cropped . save ( cropped_filename ) parsedOutput [ \"cropped_filename\" ] = cropped_filename parsedOutput [ \"parseImage\" ] = \"Done\" return SessionUpdateImageParse ( parsedOutput = parsedOutput )","title":"ImageDataParseStrategy"},{"location":"all_strategies/#oteapi.strategies.parse.image.ImageDataParseStrategy.initialize","text":"Initialize. Source code in oteapi/strategies/parse/image.py def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdate : \"\"\"Initialize.\"\"\" return SessionUpdate ()","title":"initialize()"},{"location":"all_strategies/#oteapi.strategies.parse.image.SessionUpdateImageParse","text":"Configuration model for ImageParse. Source code in oteapi/strategies/parse/image.py class SessionUpdateImageParse ( SessionUpdate ): \"\"\"Configuration model for ImageParse.\"\"\" parsedOutput : Dict [ str , str ] = Field ( ... , description = \"Parsed output from ImageParse.\" )","title":"SessionUpdateImageParse"},{"location":"all_strategies/#oteapi.strategies.parse.image.SessionUpdateImageParse.parsedOutput","text":"Parsed output from ImageParse.","title":"parsedOutput"},{"location":"all_strategies/#oteapi.strategies.parse.text_csv","text":"Strategy class for text/csv.","title":"text_csv"},{"location":"all_strategies/#oteapi.strategies.parse.text_csv.CSVParseStrategy","text":"Parse strategy for CSV files. Registers strategies : (\"mediaType\", \"text/csv\") Source code in oteapi/strategies/parse/text_csv.py @dataclass class CSVParseStrategy : \"\"\"Parse strategy for CSV files. **Registers strategies**: - `(\"mediaType\", \"text/csv\")` \"\"\" parse_config : \"ResourceConfig\" def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdate : \"\"\"Parse CSV.\"\"\" return SessionUpdate () def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdate : \"\"\"Initialize.\"\"\" return SessionUpdate ()","title":"CSVParseStrategy"},{"location":"all_strategies/#oteapi.strategies.parse.text_csv.CSVParseStrategy.get","text":"Parse CSV. Source code in oteapi/strategies/parse/text_csv.py def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdate : \"\"\"Parse CSV.\"\"\" return SessionUpdate ()","title":"get()"},{"location":"all_strategies/#oteapi.strategies.parse.text_csv.CSVParseStrategy.initialize","text":"Initialize. Source code in oteapi/strategies/parse/text_csv.py def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdate : \"\"\"Initialize.\"\"\" return SessionUpdate ()","title":"initialize()"},{"location":"all_strategies/#oteapi.strategies.transformation","text":"","title":"transformation"},{"location":"all_strategies/#oteapi.strategies.transformation.celery_remote","text":"Transformation Plugin that uses the Celery framework to call remote workers.","title":"celery_remote"},{"location":"all_strategies/#oteapi.strategies.transformation.celery_remote.CeleryConfig","text":"Celery configuration. Source code in oteapi/strategies/transformation/celery_remote.py class CeleryConfig ( BaseModel ): \"\"\"Celery configuration.\"\"\" task_name : str = Field ( ... , description = \"A task name.\" ) args : list = Field ( ... , description = \"List of arguments for the task.\" )","title":"CeleryConfig"},{"location":"all_strategies/#oteapi.strategies.transformation.celery_remote.CeleryConfig.args","text":"List of arguments for the task.","title":"args"},{"location":"all_strategies/#oteapi.strategies.transformation.celery_remote.CeleryConfig.task_name","text":"A task name.","title":"task_name"},{"location":"all_strategies/#oteapi.strategies.transformation.celery_remote.CeleryRemoteStrategy","text":"Submit job to remote Celery runner. Registers strategies : (\"transformationType\", \"celery/remote\") Source code in oteapi/strategies/transformation/celery_remote.py @dataclass class CeleryRemoteStrategy : \"\"\"Submit job to remote Celery runner. **Registers strategies**: - `(\"transformationType\", \"celery/remote\")` \"\"\" transformation_config : \"TransformationConfig\" def run ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> TransformationStatus : \"\"\"Run a job, return a job ID.\"\"\" config = self . transformation_config . configuration celery_config = CeleryConfig () if config is None else CeleryConfig ( ** config ) result : \"Union[AsyncResult, Any]\" = app . send_task ( celery_config . task_name , celery_config . args , kwargs = session ) status = AsyncResult ( id = result . task_id , app = app ) return TransformationStatus ( id = result . task_id , status = status . status ) def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdate : \"\"\"Initialize a job.\"\"\" return SessionUpdate () def status ( self , task_id : str ) -> TransformationStatus : \"\"\"Get job status.\"\"\" result = AsyncResult ( id = task_id , app = app ) return TransformationStatus ( id = task_id , status = result . state ) def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"SessionUpdateCelery\" : \"\"\"Get transformation.\"\"\" # TODO: update and return global state # pylint: disable=fixme return SessionUpdateCelery ( data = {})","title":"CeleryRemoteStrategy"},{"location":"all_strategies/#oteapi.strategies.transformation.celery_remote.CeleryRemoteStrategy.get","text":"Get transformation. Source code in oteapi/strategies/transformation/celery_remote.py def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"SessionUpdateCelery\" : \"\"\"Get transformation.\"\"\" # TODO: update and return global state # pylint: disable=fixme return SessionUpdateCelery ( data = {})","title":"get()"},{"location":"all_strategies/#oteapi.strategies.transformation.celery_remote.CeleryRemoteStrategy.initialize","text":"Initialize a job. Source code in oteapi/strategies/transformation/celery_remote.py def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdate : \"\"\"Initialize a job.\"\"\" return SessionUpdate ()","title":"initialize()"},{"location":"all_strategies/#oteapi.strategies.transformation.celery_remote.CeleryRemoteStrategy.run","text":"Run a job, return a job ID. Source code in oteapi/strategies/transformation/celery_remote.py def run ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> TransformationStatus : \"\"\"Run a job, return a job ID.\"\"\" config = self . transformation_config . configuration celery_config = CeleryConfig () if config is None else CeleryConfig ( ** config ) result : \"Union[AsyncResult, Any]\" = app . send_task ( celery_config . task_name , celery_config . args , kwargs = session ) status = AsyncResult ( id = result . task_id , app = app ) return TransformationStatus ( id = result . task_id , status = status . status )","title":"run()"},{"location":"all_strategies/#oteapi.strategies.transformation.celery_remote.CeleryRemoteStrategy.status","text":"Get job status. Source code in oteapi/strategies/transformation/celery_remote.py def status ( self , task_id : str ) -> TransformationStatus : \"\"\"Get job status.\"\"\" result = AsyncResult ( id = task_id , app = app ) return TransformationStatus ( id = task_id , status = result . state )","title":"status()"},{"location":"all_strategies/#oteapi.strategies.transformation.celery_remote.SessionUpdateCelery","text":"Class for returning values from XLSXParse. Source code in oteapi/strategies/transformation/celery_remote.py class SessionUpdateCelery ( SessionUpdate ): \"\"\"Class for returning values from XLSXParse.\"\"\" data : Dict [ str , list ] = Field ( ... , description = \"A dict with column-name/column-value pairs. The values are lists.\" , )","title":"SessionUpdateCelery"},{"location":"all_strategies/#oteapi.strategies.transformation.celery_remote.SessionUpdateCelery.data","text":"A dict with column-name/column-value pairs. The values are lists.","title":"data"},{"location":"api_reference/datacache/datacache/","text":"datacache \u00b6 Data cache based on DiskCache. See Python-DiskCache . Features: Persistent cache between sessions. Default keys are hashes of the stored data. Automatic expiration of cached data. Sessions can selectively be cleaned up via tags. Store small values in SQLite database and large values in files. Underlying library is actively developed and tested on Linux, Mac and Windows. High performance. DataCache \u00b6 Initialize a cache instance with the given download configuration. This class is also available to import from oteapi.datacache , e.g.: from oteapi.datacache import DataCache Parameters: Name Type Description Default config Union[DataCacheConfig, Dict[str, Any]] Download configurations. None cache_dir Optional[Union[Path, str]] Cache directory overriding the config. None Attributes: Name Type Description config DataCacheConfig instance. cache_dir Subdirectory used for the Path to cache directory, e.g., \"my_oteapi\" . Source code in oteapi/datacache/datacache.py class DataCache : \"\"\"Initialize a cache instance with the given download configuration. This class is also available to import from `oteapi.datacache`, e.g.: ```python from oteapi.datacache import DataCache ``` Args: config: Download configurations. cache_dir: Cache directory overriding the config. Attributes: config: DataCacheConfig instance. cache_dir: Subdirectory used for the Path to cache directory, e.g., `\"my_oteapi\"`. \"\"\" def __init__ ( self , config : \"Union[DataCacheConfig, Dict[str, Any]]\" = None , cache_dir : \"Optional[Union[Path, str]]\" = None , ) -> None : if config is None : self . config = DataCacheConfig () elif isinstance ( config , dict ): self . config = DataCacheConfig ( ** config , extra = Extra . ignore ) elif isinstance ( config , DataCacheConfig ): self . config = config else : raise TypeError ( \"config should be either a `DataCacheConfig` data model or a \" \"dictionary.\" ) if not cache_dir : cache_dir = self . config . cacheDir if isinstance ( cache_dir , str ): cache_dir = Path ( cache_dir ) if cache_dir . is_absolute (): self . cache_dir = cache_dir else : self . cache_dir = Path ( tempfile . gettempdir ()) . resolve () / cache_dir self . diskcache = DiskCache ( directory = self . cache_dir ) def __contains__ ( self , key ) -> bool : return key in self . diskcache def __len__ ( self ) -> int : return len ( self . diskcache ) def __getitem__ ( self , key ) -> \"Any\" : return self . get ( key ) def __setitem__ ( self , key , value ) -> None : self . add ( value , key ) def __delitem__ ( self , key ) -> None : del self . diskcache [ key ] def __del__ ( self ) -> None : self . diskcache . expire () self . diskcache . close () def add ( self , value : \"Any\" , key : \"Optional[str]\" = None , expire : \"Optional[int]\" = None , tag : \"Optional[str]\" = None , ) -> str : \"\"\"Add a value to cache. Existing value is overwritten if `key` is given and it already exists in the cache. Args: value: The value to add to the cache. key: If given, use this as the retrieval key. Otherwise the key is either taken from the `accessKey` configuration or generated as a hash of `value`. expire: If given, the number of seconds before the value expire. Otherwise it is taken from the configuration. tag: Tag used with [`evict()`][oteapi.datacache.datacache.DataCache.evict] for cleaning up a session. Returns: A key that can be used to retrieve `value` from cache later. \"\"\" if not key : if self . config . accessKey : key = self . config . accessKey else : key = gethash ( value , hashtype = self . config . hashType ) if not expire : expire = self . config . expireTime self . diskcache . set ( key , value , expire = expire , tag = tag ) return key def get ( self , key : str ) -> \"Any\" : \"\"\"Return the value corresponding to `key`. Args: key: The requested cached object to retrieve a value for. Returns: The value corresponding to the `key` value. \"\"\" if key not in self . diskcache : raise KeyError ( key ) return self . diskcache . get ( key ) @contextmanager def getfile ( # pylint: disable=too-many-arguments self , key : str , filename : \"Optional[Union[Path, str]]\" = None , prefix : \"Optional[str]\" = None , suffix : \"Optional[str]\" = None , directory : \"Optional[str]\" = None , delete : bool = True , ) -> \"Iterator[Path]\" : \"\"\"Write the value for `key` to file and return the filename. The file is created in the default directory for temporary files (which can be controlled by the `TEMPDIR`, `TEMP` or `TMP` environment variables). It is readable and writable only for the current user. Example: This method is intended to be used in a `with` statement, to automatically delete the file when leaving the context: ```python cache = DataCache() with cache.getfile('mykey') as filename: # do something with filename... # filename is deleted ``` Args: key: Key of value to write to file. filename: Full path to created file. If not given, a unique filename will be created. prefix: Prefix to prepend to the returned file name (default is `\"oteapi-download-\"`). suffix: Suffix to append to the returned file name. directory: File directory if `filename` is not provided (is `None`). delete: Whether to automatically delete the created file when leaving the context. Yields: Path object, referencing and representing the created file. \"\"\" if filename : filename = Path ( filename ) . resolve () filename . write_bytes ( self . get ( key )) else : if prefix is None : prefix = \"oteapi-download-\" with tempfile . NamedTemporaryFile ( prefix = prefix , suffix = suffix , dir = directory , delete = False ) as handle : handle . write ( self . get ( key )) filename = Path ( handle . name ) . resolve () try : yield filename finally : if delete : filename . unlink () def evict ( self , tag : str ) -> None : \"\"\"Remove all cache items with the given tag. Useful for cleaning up a session. Args: tag: Tag identifying objects. \"\"\" self . diskcache . evict ( tag ) def clear ( self ) -> None : \"\"\"Remove all items from cache.\"\"\" self . diskcache . clear () add ( self , value , key = None , expire = None , tag = None ) \u00b6 Add a value to cache. Existing value is overwritten if key is given and it already exists in the cache. Parameters: Name Type Description Default value Any The value to add to the cache. required key Optional[str] If given, use this as the retrieval key. Otherwise the key is either taken from the accessKey configuration or generated as a hash of value . None expire Optional[int] If given, the number of seconds before the value expire. Otherwise it is taken from the configuration. None tag Optional[str] Tag used with evict() for cleaning up a session. None Returns: Type Description str A key that can be used to retrieve value from cache later. Source code in oteapi/datacache/datacache.py def add ( self , value : \"Any\" , key : \"Optional[str]\" = None , expire : \"Optional[int]\" = None , tag : \"Optional[str]\" = None , ) -> str : \"\"\"Add a value to cache. Existing value is overwritten if `key` is given and it already exists in the cache. Args: value: The value to add to the cache. key: If given, use this as the retrieval key. Otherwise the key is either taken from the `accessKey` configuration or generated as a hash of `value`. expire: If given, the number of seconds before the value expire. Otherwise it is taken from the configuration. tag: Tag used with [`evict()`][oteapi.datacache.datacache.DataCache.evict] for cleaning up a session. Returns: A key that can be used to retrieve `value` from cache later. \"\"\" if not key : if self . config . accessKey : key = self . config . accessKey else : key = gethash ( value , hashtype = self . config . hashType ) if not expire : expire = self . config . expireTime self . diskcache . set ( key , value , expire = expire , tag = tag ) return key clear ( self ) \u00b6 Remove all items from cache. Source code in oteapi/datacache/datacache.py def clear ( self ) -> None : \"\"\"Remove all items from cache.\"\"\" self . diskcache . clear () evict ( self , tag ) \u00b6 Remove all cache items with the given tag. Useful for cleaning up a session. Parameters: Name Type Description Default tag str Tag identifying objects. required Source code in oteapi/datacache/datacache.py def evict ( self , tag : str ) -> None : \"\"\"Remove all cache items with the given tag. Useful for cleaning up a session. Args: tag: Tag identifying objects. \"\"\" self . diskcache . evict ( tag ) get ( self , key ) \u00b6 Return the value corresponding to key . Parameters: Name Type Description Default key str The requested cached object to retrieve a value for. required Returns: Type Description Any The value corresponding to the key value. Source code in oteapi/datacache/datacache.py def get ( self , key : str ) -> \"Any\" : \"\"\"Return the value corresponding to `key`. Args: key: The requested cached object to retrieve a value for. Returns: The value corresponding to the `key` value. \"\"\" if key not in self . diskcache : raise KeyError ( key ) return self . diskcache . get ( key ) getfile ( self , key , filename = None , prefix = None , suffix = None , directory = None , delete = True ) \u00b6 Write the value for key to file and return the filename. The file is created in the default directory for temporary files (which can be controlled by the TEMPDIR , TEMP or TMP environment variables). It is readable and writable only for the current user. Examples: This method is intended to be used in a with statement, to automatically delete the file when leaving the context: cache = DataCache () with cache . getfile ( 'mykey' ) as filename : # do something with filename... # filename is deleted Parameters: Name Type Description Default key str Key of value to write to file. required filename Optional[Union[Path, str]] Full path to created file. If not given, a unique filename will be created. None prefix Optional[str] Prefix to prepend to the returned file name (default is \"oteapi-download-\" ). None suffix Optional[str] Suffix to append to the returned file name. None directory Optional[str] File directory if filename is not provided (is None ). None delete bool Whether to automatically delete the created file when leaving the context. True Yields: Type Description Iterator[Path] Path object, referencing and representing the created file. Source code in oteapi/datacache/datacache.py @contextmanager def getfile ( # pylint: disable=too-many-arguments self , key : str , filename : \"Optional[Union[Path, str]]\" = None , prefix : \"Optional[str]\" = None , suffix : \"Optional[str]\" = None , directory : \"Optional[str]\" = None , delete : bool = True , ) -> \"Iterator[Path]\" : \"\"\"Write the value for `key` to file and return the filename. The file is created in the default directory for temporary files (which can be controlled by the `TEMPDIR`, `TEMP` or `TMP` environment variables). It is readable and writable only for the current user. Example: This method is intended to be used in a `with` statement, to automatically delete the file when leaving the context: ```python cache = DataCache() with cache.getfile('mykey') as filename: # do something with filename... # filename is deleted ``` Args: key: Key of value to write to file. filename: Full path to created file. If not given, a unique filename will be created. prefix: Prefix to prepend to the returned file name (default is `\"oteapi-download-\"`). suffix: Suffix to append to the returned file name. directory: File directory if `filename` is not provided (is `None`). delete: Whether to automatically delete the created file when leaving the context. Yields: Path object, referencing and representing the created file. \"\"\" if filename : filename = Path ( filename ) . resolve () filename . write_bytes ( self . get ( key )) else : if prefix is None : prefix = \"oteapi-download-\" with tempfile . NamedTemporaryFile ( prefix = prefix , suffix = suffix , dir = directory , delete = False ) as handle : handle . write ( self . get ( key )) filename = Path ( handle . name ) . resolve () try : yield filename finally : if delete : filename . unlink () gethash ( value , hashtype = 'sha256' , encoding = 'utf-8' , json_encoder = None ) \u00b6 Return a hash of value . Can hash most python objects. Bytes and bytearrays are hashed directly. Strings are converted to bytes with the given encoding. All other objects are first serialised using json. Parameters: Name Type Description Default value Any Value to hash. required hashtype str Any of the hash algorithms supported by hashlib. 'sha256' encoding str Encoding used to convert strings to bytes before calculating the hash. 'utf-8' json_encoder Optional[Type[json.JSONEncoder]] Customised json encoder for complex Python objects. None Returns: Type Description str A hash of the input value . Source code in oteapi/datacache/datacache.py def gethash ( value : \"Any\" , hashtype : str = \"sha256\" , encoding : str = \"utf-8\" , json_encoder : \"Optional[Type[json.JSONEncoder]]\" = None , ) -> str : \"\"\"Return a hash of `value`. Can hash most python objects. Bytes and bytearrays are hashed directly. Strings are converted to bytes with the given encoding. All other objects are first serialised using json. Args: value: Value to hash. hashtype: Any of the hash algorithms supported by hashlib. encoding: Encoding used to convert strings to bytes before calculating the hash. json_encoder: Customised json encoder for complex Python objects. Returns: A hash of the input `value`. \"\"\" if isinstance ( value , ( bytes , bytearray )): data = value elif isinstance ( value , str ): data = value . encode ( encoding ) else : # Try to serialise using json data = json . dumps ( value , ensure_ascii = False , cls = json_encoder , sort_keys = True , ) . encode ( encoding ) hash_ = hashlib . new ( hashtype ) hash_ . update ( data ) return hash_ . hexdigest ()","title":"datacache"},{"location":"api_reference/datacache/datacache/#datacache","text":"Data cache based on DiskCache. See Python-DiskCache . Features: Persistent cache between sessions. Default keys are hashes of the stored data. Automatic expiration of cached data. Sessions can selectively be cleaned up via tags. Store small values in SQLite database and large values in files. Underlying library is actively developed and tested on Linux, Mac and Windows. High performance.","title":"datacache"},{"location":"api_reference/datacache/datacache/#oteapi.datacache.datacache.DataCache","text":"Initialize a cache instance with the given download configuration. This class is also available to import from oteapi.datacache , e.g.: from oteapi.datacache import DataCache Parameters: Name Type Description Default config Union[DataCacheConfig, Dict[str, Any]] Download configurations. None cache_dir Optional[Union[Path, str]] Cache directory overriding the config. None Attributes: Name Type Description config DataCacheConfig instance. cache_dir Subdirectory used for the Path to cache directory, e.g., \"my_oteapi\" . Source code in oteapi/datacache/datacache.py class DataCache : \"\"\"Initialize a cache instance with the given download configuration. This class is also available to import from `oteapi.datacache`, e.g.: ```python from oteapi.datacache import DataCache ``` Args: config: Download configurations. cache_dir: Cache directory overriding the config. Attributes: config: DataCacheConfig instance. cache_dir: Subdirectory used for the Path to cache directory, e.g., `\"my_oteapi\"`. \"\"\" def __init__ ( self , config : \"Union[DataCacheConfig, Dict[str, Any]]\" = None , cache_dir : \"Optional[Union[Path, str]]\" = None , ) -> None : if config is None : self . config = DataCacheConfig () elif isinstance ( config , dict ): self . config = DataCacheConfig ( ** config , extra = Extra . ignore ) elif isinstance ( config , DataCacheConfig ): self . config = config else : raise TypeError ( \"config should be either a `DataCacheConfig` data model or a \" \"dictionary.\" ) if not cache_dir : cache_dir = self . config . cacheDir if isinstance ( cache_dir , str ): cache_dir = Path ( cache_dir ) if cache_dir . is_absolute (): self . cache_dir = cache_dir else : self . cache_dir = Path ( tempfile . gettempdir ()) . resolve () / cache_dir self . diskcache = DiskCache ( directory = self . cache_dir ) def __contains__ ( self , key ) -> bool : return key in self . diskcache def __len__ ( self ) -> int : return len ( self . diskcache ) def __getitem__ ( self , key ) -> \"Any\" : return self . get ( key ) def __setitem__ ( self , key , value ) -> None : self . add ( value , key ) def __delitem__ ( self , key ) -> None : del self . diskcache [ key ] def __del__ ( self ) -> None : self . diskcache . expire () self . diskcache . close () def add ( self , value : \"Any\" , key : \"Optional[str]\" = None , expire : \"Optional[int]\" = None , tag : \"Optional[str]\" = None , ) -> str : \"\"\"Add a value to cache. Existing value is overwritten if `key` is given and it already exists in the cache. Args: value: The value to add to the cache. key: If given, use this as the retrieval key. Otherwise the key is either taken from the `accessKey` configuration or generated as a hash of `value`. expire: If given, the number of seconds before the value expire. Otherwise it is taken from the configuration. tag: Tag used with [`evict()`][oteapi.datacache.datacache.DataCache.evict] for cleaning up a session. Returns: A key that can be used to retrieve `value` from cache later. \"\"\" if not key : if self . config . accessKey : key = self . config . accessKey else : key = gethash ( value , hashtype = self . config . hashType ) if not expire : expire = self . config . expireTime self . diskcache . set ( key , value , expire = expire , tag = tag ) return key def get ( self , key : str ) -> \"Any\" : \"\"\"Return the value corresponding to `key`. Args: key: The requested cached object to retrieve a value for. Returns: The value corresponding to the `key` value. \"\"\" if key not in self . diskcache : raise KeyError ( key ) return self . diskcache . get ( key ) @contextmanager def getfile ( # pylint: disable=too-many-arguments self , key : str , filename : \"Optional[Union[Path, str]]\" = None , prefix : \"Optional[str]\" = None , suffix : \"Optional[str]\" = None , directory : \"Optional[str]\" = None , delete : bool = True , ) -> \"Iterator[Path]\" : \"\"\"Write the value for `key` to file and return the filename. The file is created in the default directory for temporary files (which can be controlled by the `TEMPDIR`, `TEMP` or `TMP` environment variables). It is readable and writable only for the current user. Example: This method is intended to be used in a `with` statement, to automatically delete the file when leaving the context: ```python cache = DataCache() with cache.getfile('mykey') as filename: # do something with filename... # filename is deleted ``` Args: key: Key of value to write to file. filename: Full path to created file. If not given, a unique filename will be created. prefix: Prefix to prepend to the returned file name (default is `\"oteapi-download-\"`). suffix: Suffix to append to the returned file name. directory: File directory if `filename` is not provided (is `None`). delete: Whether to automatically delete the created file when leaving the context. Yields: Path object, referencing and representing the created file. \"\"\" if filename : filename = Path ( filename ) . resolve () filename . write_bytes ( self . get ( key )) else : if prefix is None : prefix = \"oteapi-download-\" with tempfile . NamedTemporaryFile ( prefix = prefix , suffix = suffix , dir = directory , delete = False ) as handle : handle . write ( self . get ( key )) filename = Path ( handle . name ) . resolve () try : yield filename finally : if delete : filename . unlink () def evict ( self , tag : str ) -> None : \"\"\"Remove all cache items with the given tag. Useful for cleaning up a session. Args: tag: Tag identifying objects. \"\"\" self . diskcache . evict ( tag ) def clear ( self ) -> None : \"\"\"Remove all items from cache.\"\"\" self . diskcache . clear ()","title":"DataCache"},{"location":"api_reference/datacache/datacache/#oteapi.datacache.datacache.DataCache.add","text":"Add a value to cache. Existing value is overwritten if key is given and it already exists in the cache. Parameters: Name Type Description Default value Any The value to add to the cache. required key Optional[str] If given, use this as the retrieval key. Otherwise the key is either taken from the accessKey configuration or generated as a hash of value . None expire Optional[int] If given, the number of seconds before the value expire. Otherwise it is taken from the configuration. None tag Optional[str] Tag used with evict() for cleaning up a session. None Returns: Type Description str A key that can be used to retrieve value from cache later. Source code in oteapi/datacache/datacache.py def add ( self , value : \"Any\" , key : \"Optional[str]\" = None , expire : \"Optional[int]\" = None , tag : \"Optional[str]\" = None , ) -> str : \"\"\"Add a value to cache. Existing value is overwritten if `key` is given and it already exists in the cache. Args: value: The value to add to the cache. key: If given, use this as the retrieval key. Otherwise the key is either taken from the `accessKey` configuration or generated as a hash of `value`. expire: If given, the number of seconds before the value expire. Otherwise it is taken from the configuration. tag: Tag used with [`evict()`][oteapi.datacache.datacache.DataCache.evict] for cleaning up a session. Returns: A key that can be used to retrieve `value` from cache later. \"\"\" if not key : if self . config . accessKey : key = self . config . accessKey else : key = gethash ( value , hashtype = self . config . hashType ) if not expire : expire = self . config . expireTime self . diskcache . set ( key , value , expire = expire , tag = tag ) return key","title":"add()"},{"location":"api_reference/datacache/datacache/#oteapi.datacache.datacache.DataCache.clear","text":"Remove all items from cache. Source code in oteapi/datacache/datacache.py def clear ( self ) -> None : \"\"\"Remove all items from cache.\"\"\" self . diskcache . clear ()","title":"clear()"},{"location":"api_reference/datacache/datacache/#oteapi.datacache.datacache.DataCache.evict","text":"Remove all cache items with the given tag. Useful for cleaning up a session. Parameters: Name Type Description Default tag str Tag identifying objects. required Source code in oteapi/datacache/datacache.py def evict ( self , tag : str ) -> None : \"\"\"Remove all cache items with the given tag. Useful for cleaning up a session. Args: tag: Tag identifying objects. \"\"\" self . diskcache . evict ( tag )","title":"evict()"},{"location":"api_reference/datacache/datacache/#oteapi.datacache.datacache.DataCache.get","text":"Return the value corresponding to key . Parameters: Name Type Description Default key str The requested cached object to retrieve a value for. required Returns: Type Description Any The value corresponding to the key value. Source code in oteapi/datacache/datacache.py def get ( self , key : str ) -> \"Any\" : \"\"\"Return the value corresponding to `key`. Args: key: The requested cached object to retrieve a value for. Returns: The value corresponding to the `key` value. \"\"\" if key not in self . diskcache : raise KeyError ( key ) return self . diskcache . get ( key )","title":"get()"},{"location":"api_reference/datacache/datacache/#oteapi.datacache.datacache.DataCache.getfile","text":"Write the value for key to file and return the filename. The file is created in the default directory for temporary files (which can be controlled by the TEMPDIR , TEMP or TMP environment variables). It is readable and writable only for the current user. Examples: This method is intended to be used in a with statement, to automatically delete the file when leaving the context: cache = DataCache () with cache . getfile ( 'mykey' ) as filename : # do something with filename... # filename is deleted Parameters: Name Type Description Default key str Key of value to write to file. required filename Optional[Union[Path, str]] Full path to created file. If not given, a unique filename will be created. None prefix Optional[str] Prefix to prepend to the returned file name (default is \"oteapi-download-\" ). None suffix Optional[str] Suffix to append to the returned file name. None directory Optional[str] File directory if filename is not provided (is None ). None delete bool Whether to automatically delete the created file when leaving the context. True Yields: Type Description Iterator[Path] Path object, referencing and representing the created file. Source code in oteapi/datacache/datacache.py @contextmanager def getfile ( # pylint: disable=too-many-arguments self , key : str , filename : \"Optional[Union[Path, str]]\" = None , prefix : \"Optional[str]\" = None , suffix : \"Optional[str]\" = None , directory : \"Optional[str]\" = None , delete : bool = True , ) -> \"Iterator[Path]\" : \"\"\"Write the value for `key` to file and return the filename. The file is created in the default directory for temporary files (which can be controlled by the `TEMPDIR`, `TEMP` or `TMP` environment variables). It is readable and writable only for the current user. Example: This method is intended to be used in a `with` statement, to automatically delete the file when leaving the context: ```python cache = DataCache() with cache.getfile('mykey') as filename: # do something with filename... # filename is deleted ``` Args: key: Key of value to write to file. filename: Full path to created file. If not given, a unique filename will be created. prefix: Prefix to prepend to the returned file name (default is `\"oteapi-download-\"`). suffix: Suffix to append to the returned file name. directory: File directory if `filename` is not provided (is `None`). delete: Whether to automatically delete the created file when leaving the context. Yields: Path object, referencing and representing the created file. \"\"\" if filename : filename = Path ( filename ) . resolve () filename . write_bytes ( self . get ( key )) else : if prefix is None : prefix = \"oteapi-download-\" with tempfile . NamedTemporaryFile ( prefix = prefix , suffix = suffix , dir = directory , delete = False ) as handle : handle . write ( self . get ( key )) filename = Path ( handle . name ) . resolve () try : yield filename finally : if delete : filename . unlink ()","title":"getfile()"},{"location":"api_reference/datacache/datacache/#oteapi.datacache.datacache.gethash","text":"Return a hash of value . Can hash most python objects. Bytes and bytearrays are hashed directly. Strings are converted to bytes with the given encoding. All other objects are first serialised using json. Parameters: Name Type Description Default value Any Value to hash. required hashtype str Any of the hash algorithms supported by hashlib. 'sha256' encoding str Encoding used to convert strings to bytes before calculating the hash. 'utf-8' json_encoder Optional[Type[json.JSONEncoder]] Customised json encoder for complex Python objects. None Returns: Type Description str A hash of the input value . Source code in oteapi/datacache/datacache.py def gethash ( value : \"Any\" , hashtype : str = \"sha256\" , encoding : str = \"utf-8\" , json_encoder : \"Optional[Type[json.JSONEncoder]]\" = None , ) -> str : \"\"\"Return a hash of `value`. Can hash most python objects. Bytes and bytearrays are hashed directly. Strings are converted to bytes with the given encoding. All other objects are first serialised using json. Args: value: Value to hash. hashtype: Any of the hash algorithms supported by hashlib. encoding: Encoding used to convert strings to bytes before calculating the hash. json_encoder: Customised json encoder for complex Python objects. Returns: A hash of the input `value`. \"\"\" if isinstance ( value , ( bytes , bytearray )): data = value elif isinstance ( value , str ): data = value . encode ( encoding ) else : # Try to serialise using json data = json . dumps ( value , ensure_ascii = False , cls = json_encoder , sort_keys = True , ) . encode ( encoding ) hash_ = hashlib . new ( hashtype ) hash_ . update ( data ) return hash_ . hexdigest ()","title":"gethash()"},{"location":"api_reference/interfaces/idownloadstrategy/","text":"idownloadstrategy \u00b6 Download Strategy Interface IDownloadStrategy ( Protocol ) dataclass \u00b6 Download Strategy Interface. Source code in oteapi/interfaces/idownloadstrategy.py @dataclass # type: ignore[misc] class IDownloadStrategy ( Protocol ): \"\"\"Download Strategy Interface.\"\"\" download_config : \"ResourceConfig\" def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"SessionUpdate\" : \"\"\"Execute the strategy. Parameters: session: A session-specific dictionary context. Returns: An update model of key/value-pairs to be stored in the session-specific context from services. \"\"\" def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"SessionUpdate\" : \"\"\"Initialize data class. This method will be called through the `/initialize` endpoint of the OTE-API Services. Parameters: session: A session-specific dictionary context. Returns: An update model of key/value-pairs to be stored in the session-specific context from services. \"\"\" get ( self , session = None ) \u00b6 Execute the strategy. Parameters: Name Type Description Default session Optional[Dict[str, Any]] A session-specific dictionary context. None Returns: Type Description SessionUpdate An update model of key/value-pairs to be stored in the session-specific context from services. Source code in oteapi/interfaces/idownloadstrategy.py def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"SessionUpdate\" : \"\"\"Execute the strategy. Parameters: session: A session-specific dictionary context. Returns: An update model of key/value-pairs to be stored in the session-specific context from services. \"\"\" initialize ( self , session = None ) \u00b6 Initialize data class. This method will be called through the /initialize endpoint of the OTE-API Services. Parameters: Name Type Description Default session Optional[Dict[str, Any]] A session-specific dictionary context. None Returns: Type Description SessionUpdate An update model of key/value-pairs to be stored in the session-specific context from services. Source code in oteapi/interfaces/idownloadstrategy.py def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"SessionUpdate\" : \"\"\"Initialize data class. This method will be called through the `/initialize` endpoint of the OTE-API Services. Parameters: session: A session-specific dictionary context. Returns: An update model of key/value-pairs to be stored in the session-specific context from services. \"\"\"","title":"idownloadstrategy"},{"location":"api_reference/interfaces/idownloadstrategy/#idownloadstrategy","text":"Download Strategy Interface","title":"idownloadstrategy"},{"location":"api_reference/interfaces/idownloadstrategy/#oteapi.interfaces.idownloadstrategy.IDownloadStrategy","text":"Download Strategy Interface. Source code in oteapi/interfaces/idownloadstrategy.py @dataclass # type: ignore[misc] class IDownloadStrategy ( Protocol ): \"\"\"Download Strategy Interface.\"\"\" download_config : \"ResourceConfig\" def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"SessionUpdate\" : \"\"\"Execute the strategy. Parameters: session: A session-specific dictionary context. Returns: An update model of key/value-pairs to be stored in the session-specific context from services. \"\"\" def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"SessionUpdate\" : \"\"\"Initialize data class. This method will be called through the `/initialize` endpoint of the OTE-API Services. Parameters: session: A session-specific dictionary context. Returns: An update model of key/value-pairs to be stored in the session-specific context from services. \"\"\"","title":"IDownloadStrategy"},{"location":"api_reference/interfaces/idownloadstrategy/#oteapi.interfaces.idownloadstrategy.IDownloadStrategy.get","text":"Execute the strategy. Parameters: Name Type Description Default session Optional[Dict[str, Any]] A session-specific dictionary context. None Returns: Type Description SessionUpdate An update model of key/value-pairs to be stored in the session-specific context from services. Source code in oteapi/interfaces/idownloadstrategy.py def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"SessionUpdate\" : \"\"\"Execute the strategy. Parameters: session: A session-specific dictionary context. Returns: An update model of key/value-pairs to be stored in the session-specific context from services. \"\"\"","title":"get()"},{"location":"api_reference/interfaces/idownloadstrategy/#oteapi.interfaces.idownloadstrategy.IDownloadStrategy.initialize","text":"Initialize data class. This method will be called through the /initialize endpoint of the OTE-API Services. Parameters: Name Type Description Default session Optional[Dict[str, Any]] A session-specific dictionary context. None Returns: Type Description SessionUpdate An update model of key/value-pairs to be stored in the session-specific context from services. Source code in oteapi/interfaces/idownloadstrategy.py def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"SessionUpdate\" : \"\"\"Initialize data class. This method will be called through the `/initialize` endpoint of the OTE-API Services. Parameters: session: A session-specific dictionary context. Returns: An update model of key/value-pairs to be stored in the session-specific context from services. \"\"\"","title":"initialize()"},{"location":"api_reference/interfaces/ifilterstrategy/","text":"ifilterstrategy \u00b6 Filter Strategy Interface IFilterStrategy ( Protocol ) dataclass \u00b6 Filter Strategy Interface. Source code in oteapi/interfaces/ifilterstrategy.py @dataclass # type: ignore[misc] class IFilterStrategy ( Protocol ): \"\"\"Filter Strategy Interface.\"\"\" filter_config : \"FilterConfig\" def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"SessionUpdate\" : \"\"\"Execute the strategy. Parameters: session: A session-specific dictionary context. Returns: An update model of key/value-pairs to be stored in the session-specific context from services. \"\"\" def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"SessionUpdate\" : \"\"\"Initialize data class. This method will be called through the `/initialize` endpoint of the OTE-API Services. Parameters: session: A session-specific dictionary context. Returns: An update model of key/value-pairs to be stored in the session-specific context from services. \"\"\" get ( self , session = None ) \u00b6 Execute the strategy. Parameters: Name Type Description Default session Optional[Dict[str, Any]] A session-specific dictionary context. None Returns: Type Description SessionUpdate An update model of key/value-pairs to be stored in the session-specific context from services. Source code in oteapi/interfaces/ifilterstrategy.py def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"SessionUpdate\" : \"\"\"Execute the strategy. Parameters: session: A session-specific dictionary context. Returns: An update model of key/value-pairs to be stored in the session-specific context from services. \"\"\" initialize ( self , session = None ) \u00b6 Initialize data class. This method will be called through the /initialize endpoint of the OTE-API Services. Parameters: Name Type Description Default session Optional[Dict[str, Any]] A session-specific dictionary context. None Returns: Type Description SessionUpdate An update model of key/value-pairs to be stored in the session-specific context from services. Source code in oteapi/interfaces/ifilterstrategy.py def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"SessionUpdate\" : \"\"\"Initialize data class. This method will be called through the `/initialize` endpoint of the OTE-API Services. Parameters: session: A session-specific dictionary context. Returns: An update model of key/value-pairs to be stored in the session-specific context from services. \"\"\"","title":"ifilterstrategy"},{"location":"api_reference/interfaces/ifilterstrategy/#ifilterstrategy","text":"Filter Strategy Interface","title":"ifilterstrategy"},{"location":"api_reference/interfaces/ifilterstrategy/#oteapi.interfaces.ifilterstrategy.IFilterStrategy","text":"Filter Strategy Interface. Source code in oteapi/interfaces/ifilterstrategy.py @dataclass # type: ignore[misc] class IFilterStrategy ( Protocol ): \"\"\"Filter Strategy Interface.\"\"\" filter_config : \"FilterConfig\" def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"SessionUpdate\" : \"\"\"Execute the strategy. Parameters: session: A session-specific dictionary context. Returns: An update model of key/value-pairs to be stored in the session-specific context from services. \"\"\" def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"SessionUpdate\" : \"\"\"Initialize data class. This method will be called through the `/initialize` endpoint of the OTE-API Services. Parameters: session: A session-specific dictionary context. Returns: An update model of key/value-pairs to be stored in the session-specific context from services. \"\"\"","title":"IFilterStrategy"},{"location":"api_reference/interfaces/ifilterstrategy/#oteapi.interfaces.ifilterstrategy.IFilterStrategy.get","text":"Execute the strategy. Parameters: Name Type Description Default session Optional[Dict[str, Any]] A session-specific dictionary context. None Returns: Type Description SessionUpdate An update model of key/value-pairs to be stored in the session-specific context from services. Source code in oteapi/interfaces/ifilterstrategy.py def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"SessionUpdate\" : \"\"\"Execute the strategy. Parameters: session: A session-specific dictionary context. Returns: An update model of key/value-pairs to be stored in the session-specific context from services. \"\"\"","title":"get()"},{"location":"api_reference/interfaces/ifilterstrategy/#oteapi.interfaces.ifilterstrategy.IFilterStrategy.initialize","text":"Initialize data class. This method will be called through the /initialize endpoint of the OTE-API Services. Parameters: Name Type Description Default session Optional[Dict[str, Any]] A session-specific dictionary context. None Returns: Type Description SessionUpdate An update model of key/value-pairs to be stored in the session-specific context from services. Source code in oteapi/interfaces/ifilterstrategy.py def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"SessionUpdate\" : \"\"\"Initialize data class. This method will be called through the `/initialize` endpoint of the OTE-API Services. Parameters: session: A session-specific dictionary context. Returns: An update model of key/value-pairs to be stored in the session-specific context from services. \"\"\"","title":"initialize()"},{"location":"api_reference/interfaces/ifunctionstrategy/","text":"ifunctionstrategy \u00b6 Function Strategy Interface IFunctionStrategy ( Protocol ) dataclass \u00b6 Function Strategy Interface. Source code in oteapi/interfaces/ifunctionstrategy.py @dataclass # type: ignore[misc] class IFunctionStrategy ( Protocol ): \"\"\"Function Strategy Interface.\"\"\" function_config : \"FunctionConfig\" def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"SessionUpdate\" : \"\"\"Execute the strategy. Parameters: session: A session-specific dictionary context. Returns: An update model of key/value-pairs to be stored in the session-specific context from services. \"\"\" def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"SessionUpdate\" : \"\"\"Initialize data class. This method will be called through the `/initialize` endpoint of the OTE-API Services. Parameters: session: A session-specific dictionary context. Returns: An update model of key/value-pairs to be stored in the session-specific context from services. \"\"\" get ( self , session = None ) \u00b6 Execute the strategy. Parameters: Name Type Description Default session Optional[Dict[str, Any]] A session-specific dictionary context. None Returns: Type Description SessionUpdate An update model of key/value-pairs to be stored in the session-specific context from services. Source code in oteapi/interfaces/ifunctionstrategy.py def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"SessionUpdate\" : \"\"\"Execute the strategy. Parameters: session: A session-specific dictionary context. Returns: An update model of key/value-pairs to be stored in the session-specific context from services. \"\"\" initialize ( self , session = None ) \u00b6 Initialize data class. This method will be called through the /initialize endpoint of the OTE-API Services. Parameters: Name Type Description Default session Optional[Dict[str, Any]] A session-specific dictionary context. None Returns: Type Description SessionUpdate An update model of key/value-pairs to be stored in the session-specific context from services. Source code in oteapi/interfaces/ifunctionstrategy.py def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"SessionUpdate\" : \"\"\"Initialize data class. This method will be called through the `/initialize` endpoint of the OTE-API Services. Parameters: session: A session-specific dictionary context. Returns: An update model of key/value-pairs to be stored in the session-specific context from services. \"\"\"","title":"ifunctionstrategy"},{"location":"api_reference/interfaces/ifunctionstrategy/#ifunctionstrategy","text":"Function Strategy Interface","title":"ifunctionstrategy"},{"location":"api_reference/interfaces/ifunctionstrategy/#oteapi.interfaces.ifunctionstrategy.IFunctionStrategy","text":"Function Strategy Interface. Source code in oteapi/interfaces/ifunctionstrategy.py @dataclass # type: ignore[misc] class IFunctionStrategy ( Protocol ): \"\"\"Function Strategy Interface.\"\"\" function_config : \"FunctionConfig\" def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"SessionUpdate\" : \"\"\"Execute the strategy. Parameters: session: A session-specific dictionary context. Returns: An update model of key/value-pairs to be stored in the session-specific context from services. \"\"\" def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"SessionUpdate\" : \"\"\"Initialize data class. This method will be called through the `/initialize` endpoint of the OTE-API Services. Parameters: session: A session-specific dictionary context. Returns: An update model of key/value-pairs to be stored in the session-specific context from services. \"\"\"","title":"IFunctionStrategy"},{"location":"api_reference/interfaces/ifunctionstrategy/#oteapi.interfaces.ifunctionstrategy.IFunctionStrategy.get","text":"Execute the strategy. Parameters: Name Type Description Default session Optional[Dict[str, Any]] A session-specific dictionary context. None Returns: Type Description SessionUpdate An update model of key/value-pairs to be stored in the session-specific context from services. Source code in oteapi/interfaces/ifunctionstrategy.py def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"SessionUpdate\" : \"\"\"Execute the strategy. Parameters: session: A session-specific dictionary context. Returns: An update model of key/value-pairs to be stored in the session-specific context from services. \"\"\"","title":"get()"},{"location":"api_reference/interfaces/ifunctionstrategy/#oteapi.interfaces.ifunctionstrategy.IFunctionStrategy.initialize","text":"Initialize data class. This method will be called through the /initialize endpoint of the OTE-API Services. Parameters: Name Type Description Default session Optional[Dict[str, Any]] A session-specific dictionary context. None Returns: Type Description SessionUpdate An update model of key/value-pairs to be stored in the session-specific context from services. Source code in oteapi/interfaces/ifunctionstrategy.py def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"SessionUpdate\" : \"\"\"Initialize data class. This method will be called through the `/initialize` endpoint of the OTE-API Services. Parameters: session: A session-specific dictionary context. Returns: An update model of key/value-pairs to be stored in the session-specific context from services. \"\"\"","title":"initialize()"},{"location":"api_reference/interfaces/imappingstrategy/","text":"imappingstrategy \u00b6 Mapping Strategy Interface IMappingStrategy ( Protocol ) dataclass \u00b6 Mapping Strategy Interface. Source code in oteapi/interfaces/imappingstrategy.py @dataclass # type: ignore[misc] class IMappingStrategy ( Protocol ): \"\"\"Mapping Strategy Interface.\"\"\" mapping_config : \"MappingConfig\" def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"SessionUpdate\" : \"\"\"Execute the strategy. Parameters: session: A session-specific dictionary context. Returns: An update model of key/value-pairs to be stored in the session-specific context from services. \"\"\" def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"SessionUpdate\" : \"\"\"Initialize data class. This method will be called through the `/initialize` endpoint of the OTE-API Services. Parameters: session: A session-specific dictionary context. Returns: An update model of key/value-pairs to be stored in the session-specific context from services. \"\"\" get ( self , session = None ) \u00b6 Execute the strategy. Parameters: Name Type Description Default session Optional[Dict[str, Any]] A session-specific dictionary context. None Returns: Type Description SessionUpdate An update model of key/value-pairs to be stored in the session-specific context from services. Source code in oteapi/interfaces/imappingstrategy.py def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"SessionUpdate\" : \"\"\"Execute the strategy. Parameters: session: A session-specific dictionary context. Returns: An update model of key/value-pairs to be stored in the session-specific context from services. \"\"\" initialize ( self , session = None ) \u00b6 Initialize data class. This method will be called through the /initialize endpoint of the OTE-API Services. Parameters: Name Type Description Default session Optional[Dict[str, Any]] A session-specific dictionary context. None Returns: Type Description SessionUpdate An update model of key/value-pairs to be stored in the session-specific context from services. Source code in oteapi/interfaces/imappingstrategy.py def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"SessionUpdate\" : \"\"\"Initialize data class. This method will be called through the `/initialize` endpoint of the OTE-API Services. Parameters: session: A session-specific dictionary context. Returns: An update model of key/value-pairs to be stored in the session-specific context from services. \"\"\"","title":"imappingstrategy"},{"location":"api_reference/interfaces/imappingstrategy/#imappingstrategy","text":"Mapping Strategy Interface","title":"imappingstrategy"},{"location":"api_reference/interfaces/imappingstrategy/#oteapi.interfaces.imappingstrategy.IMappingStrategy","text":"Mapping Strategy Interface. Source code in oteapi/interfaces/imappingstrategy.py @dataclass # type: ignore[misc] class IMappingStrategy ( Protocol ): \"\"\"Mapping Strategy Interface.\"\"\" mapping_config : \"MappingConfig\" def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"SessionUpdate\" : \"\"\"Execute the strategy. Parameters: session: A session-specific dictionary context. Returns: An update model of key/value-pairs to be stored in the session-specific context from services. \"\"\" def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"SessionUpdate\" : \"\"\"Initialize data class. This method will be called through the `/initialize` endpoint of the OTE-API Services. Parameters: session: A session-specific dictionary context. Returns: An update model of key/value-pairs to be stored in the session-specific context from services. \"\"\"","title":"IMappingStrategy"},{"location":"api_reference/interfaces/imappingstrategy/#oteapi.interfaces.imappingstrategy.IMappingStrategy.get","text":"Execute the strategy. Parameters: Name Type Description Default session Optional[Dict[str, Any]] A session-specific dictionary context. None Returns: Type Description SessionUpdate An update model of key/value-pairs to be stored in the session-specific context from services. Source code in oteapi/interfaces/imappingstrategy.py def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"SessionUpdate\" : \"\"\"Execute the strategy. Parameters: session: A session-specific dictionary context. Returns: An update model of key/value-pairs to be stored in the session-specific context from services. \"\"\"","title":"get()"},{"location":"api_reference/interfaces/imappingstrategy/#oteapi.interfaces.imappingstrategy.IMappingStrategy.initialize","text":"Initialize data class. This method will be called through the /initialize endpoint of the OTE-API Services. Parameters: Name Type Description Default session Optional[Dict[str, Any]] A session-specific dictionary context. None Returns: Type Description SessionUpdate An update model of key/value-pairs to be stored in the session-specific context from services. Source code in oteapi/interfaces/imappingstrategy.py def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"SessionUpdate\" : \"\"\"Initialize data class. This method will be called through the `/initialize` endpoint of the OTE-API Services. Parameters: session: A session-specific dictionary context. Returns: An update model of key/value-pairs to be stored in the session-specific context from services. \"\"\"","title":"initialize()"},{"location":"api_reference/interfaces/iparsestrategy/","text":"iparsestrategy \u00b6 Parse Strategy Interface IParseStrategy ( Protocol ) dataclass \u00b6 Parse Strategy Interface. Source code in oteapi/interfaces/iparsestrategy.py @dataclass # type: ignore[misc] class IParseStrategy ( Protocol ): \"\"\"Parse Strategy Interface.\"\"\" parse_config : \"ResourceConfig\" def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"SessionUpdate\" : \"\"\"Execute the strategy. Parameters: session: A session-specific dictionary context. Returns: An update model of key/value-pairs to be stored in the session-specific context from services. \"\"\" def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"SessionUpdate\" : \"\"\"Initialize data class. This method will be called through the `/initialize` endpoint of the OTE-API Services. Parameters: session: A session-specific dictionary context. Returns: An update model of key/value-pairs to be stored in the session-specific context from services. \"\"\" get ( self , session = None ) \u00b6 Execute the strategy. Parameters: Name Type Description Default session Optional[Dict[str, Any]] A session-specific dictionary context. None Returns: Type Description SessionUpdate An update model of key/value-pairs to be stored in the session-specific context from services. Source code in oteapi/interfaces/iparsestrategy.py def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"SessionUpdate\" : \"\"\"Execute the strategy. Parameters: session: A session-specific dictionary context. Returns: An update model of key/value-pairs to be stored in the session-specific context from services. \"\"\" initialize ( self , session = None ) \u00b6 Initialize data class. This method will be called through the /initialize endpoint of the OTE-API Services. Parameters: Name Type Description Default session Optional[Dict[str, Any]] A session-specific dictionary context. None Returns: Type Description SessionUpdate An update model of key/value-pairs to be stored in the session-specific context from services. Source code in oteapi/interfaces/iparsestrategy.py def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"SessionUpdate\" : \"\"\"Initialize data class. This method will be called through the `/initialize` endpoint of the OTE-API Services. Parameters: session: A session-specific dictionary context. Returns: An update model of key/value-pairs to be stored in the session-specific context from services. \"\"\"","title":"iparsestrategy"},{"location":"api_reference/interfaces/iparsestrategy/#iparsestrategy","text":"Parse Strategy Interface","title":"iparsestrategy"},{"location":"api_reference/interfaces/iparsestrategy/#oteapi.interfaces.iparsestrategy.IParseStrategy","text":"Parse Strategy Interface. Source code in oteapi/interfaces/iparsestrategy.py @dataclass # type: ignore[misc] class IParseStrategy ( Protocol ): \"\"\"Parse Strategy Interface.\"\"\" parse_config : \"ResourceConfig\" def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"SessionUpdate\" : \"\"\"Execute the strategy. Parameters: session: A session-specific dictionary context. Returns: An update model of key/value-pairs to be stored in the session-specific context from services. \"\"\" def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"SessionUpdate\" : \"\"\"Initialize data class. This method will be called through the `/initialize` endpoint of the OTE-API Services. Parameters: session: A session-specific dictionary context. Returns: An update model of key/value-pairs to be stored in the session-specific context from services. \"\"\"","title":"IParseStrategy"},{"location":"api_reference/interfaces/iparsestrategy/#oteapi.interfaces.iparsestrategy.IParseStrategy.get","text":"Execute the strategy. Parameters: Name Type Description Default session Optional[Dict[str, Any]] A session-specific dictionary context. None Returns: Type Description SessionUpdate An update model of key/value-pairs to be stored in the session-specific context from services. Source code in oteapi/interfaces/iparsestrategy.py def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"SessionUpdate\" : \"\"\"Execute the strategy. Parameters: session: A session-specific dictionary context. Returns: An update model of key/value-pairs to be stored in the session-specific context from services. \"\"\"","title":"get()"},{"location":"api_reference/interfaces/iparsestrategy/#oteapi.interfaces.iparsestrategy.IParseStrategy.initialize","text":"Initialize data class. This method will be called through the /initialize endpoint of the OTE-API Services. Parameters: Name Type Description Default session Optional[Dict[str, Any]] A session-specific dictionary context. None Returns: Type Description SessionUpdate An update model of key/value-pairs to be stored in the session-specific context from services. Source code in oteapi/interfaces/iparsestrategy.py def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"SessionUpdate\" : \"\"\"Initialize data class. This method will be called through the `/initialize` endpoint of the OTE-API Services. Parameters: session: A session-specific dictionary context. Returns: An update model of key/value-pairs to be stored in the session-specific context from services. \"\"\"","title":"initialize()"},{"location":"api_reference/interfaces/iresourcestrategy/","text":"iresourcestrategy \u00b6 Resource Strategy Interface IResourceStrategy ( Protocol ) dataclass \u00b6 Resource Strategy Interface. Source code in oteapi/interfaces/iresourcestrategy.py @dataclass # type: ignore[misc] class IResourceStrategy ( Protocol ): \"\"\"Resource Strategy Interface.\"\"\" resource_config : \"ResourceConfig\" def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"SessionUpdate\" : \"\"\"Execute the strategy. Parameters: session: A session-specific dictionary context. Returns: An update model of key/value-pairs to be stored in the session-specific context from services. \"\"\" def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"SessionUpdate\" : \"\"\"Initialize data class. This method will be called through the `/initialize` endpoint of the OTE-API Services. Parameters: session: A session-specific dictionary context. Returns: An update model of key/value-pairs to be stored in the session-specific context from services. \"\"\" get ( self , session = None ) \u00b6 Execute the strategy. Parameters: Name Type Description Default session Optional[Dict[str, Any]] A session-specific dictionary context. None Returns: Type Description SessionUpdate An update model of key/value-pairs to be stored in the session-specific context from services. Source code in oteapi/interfaces/iresourcestrategy.py def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"SessionUpdate\" : \"\"\"Execute the strategy. Parameters: session: A session-specific dictionary context. Returns: An update model of key/value-pairs to be stored in the session-specific context from services. \"\"\" initialize ( self , session = None ) \u00b6 Initialize data class. This method will be called through the /initialize endpoint of the OTE-API Services. Parameters: Name Type Description Default session Optional[Dict[str, Any]] A session-specific dictionary context. None Returns: Type Description SessionUpdate An update model of key/value-pairs to be stored in the session-specific context from services. Source code in oteapi/interfaces/iresourcestrategy.py def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"SessionUpdate\" : \"\"\"Initialize data class. This method will be called through the `/initialize` endpoint of the OTE-API Services. Parameters: session: A session-specific dictionary context. Returns: An update model of key/value-pairs to be stored in the session-specific context from services. \"\"\"","title":"iresourcestrategy"},{"location":"api_reference/interfaces/iresourcestrategy/#iresourcestrategy","text":"Resource Strategy Interface","title":"iresourcestrategy"},{"location":"api_reference/interfaces/iresourcestrategy/#oteapi.interfaces.iresourcestrategy.IResourceStrategy","text":"Resource Strategy Interface. Source code in oteapi/interfaces/iresourcestrategy.py @dataclass # type: ignore[misc] class IResourceStrategy ( Protocol ): \"\"\"Resource Strategy Interface.\"\"\" resource_config : \"ResourceConfig\" def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"SessionUpdate\" : \"\"\"Execute the strategy. Parameters: session: A session-specific dictionary context. Returns: An update model of key/value-pairs to be stored in the session-specific context from services. \"\"\" def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"SessionUpdate\" : \"\"\"Initialize data class. This method will be called through the `/initialize` endpoint of the OTE-API Services. Parameters: session: A session-specific dictionary context. Returns: An update model of key/value-pairs to be stored in the session-specific context from services. \"\"\"","title":"IResourceStrategy"},{"location":"api_reference/interfaces/iresourcestrategy/#oteapi.interfaces.iresourcestrategy.IResourceStrategy.get","text":"Execute the strategy. Parameters: Name Type Description Default session Optional[Dict[str, Any]] A session-specific dictionary context. None Returns: Type Description SessionUpdate An update model of key/value-pairs to be stored in the session-specific context from services. Source code in oteapi/interfaces/iresourcestrategy.py def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"SessionUpdate\" : \"\"\"Execute the strategy. Parameters: session: A session-specific dictionary context. Returns: An update model of key/value-pairs to be stored in the session-specific context from services. \"\"\"","title":"get()"},{"location":"api_reference/interfaces/iresourcestrategy/#oteapi.interfaces.iresourcestrategy.IResourceStrategy.initialize","text":"Initialize data class. This method will be called through the /initialize endpoint of the OTE-API Services. Parameters: Name Type Description Default session Optional[Dict[str, Any]] A session-specific dictionary context. None Returns: Type Description SessionUpdate An update model of key/value-pairs to be stored in the session-specific context from services. Source code in oteapi/interfaces/iresourcestrategy.py def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"SessionUpdate\" : \"\"\"Initialize data class. This method will be called through the `/initialize` endpoint of the OTE-API Services. Parameters: session: A session-specific dictionary context. Returns: An update model of key/value-pairs to be stored in the session-specific context from services. \"\"\"","title":"initialize()"},{"location":"api_reference/interfaces/itransformationstrategy/","text":"itransformationstrategy \u00b6 Tranformation Strategy Interface ITransformationStrategy ( Protocol ) dataclass \u00b6 Transformation Strategy Interface. Source code in oteapi/interfaces/itransformationstrategy.py @dataclass # type: ignore[misc] class ITransformationStrategy ( Protocol ): \"\"\"Transformation Strategy Interface.\"\"\" transformation_config : \"TransformationConfig\" def run ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"SessionUpdate\" : \"\"\"Run a transformation job. Parameters: session: A session-specific dictionary context. Returns: An update model of key/value-pairs to be stored in the session-specific context from services. As a minimum, the dictionary will contain the job ID. \"\"\" def status ( self , task_id : str ) -> \"TransformationStatus\" : \"\"\"Get job status. Parameters: task_id: The transformation job ID. Returns: An overview of the transformation job's status, including relevant metadata. \"\"\" def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"SessionUpdate\" : \"\"\"Execute the strategy. Parameters: session: A session-specific dictionary context. Returns: An update model of key/value-pairs to be stored in the session-specific context from services. \"\"\" def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"SessionUpdate\" : \"\"\"Initialize data class. This method will be called through the `/initialize` endpoint of the OTE-API Services. Parameters: session: A session-specific dictionary context. Returns: An update model of key/value-pairs to be stored in the session-specific context from services. \"\"\" get ( self , session = None ) \u00b6 Execute the strategy. Parameters: Name Type Description Default session Optional[Dict[str, Any]] A session-specific dictionary context. None Returns: Type Description SessionUpdate An update model of key/value-pairs to be stored in the session-specific context from services. Source code in oteapi/interfaces/itransformationstrategy.py def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"SessionUpdate\" : \"\"\"Execute the strategy. Parameters: session: A session-specific dictionary context. Returns: An update model of key/value-pairs to be stored in the session-specific context from services. \"\"\" initialize ( self , session = None ) \u00b6 Initialize data class. This method will be called through the /initialize endpoint of the OTE-API Services. Parameters: Name Type Description Default session Optional[Dict[str, Any]] A session-specific dictionary context. None Returns: Type Description SessionUpdate An update model of key/value-pairs to be stored in the session-specific context from services. Source code in oteapi/interfaces/itransformationstrategy.py def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"SessionUpdate\" : \"\"\"Initialize data class. This method will be called through the `/initialize` endpoint of the OTE-API Services. Parameters: session: A session-specific dictionary context. Returns: An update model of key/value-pairs to be stored in the session-specific context from services. \"\"\" run ( self , session = None ) \u00b6 Run a transformation job. Parameters: Name Type Description Default session Optional[Dict[str, Any]] A session-specific dictionary context. None Returns: Type Description SessionUpdate An update model of key/value-pairs to be stored in the session-specific context from services. As a minimum, the dictionary will contain the job ID. Source code in oteapi/interfaces/itransformationstrategy.py def run ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"SessionUpdate\" : \"\"\"Run a transformation job. Parameters: session: A session-specific dictionary context. Returns: An update model of key/value-pairs to be stored in the session-specific context from services. As a minimum, the dictionary will contain the job ID. \"\"\" status ( self , task_id ) \u00b6 Get job status. Parameters: Name Type Description Default task_id str The transformation job ID. required Returns: Type Description TransformationStatus An overview of the transformation job's status, including relevant metadata. Source code in oteapi/interfaces/itransformationstrategy.py def status ( self , task_id : str ) -> \"TransformationStatus\" : \"\"\"Get job status. Parameters: task_id: The transformation job ID. Returns: An overview of the transformation job's status, including relevant metadata. \"\"\"","title":"itransformationstrategy"},{"location":"api_reference/interfaces/itransformationstrategy/#itransformationstrategy","text":"Tranformation Strategy Interface","title":"itransformationstrategy"},{"location":"api_reference/interfaces/itransformationstrategy/#oteapi.interfaces.itransformationstrategy.ITransformationStrategy","text":"Transformation Strategy Interface. Source code in oteapi/interfaces/itransformationstrategy.py @dataclass # type: ignore[misc] class ITransformationStrategy ( Protocol ): \"\"\"Transformation Strategy Interface.\"\"\" transformation_config : \"TransformationConfig\" def run ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"SessionUpdate\" : \"\"\"Run a transformation job. Parameters: session: A session-specific dictionary context. Returns: An update model of key/value-pairs to be stored in the session-specific context from services. As a minimum, the dictionary will contain the job ID. \"\"\" def status ( self , task_id : str ) -> \"TransformationStatus\" : \"\"\"Get job status. Parameters: task_id: The transformation job ID. Returns: An overview of the transformation job's status, including relevant metadata. \"\"\" def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"SessionUpdate\" : \"\"\"Execute the strategy. Parameters: session: A session-specific dictionary context. Returns: An update model of key/value-pairs to be stored in the session-specific context from services. \"\"\" def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"SessionUpdate\" : \"\"\"Initialize data class. This method will be called through the `/initialize` endpoint of the OTE-API Services. Parameters: session: A session-specific dictionary context. Returns: An update model of key/value-pairs to be stored in the session-specific context from services. \"\"\"","title":"ITransformationStrategy"},{"location":"api_reference/interfaces/itransformationstrategy/#oteapi.interfaces.itransformationstrategy.ITransformationStrategy.get","text":"Execute the strategy. Parameters: Name Type Description Default session Optional[Dict[str, Any]] A session-specific dictionary context. None Returns: Type Description SessionUpdate An update model of key/value-pairs to be stored in the session-specific context from services. Source code in oteapi/interfaces/itransformationstrategy.py def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"SessionUpdate\" : \"\"\"Execute the strategy. Parameters: session: A session-specific dictionary context. Returns: An update model of key/value-pairs to be stored in the session-specific context from services. \"\"\"","title":"get()"},{"location":"api_reference/interfaces/itransformationstrategy/#oteapi.interfaces.itransformationstrategy.ITransformationStrategy.initialize","text":"Initialize data class. This method will be called through the /initialize endpoint of the OTE-API Services. Parameters: Name Type Description Default session Optional[Dict[str, Any]] A session-specific dictionary context. None Returns: Type Description SessionUpdate An update model of key/value-pairs to be stored in the session-specific context from services. Source code in oteapi/interfaces/itransformationstrategy.py def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"SessionUpdate\" : \"\"\"Initialize data class. This method will be called through the `/initialize` endpoint of the OTE-API Services. Parameters: session: A session-specific dictionary context. Returns: An update model of key/value-pairs to be stored in the session-specific context from services. \"\"\"","title":"initialize()"},{"location":"api_reference/interfaces/itransformationstrategy/#oteapi.interfaces.itransformationstrategy.ITransformationStrategy.run","text":"Run a transformation job. Parameters: Name Type Description Default session Optional[Dict[str, Any]] A session-specific dictionary context. None Returns: Type Description SessionUpdate An update model of key/value-pairs to be stored in the session-specific context from services. As a minimum, the dictionary will contain the job ID. Source code in oteapi/interfaces/itransformationstrategy.py def run ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"SessionUpdate\" : \"\"\"Run a transformation job. Parameters: session: A session-specific dictionary context. Returns: An update model of key/value-pairs to be stored in the session-specific context from services. As a minimum, the dictionary will contain the job ID. \"\"\"","title":"run()"},{"location":"api_reference/interfaces/itransformationstrategy/#oteapi.interfaces.itransformationstrategy.ITransformationStrategy.status","text":"Get job status. Parameters: Name Type Description Default task_id str The transformation job ID. required Returns: Type Description TransformationStatus An overview of the transformation job's status, including relevant metadata. Source code in oteapi/interfaces/itransformationstrategy.py def status ( self , task_id : str ) -> \"TransformationStatus\" : \"\"\"Get job status. Parameters: task_id: The transformation job ID. Returns: An overview of the transformation job's status, including relevant metadata. \"\"\"","title":"status()"},{"location":"api_reference/models/datacacheconfig/","text":"datacacheconfig \u00b6 Pydantic DataCache Configuration Data Model. DataCacheConfig ( AttrDict ) pydantic-model \u00b6 DataCache Configuration. This class should not be used directly as a configuration object for a strategy object, but only as a configuration field inside a configuration object. Source code in oteapi/models/datacacheconfig.py class DataCacheConfig ( AttrDict ): \"\"\"DataCache Configuration. This class should not be used directly as a configuration object for a strategy object, but only as a configuration field inside a configuration object. \"\"\" cacheDir : Path = Field ( \"oteapi\" , description = \"Cache directory.\" ) accessKey : str = Field ( None , description = \"Key with which the downloaded content can be accessed. \" \"Should preferable be the hash (corresponding to `hashType`) of the \" \"content if it is known.\" , ) hashType : str = Field ( \"md5\" , description = \"Hash algorithm to use for creating hash keys for stored \" \"data. Can be any algorithm supported by hashlib.\" , ) expireTime : int = Field ( 3600 * 24 * 14 , description = \"Number of seconds before the cache entry expires. \" \"Zero means no expiration. Default is two weeks.\" , ) tag : str = Field ( None , description = \"Tag assigned to the downloaded content, typically \" \"identifying a session. Used with the `evict()` method to clean up a \" \"all cache entries with a given tag.\" , ) accessKey : str pydantic-field \u00b6 Key with which the downloaded content can be accessed. Should preferable be the hash (corresponding to hashType ) of the content if it is known. cacheDir : Path pydantic-field \u00b6 Cache directory. expireTime : int pydantic-field \u00b6 Number of seconds before the cache entry expires. Zero means no expiration. Default is two weeks. hashType : str pydantic-field \u00b6 Hash algorithm to use for creating hash keys for stored data. Can be any algorithm supported by hashlib. tag : str pydantic-field \u00b6 Tag assigned to the downloaded content, typically identifying a session. Used with the evict() method to clean up a all cache entries with a given tag.","title":"datacacheconfig"},{"location":"api_reference/models/datacacheconfig/#datacacheconfig","text":"Pydantic DataCache Configuration Data Model.","title":"datacacheconfig"},{"location":"api_reference/models/datacacheconfig/#oteapi.models.datacacheconfig.DataCacheConfig","text":"DataCache Configuration. This class should not be used directly as a configuration object for a strategy object, but only as a configuration field inside a configuration object. Source code in oteapi/models/datacacheconfig.py class DataCacheConfig ( AttrDict ): \"\"\"DataCache Configuration. This class should not be used directly as a configuration object for a strategy object, but only as a configuration field inside a configuration object. \"\"\" cacheDir : Path = Field ( \"oteapi\" , description = \"Cache directory.\" ) accessKey : str = Field ( None , description = \"Key with which the downloaded content can be accessed. \" \"Should preferable be the hash (corresponding to `hashType`) of the \" \"content if it is known.\" , ) hashType : str = Field ( \"md5\" , description = \"Hash algorithm to use for creating hash keys for stored \" \"data. Can be any algorithm supported by hashlib.\" , ) expireTime : int = Field ( 3600 * 24 * 14 , description = \"Number of seconds before the cache entry expires. \" \"Zero means no expiration. Default is two weeks.\" , ) tag : str = Field ( None , description = \"Tag assigned to the downloaded content, typically \" \"identifying a session. Used with the `evict()` method to clean up a \" \"all cache entries with a given tag.\" , )","title":"DataCacheConfig"},{"location":"api_reference/models/datacacheconfig/#oteapi.models.datacacheconfig.DataCacheConfig.accessKey","text":"Key with which the downloaded content can be accessed. Should preferable be the hash (corresponding to hashType ) of the content if it is known.","title":"accessKey"},{"location":"api_reference/models/datacacheconfig/#oteapi.models.datacacheconfig.DataCacheConfig.cacheDir","text":"Cache directory.","title":"cacheDir"},{"location":"api_reference/models/datacacheconfig/#oteapi.models.datacacheconfig.DataCacheConfig.expireTime","text":"Number of seconds before the cache entry expires. Zero means no expiration. Default is two weeks.","title":"expireTime"},{"location":"api_reference/models/datacacheconfig/#oteapi.models.datacacheconfig.DataCacheConfig.hashType","text":"Hash algorithm to use for creating hash keys for stored data. Can be any algorithm supported by hashlib.","title":"hashType"},{"location":"api_reference/models/datacacheconfig/#oteapi.models.datacacheconfig.DataCacheConfig.tag","text":"Tag assigned to the downloaded content, typically identifying a session. Used with the evict() method to clean up a all cache entries with a given tag.","title":"tag"},{"location":"api_reference/models/filterconfig/","text":"filterconfig \u00b6 Pydantic Filter Configuration Data Model. FilterConfig ( GenericConfig ) pydantic-model \u00b6 Filter Strategy Data Configuration. Source code in oteapi/models/filterconfig.py class FilterConfig ( GenericConfig ): \"\"\"Filter Strategy Data Configuration.\"\"\" filterType : str = Field ( ... , description = \"Type of registered filter strategy. E.g., `filter/sql`.\" ) query : Optional [ str ] = Field ( None , description = \"Define a query operation.\" ) condition : Optional [ str ] = Field ( None , description = \"Logical statement indicating when a filter should be applied.\" , ) limit : Optional [ int ] = Field ( None , description = \"Number of items remaining after a filter expression.\" ) condition : str pydantic-field \u00b6 Logical statement indicating when a filter should be applied. filterType : str pydantic-field required \u00b6 Type of registered filter strategy. E.g., filter/sql . limit : int pydantic-field \u00b6 Number of items remaining after a filter expression. query : str pydantic-field \u00b6 Define a query operation.","title":"filterconfig"},{"location":"api_reference/models/filterconfig/#filterconfig","text":"Pydantic Filter Configuration Data Model.","title":"filterconfig"},{"location":"api_reference/models/filterconfig/#oteapi.models.filterconfig.FilterConfig","text":"Filter Strategy Data Configuration. Source code in oteapi/models/filterconfig.py class FilterConfig ( GenericConfig ): \"\"\"Filter Strategy Data Configuration.\"\"\" filterType : str = Field ( ... , description = \"Type of registered filter strategy. E.g., `filter/sql`.\" ) query : Optional [ str ] = Field ( None , description = \"Define a query operation.\" ) condition : Optional [ str ] = Field ( None , description = \"Logical statement indicating when a filter should be applied.\" , ) limit : Optional [ int ] = Field ( None , description = \"Number of items remaining after a filter expression.\" )","title":"FilterConfig"},{"location":"api_reference/models/filterconfig/#oteapi.models.filterconfig.FilterConfig.condition","text":"Logical statement indicating when a filter should be applied.","title":"condition"},{"location":"api_reference/models/filterconfig/#oteapi.models.filterconfig.FilterConfig.filterType","text":"Type of registered filter strategy. E.g., filter/sql .","title":"filterType"},{"location":"api_reference/models/filterconfig/#oteapi.models.filterconfig.FilterConfig.limit","text":"Number of items remaining after a filter expression.","title":"limit"},{"location":"api_reference/models/filterconfig/#oteapi.models.filterconfig.FilterConfig.query","text":"Define a query operation.","title":"query"},{"location":"api_reference/models/functionconfig/","text":"functionconfig \u00b6 Pydantic Function Configuration Data Model. FunctionConfig ( GenericConfig ) pydantic-model \u00b6 Function Strategy Data Configuration. Source code in oteapi/models/functionconfig.py class FunctionConfig ( GenericConfig ): \"\"\"Function Strategy Data Configuration.\"\"\" functionType : str = Field ( ... , description = ( \"Type of registered function strategy.\" ), ) functionType : str pydantic-field required \u00b6 Type of registered function strategy.","title":"functionconfig"},{"location":"api_reference/models/functionconfig/#functionconfig","text":"Pydantic Function Configuration Data Model.","title":"functionconfig"},{"location":"api_reference/models/functionconfig/#oteapi.models.functionconfig.FunctionConfig","text":"Function Strategy Data Configuration. Source code in oteapi/models/functionconfig.py class FunctionConfig ( GenericConfig ): \"\"\"Function Strategy Data Configuration.\"\"\" functionType : str = Field ( ... , description = ( \"Type of registered function strategy.\" ), )","title":"FunctionConfig"},{"location":"api_reference/models/functionconfig/#oteapi.models.functionconfig.FunctionConfig.functionType","text":"Type of registered function strategy.","title":"functionType"},{"location":"api_reference/models/genericconfig/","text":"genericconfig \u00b6 Generic data model for configuration attributes. AttrDict ( BaseModel ) pydantic-model \u00b6 An object whose attributes can also be accessed through subscription, like with a dictionary. Source code in oteapi/models/genericconfig.py class AttrDict ( BaseModel ): \"\"\"An object whose attributes can also be accessed through subscription, like with a dictionary.\"\"\" class Config : \"\"\"Class for configuration of pydantic models.\"\"\" extra = \"allow\" def __contains__ ( self , name : Any ) -> bool : \"\"\"Enable using the 'in' operator on this object.\"\"\" return self . __dict__ . __contains__ ( name ) def __delitem__ ( self , key : str ) -> None : \"\"\"Enable deletion access through subscription.\"\"\" if key in dir ( self ): self . __delattr__ ( key ) if key in self . __fields__ : del self . __fields__ [ key ] self . __fields_set__ . remove ( key ) # pylint: disable=no-member else : raise KeyError ( key ) def __getitem__ ( self , key : str ) -> Any : \"\"\"Enable read access through subscription.\"\"\" if key in dir ( self ): return getattr ( self , key ) raise KeyError ( key ) def __setattr__ ( self , name : str , value : Any ) -> None : \"\"\"Extend BaseModel.__setattr__ with type-checking.\"\"\" if name in self . __dict__ and self . __dict__ [ name ]: target_type = type ( self . __dict__ [ name ]) if not isinstance ( value , target_type ): raise TypeError ( \"Mapped value must be subclass of \" + target_type . __name__ ) super () . __setattr__ ( name , value ) def __setitem__ ( self , key : str , value : Any ) -> None : \"\"\"Enable write access through subscription.\"\"\" self . __setattr__ ( key , value ) def __len__ ( self ): \"\"\"Return number of items.\"\"\" return self . __dict__ . __len__ () def __iter__ ( self ): \"\"\"Enable **unpacking.\"\"\" return self . __dict__ . __iter__ () def items ( self ): \"\"\"Return a view of all (key, value) pairs.\"\"\" return self . __dict__ . items () def keys ( self ): \"\"\"Return a view of all keys.\"\"\" return self . __dict__ . keys () def values ( self ): \"\"\"Return a view of all values.\"\"\" return self . __dict__ . values () def get ( self , key : str , default : Optional [ Any ] = None ) -> Any : \"\"\"Mapping `get`-method.\"\"\" return self . __dict__ . get ( key , default ) def __ne__ ( self , other : Any ) -> bool : if isinstance ( other , BaseModel ): return self . dict () != other . dict () return self . dict () != other Config \u00b6 Class for configuration of pydantic models. Source code in oteapi/models/genericconfig.py class Config : \"\"\"Class for configuration of pydantic models.\"\"\" extra = \"allow\" extra \u00b6 get ( self , key , default = None ) \u00b6 Mapping get -method. Source code in oteapi/models/genericconfig.py def get ( self , key : str , default : Optional [ Any ] = None ) -> Any : \"\"\"Mapping `get`-method.\"\"\" return self . __dict__ . get ( key , default ) items ( self ) \u00b6 Return a view of all (key, value) pairs. Source code in oteapi/models/genericconfig.py def items ( self ): \"\"\"Return a view of all (key, value) pairs.\"\"\" return self . __dict__ . items () keys ( self ) \u00b6 Return a view of all keys. Source code in oteapi/models/genericconfig.py def keys ( self ): \"\"\"Return a view of all keys.\"\"\" return self . __dict__ . keys () values ( self ) \u00b6 Return a view of all values. Source code in oteapi/models/genericconfig.py def values ( self ): \"\"\"Return a view of all values.\"\"\" return self . __dict__ . values () GenericConfig ( BaseModel ) pydantic-model \u00b6 Generic class for configuration objects. Source code in oteapi/models/genericconfig.py class GenericConfig ( BaseModel ): \"\"\"Generic class for configuration objects.\"\"\" configuration : Optional [ AttrDict ] = Field ( None , description = \"Model-specific configuration options which can either \" \"be given as key/value-pairs or set as attributes.\" , ) description : str = Field ( __doc__ , description = \"A description of the configuration model.\" , ) @classmethod def __init_subclass__ ( cls ) -> None : \"\"\"Initialize subclass descriptions with their docstrings.\"\"\" cls . __fields__ [ \"description\" ] . default = cls . __doc__ configuration : AttrDict pydantic-field \u00b6 Model-specific configuration options which can either be given as key/value-pairs or set as attributes. description : str pydantic-field \u00b6 A description of the configuration model.","title":"genericconfig"},{"location":"api_reference/models/genericconfig/#genericconfig","text":"Generic data model for configuration attributes.","title":"genericconfig"},{"location":"api_reference/models/genericconfig/#oteapi.models.genericconfig.AttrDict","text":"An object whose attributes can also be accessed through subscription, like with a dictionary. Source code in oteapi/models/genericconfig.py class AttrDict ( BaseModel ): \"\"\"An object whose attributes can also be accessed through subscription, like with a dictionary.\"\"\" class Config : \"\"\"Class for configuration of pydantic models.\"\"\" extra = \"allow\" def __contains__ ( self , name : Any ) -> bool : \"\"\"Enable using the 'in' operator on this object.\"\"\" return self . __dict__ . __contains__ ( name ) def __delitem__ ( self , key : str ) -> None : \"\"\"Enable deletion access through subscription.\"\"\" if key in dir ( self ): self . __delattr__ ( key ) if key in self . __fields__ : del self . __fields__ [ key ] self . __fields_set__ . remove ( key ) # pylint: disable=no-member else : raise KeyError ( key ) def __getitem__ ( self , key : str ) -> Any : \"\"\"Enable read access through subscription.\"\"\" if key in dir ( self ): return getattr ( self , key ) raise KeyError ( key ) def __setattr__ ( self , name : str , value : Any ) -> None : \"\"\"Extend BaseModel.__setattr__ with type-checking.\"\"\" if name in self . __dict__ and self . __dict__ [ name ]: target_type = type ( self . __dict__ [ name ]) if not isinstance ( value , target_type ): raise TypeError ( \"Mapped value must be subclass of \" + target_type . __name__ ) super () . __setattr__ ( name , value ) def __setitem__ ( self , key : str , value : Any ) -> None : \"\"\"Enable write access through subscription.\"\"\" self . __setattr__ ( key , value ) def __len__ ( self ): \"\"\"Return number of items.\"\"\" return self . __dict__ . __len__ () def __iter__ ( self ): \"\"\"Enable **unpacking.\"\"\" return self . __dict__ . __iter__ () def items ( self ): \"\"\"Return a view of all (key, value) pairs.\"\"\" return self . __dict__ . items () def keys ( self ): \"\"\"Return a view of all keys.\"\"\" return self . __dict__ . keys () def values ( self ): \"\"\"Return a view of all values.\"\"\" return self . __dict__ . values () def get ( self , key : str , default : Optional [ Any ] = None ) -> Any : \"\"\"Mapping `get`-method.\"\"\" return self . __dict__ . get ( key , default ) def __ne__ ( self , other : Any ) -> bool : if isinstance ( other , BaseModel ): return self . dict () != other . dict () return self . dict () != other","title":"AttrDict"},{"location":"api_reference/models/genericconfig/#oteapi.models.genericconfig.AttrDict.Config","text":"Class for configuration of pydantic models. Source code in oteapi/models/genericconfig.py class Config : \"\"\"Class for configuration of pydantic models.\"\"\" extra = \"allow\"","title":"Config"},{"location":"api_reference/models/genericconfig/#oteapi.models.genericconfig.AttrDict.Config.extra","text":"","title":"extra"},{"location":"api_reference/models/genericconfig/#oteapi.models.genericconfig.AttrDict.get","text":"Mapping get -method. Source code in oteapi/models/genericconfig.py def get ( self , key : str , default : Optional [ Any ] = None ) -> Any : \"\"\"Mapping `get`-method.\"\"\" return self . __dict__ . get ( key , default )","title":"get()"},{"location":"api_reference/models/genericconfig/#oteapi.models.genericconfig.AttrDict.items","text":"Return a view of all (key, value) pairs. Source code in oteapi/models/genericconfig.py def items ( self ): \"\"\"Return a view of all (key, value) pairs.\"\"\" return self . __dict__ . items ()","title":"items()"},{"location":"api_reference/models/genericconfig/#oteapi.models.genericconfig.AttrDict.keys","text":"Return a view of all keys. Source code in oteapi/models/genericconfig.py def keys ( self ): \"\"\"Return a view of all keys.\"\"\" return self . __dict__ . keys ()","title":"keys()"},{"location":"api_reference/models/genericconfig/#oteapi.models.genericconfig.AttrDict.values","text":"Return a view of all values. Source code in oteapi/models/genericconfig.py def values ( self ): \"\"\"Return a view of all values.\"\"\" return self . __dict__ . values ()","title":"values()"},{"location":"api_reference/models/genericconfig/#oteapi.models.genericconfig.GenericConfig","text":"Generic class for configuration objects. Source code in oteapi/models/genericconfig.py class GenericConfig ( BaseModel ): \"\"\"Generic class for configuration objects.\"\"\" configuration : Optional [ AttrDict ] = Field ( None , description = \"Model-specific configuration options which can either \" \"be given as key/value-pairs or set as attributes.\" , ) description : str = Field ( __doc__ , description = \"A description of the configuration model.\" , ) @classmethod def __init_subclass__ ( cls ) -> None : \"\"\"Initialize subclass descriptions with their docstrings.\"\"\" cls . __fields__ [ \"description\" ] . default = cls . __doc__","title":"GenericConfig"},{"location":"api_reference/models/genericconfig/#oteapi.models.genericconfig.GenericConfig.configuration","text":"Model-specific configuration options which can either be given as key/value-pairs or set as attributes.","title":"configuration"},{"location":"api_reference/models/genericconfig/#oteapi.models.genericconfig.GenericConfig.description","text":"A description of the configuration model.","title":"description"},{"location":"api_reference/models/mappingconfig/","text":"mappingconfig \u00b6 Pydantic Mapping Configuration Data Model. SemanticTriple \u00b6 MappingConfig ( GenericConfig ) pydantic-model \u00b6 Mapping Strategy Data Configuration. Source code in oteapi/models/mappingconfig.py class MappingConfig ( GenericConfig ): \"\"\"Mapping Strategy Data Configuration.\"\"\" mappingType : str = Field ( ... , description = \"Type of registered mapping strategy. E.g., `mapping/demo`.\" ) prefixes : Optional [ Dict [ str , str ]] = Field ( None , description = ( \"List of shortnames that expands to an IRI \" \"given as local value/IRI-expansion-pairs.\" ), ) triples : Optional [ List [ SemanticTriple ]] = Field ( # type: ignore[valid-type] None , description = \"List of semantic triples given as (subject, predicate, object).\" , ) mappingType : str pydantic-field required \u00b6 Type of registered mapping strategy. E.g., mapping/demo . prefixes : Dict [ str , str ] pydantic-field \u00b6 List of shortnames that expands to an IRI given as local value/IRI-expansion-pairs. triples : List [ types . ConstrainedListValue ] pydantic-field \u00b6 List of semantic triples given as (subject, predicate, object).","title":"mappingconfig"},{"location":"api_reference/models/mappingconfig/#mappingconfig","text":"Pydantic Mapping Configuration Data Model.","title":"mappingconfig"},{"location":"api_reference/models/mappingconfig/#oteapi.models.mappingconfig.SemanticTriple","text":"","title":"SemanticTriple"},{"location":"api_reference/models/mappingconfig/#oteapi.models.mappingconfig.MappingConfig","text":"Mapping Strategy Data Configuration. Source code in oteapi/models/mappingconfig.py class MappingConfig ( GenericConfig ): \"\"\"Mapping Strategy Data Configuration.\"\"\" mappingType : str = Field ( ... , description = \"Type of registered mapping strategy. E.g., `mapping/demo`.\" ) prefixes : Optional [ Dict [ str , str ]] = Field ( None , description = ( \"List of shortnames that expands to an IRI \" \"given as local value/IRI-expansion-pairs.\" ), ) triples : Optional [ List [ SemanticTriple ]] = Field ( # type: ignore[valid-type] None , description = \"List of semantic triples given as (subject, predicate, object).\" , )","title":"MappingConfig"},{"location":"api_reference/models/mappingconfig/#oteapi.models.mappingconfig.MappingConfig.mappingType","text":"Type of registered mapping strategy. E.g., mapping/demo .","title":"mappingType"},{"location":"api_reference/models/mappingconfig/#oteapi.models.mappingconfig.MappingConfig.prefixes","text":"List of shortnames that expands to an IRI given as local value/IRI-expansion-pairs.","title":"prefixes"},{"location":"api_reference/models/mappingconfig/#oteapi.models.mappingconfig.MappingConfig.triples","text":"List of semantic triples given as (subject, predicate, object).","title":"triples"},{"location":"api_reference/models/resourceconfig/","text":"resourceconfig \u00b6 Pydantic Resource Configuration Data Model. ResourceConfig ( GenericConfig ) pydantic-model \u00b6 Resource Strategy Data Configuration. Important Either of the pairs of attributes downloadUrl / mediaType or accessUrl / accessService MUST be specified. Source code in oteapi/models/resourceconfig.py class ResourceConfig ( GenericConfig ): \"\"\"Resource Strategy Data Configuration. Important: Either of the pairs of attributes `downloadUrl`/`mediaType` or `accessUrl`/`accessService` MUST be specified. \"\"\" downloadUrl : Optional [ Union [ AnyUrl , FileUrl ]] = Field ( None , description = ( \"Definition: The URL of the downloadable file in a given format. E.g. CSV \" \"file or RDF file. \\n\\n Usage: `downloadURL` *SHOULD* be used for the URL at\" \" which this distribution is available directly, typically through a HTTPS\" \" GET request or SFTP.\" ), ) mediaType : Optional [ str ] = Field ( None , description = ( \"The media type of the distribution as defined by IANA \" \"[[IANA-MEDIA-TYPES](https://www.w3.org/TR/vocab-dcat-2/#bib-iana-media-types)]\" \". \\n\\n Usage: This property *SHOULD* be used when the media\" \" type of the distribution is defined in IANA \" \"[[IANA-MEDIA-TYPES](https://www.w3.org/TR/vocab-dcat-2/#bib-iana-media-types)].\" ), ) accessUrl : Optional [ AnyUrl ] = Field ( None , description = ( \"A URL of the resource that gives access to a distribution of \" \"the dataset. E.g. landing page, feed, SPARQL endpoint. \\n\\n Usage: \" \"`accessURL` *SHOULD* be used for the URL of a service or location that \" \"can provide access to this distribution, typically through a Web form, \" \"query or API call. \\n `downloadURL` is preferred for direct links to \" \"downloadable resources.\" ), ) accessService : Optional [ str ] = Field ( None , description = ( \"A data service that gives access to the distribution of the dataset.\" ), ) license : Optional [ str ] = Field ( None , description = ( \"A legal document under which the distribution is made available.\" ), ) accessRights : Optional [ str ] = Field ( None , description = ( \"A rights statement that concerns how the distribution is accessed.\" ), ) publisher : Optional [ str ] = Field ( None , description = \"The entity responsible for making the resource/item available.\" , ) configuration : DataCacheConfig = Field ( DataCacheConfig (), description = \"Resource-specific configuration options given as key/value-pairs.\" , ) @root_validator def ensure_unique_url_pairs ( # pylint: disable=no-self-use cls , values : Dict [ str , Any ] ) -> Dict [ str , Any ]: \"\"\"Ensure either downloadUrl/mediaType or accessUrl/accessService are defined. It's fine to define them all, but at least one complete pair MUST be specified.\"\"\" if not ( all ( values . get ( _ ) for _ in [ \"downloadUrl\" , \"mediaType\" ]) or all ( values . get ( _ ) for _ in [ \"accessUrl\" , \"accessService\" ]) ): raise ValueError ( \"Either of the pairs of attributes downloadUrl/mediaType or \" \"accessUrl/accessService MUST be specified.\" ) return values accessRights : str pydantic-field \u00b6 A rights statement that concerns how the distribution is accessed. accessService : str pydantic-field \u00b6 A data service that gives access to the distribution of the dataset. accessUrl : AnyUrl pydantic-field \u00b6 A URL of the resource that gives access to a distribution of the dataset. E.g. landing page, feed, SPARQL endpoint. Usage: accessURL SHOULD be used for the URL of a service or location that can provide access to this distribution, typically through a Web form, query or API call. downloadURL is preferred for direct links to downloadable resources. downloadUrl : Union [ pydantic . networks . AnyUrl , pydantic . networks . FileUrl ] pydantic-field \u00b6 Definition: The URL of the downloadable file in a given format. E.g. CSV file or RDF file. Usage: downloadURL SHOULD be used for the URL at which this distribution is available directly, typically through a HTTPS GET request or SFTP. license : str pydantic-field \u00b6 A legal document under which the distribution is made available. mediaType : str pydantic-field \u00b6 The media type of the distribution as defined by IANA [ IANA-MEDIA-TYPES ]. Usage: This property SHOULD be used when the media type of the distribution is defined in IANA [ IANA-MEDIA-TYPES ]. publisher : str pydantic-field \u00b6 The entity responsible for making the resource/item available. ensure_unique_url_pairs ( values ) classmethod \u00b6 Ensure either downloadUrl/mediaType or accessUrl/accessService are defined. It's fine to define them all, but at least one complete pair MUST be specified. Source code in oteapi/models/resourceconfig.py @root_validator def ensure_unique_url_pairs ( # pylint: disable=no-self-use cls , values : Dict [ str , Any ] ) -> Dict [ str , Any ]: \"\"\"Ensure either downloadUrl/mediaType or accessUrl/accessService are defined. It's fine to define them all, but at least one complete pair MUST be specified.\"\"\" if not ( all ( values . get ( _ ) for _ in [ \"downloadUrl\" , \"mediaType\" ]) or all ( values . get ( _ ) for _ in [ \"accessUrl\" , \"accessService\" ]) ): raise ValueError ( \"Either of the pairs of attributes downloadUrl/mediaType or \" \"accessUrl/accessService MUST be specified.\" ) return values","title":"resourceconfig"},{"location":"api_reference/models/resourceconfig/#resourceconfig","text":"Pydantic Resource Configuration Data Model.","title":"resourceconfig"},{"location":"api_reference/models/resourceconfig/#oteapi.models.resourceconfig.ResourceConfig","text":"Resource Strategy Data Configuration. Important Either of the pairs of attributes downloadUrl / mediaType or accessUrl / accessService MUST be specified. Source code in oteapi/models/resourceconfig.py class ResourceConfig ( GenericConfig ): \"\"\"Resource Strategy Data Configuration. Important: Either of the pairs of attributes `downloadUrl`/`mediaType` or `accessUrl`/`accessService` MUST be specified. \"\"\" downloadUrl : Optional [ Union [ AnyUrl , FileUrl ]] = Field ( None , description = ( \"Definition: The URL of the downloadable file in a given format. E.g. CSV \" \"file or RDF file. \\n\\n Usage: `downloadURL` *SHOULD* be used for the URL at\" \" which this distribution is available directly, typically through a HTTPS\" \" GET request or SFTP.\" ), ) mediaType : Optional [ str ] = Field ( None , description = ( \"The media type of the distribution as defined by IANA \" \"[[IANA-MEDIA-TYPES](https://www.w3.org/TR/vocab-dcat-2/#bib-iana-media-types)]\" \". \\n\\n Usage: This property *SHOULD* be used when the media\" \" type of the distribution is defined in IANA \" \"[[IANA-MEDIA-TYPES](https://www.w3.org/TR/vocab-dcat-2/#bib-iana-media-types)].\" ), ) accessUrl : Optional [ AnyUrl ] = Field ( None , description = ( \"A URL of the resource that gives access to a distribution of \" \"the dataset. E.g. landing page, feed, SPARQL endpoint. \\n\\n Usage: \" \"`accessURL` *SHOULD* be used for the URL of a service or location that \" \"can provide access to this distribution, typically through a Web form, \" \"query or API call. \\n `downloadURL` is preferred for direct links to \" \"downloadable resources.\" ), ) accessService : Optional [ str ] = Field ( None , description = ( \"A data service that gives access to the distribution of the dataset.\" ), ) license : Optional [ str ] = Field ( None , description = ( \"A legal document under which the distribution is made available.\" ), ) accessRights : Optional [ str ] = Field ( None , description = ( \"A rights statement that concerns how the distribution is accessed.\" ), ) publisher : Optional [ str ] = Field ( None , description = \"The entity responsible for making the resource/item available.\" , ) configuration : DataCacheConfig = Field ( DataCacheConfig (), description = \"Resource-specific configuration options given as key/value-pairs.\" , ) @root_validator def ensure_unique_url_pairs ( # pylint: disable=no-self-use cls , values : Dict [ str , Any ] ) -> Dict [ str , Any ]: \"\"\"Ensure either downloadUrl/mediaType or accessUrl/accessService are defined. It's fine to define them all, but at least one complete pair MUST be specified.\"\"\" if not ( all ( values . get ( _ ) for _ in [ \"downloadUrl\" , \"mediaType\" ]) or all ( values . get ( _ ) for _ in [ \"accessUrl\" , \"accessService\" ]) ): raise ValueError ( \"Either of the pairs of attributes downloadUrl/mediaType or \" \"accessUrl/accessService MUST be specified.\" ) return values","title":"ResourceConfig"},{"location":"api_reference/models/resourceconfig/#oteapi.models.resourceconfig.ResourceConfig.accessRights","text":"A rights statement that concerns how the distribution is accessed.","title":"accessRights"},{"location":"api_reference/models/resourceconfig/#oteapi.models.resourceconfig.ResourceConfig.accessService","text":"A data service that gives access to the distribution of the dataset.","title":"accessService"},{"location":"api_reference/models/resourceconfig/#oteapi.models.resourceconfig.ResourceConfig.accessUrl","text":"A URL of the resource that gives access to a distribution of the dataset. E.g. landing page, feed, SPARQL endpoint. Usage: accessURL SHOULD be used for the URL of a service or location that can provide access to this distribution, typically through a Web form, query or API call. downloadURL is preferred for direct links to downloadable resources.","title":"accessUrl"},{"location":"api_reference/models/resourceconfig/#oteapi.models.resourceconfig.ResourceConfig.downloadUrl","text":"Definition: The URL of the downloadable file in a given format. E.g. CSV file or RDF file. Usage: downloadURL SHOULD be used for the URL at which this distribution is available directly, typically through a HTTPS GET request or SFTP.","title":"downloadUrl"},{"location":"api_reference/models/resourceconfig/#oteapi.models.resourceconfig.ResourceConfig.license","text":"A legal document under which the distribution is made available.","title":"license"},{"location":"api_reference/models/resourceconfig/#oteapi.models.resourceconfig.ResourceConfig.mediaType","text":"The media type of the distribution as defined by IANA [ IANA-MEDIA-TYPES ]. Usage: This property SHOULD be used when the media type of the distribution is defined in IANA [ IANA-MEDIA-TYPES ].","title":"mediaType"},{"location":"api_reference/models/resourceconfig/#oteapi.models.resourceconfig.ResourceConfig.publisher","text":"The entity responsible for making the resource/item available.","title":"publisher"},{"location":"api_reference/models/resourceconfig/#oteapi.models.resourceconfig.ResourceConfig.ensure_unique_url_pairs","text":"Ensure either downloadUrl/mediaType or accessUrl/accessService are defined. It's fine to define them all, but at least one complete pair MUST be specified. Source code in oteapi/models/resourceconfig.py @root_validator def ensure_unique_url_pairs ( # pylint: disable=no-self-use cls , values : Dict [ str , Any ] ) -> Dict [ str , Any ]: \"\"\"Ensure either downloadUrl/mediaType or accessUrl/accessService are defined. It's fine to define them all, but at least one complete pair MUST be specified.\"\"\" if not ( all ( values . get ( _ ) for _ in [ \"downloadUrl\" , \"mediaType\" ]) or all ( values . get ( _ ) for _ in [ \"accessUrl\" , \"accessService\" ]) ): raise ValueError ( \"Either of the pairs of attributes downloadUrl/mediaType or \" \"accessUrl/accessService MUST be specified.\" ) return values","title":"ensure_unique_url_pairs()"},{"location":"api_reference/models/sessionupdate/","text":"sessionupdate \u00b6 Pydantic SessionUpdate Data Model. SessionUpdate ( AttrDict ) pydantic-model \u00b6 Session Update Data Model for returning values. Source code in oteapi/models/sessionupdate.py class SessionUpdate ( AttrDict ): \"\"\"Session Update Data Model for returning values.\"\"\"","title":"sessionupdate"},{"location":"api_reference/models/sessionupdate/#sessionupdate","text":"Pydantic SessionUpdate Data Model.","title":"sessionupdate"},{"location":"api_reference/models/sessionupdate/#oteapi.models.sessionupdate.SessionUpdate","text":"Session Update Data Model for returning values. Source code in oteapi/models/sessionupdate.py class SessionUpdate ( AttrDict ): \"\"\"Session Update Data Model for returning values.\"\"\"","title":"SessionUpdate"},{"location":"api_reference/models/transformationconfig/","text":"transformationconfig \u00b6 Pydantic Transformation Configuration Data Model. A transformation status data model is provided as well. This data model represents what should be returned from the strategy's status() method. PriorityEnum ( str , Enum ) \u00b6 Defining process priority enumerators. Process priorities: Low Medium High Source code in oteapi/models/transformationconfig.py class PriorityEnum ( str , Enum ): \"\"\"Defining process priority enumerators. Process priorities: - Low - Medium - High \"\"\" LOW = \"Low\" MEDIUM = \"Medium\" HIGH = \"High\" HIGH \u00b6 LOW \u00b6 MEDIUM \u00b6 TransformationConfig ( GenericConfig ) pydantic-model \u00b6 Transformation Strategy Data Configuration. Source code in oteapi/models/transformationconfig.py class TransformationConfig ( GenericConfig ): \"\"\"Transformation Strategy Data Configuration.\"\"\" transformationType : str = Field ( ... , description = ( \"Type of registered transformation strategy. E.g., `celery/remote`.\" ), ) name : Optional [ str ] = Field ( None , description = \"Human-readable name of the transformation strategy.\" ) due : Optional [ datetime ] = Field ( None , description = ( \"Optional field to indicate a due data/time for when a transformation \" \"should finish.\" ), ) priority : Optional [ PriorityEnum ] = Field ( PriorityEnum . MEDIUM , description = \"Define the process priority of the transformation execution.\" , ) secret : Optional [ str ] = Field ( None , description = \"Authorization secret given when running a transformation.\" , ) due : datetime pydantic-field \u00b6 Optional field to indicate a due data/time for when a transformation should finish. name : str pydantic-field \u00b6 Human-readable name of the transformation strategy. priority : PriorityEnum pydantic-field \u00b6 Define the process priority of the transformation execution. secret : str pydantic-field \u00b6 Authorization secret given when running a transformation. transformationType : str pydantic-field required \u00b6 Type of registered transformation strategy. E.g., celery/remote . TransformationStatus ( BaseModel ) pydantic-model \u00b6 Return from transformation status. Source code in oteapi/models/transformationconfig.py class TransformationStatus ( BaseModel ): \"\"\"Return from transformation status.\"\"\" id : str = Field ( ... , description = \"ID for the given transformation process.\" ) status : Optional [ str ] = Field ( None , description = \"Status for the transformation process.\" ) messages : Optional [ List [ str ]] = Field ( None , description = \"Messages related to the transformation process.\" ) created : Optional [ datetime ] = Field ( None , description = \"Time of creation for the transformation process. Given in UTC.\" , ) startTime : Optional [ datetime ] = Field ( None , description = \"Time when the transformation process started. Given in UTC.\" ) finishTime : Optional [ datetime ] = Field ( None , description = \"Time when the tranformation process finished. Given in UTC.\" ) created : datetime pydantic-field \u00b6 Time of creation for the transformation process. Given in UTC. finishTime : datetime pydantic-field \u00b6 Time when the tranformation process finished. Given in UTC. id : str pydantic-field required \u00b6 ID for the given transformation process. messages : List [ str ] pydantic-field \u00b6 Messages related to the transformation process. startTime : datetime pydantic-field \u00b6 Time when the transformation process started. Given in UTC. status : str pydantic-field \u00b6 Status for the transformation process.","title":"transformationconfig"},{"location":"api_reference/models/transformationconfig/#transformationconfig","text":"Pydantic Transformation Configuration Data Model. A transformation status data model is provided as well. This data model represents what should be returned from the strategy's status() method.","title":"transformationconfig"},{"location":"api_reference/models/transformationconfig/#oteapi.models.transformationconfig.PriorityEnum","text":"Defining process priority enumerators. Process priorities: Low Medium High Source code in oteapi/models/transformationconfig.py class PriorityEnum ( str , Enum ): \"\"\"Defining process priority enumerators. Process priorities: - Low - Medium - High \"\"\" LOW = \"Low\" MEDIUM = \"Medium\" HIGH = \"High\"","title":"PriorityEnum"},{"location":"api_reference/models/transformationconfig/#oteapi.models.transformationconfig.PriorityEnum.HIGH","text":"","title":"HIGH"},{"location":"api_reference/models/transformationconfig/#oteapi.models.transformationconfig.PriorityEnum.LOW","text":"","title":"LOW"},{"location":"api_reference/models/transformationconfig/#oteapi.models.transformationconfig.PriorityEnum.MEDIUM","text":"","title":"MEDIUM"},{"location":"api_reference/models/transformationconfig/#oteapi.models.transformationconfig.TransformationConfig","text":"Transformation Strategy Data Configuration. Source code in oteapi/models/transformationconfig.py class TransformationConfig ( GenericConfig ): \"\"\"Transformation Strategy Data Configuration.\"\"\" transformationType : str = Field ( ... , description = ( \"Type of registered transformation strategy. E.g., `celery/remote`.\" ), ) name : Optional [ str ] = Field ( None , description = \"Human-readable name of the transformation strategy.\" ) due : Optional [ datetime ] = Field ( None , description = ( \"Optional field to indicate a due data/time for when a transformation \" \"should finish.\" ), ) priority : Optional [ PriorityEnum ] = Field ( PriorityEnum . MEDIUM , description = \"Define the process priority of the transformation execution.\" , ) secret : Optional [ str ] = Field ( None , description = \"Authorization secret given when running a transformation.\" , )","title":"TransformationConfig"},{"location":"api_reference/models/transformationconfig/#oteapi.models.transformationconfig.TransformationConfig.due","text":"Optional field to indicate a due data/time for when a transformation should finish.","title":"due"},{"location":"api_reference/models/transformationconfig/#oteapi.models.transformationconfig.TransformationConfig.name","text":"Human-readable name of the transformation strategy.","title":"name"},{"location":"api_reference/models/transformationconfig/#oteapi.models.transformationconfig.TransformationConfig.priority","text":"Define the process priority of the transformation execution.","title":"priority"},{"location":"api_reference/models/transformationconfig/#oteapi.models.transformationconfig.TransformationConfig.secret","text":"Authorization secret given when running a transformation.","title":"secret"},{"location":"api_reference/models/transformationconfig/#oteapi.models.transformationconfig.TransformationConfig.transformationType","text":"Type of registered transformation strategy. E.g., celery/remote .","title":"transformationType"},{"location":"api_reference/models/transformationconfig/#oteapi.models.transformationconfig.TransformationStatus","text":"Return from transformation status. Source code in oteapi/models/transformationconfig.py class TransformationStatus ( BaseModel ): \"\"\"Return from transformation status.\"\"\" id : str = Field ( ... , description = \"ID for the given transformation process.\" ) status : Optional [ str ] = Field ( None , description = \"Status for the transformation process.\" ) messages : Optional [ List [ str ]] = Field ( None , description = \"Messages related to the transformation process.\" ) created : Optional [ datetime ] = Field ( None , description = \"Time of creation for the transformation process. Given in UTC.\" , ) startTime : Optional [ datetime ] = Field ( None , description = \"Time when the transformation process started. Given in UTC.\" ) finishTime : Optional [ datetime ] = Field ( None , description = \"Time when the tranformation process finished. Given in UTC.\" )","title":"TransformationStatus"},{"location":"api_reference/models/transformationconfig/#oteapi.models.transformationconfig.TransformationStatus.created","text":"Time of creation for the transformation process. Given in UTC.","title":"created"},{"location":"api_reference/models/transformationconfig/#oteapi.models.transformationconfig.TransformationStatus.finishTime","text":"Time when the tranformation process finished. Given in UTC.","title":"finishTime"},{"location":"api_reference/models/transformationconfig/#oteapi.models.transformationconfig.TransformationStatus.id","text":"ID for the given transformation process.","title":"id"},{"location":"api_reference/models/transformationconfig/#oteapi.models.transformationconfig.TransformationStatus.messages","text":"Messages related to the transformation process.","title":"messages"},{"location":"api_reference/models/transformationconfig/#oteapi.models.transformationconfig.TransformationStatus.startTime","text":"Time when the transformation process started. Given in UTC.","title":"startTime"},{"location":"api_reference/models/transformationconfig/#oteapi.models.transformationconfig.TransformationStatus.status","text":"Status for the transformation process.","title":"status"},{"location":"api_reference/plugins/entry_points/","text":"entry_points \u00b6 Load plugins through entry points. This module deals with handling all plugged in strategies through the entry points API and importlib metadata API. Special functionality is put in place to handle the OTE-API-specific entry points. Since the entry points are information complete in and of themselves, there is no need to import actual strategy classes until they are truly needed. This therefore implements lazy loading of all plugin strategies. EntryPointNotFound ( Exception ) \u00b6 A given strategy implementation (class) cannot be found from the given entry point value. Source code in oteapi/plugins/entry_points.py class EntryPointNotFound ( Exception ): \"\"\"A given strategy implementation (class) cannot be found from the given entry point value.\"\"\" EntryPointStrategy \u00b6 A strategy realized from an entry point. An entry point strategy is made unique by its \"strategy\", i.e., its (strategy type, strategy name)-tuple, e.g., (\"download\", \"https\") . This tuple can be retrieved from the strategy property, where the strategy type is represented by the StrategyType enumeration. Note It may be that in the future an entry points strategy is made unique by its \"full name\" instead, i.e., the entry point group + the entry points name, e.g., oteapi.download:oteapi.https . This value can be retrieved from the full_name property. This is a condition for uniqueness that is considered to be a superset of the current condition for uniqueness. It adds an extra package-specific uniqueness trait, allowing for different packages to implement the same strategies (which is currently not allowed according to the condition of uniqueness explained above). Currently there is no consensus on the API for handling this added strategy ambiguity. Exceptions: Type Description ValueError If the entry point name is not properly defined. Source code in oteapi/plugins/entry_points.py class EntryPointStrategy : \"\"\"A strategy realized from an entry point. An entry point strategy is made unique by its \"strategy\", i.e., its (strategy type, strategy name)-tuple, e.g., `(\"download\", \"https\")`. This tuple can be retrieved from the [`strategy`][oteapi.plugins.entry_points.EntryPointStrategy.strategy] property, where the strategy type is represented by the [`StrategyType`][oteapi.plugins.entry_points.StrategyType] enumeration. Note: It may be that in the future an entry points strategy is made unique by its \"full name\" instead, i.e., the entry point group + the entry points name, e.g., `oteapi.download:oteapi.https`. This value can be retrieved from the [`full_name`][oteapi.plugins.entry_points.EntryPointStrategy.full_name] property. This is a condition for uniqueness that is considered to be a superset of the current condition for uniqueness. It adds an extra package-specific uniqueness trait, allowing for different packages to implement the same strategies (which is currently not allowed according to the condition of uniqueness explained above). Currently there is no consensus on the API for handling this added strategy ambiguity. Raises: ValueError: If the entry point name is not properly defined. \"\"\" ENTRY_POINT_NAME_REGEX = re . compile ( r \"^(?P<package_name>[a-z_]+)\\.(?P<strategy_name>.+)$\" ) ENTRY_POINT_NAME_SEPARATOR = \":\" def __init__ ( self , entry_point : \"EntryPoint\" ) -> None : self . _entry_point = entry_point match = self . ENTRY_POINT_NAME_REGEX . match ( self . _entry_point . name ) if match is None : raise ValueError ( \"Could not determine package name and/or strategy name for entry \" f \"point: { self . full_name } \" ) self . _match = match self . _type = StrategyType ( self . _entry_point . group [ len ( \"oteapi.\" ) :]) self . _implementation : \"Optional[Type[IStrategy]]\" = None @property def type ( self ) -> StrategyType : \"\"\"The strategy type. One part of the (strategy type, strategy name)-tuple. \"\"\" return self . _type @property def name ( self ) -> str : \"\"\"The strategy name. One part of the (strategy type, strategy name)-tuple. \"\"\" return self . _match . group ( \"strategy_name\" ) @property def strategy ( self ) -> \"Tuple[StrategyType, str]\" : \"\"\"The unique index identifier for the strategy.\"\"\" return self . type , self . name @property def package ( self ) -> str : \"\"\"The importable base package name for the strategy plugin.\"\"\" return self . _match . group ( \"package_name\" ) @property def module ( self ) -> str : \"\"\"The fully resolved importable module path.\"\"\" return self . _entry_point . module # type: ignore[attr-defined] @property def full_name ( self ) -> str : \"\"\"The full entry point name.\"\"\" return f \" { self . _entry_point . group }{ self . ENTRY_POINT_NAME_SEPARATOR }{ self . _entry_point . name } \" def __str__ ( self ) -> str : return self . full_name def __repr__ ( self ) -> str : return f \" { self . __class__ . __name__ } (entry_point= { self . _entry_point !r} )\" @property def implementation_name ( self ) -> str : \"\"\"The EntryPoint attr, which should be the strategy implementation class name.\"\"\" return self . _entry_point . attr # type: ignore[attr-defined] @property def implementation ( self ) -> \"Type[IStrategy]\" : \"\"\"The actual strategy implementation.\"\"\" if self . _implementation is None : self . _implementation = self . _load_implementation () return self . _implementation def _load_implementation ( self ) -> \"Type[IStrategy]\" : \"\"\"Load the strategy implementation. Because the actual importing of the module does not happen until this method is called, we are lazily loading in the strategy implementation. There is no need to check through the `globals()` built-in for whether the module and class have already been imported, because this caching layer is already implemented in the `importlib` API. Raises: EntryPointNotFound: If the strategy implementation (class) the entry point is pointing to cannot be found in the module or if the module cannot be imported. Returns: The imported strategy implementation (class). \"\"\" try : module = importlib . import_module ( self . module ) except ImportError as exc : raise EntryPointNotFound ( f \" { self . module } cannot be imported. Did you install the \" f \" { self . package !r} package?\" ) from exc if hasattr ( module , self . implementation_name ): return getattr ( module , self . implementation_name ) raise EntryPointNotFound ( f \" { self . implementation_name } cannot be found in { self . module } \" ) def __eq__ ( self , other : \"Any\" ) -> bool : if isinstance ( other , self . __class__ ): return hash ( self ) == hash ( other ) return False def __hash__ ( self ) -> int : return hash ( self . strategy ) def __lt__ ( self , other : \"Any\" ) -> bool : \"\"\"Whether or not `self` is less than (`<`) `other`. This is implemented to allow sorting (using `sorted()`). The inequality is determined on the basis of the following properties: 1. [`type`][oteapi.plugins.entry_points.EntryPointStrategy.type] 2. [`package`][oteapi.plugins.entry_points.EntryPointStrategy.package] 3. [`name`][oteapi.plugins.entry_points.EntryPointStrategy.name] Going from highest priority to lowest and in alphabetical ascending order. \"\"\" if isinstance ( other , self . __class__ ): if self . type == other . type : if self . package == other . package : if self . name == other . name : # Considered equal, i.e., one can by definition not be unequal # with the other. return False return sorted ([ self . name , other . name ])[ 0 ] == self . name return sorted ([ self . package , other . package ])[ 0 ] == self . package return sorted ([ self . type . value , other . type . value ])[ 0 ] == self . type . value raise NotImplementedError ( f \"Less than comparison is not implemented for { type ( other ) } type objects.\" ) full_name : str property readonly \u00b6 The full entry point name. implementation : Type [ IStrategy ] property readonly \u00b6 The actual strategy implementation. implementation_name : str property readonly \u00b6 The EntryPoint attr, which should be the strategy implementation class name. module : str property readonly \u00b6 The fully resolved importable module path. name : str property readonly \u00b6 The strategy name. One part of the (strategy type, strategy name)-tuple. package : str property readonly \u00b6 The importable base package name for the strategy plugin. strategy : Tuple [ StrategyType , str ] property readonly \u00b6 The unique index identifier for the strategy. type : StrategyType property readonly \u00b6 The strategy type. One part of the (strategy type, strategy name)-tuple. EntryPointStrategyCollection ( Collection ) \u00b6 A collection of EntryPointStrategy s. Source code in oteapi/plugins/entry_points.py class EntryPointStrategyCollection ( abc . Collection ): \"\"\"A collection of [`EntryPointStrategy`][oteapi.plugins.entry_points.EntryPointStrategy]s.\"\"\" def __init__ ( self , * entry_points : \"EntryPointStrategy\" ) -> None : self . _entry_points : \"Set[EntryPointStrategy]\" = ( set ( entry_points ) if entry_points else set () ) def add ( self , * entry_points : EntryPointStrategy ) -> None : \"\"\"Add entry points to the collection. Parameters: entry_points: Entry points to add to the collection. \"\"\" self . _entry_points |= set ( entry_points ) def remove ( self , * entry_points : EntryPointStrategy ) -> None : \"\"\"Remove entry points from the collection. Parameters: entry_points: Entry points to remove from the collection. \"\"\" self . _entry_points -= set ( entry_points ) def exclusive_add ( self , * entry_points : EntryPointStrategy ) -> None : \"\"\"Exclusively add entry points to the collection. Parameters: entry_points: Entry points to add to the collection. Raises: KeyError: If an entry point to be added already exists in the collection. \"\"\" for entry_point in entry_points : if entry_point in self : raise KeyError ( f \" { entry_point . strategy } already exists in { self } . \" f \"(Tried adding { entry_point } .)\" ) self . add ( entry_point ) def __len__ ( self ) -> int : return len ( self . _entry_points ) def __contains__ ( self , item : \"Any\" ) -> bool : \"\"\"Whether or not `item` is contained in the collection. One can test with an `EntryPointStrategy`, a string of an entry point strategy's full name, or a tuple of an entry point's strategy type and name. Parameters: item: Item to test whether it is contained in the collection. Returns: Whether or not `item` is contained in the collection. If the `item` is an unrecognized type, `False` will be returned. \"\"\" if isinstance ( item , EntryPointStrategy ): return item in self . _entry_points if isinstance ( item , str ): for entry_point in self . _entry_points : if item == entry_point . full_name : return True if isinstance ( item , tuple ): if len ( item ) != 2 or ( not isinstance ( item [ 0 ], ( StrategyType , str )) or not isinstance ( item [ 1 ], str ) ): # Only tuples of type (Union[StrategyType, str], str) are allowed. return False try : item_ = ( StrategyType . init ( item [ 0 ]), item [ 1 ]) except ValueError : # We only want to return True or False return False for entry_point in self . _entry_points : if item_ == entry_point . strategy : return True # For any other type: return False def __iter__ ( self ) -> \"Iterator[EntryPointStrategy]\" : yield from self . _entry_points def __getitem__ ( self , key : \"Any\" ) -> EntryPointStrategy : return self . get_entry_point ( key ) def get_entry_point ( self , key : \"Union[EntryPointStrategy, str, Tuple[Union[StrategyType, str], str]]\" , ) -> EntryPointStrategy : \"\"\"Retrieve an entry point from the collection. Parameters: key: The key to check for in the collection. Raises: KeyError: If an entry point cannot be found in the collection. TypeError: If the `key` is not of an expected type. See the `key` parameter above for the expected types. Returns: An entry point in the collection representing the key. \"\"\" if isinstance ( key , ( EntryPointStrategy , str , tuple )): if key not in self : raise KeyError ( f \" { key } not found in { self } \" ) return self . _get_entry_point ( key ) raise TypeError ( \"key should either be of type EntryPointStrategy, a string of the full \" \"name or a strategy tuple.\" ) def _get_entry_point ( self , key : \"Union[EntryPointStrategy, str, Tuple[Union[StrategyType, str], str]]\" , ) -> EntryPointStrategy : \"\"\"Helper method for retrieving an entry point from the collection. Important: It is expected that the entry point representing the key exists in the collection. For example through a `key in self` test. Parameters: key: The key to check for in the collection. Raises: RuntimeError: If an entry point cannot be found in the collection, since this is a requirement. Returns: An entry point in the collection representing the key. \"\"\" if isinstance ( key , EntryPointStrategy ): return key if isinstance ( key , str ): for entry_point in self . _entry_points : if key == entry_point . full_name : return entry_point if isinstance ( key , tuple ): key_ = ( StrategyType ( key [ 0 ]), key [ 1 ]) for entry_point in self . _entry_points : if key_ == entry_point . strategy : return entry_point raise RuntimeError ( f \" { key } not found in { self } , which is a requirement for the \" \"_get_entry_point method.\" ) def __eq__ ( self , other : \"Any\" ) -> bool : if isinstance ( other , self . __class__ ): return hash ( self ) == hash ( other ) return False def __hash__ ( self ) -> int : return hash ( tuple ( _ for _ in sorted ( self . _entry_points ))) def __str__ ( self ) -> str : res = {} # type: ignore[var-annotated] for _ in self . _entry_points : if _ . type . value in res : res [ _ . type . value ] += 1 else : res [ _ . type . value ] = 1 res = sorted ( f \" { key } ( { value } )\" for key , value in res . items ()) return f \"< { self . __class__ . __name__ } : \" f \"Strategies= { ', ' . join ( res ) } >\" def __repr__ ( self ) -> str : return f \" { self . __class__ . __name__ } (* { tuple ( sorted ( self . _entry_points )) !r} )\" add ( self , * entry_points ) \u00b6 Add entry points to the collection. Parameters: Name Type Description Default entry_points EntryPointStrategy Entry points to add to the collection. () Source code in oteapi/plugins/entry_points.py def add ( self , * entry_points : EntryPointStrategy ) -> None : \"\"\"Add entry points to the collection. Parameters: entry_points: Entry points to add to the collection. \"\"\" self . _entry_points |= set ( entry_points ) exclusive_add ( self , * entry_points ) \u00b6 Exclusively add entry points to the collection. Parameters: Name Type Description Default entry_points EntryPointStrategy Entry points to add to the collection. () Exceptions: Type Description KeyError If an entry point to be added already exists in the collection. Source code in oteapi/plugins/entry_points.py def exclusive_add ( self , * entry_points : EntryPointStrategy ) -> None : \"\"\"Exclusively add entry points to the collection. Parameters: entry_points: Entry points to add to the collection. Raises: KeyError: If an entry point to be added already exists in the collection. \"\"\" for entry_point in entry_points : if entry_point in self : raise KeyError ( f \" { entry_point . strategy } already exists in { self } . \" f \"(Tried adding { entry_point } .)\" ) self . add ( entry_point ) get_entry_point ( self , key ) \u00b6 Retrieve an entry point from the collection. Parameters: Name Type Description Default key Union[EntryPointStrategy, str, Tuple[Union[StrategyType, str], str]] The key to check for in the collection. required Exceptions: Type Description KeyError If an entry point cannot be found in the collection. TypeError If the key is not of an expected type. See the key parameter above for the expected types. Returns: Type Description EntryPointStrategy An entry point in the collection representing the key. Source code in oteapi/plugins/entry_points.py def get_entry_point ( self , key : \"Union[EntryPointStrategy, str, Tuple[Union[StrategyType, str], str]]\" , ) -> EntryPointStrategy : \"\"\"Retrieve an entry point from the collection. Parameters: key: The key to check for in the collection. Raises: KeyError: If an entry point cannot be found in the collection. TypeError: If the `key` is not of an expected type. See the `key` parameter above for the expected types. Returns: An entry point in the collection representing the key. \"\"\" if isinstance ( key , ( EntryPointStrategy , str , tuple )): if key not in self : raise KeyError ( f \" { key } not found in { self } \" ) return self . _get_entry_point ( key ) raise TypeError ( \"key should either be of type EntryPointStrategy, a string of the full \" \"name or a strategy tuple.\" ) remove ( self , * entry_points ) \u00b6 Remove entry points from the collection. Parameters: Name Type Description Default entry_points EntryPointStrategy Entry points to remove from the collection. () Source code in oteapi/plugins/entry_points.py def remove ( self , * entry_points : EntryPointStrategy ) -> None : \"\"\"Remove entry points from the collection. Parameters: entry_points: Entry points to remove from the collection. \"\"\" self . _entry_points -= set ( entry_points ) StrategyType ( Enum ) \u00b6 An enumeration of available strategy types. Available strategy types: download filter mapping parse resource transformation Source code in oteapi/plugins/entry_points.py class StrategyType ( Enum ): \"\"\"An enumeration of available strategy types. Available strategy types: - download - filter - mapping - parse - resource - transformation \"\"\" DOWNLOAD = \"download\" FILTER = \"filter\" FUNCTION = \"function\" MAPPING = \"mapping\" PARSE = \"parse\" RESOURCE = \"resource\" TRANSFORMATION = \"transformation\" def map_to_field ( self ) -> str : \"\"\"Map enumeration value to the strategy type's field.\"\"\" return { \"download\" : \"scheme\" , \"filter\" : \"filterType\" , \"function\" : \"functionType\" , \"mapping\" : \"mappingType\" , \"parse\" : \"mediaType\" , \"resource\" : \"accessService\" , \"transformation\" : \"transformationType\" , }[ self . value ] @classmethod def map_from_field ( cls , strategy_type_field : str ) -> \"StrategyType\" : \"\"\"Map the strategy type's field to enumeration. Parameters: strategy_type_field: The strategy type's field. E.g., `scheme` for `download`. Raises: KeyError: If the `strategy_type_field` is not valid. Returns: An enumeration instance representing the strategy type's field. \"\"\" return { \"scheme\" : cls . DOWNLOAD , \"filterType\" : cls . FILTER , \"functionType\" : cls . FUNCTION , \"mappingType\" : cls . MAPPING , \"mediaType\" : cls . PARSE , \"accessService\" : cls . RESOURCE , \"transformationType\" : cls . TRANSFORMATION , }[ strategy_type_field ] @classmethod def init ( cls , value : \"Union[str, StrategyType]\" ) -> \"StrategyType\" : \"\"\"Initialize a StrategyType with more than just the enumeration value. This method allows one to also initialize a StrategyType with an actual strategy type string, e.g., `scheme`, `mediaType`, etc. Raises: ValueError: As normal if the enumeration value is not valid. \"\"\" if isinstance ( value , str ): try : return cls . map_from_field ( value ) except KeyError : pass return cls ( value ) @classmethod @lru_cache def all_values ( cls ) -> \"Tuple[str, ...]\" : \"\"\"Return all values.\"\"\" return tuple ( strategy_type . value for strategy_type in cls ) def __str__ ( self ) -> str : return str ( self . value ) def __repr__ ( self ) -> str : return repr ( str ( self )) get_strategy_entry_points ( strategy_type , enforce_uniqueness = True ) \u00b6 Retrieve all entry points from a specific strategy type. Exceptions: Type Description ValueError If the strategy type is not supported. KeyError If enforce_uniqueness is True and an entry point strategy is duplicated. Parameters: Name Type Description Default strategy_type Union[StrategyType, str] A strategy type for which the entry points will be retrieved. required enforce_uniqueness bool Whether or not duplicate entry point strategies are allowed. Defaults to True , meaning duplicates are not allowed. True Returns: Type Description EntryPointStrategyCollection A collection of entry points for the specific strategy type. Source code in oteapi/plugins/entry_points.py def get_strategy_entry_points ( strategy_type : \"Union[StrategyType, str]\" , enforce_uniqueness : bool = True , ) -> EntryPointStrategyCollection : \"\"\"Retrieve all entry points from a specific strategy type. Raises: ValueError: If the strategy type is not supported. KeyError: If `enforce_uniqueness` is `True` and an entry point strategy is duplicated. Parameters: strategy_type: A strategy type for which the entry points will be retrieved. enforce_uniqueness: Whether or not duplicate entry point strategies are allowed. Defaults to `True`, meaning duplicates are *not* allowed. Returns: A collection of entry points for the specific strategy type. \"\"\" try : strategy_type = StrategyType ( strategy_type ) except ValueError as exc : raise ValueError ( \"Strategy type \" f \" { strategy_type if isinstance ( strategy_type , str ) else str ( strategy_type . value ) !r} \" \" is not supported.\" ) from exc collection = EntryPointStrategyCollection () for group , oteapi_entry_points in get_entry_points () . items (): if group . startswith ( \"oteapi.\" ) and group [ len ( \"oteapi.\" ) :] == str ( strategy_type . value ): if enforce_uniqueness : collection . exclusive_add ( * ( EntryPointStrategy ( _ ) for _ in oteapi_entry_points ) ) else : collection . add ( * ( EntryPointStrategy ( _ ) for _ in oteapi_entry_points )) return collection","title":"entry_points"},{"location":"api_reference/plugins/entry_points/#entry_points","text":"Load plugins through entry points. This module deals with handling all plugged in strategies through the entry points API and importlib metadata API. Special functionality is put in place to handle the OTE-API-specific entry points. Since the entry points are information complete in and of themselves, there is no need to import actual strategy classes until they are truly needed. This therefore implements lazy loading of all plugin strategies.","title":"entry_points"},{"location":"api_reference/plugins/entry_points/#oteapi.plugins.entry_points.EntryPointNotFound","text":"A given strategy implementation (class) cannot be found from the given entry point value. Source code in oteapi/plugins/entry_points.py class EntryPointNotFound ( Exception ): \"\"\"A given strategy implementation (class) cannot be found from the given entry point value.\"\"\"","title":"EntryPointNotFound"},{"location":"api_reference/plugins/entry_points/#oteapi.plugins.entry_points.EntryPointStrategy","text":"A strategy realized from an entry point. An entry point strategy is made unique by its \"strategy\", i.e., its (strategy type, strategy name)-tuple, e.g., (\"download\", \"https\") . This tuple can be retrieved from the strategy property, where the strategy type is represented by the StrategyType enumeration. Note It may be that in the future an entry points strategy is made unique by its \"full name\" instead, i.e., the entry point group + the entry points name, e.g., oteapi.download:oteapi.https . This value can be retrieved from the full_name property. This is a condition for uniqueness that is considered to be a superset of the current condition for uniqueness. It adds an extra package-specific uniqueness trait, allowing for different packages to implement the same strategies (which is currently not allowed according to the condition of uniqueness explained above). Currently there is no consensus on the API for handling this added strategy ambiguity. Exceptions: Type Description ValueError If the entry point name is not properly defined. Source code in oteapi/plugins/entry_points.py class EntryPointStrategy : \"\"\"A strategy realized from an entry point. An entry point strategy is made unique by its \"strategy\", i.e., its (strategy type, strategy name)-tuple, e.g., `(\"download\", \"https\")`. This tuple can be retrieved from the [`strategy`][oteapi.plugins.entry_points.EntryPointStrategy.strategy] property, where the strategy type is represented by the [`StrategyType`][oteapi.plugins.entry_points.StrategyType] enumeration. Note: It may be that in the future an entry points strategy is made unique by its \"full name\" instead, i.e., the entry point group + the entry points name, e.g., `oteapi.download:oteapi.https`. This value can be retrieved from the [`full_name`][oteapi.plugins.entry_points.EntryPointStrategy.full_name] property. This is a condition for uniqueness that is considered to be a superset of the current condition for uniqueness. It adds an extra package-specific uniqueness trait, allowing for different packages to implement the same strategies (which is currently not allowed according to the condition of uniqueness explained above). Currently there is no consensus on the API for handling this added strategy ambiguity. Raises: ValueError: If the entry point name is not properly defined. \"\"\" ENTRY_POINT_NAME_REGEX = re . compile ( r \"^(?P<package_name>[a-z_]+)\\.(?P<strategy_name>.+)$\" ) ENTRY_POINT_NAME_SEPARATOR = \":\" def __init__ ( self , entry_point : \"EntryPoint\" ) -> None : self . _entry_point = entry_point match = self . ENTRY_POINT_NAME_REGEX . match ( self . _entry_point . name ) if match is None : raise ValueError ( \"Could not determine package name and/or strategy name for entry \" f \"point: { self . full_name } \" ) self . _match = match self . _type = StrategyType ( self . _entry_point . group [ len ( \"oteapi.\" ) :]) self . _implementation : \"Optional[Type[IStrategy]]\" = None @property def type ( self ) -> StrategyType : \"\"\"The strategy type. One part of the (strategy type, strategy name)-tuple. \"\"\" return self . _type @property def name ( self ) -> str : \"\"\"The strategy name. One part of the (strategy type, strategy name)-tuple. \"\"\" return self . _match . group ( \"strategy_name\" ) @property def strategy ( self ) -> \"Tuple[StrategyType, str]\" : \"\"\"The unique index identifier for the strategy.\"\"\" return self . type , self . name @property def package ( self ) -> str : \"\"\"The importable base package name for the strategy plugin.\"\"\" return self . _match . group ( \"package_name\" ) @property def module ( self ) -> str : \"\"\"The fully resolved importable module path.\"\"\" return self . _entry_point . module # type: ignore[attr-defined] @property def full_name ( self ) -> str : \"\"\"The full entry point name.\"\"\" return f \" { self . _entry_point . group }{ self . ENTRY_POINT_NAME_SEPARATOR }{ self . _entry_point . name } \" def __str__ ( self ) -> str : return self . full_name def __repr__ ( self ) -> str : return f \" { self . __class__ . __name__ } (entry_point= { self . _entry_point !r} )\" @property def implementation_name ( self ) -> str : \"\"\"The EntryPoint attr, which should be the strategy implementation class name.\"\"\" return self . _entry_point . attr # type: ignore[attr-defined] @property def implementation ( self ) -> \"Type[IStrategy]\" : \"\"\"The actual strategy implementation.\"\"\" if self . _implementation is None : self . _implementation = self . _load_implementation () return self . _implementation def _load_implementation ( self ) -> \"Type[IStrategy]\" : \"\"\"Load the strategy implementation. Because the actual importing of the module does not happen until this method is called, we are lazily loading in the strategy implementation. There is no need to check through the `globals()` built-in for whether the module and class have already been imported, because this caching layer is already implemented in the `importlib` API. Raises: EntryPointNotFound: If the strategy implementation (class) the entry point is pointing to cannot be found in the module or if the module cannot be imported. Returns: The imported strategy implementation (class). \"\"\" try : module = importlib . import_module ( self . module ) except ImportError as exc : raise EntryPointNotFound ( f \" { self . module } cannot be imported. Did you install the \" f \" { self . package !r} package?\" ) from exc if hasattr ( module , self . implementation_name ): return getattr ( module , self . implementation_name ) raise EntryPointNotFound ( f \" { self . implementation_name } cannot be found in { self . module } \" ) def __eq__ ( self , other : \"Any\" ) -> bool : if isinstance ( other , self . __class__ ): return hash ( self ) == hash ( other ) return False def __hash__ ( self ) -> int : return hash ( self . strategy ) def __lt__ ( self , other : \"Any\" ) -> bool : \"\"\"Whether or not `self` is less than (`<`) `other`. This is implemented to allow sorting (using `sorted()`). The inequality is determined on the basis of the following properties: 1. [`type`][oteapi.plugins.entry_points.EntryPointStrategy.type] 2. [`package`][oteapi.plugins.entry_points.EntryPointStrategy.package] 3. [`name`][oteapi.plugins.entry_points.EntryPointStrategy.name] Going from highest priority to lowest and in alphabetical ascending order. \"\"\" if isinstance ( other , self . __class__ ): if self . type == other . type : if self . package == other . package : if self . name == other . name : # Considered equal, i.e., one can by definition not be unequal # with the other. return False return sorted ([ self . name , other . name ])[ 0 ] == self . name return sorted ([ self . package , other . package ])[ 0 ] == self . package return sorted ([ self . type . value , other . type . value ])[ 0 ] == self . type . value raise NotImplementedError ( f \"Less than comparison is not implemented for { type ( other ) } type objects.\" )","title":"EntryPointStrategy"},{"location":"api_reference/plugins/entry_points/#oteapi.plugins.entry_points.EntryPointStrategy.full_name","text":"The full entry point name.","title":"full_name"},{"location":"api_reference/plugins/entry_points/#oteapi.plugins.entry_points.EntryPointStrategy.implementation","text":"The actual strategy implementation.","title":"implementation"},{"location":"api_reference/plugins/entry_points/#oteapi.plugins.entry_points.EntryPointStrategy.implementation_name","text":"The EntryPoint attr, which should be the strategy implementation class name.","title":"implementation_name"},{"location":"api_reference/plugins/entry_points/#oteapi.plugins.entry_points.EntryPointStrategy.module","text":"The fully resolved importable module path.","title":"module"},{"location":"api_reference/plugins/entry_points/#oteapi.plugins.entry_points.EntryPointStrategy.name","text":"The strategy name. One part of the (strategy type, strategy name)-tuple.","title":"name"},{"location":"api_reference/plugins/entry_points/#oteapi.plugins.entry_points.EntryPointStrategy.package","text":"The importable base package name for the strategy plugin.","title":"package"},{"location":"api_reference/plugins/entry_points/#oteapi.plugins.entry_points.EntryPointStrategy.strategy","text":"The unique index identifier for the strategy.","title":"strategy"},{"location":"api_reference/plugins/entry_points/#oteapi.plugins.entry_points.EntryPointStrategy.type","text":"The strategy type. One part of the (strategy type, strategy name)-tuple.","title":"type"},{"location":"api_reference/plugins/entry_points/#oteapi.plugins.entry_points.EntryPointStrategyCollection","text":"A collection of EntryPointStrategy s. Source code in oteapi/plugins/entry_points.py class EntryPointStrategyCollection ( abc . Collection ): \"\"\"A collection of [`EntryPointStrategy`][oteapi.plugins.entry_points.EntryPointStrategy]s.\"\"\" def __init__ ( self , * entry_points : \"EntryPointStrategy\" ) -> None : self . _entry_points : \"Set[EntryPointStrategy]\" = ( set ( entry_points ) if entry_points else set () ) def add ( self , * entry_points : EntryPointStrategy ) -> None : \"\"\"Add entry points to the collection. Parameters: entry_points: Entry points to add to the collection. \"\"\" self . _entry_points |= set ( entry_points ) def remove ( self , * entry_points : EntryPointStrategy ) -> None : \"\"\"Remove entry points from the collection. Parameters: entry_points: Entry points to remove from the collection. \"\"\" self . _entry_points -= set ( entry_points ) def exclusive_add ( self , * entry_points : EntryPointStrategy ) -> None : \"\"\"Exclusively add entry points to the collection. Parameters: entry_points: Entry points to add to the collection. Raises: KeyError: If an entry point to be added already exists in the collection. \"\"\" for entry_point in entry_points : if entry_point in self : raise KeyError ( f \" { entry_point . strategy } already exists in { self } . \" f \"(Tried adding { entry_point } .)\" ) self . add ( entry_point ) def __len__ ( self ) -> int : return len ( self . _entry_points ) def __contains__ ( self , item : \"Any\" ) -> bool : \"\"\"Whether or not `item` is contained in the collection. One can test with an `EntryPointStrategy`, a string of an entry point strategy's full name, or a tuple of an entry point's strategy type and name. Parameters: item: Item to test whether it is contained in the collection. Returns: Whether or not `item` is contained in the collection. If the `item` is an unrecognized type, `False` will be returned. \"\"\" if isinstance ( item , EntryPointStrategy ): return item in self . _entry_points if isinstance ( item , str ): for entry_point in self . _entry_points : if item == entry_point . full_name : return True if isinstance ( item , tuple ): if len ( item ) != 2 or ( not isinstance ( item [ 0 ], ( StrategyType , str )) or not isinstance ( item [ 1 ], str ) ): # Only tuples of type (Union[StrategyType, str], str) are allowed. return False try : item_ = ( StrategyType . init ( item [ 0 ]), item [ 1 ]) except ValueError : # We only want to return True or False return False for entry_point in self . _entry_points : if item_ == entry_point . strategy : return True # For any other type: return False def __iter__ ( self ) -> \"Iterator[EntryPointStrategy]\" : yield from self . _entry_points def __getitem__ ( self , key : \"Any\" ) -> EntryPointStrategy : return self . get_entry_point ( key ) def get_entry_point ( self , key : \"Union[EntryPointStrategy, str, Tuple[Union[StrategyType, str], str]]\" , ) -> EntryPointStrategy : \"\"\"Retrieve an entry point from the collection. Parameters: key: The key to check for in the collection. Raises: KeyError: If an entry point cannot be found in the collection. TypeError: If the `key` is not of an expected type. See the `key` parameter above for the expected types. Returns: An entry point in the collection representing the key. \"\"\" if isinstance ( key , ( EntryPointStrategy , str , tuple )): if key not in self : raise KeyError ( f \" { key } not found in { self } \" ) return self . _get_entry_point ( key ) raise TypeError ( \"key should either be of type EntryPointStrategy, a string of the full \" \"name or a strategy tuple.\" ) def _get_entry_point ( self , key : \"Union[EntryPointStrategy, str, Tuple[Union[StrategyType, str], str]]\" , ) -> EntryPointStrategy : \"\"\"Helper method for retrieving an entry point from the collection. Important: It is expected that the entry point representing the key exists in the collection. For example through a `key in self` test. Parameters: key: The key to check for in the collection. Raises: RuntimeError: If an entry point cannot be found in the collection, since this is a requirement. Returns: An entry point in the collection representing the key. \"\"\" if isinstance ( key , EntryPointStrategy ): return key if isinstance ( key , str ): for entry_point in self . _entry_points : if key == entry_point . full_name : return entry_point if isinstance ( key , tuple ): key_ = ( StrategyType ( key [ 0 ]), key [ 1 ]) for entry_point in self . _entry_points : if key_ == entry_point . strategy : return entry_point raise RuntimeError ( f \" { key } not found in { self } , which is a requirement for the \" \"_get_entry_point method.\" ) def __eq__ ( self , other : \"Any\" ) -> bool : if isinstance ( other , self . __class__ ): return hash ( self ) == hash ( other ) return False def __hash__ ( self ) -> int : return hash ( tuple ( _ for _ in sorted ( self . _entry_points ))) def __str__ ( self ) -> str : res = {} # type: ignore[var-annotated] for _ in self . _entry_points : if _ . type . value in res : res [ _ . type . value ] += 1 else : res [ _ . type . value ] = 1 res = sorted ( f \" { key } ( { value } )\" for key , value in res . items ()) return f \"< { self . __class__ . __name__ } : \" f \"Strategies= { ', ' . join ( res ) } >\" def __repr__ ( self ) -> str : return f \" { self . __class__ . __name__ } (* { tuple ( sorted ( self . _entry_points )) !r} )\"","title":"EntryPointStrategyCollection"},{"location":"api_reference/plugins/entry_points/#oteapi.plugins.entry_points.EntryPointStrategyCollection.add","text":"Add entry points to the collection. Parameters: Name Type Description Default entry_points EntryPointStrategy Entry points to add to the collection. () Source code in oteapi/plugins/entry_points.py def add ( self , * entry_points : EntryPointStrategy ) -> None : \"\"\"Add entry points to the collection. Parameters: entry_points: Entry points to add to the collection. \"\"\" self . _entry_points |= set ( entry_points )","title":"add()"},{"location":"api_reference/plugins/entry_points/#oteapi.plugins.entry_points.EntryPointStrategyCollection.exclusive_add","text":"Exclusively add entry points to the collection. Parameters: Name Type Description Default entry_points EntryPointStrategy Entry points to add to the collection. () Exceptions: Type Description KeyError If an entry point to be added already exists in the collection. Source code in oteapi/plugins/entry_points.py def exclusive_add ( self , * entry_points : EntryPointStrategy ) -> None : \"\"\"Exclusively add entry points to the collection. Parameters: entry_points: Entry points to add to the collection. Raises: KeyError: If an entry point to be added already exists in the collection. \"\"\" for entry_point in entry_points : if entry_point in self : raise KeyError ( f \" { entry_point . strategy } already exists in { self } . \" f \"(Tried adding { entry_point } .)\" ) self . add ( entry_point )","title":"exclusive_add()"},{"location":"api_reference/plugins/entry_points/#oteapi.plugins.entry_points.EntryPointStrategyCollection.get_entry_point","text":"Retrieve an entry point from the collection. Parameters: Name Type Description Default key Union[EntryPointStrategy, str, Tuple[Union[StrategyType, str], str]] The key to check for in the collection. required Exceptions: Type Description KeyError If an entry point cannot be found in the collection. TypeError If the key is not of an expected type. See the key parameter above for the expected types. Returns: Type Description EntryPointStrategy An entry point in the collection representing the key. Source code in oteapi/plugins/entry_points.py def get_entry_point ( self , key : \"Union[EntryPointStrategy, str, Tuple[Union[StrategyType, str], str]]\" , ) -> EntryPointStrategy : \"\"\"Retrieve an entry point from the collection. Parameters: key: The key to check for in the collection. Raises: KeyError: If an entry point cannot be found in the collection. TypeError: If the `key` is not of an expected type. See the `key` parameter above for the expected types. Returns: An entry point in the collection representing the key. \"\"\" if isinstance ( key , ( EntryPointStrategy , str , tuple )): if key not in self : raise KeyError ( f \" { key } not found in { self } \" ) return self . _get_entry_point ( key ) raise TypeError ( \"key should either be of type EntryPointStrategy, a string of the full \" \"name or a strategy tuple.\" )","title":"get_entry_point()"},{"location":"api_reference/plugins/entry_points/#oteapi.plugins.entry_points.EntryPointStrategyCollection.remove","text":"Remove entry points from the collection. Parameters: Name Type Description Default entry_points EntryPointStrategy Entry points to remove from the collection. () Source code in oteapi/plugins/entry_points.py def remove ( self , * entry_points : EntryPointStrategy ) -> None : \"\"\"Remove entry points from the collection. Parameters: entry_points: Entry points to remove from the collection. \"\"\" self . _entry_points -= set ( entry_points )","title":"remove()"},{"location":"api_reference/plugins/entry_points/#oteapi.plugins.entry_points.StrategyType","text":"An enumeration of available strategy types. Available strategy types: download filter mapping parse resource transformation Source code in oteapi/plugins/entry_points.py class StrategyType ( Enum ): \"\"\"An enumeration of available strategy types. Available strategy types: - download - filter - mapping - parse - resource - transformation \"\"\" DOWNLOAD = \"download\" FILTER = \"filter\" FUNCTION = \"function\" MAPPING = \"mapping\" PARSE = \"parse\" RESOURCE = \"resource\" TRANSFORMATION = \"transformation\" def map_to_field ( self ) -> str : \"\"\"Map enumeration value to the strategy type's field.\"\"\" return { \"download\" : \"scheme\" , \"filter\" : \"filterType\" , \"function\" : \"functionType\" , \"mapping\" : \"mappingType\" , \"parse\" : \"mediaType\" , \"resource\" : \"accessService\" , \"transformation\" : \"transformationType\" , }[ self . value ] @classmethod def map_from_field ( cls , strategy_type_field : str ) -> \"StrategyType\" : \"\"\"Map the strategy type's field to enumeration. Parameters: strategy_type_field: The strategy type's field. E.g., `scheme` for `download`. Raises: KeyError: If the `strategy_type_field` is not valid. Returns: An enumeration instance representing the strategy type's field. \"\"\" return { \"scheme\" : cls . DOWNLOAD , \"filterType\" : cls . FILTER , \"functionType\" : cls . FUNCTION , \"mappingType\" : cls . MAPPING , \"mediaType\" : cls . PARSE , \"accessService\" : cls . RESOURCE , \"transformationType\" : cls . TRANSFORMATION , }[ strategy_type_field ] @classmethod def init ( cls , value : \"Union[str, StrategyType]\" ) -> \"StrategyType\" : \"\"\"Initialize a StrategyType with more than just the enumeration value. This method allows one to also initialize a StrategyType with an actual strategy type string, e.g., `scheme`, `mediaType`, etc. Raises: ValueError: As normal if the enumeration value is not valid. \"\"\" if isinstance ( value , str ): try : return cls . map_from_field ( value ) except KeyError : pass return cls ( value ) @classmethod @lru_cache def all_values ( cls ) -> \"Tuple[str, ...]\" : \"\"\"Return all values.\"\"\" return tuple ( strategy_type . value for strategy_type in cls ) def __str__ ( self ) -> str : return str ( self . value ) def __repr__ ( self ) -> str : return repr ( str ( self ))","title":"StrategyType"},{"location":"api_reference/plugins/entry_points/#oteapi.plugins.entry_points.get_strategy_entry_points","text":"Retrieve all entry points from a specific strategy type. Exceptions: Type Description ValueError If the strategy type is not supported. KeyError If enforce_uniqueness is True and an entry point strategy is duplicated. Parameters: Name Type Description Default strategy_type Union[StrategyType, str] A strategy type for which the entry points will be retrieved. required enforce_uniqueness bool Whether or not duplicate entry point strategies are allowed. Defaults to True , meaning duplicates are not allowed. True Returns: Type Description EntryPointStrategyCollection A collection of entry points for the specific strategy type. Source code in oteapi/plugins/entry_points.py def get_strategy_entry_points ( strategy_type : \"Union[StrategyType, str]\" , enforce_uniqueness : bool = True , ) -> EntryPointStrategyCollection : \"\"\"Retrieve all entry points from a specific strategy type. Raises: ValueError: If the strategy type is not supported. KeyError: If `enforce_uniqueness` is `True` and an entry point strategy is duplicated. Parameters: strategy_type: A strategy type for which the entry points will be retrieved. enforce_uniqueness: Whether or not duplicate entry point strategies are allowed. Defaults to `True`, meaning duplicates are *not* allowed. Returns: A collection of entry points for the specific strategy type. \"\"\" try : strategy_type = StrategyType ( strategy_type ) except ValueError as exc : raise ValueError ( \"Strategy type \" f \" { strategy_type if isinstance ( strategy_type , str ) else str ( strategy_type . value ) !r} \" \" is not supported.\" ) from exc collection = EntryPointStrategyCollection () for group , oteapi_entry_points in get_entry_points () . items (): if group . startswith ( \"oteapi.\" ) and group [ len ( \"oteapi.\" ) :] == str ( strategy_type . value ): if enforce_uniqueness : collection . exclusive_add ( * ( EntryPointStrategy ( _ ) for _ in oteapi_entry_points ) ) else : collection . add ( * ( EntryPointStrategy ( _ ) for _ in oteapi_entry_points )) return collection","title":"get_strategy_entry_points()"},{"location":"api_reference/plugins/factories/","text":"factories \u00b6 Factory class for registering and creating strategy instances. Factory wrapper methods for creating the individual strategies. StrategiesNotLoaded ( Exception ) \u00b6 Entry point strategies have not been loaded, run load_strategies() . Source code in oteapi/plugins/factories.py class StrategiesNotLoaded ( Exception ): \"\"\"Entry point strategies have not been loaded, run [`load_strategies()`][oteapi.plugins.factories.load_strategies].\"\"\" StrategyFactory \u00b6 Decorator-based Factory class. Attributes: Name Type Description strategy_create_func Dict[StrategyType, EntryPointStrategyCollection] An in-memory cache of all registered strategies. Source code in oteapi/plugins/factories.py class StrategyFactory : \"\"\"Decorator-based Factory class. Attributes: strategy_create_func (Dict[StrategyType, EntryPointStrategyCollection]): An in-memory cache of all registered strategies. \"\"\" strategy_create_func : \"Dict[StrategyType, EntryPointStrategyCollection]\" @classmethod def make_strategy ( cls , config : \"StrategyConfig\" , strategy_type : \"Union[StrategyType, str]\" ) -> \"IStrategy\" : \"\"\"Instantiate a strategy in a context class. Parameters: config: A strategy configuration. strategy_type: The strategy type, e.g., `\"scheme\"`, `\"mediaType\"`, ... or `\"download\"`, `\"parse\"`, ... See the [`StrategyType`][oteapi.plugins.entry_points.StrategyType] enumeration for a definition of valid strategy types. Raises: NotImplementedError: If the strategy cannot be found. ValueError: If the `strategy_type` is not a valid strategy type. See the [`StrategyType`][oteapi.plugins.entry_points.StrategyType] enumeration for a definition of valid strategy types. StrategiesNotLoaded: If the entry point strategies have not been loaded. Returns: An instantiated strategy. The strategy is instantiated with the provided configuration, through the `config` parameter. \"\"\" if not hasattr ( cls , \"strategy_create_func\" ): raise StrategiesNotLoaded ( \"Strategies have not been loaded, run `load_strategies()` or \" \"`StrategyFactory.load_strategies()`.\" ) if isinstance ( strategy_type , str ): try : strategy_type = StrategyType . init ( strategy_type ) except ValueError as exc : raise ValueError ( f \"Strategy type { strategy_type !r} is not supported.\" ) from exc elif not isinstance ( strategy_type , StrategyType ): raise TypeError ( \"strategy_type should be either of type StrategyType or a string.\" ) strategy_name : str = cls . _get_strategy_name ( config , strategy_type ) if ( strategy_type , strategy_name ) in cls . strategy_create_func [ strategy_type ]: return cls . strategy_create_func [ strategy_type ][ ( strategy_type , strategy_name ) ] . implementation ( config ) raise NotImplementedError ( f \"The { strategy_type . value } strategy { strategy_name !r} does not exist.\" ) @classmethod def _get_strategy_name ( cls , config : \"StrategyConfig\" , strategy_type : StrategyType , ) -> str : \"\"\"Return the strategy name through the config. This is a method to accommodate strategy type-specific quirks to retrieve the strategy name. Parameters: config: A strategy configuration. strategy_type: The strategy type as initialized in `make_strategy()`. Returns: The strategy name provided in the configuration. \"\"\" if strategy_type == StrategyType . DOWNLOAD : return config . downloadUrl . scheme if config . downloadUrl is not None else \"\" return getattr ( config , strategy_type . map_to_field (), \"\" ) @classmethod def load_strategies ( cls , test_for_uniqueness : bool = True ) -> None : \"\"\"Load strategies from entry points and store in class attribute. Important: This is not a cached method. The importlib.metadata API will be re-requested to load the entry points and strategies. Note: This does *not* import the actual strategy implementations (classes). It only loads the strategies from the registerred OTE-API entry points. Raises: KeyError: If `test_for_uniqueness` is `True` and an entry point strategy is duplicated. Parameters: test_for_uniqueness: If `True`, this will raise `KeyError` should an entry point strategy be duplicated. Otherwise, the first loaded entry point strategy will silently become the implementation of choice for the duplicated strategy and the duplicates will be ignored. \"\"\" cls . strategy_create_func = { strategy_type : get_strategy_entry_points ( strategy_type , enforce_uniqueness = test_for_uniqueness ) for strategy_type in StrategyType } load_strategies ( test_for_uniqueness = True ) classmethod \u00b6 Load strategies from entry points and store in class attribute. Important This is not a cached method. The importlib.metadata API will be re-requested to load the entry points and strategies. Note This does not import the actual strategy implementations (classes). It only loads the strategies from the registerred OTE-API entry points. Exceptions: Type Description KeyError If test_for_uniqueness is True and an entry point strategy is duplicated. Parameters: Name Type Description Default test_for_uniqueness bool If True , this will raise KeyError should an entry point strategy be duplicated. Otherwise, the first loaded entry point strategy will silently become the implementation of choice for the duplicated strategy and the duplicates will be ignored. True Source code in oteapi/plugins/factories.py @classmethod def load_strategies ( cls , test_for_uniqueness : bool = True ) -> None : \"\"\"Load strategies from entry points and store in class attribute. Important: This is not a cached method. The importlib.metadata API will be re-requested to load the entry points and strategies. Note: This does *not* import the actual strategy implementations (classes). It only loads the strategies from the registerred OTE-API entry points. Raises: KeyError: If `test_for_uniqueness` is `True` and an entry point strategy is duplicated. Parameters: test_for_uniqueness: If `True`, this will raise `KeyError` should an entry point strategy be duplicated. Otherwise, the first loaded entry point strategy will silently become the implementation of choice for the duplicated strategy and the duplicates will be ignored. \"\"\" cls . strategy_create_func = { strategy_type : get_strategy_entry_points ( strategy_type , enforce_uniqueness = test_for_uniqueness ) for strategy_type in StrategyType } make_strategy ( config , strategy_type ) classmethod \u00b6 Instantiate a strategy in a context class. Parameters: Name Type Description Default config StrategyConfig A strategy configuration. required strategy_type Union[StrategyType, str] The strategy type, e.g., \"scheme\" , \"mediaType\" , ... or \"download\" , \"parse\" , ... See the StrategyType enumeration for a definition of valid strategy types. required Exceptions: Type Description NotImplementedError If the strategy cannot be found. ValueError If the strategy_type is not a valid strategy type. See the StrategyType enumeration for a definition of valid strategy types. StrategiesNotLoaded If the entry point strategies have not been loaded. Returns: Type Description IStrategy An instantiated strategy. The strategy is instantiated with the provided configuration, through the config parameter. Source code in oteapi/plugins/factories.py @classmethod def make_strategy ( cls , config : \"StrategyConfig\" , strategy_type : \"Union[StrategyType, str]\" ) -> \"IStrategy\" : \"\"\"Instantiate a strategy in a context class. Parameters: config: A strategy configuration. strategy_type: The strategy type, e.g., `\"scheme\"`, `\"mediaType\"`, ... or `\"download\"`, `\"parse\"`, ... See the [`StrategyType`][oteapi.plugins.entry_points.StrategyType] enumeration for a definition of valid strategy types. Raises: NotImplementedError: If the strategy cannot be found. ValueError: If the `strategy_type` is not a valid strategy type. See the [`StrategyType`][oteapi.plugins.entry_points.StrategyType] enumeration for a definition of valid strategy types. StrategiesNotLoaded: If the entry point strategies have not been loaded. Returns: An instantiated strategy. The strategy is instantiated with the provided configuration, through the `config` parameter. \"\"\" if not hasattr ( cls , \"strategy_create_func\" ): raise StrategiesNotLoaded ( \"Strategies have not been loaded, run `load_strategies()` or \" \"`StrategyFactory.load_strategies()`.\" ) if isinstance ( strategy_type , str ): try : strategy_type = StrategyType . init ( strategy_type ) except ValueError as exc : raise ValueError ( f \"Strategy type { strategy_type !r} is not supported.\" ) from exc elif not isinstance ( strategy_type , StrategyType ): raise TypeError ( \"strategy_type should be either of type StrategyType or a string.\" ) strategy_name : str = cls . _get_strategy_name ( config , strategy_type ) if ( strategy_type , strategy_name ) in cls . strategy_create_func [ strategy_type ]: return cls . strategy_create_func [ strategy_type ][ ( strategy_type , strategy_name ) ] . implementation ( config ) raise NotImplementedError ( f \"The { strategy_type . value } strategy { strategy_name !r} does not exist.\" ) create_strategy ( strategy_type , config ) \u00b6 Proxy function for StrategyFactory.make_strategy() . Parameters: Name Type Description Default strategy_type Union[StrategyType, str] A valid strategy type. See the StrategyType enumeration for a definition of valid strategy types. required config StrategyConfig A strategy configuration. required Returns: Type Description IStrategy The created strategy. Source code in oteapi/plugins/factories.py def create_strategy ( strategy_type : \"Union[StrategyType, str]\" , config : \"StrategyConfig\" ) -> \"IStrategy\" : \"\"\"Proxy function for [`StrategyFactory.make_strategy()`][oteapi.plugins.factories.StrategyFactory.make_strategy]. Parameters: strategy_type: A valid strategy type. See the [`StrategyType`][oteapi.plugins.entry_points.StrategyType] enumeration for a definition of valid strategy types. config: A strategy configuration. Returns: The created strategy. \"\"\" return StrategyFactory . make_strategy ( config , strategy_type ) load_strategies ( test_for_uniqueness = True ) \u00b6 Proxy function for StrategyFactory.load_strategies() . Parameters: Name Type Description Default test_for_uniqueness bool If True , this will raise KeyError should an entry point strategy be duplicated. Otherwise, the first loaded entry point strategy will silently become the implementation of choice for the duplicated strategy and the duplicates will be ignored. True Source code in oteapi/plugins/factories.py def load_strategies ( test_for_uniqueness : bool = True ) -> None : # pylint: disable=line-too-long \"\"\"Proxy function for [`StrategyFactory.load_strategies()`][oteapi.plugins.factories.StrategyFactory.load_strategies]. Parameters: test_for_uniqueness: If `True`, this will raise `KeyError` should an entry point strategy be duplicated. Otherwise, the first loaded entry point strategy will silently become the implementation of choice for the duplicated strategy and the duplicates will be ignored. \"\"\" StrategyFactory . load_strategies ( test_for_uniqueness )","title":"factories"},{"location":"api_reference/plugins/factories/#factories","text":"Factory class for registering and creating strategy instances. Factory wrapper methods for creating the individual strategies.","title":"factories"},{"location":"api_reference/plugins/factories/#oteapi.plugins.factories.StrategiesNotLoaded","text":"Entry point strategies have not been loaded, run load_strategies() . Source code in oteapi/plugins/factories.py class StrategiesNotLoaded ( Exception ): \"\"\"Entry point strategies have not been loaded, run [`load_strategies()`][oteapi.plugins.factories.load_strategies].\"\"\"","title":"StrategiesNotLoaded"},{"location":"api_reference/plugins/factories/#oteapi.plugins.factories.StrategyFactory","text":"Decorator-based Factory class. Attributes: Name Type Description strategy_create_func Dict[StrategyType, EntryPointStrategyCollection] An in-memory cache of all registered strategies. Source code in oteapi/plugins/factories.py class StrategyFactory : \"\"\"Decorator-based Factory class. Attributes: strategy_create_func (Dict[StrategyType, EntryPointStrategyCollection]): An in-memory cache of all registered strategies. \"\"\" strategy_create_func : \"Dict[StrategyType, EntryPointStrategyCollection]\" @classmethod def make_strategy ( cls , config : \"StrategyConfig\" , strategy_type : \"Union[StrategyType, str]\" ) -> \"IStrategy\" : \"\"\"Instantiate a strategy in a context class. Parameters: config: A strategy configuration. strategy_type: The strategy type, e.g., `\"scheme\"`, `\"mediaType\"`, ... or `\"download\"`, `\"parse\"`, ... See the [`StrategyType`][oteapi.plugins.entry_points.StrategyType] enumeration for a definition of valid strategy types. Raises: NotImplementedError: If the strategy cannot be found. ValueError: If the `strategy_type` is not a valid strategy type. See the [`StrategyType`][oteapi.plugins.entry_points.StrategyType] enumeration for a definition of valid strategy types. StrategiesNotLoaded: If the entry point strategies have not been loaded. Returns: An instantiated strategy. The strategy is instantiated with the provided configuration, through the `config` parameter. \"\"\" if not hasattr ( cls , \"strategy_create_func\" ): raise StrategiesNotLoaded ( \"Strategies have not been loaded, run `load_strategies()` or \" \"`StrategyFactory.load_strategies()`.\" ) if isinstance ( strategy_type , str ): try : strategy_type = StrategyType . init ( strategy_type ) except ValueError as exc : raise ValueError ( f \"Strategy type { strategy_type !r} is not supported.\" ) from exc elif not isinstance ( strategy_type , StrategyType ): raise TypeError ( \"strategy_type should be either of type StrategyType or a string.\" ) strategy_name : str = cls . _get_strategy_name ( config , strategy_type ) if ( strategy_type , strategy_name ) in cls . strategy_create_func [ strategy_type ]: return cls . strategy_create_func [ strategy_type ][ ( strategy_type , strategy_name ) ] . implementation ( config ) raise NotImplementedError ( f \"The { strategy_type . value } strategy { strategy_name !r} does not exist.\" ) @classmethod def _get_strategy_name ( cls , config : \"StrategyConfig\" , strategy_type : StrategyType , ) -> str : \"\"\"Return the strategy name through the config. This is a method to accommodate strategy type-specific quirks to retrieve the strategy name. Parameters: config: A strategy configuration. strategy_type: The strategy type as initialized in `make_strategy()`. Returns: The strategy name provided in the configuration. \"\"\" if strategy_type == StrategyType . DOWNLOAD : return config . downloadUrl . scheme if config . downloadUrl is not None else \"\" return getattr ( config , strategy_type . map_to_field (), \"\" ) @classmethod def load_strategies ( cls , test_for_uniqueness : bool = True ) -> None : \"\"\"Load strategies from entry points and store in class attribute. Important: This is not a cached method. The importlib.metadata API will be re-requested to load the entry points and strategies. Note: This does *not* import the actual strategy implementations (classes). It only loads the strategies from the registerred OTE-API entry points. Raises: KeyError: If `test_for_uniqueness` is `True` and an entry point strategy is duplicated. Parameters: test_for_uniqueness: If `True`, this will raise `KeyError` should an entry point strategy be duplicated. Otherwise, the first loaded entry point strategy will silently become the implementation of choice for the duplicated strategy and the duplicates will be ignored. \"\"\" cls . strategy_create_func = { strategy_type : get_strategy_entry_points ( strategy_type , enforce_uniqueness = test_for_uniqueness ) for strategy_type in StrategyType }","title":"StrategyFactory"},{"location":"api_reference/plugins/factories/#oteapi.plugins.factories.StrategyFactory.load_strategies","text":"Load strategies from entry points and store in class attribute. Important This is not a cached method. The importlib.metadata API will be re-requested to load the entry points and strategies. Note This does not import the actual strategy implementations (classes). It only loads the strategies from the registerred OTE-API entry points. Exceptions: Type Description KeyError If test_for_uniqueness is True and an entry point strategy is duplicated. Parameters: Name Type Description Default test_for_uniqueness bool If True , this will raise KeyError should an entry point strategy be duplicated. Otherwise, the first loaded entry point strategy will silently become the implementation of choice for the duplicated strategy and the duplicates will be ignored. True Source code in oteapi/plugins/factories.py @classmethod def load_strategies ( cls , test_for_uniqueness : bool = True ) -> None : \"\"\"Load strategies from entry points and store in class attribute. Important: This is not a cached method. The importlib.metadata API will be re-requested to load the entry points and strategies. Note: This does *not* import the actual strategy implementations (classes). It only loads the strategies from the registerred OTE-API entry points. Raises: KeyError: If `test_for_uniqueness` is `True` and an entry point strategy is duplicated. Parameters: test_for_uniqueness: If `True`, this will raise `KeyError` should an entry point strategy be duplicated. Otherwise, the first loaded entry point strategy will silently become the implementation of choice for the duplicated strategy and the duplicates will be ignored. \"\"\" cls . strategy_create_func = { strategy_type : get_strategy_entry_points ( strategy_type , enforce_uniqueness = test_for_uniqueness ) for strategy_type in StrategyType }","title":"load_strategies()"},{"location":"api_reference/plugins/factories/#oteapi.plugins.factories.StrategyFactory.make_strategy","text":"Instantiate a strategy in a context class. Parameters: Name Type Description Default config StrategyConfig A strategy configuration. required strategy_type Union[StrategyType, str] The strategy type, e.g., \"scheme\" , \"mediaType\" , ... or \"download\" , \"parse\" , ... See the StrategyType enumeration for a definition of valid strategy types. required Exceptions: Type Description NotImplementedError If the strategy cannot be found. ValueError If the strategy_type is not a valid strategy type. See the StrategyType enumeration for a definition of valid strategy types. StrategiesNotLoaded If the entry point strategies have not been loaded. Returns: Type Description IStrategy An instantiated strategy. The strategy is instantiated with the provided configuration, through the config parameter. Source code in oteapi/plugins/factories.py @classmethod def make_strategy ( cls , config : \"StrategyConfig\" , strategy_type : \"Union[StrategyType, str]\" ) -> \"IStrategy\" : \"\"\"Instantiate a strategy in a context class. Parameters: config: A strategy configuration. strategy_type: The strategy type, e.g., `\"scheme\"`, `\"mediaType\"`, ... or `\"download\"`, `\"parse\"`, ... See the [`StrategyType`][oteapi.plugins.entry_points.StrategyType] enumeration for a definition of valid strategy types. Raises: NotImplementedError: If the strategy cannot be found. ValueError: If the `strategy_type` is not a valid strategy type. See the [`StrategyType`][oteapi.plugins.entry_points.StrategyType] enumeration for a definition of valid strategy types. StrategiesNotLoaded: If the entry point strategies have not been loaded. Returns: An instantiated strategy. The strategy is instantiated with the provided configuration, through the `config` parameter. \"\"\" if not hasattr ( cls , \"strategy_create_func\" ): raise StrategiesNotLoaded ( \"Strategies have not been loaded, run `load_strategies()` or \" \"`StrategyFactory.load_strategies()`.\" ) if isinstance ( strategy_type , str ): try : strategy_type = StrategyType . init ( strategy_type ) except ValueError as exc : raise ValueError ( f \"Strategy type { strategy_type !r} is not supported.\" ) from exc elif not isinstance ( strategy_type , StrategyType ): raise TypeError ( \"strategy_type should be either of type StrategyType or a string.\" ) strategy_name : str = cls . _get_strategy_name ( config , strategy_type ) if ( strategy_type , strategy_name ) in cls . strategy_create_func [ strategy_type ]: return cls . strategy_create_func [ strategy_type ][ ( strategy_type , strategy_name ) ] . implementation ( config ) raise NotImplementedError ( f \"The { strategy_type . value } strategy { strategy_name !r} does not exist.\" )","title":"make_strategy()"},{"location":"api_reference/plugins/factories/#oteapi.plugins.factories.create_strategy","text":"Proxy function for StrategyFactory.make_strategy() . Parameters: Name Type Description Default strategy_type Union[StrategyType, str] A valid strategy type. See the StrategyType enumeration for a definition of valid strategy types. required config StrategyConfig A strategy configuration. required Returns: Type Description IStrategy The created strategy. Source code in oteapi/plugins/factories.py def create_strategy ( strategy_type : \"Union[StrategyType, str]\" , config : \"StrategyConfig\" ) -> \"IStrategy\" : \"\"\"Proxy function for [`StrategyFactory.make_strategy()`][oteapi.plugins.factories.StrategyFactory.make_strategy]. Parameters: strategy_type: A valid strategy type. See the [`StrategyType`][oteapi.plugins.entry_points.StrategyType] enumeration for a definition of valid strategy types. config: A strategy configuration. Returns: The created strategy. \"\"\" return StrategyFactory . make_strategy ( config , strategy_type )","title":"create_strategy()"},{"location":"api_reference/plugins/factories/#oteapi.plugins.factories.load_strategies","text":"Proxy function for StrategyFactory.load_strategies() . Parameters: Name Type Description Default test_for_uniqueness bool If True , this will raise KeyError should an entry point strategy be duplicated. Otherwise, the first loaded entry point strategy will silently become the implementation of choice for the duplicated strategy and the duplicates will be ignored. True Source code in oteapi/plugins/factories.py def load_strategies ( test_for_uniqueness : bool = True ) -> None : # pylint: disable=line-too-long \"\"\"Proxy function for [`StrategyFactory.load_strategies()`][oteapi.plugins.factories.StrategyFactory.load_strategies]. Parameters: test_for_uniqueness: If `True`, this will raise `KeyError` should an entry point strategy be duplicated. Otherwise, the first loaded entry point strategy will silently become the implementation of choice for the duplicated strategy and the duplicates will be ignored. \"\"\" StrategyFactory . load_strategies ( test_for_uniqueness )","title":"load_strategies()"},{"location":"api_reference/strategies/download/file/","text":"file \u00b6 Download strategy class for the file scheme. FileConfig ( BaseModel ) pydantic-model \u00b6 File-specific Configuration Data Model. Source code in oteapi/strategies/download/file.py class FileConfig ( BaseModel ): \"\"\"File-specific Configuration Data Model.\"\"\" text : bool = Field ( False , description = ( \"Whether the file should be opened in text mode. If `False`, the file will\" \" be opened in bytes mode.\" ), ) encoding : Optional [ str ] = Field ( None , description = ( \"Encoding used when opening the file. The default is platform dependent.\" ), ) encoding : str pydantic-field \u00b6 Encoding used when opening the file. The default is platform dependent. text : bool pydantic-field \u00b6 Whether the file should be opened in text mode. If False , the file will be opened in bytes mode. FileStrategy dataclass \u00b6 Strategy for retrieving data from a local file. Registers strategies : (\"scheme\", \"file\") Source code in oteapi/strategies/download/file.py @dataclass class FileStrategy : \"\"\"Strategy for retrieving data from a local file. **Registers strategies**: - `(\"scheme\", \"file\")` \"\"\" download_config : \"ResourceConfig\" def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdate : \"\"\"Initialize.\"\"\" return SessionUpdate () def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdateFile : \"\"\"Read local file.\"\"\" if ( self . download_config . downloadUrl is None or self . download_config . downloadUrl . scheme != \"file\" ): raise ValueError ( \"Expected 'downloadUrl' to have scheme 'file' in the configuration.\" ) filename = Path ( self . download_config . downloadUrl . path ) . resolve () if isinstance ( filename , PosixPath ): filename = Path ( \"/\" + self . download_config . downloadUrl . host + str ( filename )) cache = DataCache ( self . download_config . configuration ) if cache . config . accessKey and cache . config . accessKey in cache : key = cache . config . accessKey else : config = FileConfig ( ** self . download_config . configuration ) key = cache . add ( filename . read_text ( encoding = config . encoding ) if config . text else filename . read_bytes () ) return SessionUpdateFile ( key = key ) get ( self , session = None ) \u00b6 Read local file. Source code in oteapi/strategies/download/file.py def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdateFile : \"\"\"Read local file.\"\"\" if ( self . download_config . downloadUrl is None or self . download_config . downloadUrl . scheme != \"file\" ): raise ValueError ( \"Expected 'downloadUrl' to have scheme 'file' in the configuration.\" ) filename = Path ( self . download_config . downloadUrl . path ) . resolve () if isinstance ( filename , PosixPath ): filename = Path ( \"/\" + self . download_config . downloadUrl . host + str ( filename )) cache = DataCache ( self . download_config . configuration ) if cache . config . accessKey and cache . config . accessKey in cache : key = cache . config . accessKey else : config = FileConfig ( ** self . download_config . configuration ) key = cache . add ( filename . read_text ( encoding = config . encoding ) if config . text else filename . read_bytes () ) return SessionUpdateFile ( key = key ) initialize ( self , session = None ) \u00b6 Initialize. Source code in oteapi/strategies/download/file.py def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdate : \"\"\"Initialize.\"\"\" return SessionUpdate () SessionUpdateFile ( SessionUpdate ) pydantic-model \u00b6 Class for returning values from Download File strategy. Source code in oteapi/strategies/download/file.py class SessionUpdateFile ( SessionUpdate ): \"\"\"Class for returning values from Download File strategy.\"\"\" key : str = Field ( ... , description = \"Key to access the data in the cache.\" ) key : str pydantic-field required \u00b6 Key to access the data in the cache.","title":"file"},{"location":"api_reference/strategies/download/file/#file","text":"Download strategy class for the file scheme.","title":"file"},{"location":"api_reference/strategies/download/file/#oteapi.strategies.download.file.FileConfig","text":"File-specific Configuration Data Model. Source code in oteapi/strategies/download/file.py class FileConfig ( BaseModel ): \"\"\"File-specific Configuration Data Model.\"\"\" text : bool = Field ( False , description = ( \"Whether the file should be opened in text mode. If `False`, the file will\" \" be opened in bytes mode.\" ), ) encoding : Optional [ str ] = Field ( None , description = ( \"Encoding used when opening the file. The default is platform dependent.\" ), )","title":"FileConfig"},{"location":"api_reference/strategies/download/file/#oteapi.strategies.download.file.FileConfig.encoding","text":"Encoding used when opening the file. The default is platform dependent.","title":"encoding"},{"location":"api_reference/strategies/download/file/#oteapi.strategies.download.file.FileConfig.text","text":"Whether the file should be opened in text mode. If False , the file will be opened in bytes mode.","title":"text"},{"location":"api_reference/strategies/download/file/#oteapi.strategies.download.file.FileStrategy","text":"Strategy for retrieving data from a local file. Registers strategies : (\"scheme\", \"file\") Source code in oteapi/strategies/download/file.py @dataclass class FileStrategy : \"\"\"Strategy for retrieving data from a local file. **Registers strategies**: - `(\"scheme\", \"file\")` \"\"\" download_config : \"ResourceConfig\" def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdate : \"\"\"Initialize.\"\"\" return SessionUpdate () def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdateFile : \"\"\"Read local file.\"\"\" if ( self . download_config . downloadUrl is None or self . download_config . downloadUrl . scheme != \"file\" ): raise ValueError ( \"Expected 'downloadUrl' to have scheme 'file' in the configuration.\" ) filename = Path ( self . download_config . downloadUrl . path ) . resolve () if isinstance ( filename , PosixPath ): filename = Path ( \"/\" + self . download_config . downloadUrl . host + str ( filename )) cache = DataCache ( self . download_config . configuration ) if cache . config . accessKey and cache . config . accessKey in cache : key = cache . config . accessKey else : config = FileConfig ( ** self . download_config . configuration ) key = cache . add ( filename . read_text ( encoding = config . encoding ) if config . text else filename . read_bytes () ) return SessionUpdateFile ( key = key )","title":"FileStrategy"},{"location":"api_reference/strategies/download/file/#oteapi.strategies.download.file.FileStrategy.get","text":"Read local file. Source code in oteapi/strategies/download/file.py def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdateFile : \"\"\"Read local file.\"\"\" if ( self . download_config . downloadUrl is None or self . download_config . downloadUrl . scheme != \"file\" ): raise ValueError ( \"Expected 'downloadUrl' to have scheme 'file' in the configuration.\" ) filename = Path ( self . download_config . downloadUrl . path ) . resolve () if isinstance ( filename , PosixPath ): filename = Path ( \"/\" + self . download_config . downloadUrl . host + str ( filename )) cache = DataCache ( self . download_config . configuration ) if cache . config . accessKey and cache . config . accessKey in cache : key = cache . config . accessKey else : config = FileConfig ( ** self . download_config . configuration ) key = cache . add ( filename . read_text ( encoding = config . encoding ) if config . text else filename . read_bytes () ) return SessionUpdateFile ( key = key )","title":"get()"},{"location":"api_reference/strategies/download/file/#oteapi.strategies.download.file.FileStrategy.initialize","text":"Initialize. Source code in oteapi/strategies/download/file.py def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdate : \"\"\"Initialize.\"\"\" return SessionUpdate ()","title":"initialize()"},{"location":"api_reference/strategies/download/file/#oteapi.strategies.download.file.SessionUpdateFile","text":"Class for returning values from Download File strategy. Source code in oteapi/strategies/download/file.py class SessionUpdateFile ( SessionUpdate ): \"\"\"Class for returning values from Download File strategy.\"\"\" key : str = Field ( ... , description = \"Key to access the data in the cache.\" )","title":"SessionUpdateFile"},{"location":"api_reference/strategies/download/file/#oteapi.strategies.download.file.SessionUpdateFile.key","text":"Key to access the data in the cache.","title":"key"},{"location":"api_reference/strategies/download/https/","text":"https \u00b6 Download strategy class for http/https HTTPSStrategy dataclass \u00b6 Strategy for retrieving data via http. Registers strategies : (\"scheme\", \"http\") (\"scheme\", \"https\") Source code in oteapi/strategies/download/https.py @dataclass class HTTPSStrategy : \"\"\"Strategy for retrieving data via http. **Registers strategies**: - `(\"scheme\", \"http\")` - `(\"scheme\", \"https\")` \"\"\" download_config : \"ResourceConfig\" def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdate : \"\"\"Initialize.\"\"\" return SessionUpdate () def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdateHTTPS : \"\"\"Download via http/https and store on local cache.\"\"\" cache = DataCache ( self . download_config . configuration ) if cache . config . accessKey and cache . config . accessKey in cache : key = cache . config . accessKey else : if not self . download_config . downloadUrl : raise ValueError ( \"downloadUrl not defined in configuration.\" ) req = requests . get ( self . download_config . downloadUrl , allow_redirects = True ) key = cache . add ( req . content ) return SessionUpdateHTTPS ( key = key ) get ( self , session = None ) \u00b6 Download via http/https and store on local cache. Source code in oteapi/strategies/download/https.py def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdateHTTPS : \"\"\"Download via http/https and store on local cache.\"\"\" cache = DataCache ( self . download_config . configuration ) if cache . config . accessKey and cache . config . accessKey in cache : key = cache . config . accessKey else : if not self . download_config . downloadUrl : raise ValueError ( \"downloadUrl not defined in configuration.\" ) req = requests . get ( self . download_config . downloadUrl , allow_redirects = True ) key = cache . add ( req . content ) return SessionUpdateHTTPS ( key = key ) initialize ( self , session = None ) \u00b6 Initialize. Source code in oteapi/strategies/download/https.py def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdate : \"\"\"Initialize.\"\"\" return SessionUpdate () SessionUpdateHTTPS ( SessionUpdate ) pydantic-model \u00b6 Class for returning values from Download HTTPS strategy. Source code in oteapi/strategies/download/https.py class SessionUpdateHTTPS ( SessionUpdate ): \"\"\"Class for returning values from Download HTTPS strategy.\"\"\" key : str = Field ( ... , description = \"Key to access the data in the cache.\" ) key : str pydantic-field required \u00b6 Key to access the data in the cache.","title":"https"},{"location":"api_reference/strategies/download/https/#https","text":"Download strategy class for http/https","title":"https"},{"location":"api_reference/strategies/download/https/#oteapi.strategies.download.https.HTTPSStrategy","text":"Strategy for retrieving data via http. Registers strategies : (\"scheme\", \"http\") (\"scheme\", \"https\") Source code in oteapi/strategies/download/https.py @dataclass class HTTPSStrategy : \"\"\"Strategy for retrieving data via http. **Registers strategies**: - `(\"scheme\", \"http\")` - `(\"scheme\", \"https\")` \"\"\" download_config : \"ResourceConfig\" def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdate : \"\"\"Initialize.\"\"\" return SessionUpdate () def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdateHTTPS : \"\"\"Download via http/https and store on local cache.\"\"\" cache = DataCache ( self . download_config . configuration ) if cache . config . accessKey and cache . config . accessKey in cache : key = cache . config . accessKey else : if not self . download_config . downloadUrl : raise ValueError ( \"downloadUrl not defined in configuration.\" ) req = requests . get ( self . download_config . downloadUrl , allow_redirects = True ) key = cache . add ( req . content ) return SessionUpdateHTTPS ( key = key )","title":"HTTPSStrategy"},{"location":"api_reference/strategies/download/https/#oteapi.strategies.download.https.HTTPSStrategy.get","text":"Download via http/https and store on local cache. Source code in oteapi/strategies/download/https.py def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdateHTTPS : \"\"\"Download via http/https and store on local cache.\"\"\" cache = DataCache ( self . download_config . configuration ) if cache . config . accessKey and cache . config . accessKey in cache : key = cache . config . accessKey else : if not self . download_config . downloadUrl : raise ValueError ( \"downloadUrl not defined in configuration.\" ) req = requests . get ( self . download_config . downloadUrl , allow_redirects = True ) key = cache . add ( req . content ) return SessionUpdateHTTPS ( key = key )","title":"get()"},{"location":"api_reference/strategies/download/https/#oteapi.strategies.download.https.HTTPSStrategy.initialize","text":"Initialize. Source code in oteapi/strategies/download/https.py def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdate : \"\"\"Initialize.\"\"\" return SessionUpdate ()","title":"initialize()"},{"location":"api_reference/strategies/download/https/#oteapi.strategies.download.https.SessionUpdateHTTPS","text":"Class for returning values from Download HTTPS strategy. Source code in oteapi/strategies/download/https.py class SessionUpdateHTTPS ( SessionUpdate ): \"\"\"Class for returning values from Download HTTPS strategy.\"\"\" key : str = Field ( ... , description = \"Key to access the data in the cache.\" )","title":"SessionUpdateHTTPS"},{"location":"api_reference/strategies/download/https/#oteapi.strategies.download.https.SessionUpdateHTTPS.key","text":"Key to access the data in the cache.","title":"key"},{"location":"api_reference/strategies/download/sftp/","text":"sftp \u00b6 Strategy class for sftp/ftp SFTPStrategy dataclass \u00b6 Strategy for retrieving data via sftp. Registers strategies : (\"scheme\", \"ftp\") (\"scheme\", \"sftp\") Source code in oteapi/strategies/download/sftp.py @dataclass class SFTPStrategy : \"\"\"Strategy for retrieving data via sftp. **Registers strategies**: - `(\"scheme\", \"ftp\")` - `(\"scheme\", \"sftp\")` \"\"\" download_config : \"ResourceConfig\" def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdate : \"\"\"Initialize.\"\"\" return SessionUpdate () def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdateSFTP : \"\"\"Download via sftp\"\"\" cache = DataCache ( self . download_config . configuration ) if cache . config . accessKey and cache . config . accessKey in cache : key = cache . config . accessKey else : # Setup connection options cnopts = pysftp . CnOpts () cnopts . hostkeys = None if not self . download_config . downloadUrl : raise ValueError ( \"downloadUrl is not defined in configuration.\" ) # open connection and store data locally with pysftp . Connection ( host = self . download_config . downloadUrl . host , username = self . download_config . downloadUrl . user , password = self . download_config . downloadUrl . password , port = self . download_config . downloadUrl . port , cnopts = cnopts , ) as sftp : # Because of insane locking on Windows, we have to close # the downloaded file before adding it to the cache with NamedTemporaryFile ( prefix = \"oteapi-sftp-\" , delete = False ) as handle : localpath = Path ( handle . name ) . resolve () try : sftp . get ( self . download_config . downloadUrl . path , localpath = localpath ) key = cache . add ( localpath . read_bytes ()) finally : localpath . unlink () return SessionUpdateSFTP ( key = key ) get ( self , session = None ) \u00b6 Download via sftp Source code in oteapi/strategies/download/sftp.py def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdateSFTP : \"\"\"Download via sftp\"\"\" cache = DataCache ( self . download_config . configuration ) if cache . config . accessKey and cache . config . accessKey in cache : key = cache . config . accessKey else : # Setup connection options cnopts = pysftp . CnOpts () cnopts . hostkeys = None if not self . download_config . downloadUrl : raise ValueError ( \"downloadUrl is not defined in configuration.\" ) # open connection and store data locally with pysftp . Connection ( host = self . download_config . downloadUrl . host , username = self . download_config . downloadUrl . user , password = self . download_config . downloadUrl . password , port = self . download_config . downloadUrl . port , cnopts = cnopts , ) as sftp : # Because of insane locking on Windows, we have to close # the downloaded file before adding it to the cache with NamedTemporaryFile ( prefix = \"oteapi-sftp-\" , delete = False ) as handle : localpath = Path ( handle . name ) . resolve () try : sftp . get ( self . download_config . downloadUrl . path , localpath = localpath ) key = cache . add ( localpath . read_bytes ()) finally : localpath . unlink () return SessionUpdateSFTP ( key = key ) initialize ( self , session = None ) \u00b6 Initialize. Source code in oteapi/strategies/download/sftp.py def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdate : \"\"\"Initialize.\"\"\" return SessionUpdate () SessionUpdateSFTP ( SessionUpdate ) pydantic-model \u00b6 Class for returning values from Download SFTP strategy. Source code in oteapi/strategies/download/sftp.py class SessionUpdateSFTP ( SessionUpdate ): \"\"\"Class for returning values from Download SFTP strategy.\"\"\" key : str = Field ( ... , description = \"Key to access the data in the cache.\" ) key : str pydantic-field required \u00b6 Key to access the data in the cache.","title":"sftp"},{"location":"api_reference/strategies/download/sftp/#sftp","text":"Strategy class for sftp/ftp","title":"sftp"},{"location":"api_reference/strategies/download/sftp/#oteapi.strategies.download.sftp.SFTPStrategy","text":"Strategy for retrieving data via sftp. Registers strategies : (\"scheme\", \"ftp\") (\"scheme\", \"sftp\") Source code in oteapi/strategies/download/sftp.py @dataclass class SFTPStrategy : \"\"\"Strategy for retrieving data via sftp. **Registers strategies**: - `(\"scheme\", \"ftp\")` - `(\"scheme\", \"sftp\")` \"\"\" download_config : \"ResourceConfig\" def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdate : \"\"\"Initialize.\"\"\" return SessionUpdate () def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdateSFTP : \"\"\"Download via sftp\"\"\" cache = DataCache ( self . download_config . configuration ) if cache . config . accessKey and cache . config . accessKey in cache : key = cache . config . accessKey else : # Setup connection options cnopts = pysftp . CnOpts () cnopts . hostkeys = None if not self . download_config . downloadUrl : raise ValueError ( \"downloadUrl is not defined in configuration.\" ) # open connection and store data locally with pysftp . Connection ( host = self . download_config . downloadUrl . host , username = self . download_config . downloadUrl . user , password = self . download_config . downloadUrl . password , port = self . download_config . downloadUrl . port , cnopts = cnopts , ) as sftp : # Because of insane locking on Windows, we have to close # the downloaded file before adding it to the cache with NamedTemporaryFile ( prefix = \"oteapi-sftp-\" , delete = False ) as handle : localpath = Path ( handle . name ) . resolve () try : sftp . get ( self . download_config . downloadUrl . path , localpath = localpath ) key = cache . add ( localpath . read_bytes ()) finally : localpath . unlink () return SessionUpdateSFTP ( key = key )","title":"SFTPStrategy"},{"location":"api_reference/strategies/download/sftp/#oteapi.strategies.download.sftp.SFTPStrategy.get","text":"Download via sftp Source code in oteapi/strategies/download/sftp.py def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdateSFTP : \"\"\"Download via sftp\"\"\" cache = DataCache ( self . download_config . configuration ) if cache . config . accessKey and cache . config . accessKey in cache : key = cache . config . accessKey else : # Setup connection options cnopts = pysftp . CnOpts () cnopts . hostkeys = None if not self . download_config . downloadUrl : raise ValueError ( \"downloadUrl is not defined in configuration.\" ) # open connection and store data locally with pysftp . Connection ( host = self . download_config . downloadUrl . host , username = self . download_config . downloadUrl . user , password = self . download_config . downloadUrl . password , port = self . download_config . downloadUrl . port , cnopts = cnopts , ) as sftp : # Because of insane locking on Windows, we have to close # the downloaded file before adding it to the cache with NamedTemporaryFile ( prefix = \"oteapi-sftp-\" , delete = False ) as handle : localpath = Path ( handle . name ) . resolve () try : sftp . get ( self . download_config . downloadUrl . path , localpath = localpath ) key = cache . add ( localpath . read_bytes ()) finally : localpath . unlink () return SessionUpdateSFTP ( key = key )","title":"get()"},{"location":"api_reference/strategies/download/sftp/#oteapi.strategies.download.sftp.SFTPStrategy.initialize","text":"Initialize. Source code in oteapi/strategies/download/sftp.py def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdate : \"\"\"Initialize.\"\"\" return SessionUpdate ()","title":"initialize()"},{"location":"api_reference/strategies/download/sftp/#oteapi.strategies.download.sftp.SessionUpdateSFTP","text":"Class for returning values from Download SFTP strategy. Source code in oteapi/strategies/download/sftp.py class SessionUpdateSFTP ( SessionUpdate ): \"\"\"Class for returning values from Download SFTP strategy.\"\"\" key : str = Field ( ... , description = \"Key to access the data in the cache.\" )","title":"SessionUpdateSFTP"},{"location":"api_reference/strategies/download/sftp/#oteapi.strategies.download.sftp.SessionUpdateSFTP.key","text":"Key to access the data in the cache.","title":"key"},{"location":"api_reference/strategies/filter/crop_filter/","text":"crop_filter \u00b6 Demo-filter strategy CropFilter dataclass \u00b6 Strategy for cropping an image. Registers strategies : (\"filterType\", \"filter/crop\") Source code in oteapi/strategies/filter/crop_filter.py @dataclass class CropFilter : \"\"\"Strategy for cropping an image. **Registers strategies**: - `(\"filterType\", \"filter/crop\")` \"\"\" filter_config : \"FilterConfig\" def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdate : \"\"\"Initialize strategy and return a dictionary.\"\"\" return SessionUpdate () def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdateCrop : \"\"\"Execute strategy and return a dictionary\"\"\" cropData = ( SessionUpdateCrop ( ** self . filter_config . configuration ) if self . filter_config . configuration else SessionUpdateCrop () ) return cropData get ( self , session = None ) \u00b6 Execute strategy and return a dictionary Source code in oteapi/strategies/filter/crop_filter.py def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdateCrop : \"\"\"Execute strategy and return a dictionary\"\"\" cropData = ( SessionUpdateCrop ( ** self . filter_config . configuration ) if self . filter_config . configuration else SessionUpdateCrop () ) return cropData initialize ( self , session = None ) \u00b6 Initialize strategy and return a dictionary. Source code in oteapi/strategies/filter/crop_filter.py def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdate : \"\"\"Initialize strategy and return a dictionary.\"\"\" return SessionUpdate () SessionUpdateCrop ( SessionUpdate ) pydantic-model \u00b6 Class for returning values from crop data. Source code in oteapi/strategies/filter/crop_filter.py class SessionUpdateCrop ( SessionUpdate ): \"\"\"Class for returning values from crop data.\"\"\" crop : List [ int ] = Field ( ... , description = \"List of image cropping details.\" ) crop : List [ int ] pydantic-field required \u00b6 List of image cropping details.","title":"crop_filter"},{"location":"api_reference/strategies/filter/crop_filter/#crop_filter","text":"Demo-filter strategy","title":"crop_filter"},{"location":"api_reference/strategies/filter/crop_filter/#oteapi.strategies.filter.crop_filter.CropFilter","text":"Strategy for cropping an image. Registers strategies : (\"filterType\", \"filter/crop\") Source code in oteapi/strategies/filter/crop_filter.py @dataclass class CropFilter : \"\"\"Strategy for cropping an image. **Registers strategies**: - `(\"filterType\", \"filter/crop\")` \"\"\" filter_config : \"FilterConfig\" def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdate : \"\"\"Initialize strategy and return a dictionary.\"\"\" return SessionUpdate () def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdateCrop : \"\"\"Execute strategy and return a dictionary\"\"\" cropData = ( SessionUpdateCrop ( ** self . filter_config . configuration ) if self . filter_config . configuration else SessionUpdateCrop () ) return cropData","title":"CropFilter"},{"location":"api_reference/strategies/filter/crop_filter/#oteapi.strategies.filter.crop_filter.CropFilter.get","text":"Execute strategy and return a dictionary Source code in oteapi/strategies/filter/crop_filter.py def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdateCrop : \"\"\"Execute strategy and return a dictionary\"\"\" cropData = ( SessionUpdateCrop ( ** self . filter_config . configuration ) if self . filter_config . configuration else SessionUpdateCrop () ) return cropData","title":"get()"},{"location":"api_reference/strategies/filter/crop_filter/#oteapi.strategies.filter.crop_filter.CropFilter.initialize","text":"Initialize strategy and return a dictionary. Source code in oteapi/strategies/filter/crop_filter.py def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdate : \"\"\"Initialize strategy and return a dictionary.\"\"\" return SessionUpdate ()","title":"initialize()"},{"location":"api_reference/strategies/filter/crop_filter/#oteapi.strategies.filter.crop_filter.SessionUpdateCrop","text":"Class for returning values from crop data. Source code in oteapi/strategies/filter/crop_filter.py class SessionUpdateCrop ( SessionUpdate ): \"\"\"Class for returning values from crop data.\"\"\" crop : List [ int ] = Field ( ... , description = \"List of image cropping details.\" )","title":"SessionUpdateCrop"},{"location":"api_reference/strategies/filter/crop_filter/#oteapi.strategies.filter.crop_filter.SessionUpdateCrop.crop","text":"List of image cropping details.","title":"crop"},{"location":"api_reference/strategies/filter/sql_query_filter/","text":"sql_query_filter \u00b6 SQL query filter strategy. SQLQueryFilter dataclass \u00b6 Strategy for a SQL query filter. Registers strategies : (\"filterType\", \"filter/sql\") Source code in oteapi/strategies/filter/sql_query_filter.py @dataclass class SQLQueryFilter : \"\"\"Strategy for a SQL query filter. **Registers strategies**: - `(\"filterType\", \"filter/sql\")` \"\"\" filter_config : \"FilterConfig\" def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdateSqlQuery : \"\"\"Initialize strategy and return a dictionary\"\"\" return SessionUpdateSqlQuery ( ** { \"query\" : self . filter_config . query }) def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdate : \"\"\"Execute strategy and return a dictionary\"\"\" return SessionUpdate () get ( self , session = None ) \u00b6 Execute strategy and return a dictionary Source code in oteapi/strategies/filter/sql_query_filter.py def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdate : \"\"\"Execute strategy and return a dictionary\"\"\" return SessionUpdate () initialize ( self , session = None ) \u00b6 Initialize strategy and return a dictionary Source code in oteapi/strategies/filter/sql_query_filter.py def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdateSqlQuery : \"\"\"Initialize strategy and return a dictionary\"\"\" return SessionUpdateSqlQuery ( ** { \"query\" : self . filter_config . query }) SessionUpdateSqlQuery ( SessionUpdate ) pydantic-model \u00b6 Class for returning values from SQL Query data model. Source code in oteapi/strategies/filter/sql_query_filter.py class SessionUpdateSqlQuery ( SessionUpdate ): \"\"\"Class for returning values from SQL Query data model.\"\"\" query : str = Field ( ... , description = \"A SQL query string.\" ) query : str pydantic-field required \u00b6 A SQL query string.","title":"sql_query_filter"},{"location":"api_reference/strategies/filter/sql_query_filter/#sql_query_filter","text":"SQL query filter strategy.","title":"sql_query_filter"},{"location":"api_reference/strategies/filter/sql_query_filter/#oteapi.strategies.filter.sql_query_filter.SQLQueryFilter","text":"Strategy for a SQL query filter. Registers strategies : (\"filterType\", \"filter/sql\") Source code in oteapi/strategies/filter/sql_query_filter.py @dataclass class SQLQueryFilter : \"\"\"Strategy for a SQL query filter. **Registers strategies**: - `(\"filterType\", \"filter/sql\")` \"\"\" filter_config : \"FilterConfig\" def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdateSqlQuery : \"\"\"Initialize strategy and return a dictionary\"\"\" return SessionUpdateSqlQuery ( ** { \"query\" : self . filter_config . query }) def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdate : \"\"\"Execute strategy and return a dictionary\"\"\" return SessionUpdate ()","title":"SQLQueryFilter"},{"location":"api_reference/strategies/filter/sql_query_filter/#oteapi.strategies.filter.sql_query_filter.SQLQueryFilter.get","text":"Execute strategy and return a dictionary Source code in oteapi/strategies/filter/sql_query_filter.py def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdate : \"\"\"Execute strategy and return a dictionary\"\"\" return SessionUpdate ()","title":"get()"},{"location":"api_reference/strategies/filter/sql_query_filter/#oteapi.strategies.filter.sql_query_filter.SQLQueryFilter.initialize","text":"Initialize strategy and return a dictionary Source code in oteapi/strategies/filter/sql_query_filter.py def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdateSqlQuery : \"\"\"Initialize strategy and return a dictionary\"\"\" return SessionUpdateSqlQuery ( ** { \"query\" : self . filter_config . query })","title":"initialize()"},{"location":"api_reference/strategies/filter/sql_query_filter/#oteapi.strategies.filter.sql_query_filter.SessionUpdateSqlQuery","text":"Class for returning values from SQL Query data model. Source code in oteapi/strategies/filter/sql_query_filter.py class SessionUpdateSqlQuery ( SessionUpdate ): \"\"\"Class for returning values from SQL Query data model.\"\"\" query : str = Field ( ... , description = \"A SQL query string.\" )","title":"SessionUpdateSqlQuery"},{"location":"api_reference/strategies/filter/sql_query_filter/#oteapi.strategies.filter.sql_query_filter.SessionUpdateSqlQuery.query","text":"A SQL query string.","title":"query"},{"location":"api_reference/strategies/parse/application_json/","text":"application_json \u00b6 Strategy class for application/json. JSONDataParseStrategy dataclass \u00b6 Parse strategy for JSON. Registers strategies : (\"mediaType\", \"application/json\") Source code in oteapi/strategies/parse/application_json.py @dataclass class JSONDataParseStrategy : \"\"\"Parse strategy for JSON. **Registers strategies**: - `(\"mediaType\", \"application/json\")` \"\"\" parse_config : \"ResourceConfig\" def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdate : \"\"\"Initialize.\"\"\" return SessionUpdate () def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdateJSONParse : \"\"\"Parse json.\"\"\" downloader = create_strategy ( \"download\" , self . parse_config ) output = downloader . get () cache = DataCache ( self . parse_config . configuration ) content = cache . get ( output [ \"key\" ]) if isinstance ( content , dict ): return SessionUpdateJSONParse ( content = content ) return SessionUpdateJSONParse ( content = json . loads ( content )) get ( self , session = None ) \u00b6 Parse json. Source code in oteapi/strategies/parse/application_json.py def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdateJSONParse : \"\"\"Parse json.\"\"\" downloader = create_strategy ( \"download\" , self . parse_config ) output = downloader . get () cache = DataCache ( self . parse_config . configuration ) content = cache . get ( output [ \"key\" ]) if isinstance ( content , dict ): return SessionUpdateJSONParse ( content = content ) return SessionUpdateJSONParse ( content = json . loads ( content )) initialize ( self , session = None ) \u00b6 Initialize. Source code in oteapi/strategies/parse/application_json.py def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdate : \"\"\"Initialize.\"\"\" return SessionUpdate () SessionUpdateJSONParse ( SessionUpdate ) pydantic-model \u00b6 Class for returning values from JSON Parse. Source code in oteapi/strategies/parse/application_json.py class SessionUpdateJSONParse ( SessionUpdate ): \"\"\"Class for returning values from JSON Parse.\"\"\" content : dict = Field ( ... , description = \"Content of the JSON document.\" ) content : dict pydantic-field required \u00b6 Content of the JSON document.","title":"application_json"},{"location":"api_reference/strategies/parse/application_json/#application_json","text":"Strategy class for application/json.","title":"application_json"},{"location":"api_reference/strategies/parse/application_json/#oteapi.strategies.parse.application_json.JSONDataParseStrategy","text":"Parse strategy for JSON. Registers strategies : (\"mediaType\", \"application/json\") Source code in oteapi/strategies/parse/application_json.py @dataclass class JSONDataParseStrategy : \"\"\"Parse strategy for JSON. **Registers strategies**: - `(\"mediaType\", \"application/json\")` \"\"\" parse_config : \"ResourceConfig\" def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdate : \"\"\"Initialize.\"\"\" return SessionUpdate () def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdateJSONParse : \"\"\"Parse json.\"\"\" downloader = create_strategy ( \"download\" , self . parse_config ) output = downloader . get () cache = DataCache ( self . parse_config . configuration ) content = cache . get ( output [ \"key\" ]) if isinstance ( content , dict ): return SessionUpdateJSONParse ( content = content ) return SessionUpdateJSONParse ( content = json . loads ( content ))","title":"JSONDataParseStrategy"},{"location":"api_reference/strategies/parse/application_json/#oteapi.strategies.parse.application_json.JSONDataParseStrategy.get","text":"Parse json. Source code in oteapi/strategies/parse/application_json.py def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdateJSONParse : \"\"\"Parse json.\"\"\" downloader = create_strategy ( \"download\" , self . parse_config ) output = downloader . get () cache = DataCache ( self . parse_config . configuration ) content = cache . get ( output [ \"key\" ]) if isinstance ( content , dict ): return SessionUpdateJSONParse ( content = content ) return SessionUpdateJSONParse ( content = json . loads ( content ))","title":"get()"},{"location":"api_reference/strategies/parse/application_json/#oteapi.strategies.parse.application_json.JSONDataParseStrategy.initialize","text":"Initialize. Source code in oteapi/strategies/parse/application_json.py def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdate : \"\"\"Initialize.\"\"\" return SessionUpdate ()","title":"initialize()"},{"location":"api_reference/strategies/parse/application_json/#oteapi.strategies.parse.application_json.SessionUpdateJSONParse","text":"Class for returning values from JSON Parse. Source code in oteapi/strategies/parse/application_json.py class SessionUpdateJSONParse ( SessionUpdate ): \"\"\"Class for returning values from JSON Parse.\"\"\" content : dict = Field ( ... , description = \"Content of the JSON document.\" )","title":"SessionUpdateJSONParse"},{"location":"api_reference/strategies/parse/application_json/#oteapi.strategies.parse.application_json.SessionUpdateJSONParse.content","text":"Content of the JSON document.","title":"content"},{"location":"api_reference/strategies/parse/application_vnd_sqlite/","text":"application_vnd_sqlite \u00b6 Strategy class for application/vnd.sqlite3. SessionUpdateSqLiteParse ( SessionUpdate ) pydantic-model \u00b6 Configuration model for SqLiteParse. Source code in oteapi/strategies/parse/application_vnd_sqlite.py class SessionUpdateSqLiteParse ( SessionUpdate ): \"\"\"Configuration model for SqLiteParse.\"\"\" result : Optional [ list ] = Field ( None , description = \"List of results from the query.\" ) msg : str = Field ( ... , description = \"Messsage concerning the execution of the query.\" ) msg : str pydantic-field required \u00b6 Messsage concerning the execution of the query. result : list pydantic-field \u00b6 List of results from the query. SqliteParseStrategy dataclass \u00b6 Parse strategy for SQLite. Registers strategies : (\"mediaType\", \"application/vnd.sqlite3\") Source code in oteapi/strategies/parse/application_vnd_sqlite.py @dataclass class SqliteParseStrategy : \"\"\"Parse strategy for SQLite. **Registers strategies**: - `(\"mediaType\", \"application/vnd.sqlite3\")` \"\"\" parse_config : \"ResourceConfig\" def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdateSqLiteParse : \"\"\"Parse SQLite query responses.\"\"\" if session is None : raise ValueError ( \"Missing session\" ) if \"sqlquery\" in session : cn = create_connection ( session [ \"filename\" ]) cur = cn . cursor () rows = cur . execute ( session [ \"sqlquery\" ]) . fetchall () return SessionUpdateSqLiteParse ( result = rows , msg = \"Query executed\" ) return SessionUpdateSqLiteParse ( msg = \"No query given\" ) def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdate : \"\"\"Initialize.\"\"\" return SessionUpdate () get ( self , session = None ) \u00b6 Parse SQLite query responses. Source code in oteapi/strategies/parse/application_vnd_sqlite.py def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdateSqLiteParse : \"\"\"Parse SQLite query responses.\"\"\" if session is None : raise ValueError ( \"Missing session\" ) if \"sqlquery\" in session : cn = create_connection ( session [ \"filename\" ]) cur = cn . cursor () rows = cur . execute ( session [ \"sqlquery\" ]) . fetchall () return SessionUpdateSqLiteParse ( result = rows , msg = \"Query executed\" ) return SessionUpdateSqLiteParse ( msg = \"No query given\" ) initialize ( self , session = None ) \u00b6 Initialize. Source code in oteapi/strategies/parse/application_vnd_sqlite.py def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdate : \"\"\"Initialize.\"\"\" return SessionUpdate () create_connection ( db_file ) \u00b6 create a database connection to the SQLite database specified by db_file :param db_file: database file :return: Connection object or None Source code in oteapi/strategies/parse/application_vnd_sqlite.py def create_connection ( db_file ): \"\"\"create a database connection to the SQLite database specified by db_file :param db_file: database file :return: Connection object or None \"\"\" conn = None try : conn = sqlite3 . connect ( db_file ) return conn except sqlite3 . Error as exc : print ( exc ) return conn","title":"application_vnd_sqlite"},{"location":"api_reference/strategies/parse/application_vnd_sqlite/#application_vnd_sqlite","text":"Strategy class for application/vnd.sqlite3.","title":"application_vnd_sqlite"},{"location":"api_reference/strategies/parse/application_vnd_sqlite/#oteapi.strategies.parse.application_vnd_sqlite.SessionUpdateSqLiteParse","text":"Configuration model for SqLiteParse. Source code in oteapi/strategies/parse/application_vnd_sqlite.py class SessionUpdateSqLiteParse ( SessionUpdate ): \"\"\"Configuration model for SqLiteParse.\"\"\" result : Optional [ list ] = Field ( None , description = \"List of results from the query.\" ) msg : str = Field ( ... , description = \"Messsage concerning the execution of the query.\" )","title":"SessionUpdateSqLiteParse"},{"location":"api_reference/strategies/parse/application_vnd_sqlite/#oteapi.strategies.parse.application_vnd_sqlite.SessionUpdateSqLiteParse.msg","text":"Messsage concerning the execution of the query.","title":"msg"},{"location":"api_reference/strategies/parse/application_vnd_sqlite/#oteapi.strategies.parse.application_vnd_sqlite.SessionUpdateSqLiteParse.result","text":"List of results from the query.","title":"result"},{"location":"api_reference/strategies/parse/application_vnd_sqlite/#oteapi.strategies.parse.application_vnd_sqlite.SqliteParseStrategy","text":"Parse strategy for SQLite. Registers strategies : (\"mediaType\", \"application/vnd.sqlite3\") Source code in oteapi/strategies/parse/application_vnd_sqlite.py @dataclass class SqliteParseStrategy : \"\"\"Parse strategy for SQLite. **Registers strategies**: - `(\"mediaType\", \"application/vnd.sqlite3\")` \"\"\" parse_config : \"ResourceConfig\" def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdateSqLiteParse : \"\"\"Parse SQLite query responses.\"\"\" if session is None : raise ValueError ( \"Missing session\" ) if \"sqlquery\" in session : cn = create_connection ( session [ \"filename\" ]) cur = cn . cursor () rows = cur . execute ( session [ \"sqlquery\" ]) . fetchall () return SessionUpdateSqLiteParse ( result = rows , msg = \"Query executed\" ) return SessionUpdateSqLiteParse ( msg = \"No query given\" ) def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdate : \"\"\"Initialize.\"\"\" return SessionUpdate ()","title":"SqliteParseStrategy"},{"location":"api_reference/strategies/parse/application_vnd_sqlite/#oteapi.strategies.parse.application_vnd_sqlite.SqliteParseStrategy.get","text":"Parse SQLite query responses. Source code in oteapi/strategies/parse/application_vnd_sqlite.py def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdateSqLiteParse : \"\"\"Parse SQLite query responses.\"\"\" if session is None : raise ValueError ( \"Missing session\" ) if \"sqlquery\" in session : cn = create_connection ( session [ \"filename\" ]) cur = cn . cursor () rows = cur . execute ( session [ \"sqlquery\" ]) . fetchall () return SessionUpdateSqLiteParse ( result = rows , msg = \"Query executed\" ) return SessionUpdateSqLiteParse ( msg = \"No query given\" )","title":"get()"},{"location":"api_reference/strategies/parse/application_vnd_sqlite/#oteapi.strategies.parse.application_vnd_sqlite.SqliteParseStrategy.initialize","text":"Initialize. Source code in oteapi/strategies/parse/application_vnd_sqlite.py def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdate : \"\"\"Initialize.\"\"\" return SessionUpdate ()","title":"initialize()"},{"location":"api_reference/strategies/parse/application_vnd_sqlite/#oteapi.strategies.parse.application_vnd_sqlite.create_connection","text":"create a database connection to the SQLite database specified by db_file :param db_file: database file :return: Connection object or None Source code in oteapi/strategies/parse/application_vnd_sqlite.py def create_connection ( db_file ): \"\"\"create a database connection to the SQLite database specified by db_file :param db_file: database file :return: Connection object or None \"\"\" conn = None try : conn = sqlite3 . connect ( db_file ) return conn except sqlite3 . Error as exc : print ( exc ) return conn","title":"create_connection()"},{"location":"api_reference/strategies/parse/excel_xlsx/","text":"excel_xlsx \u00b6 Strategy class for workbook/xlsx. SessionUpdateXLSXParse ( SessionUpdate ) pydantic-model \u00b6 Class for returning values from XLSXParse. Source code in oteapi/strategies/parse/excel_xlsx.py class SessionUpdateXLSXParse ( SessionUpdate ): \"\"\"Class for returning values from XLSXParse.\"\"\" data : Dict [ str , list ] = Field ( ... , description = \"A dict with column-name/column-value pairs. The values are lists.\" , ) data : Dict [ str , list ] pydantic-field required \u00b6 A dict with column-name/column-value pairs. The values are lists. XLSXParseDataModel ( BaseModel ) pydantic-model \u00b6 Data model for retrieving a rectangular section of an Excel sheet. Source code in oteapi/strategies/parse/excel_xlsx.py class XLSXParseDataModel ( BaseModel ): \"\"\"Data model for retrieving a rectangular section of an Excel sheet.\"\"\" worksheet : str = Field ( ... , description = \"Name of worksheet to load.\" ) row_from : Optional [ int ] = Field ( None , description = \"Excel row number of first row. Defaults to first assigned row.\" , ) col_from : Optional [ Union [ int , str ]] = Field ( None , description = ( \"Excel column number or label of first column. Defaults to first assigned \" \"column.\" ), ) row_to : Optional [ int ] = Field ( None , description = \"Excel row number of last row. Defaults to last assigned row.\" ) col_to : Optional [ Union [ int , str ]] = Field ( None , description = ( \"Excel column number or label of last column. Defaults to last assigned \" \"column.\" ), ) header_row : Optional [ int ] = Field ( None , description = ( \"Row number with the headers. Defaults to `1` if header is given, \" \"otherwise `None`.\" ), ) header : Optional [ List [ str ]] = Field ( None , description = ( \"Optional list of column names, specifying the columns to return. \" \"These names they should match cells in `header_row`.\" ), ) new_header : Optional [ List [ str ]] = Field ( None , description = ( \"Optional list of new column names replacing `header` in the output.\" ), ) download_config : AttrDict = Field ( AttrDict (), description = \"Configurations provided to a download strategy.\" , ) col_from : Union [ int , str ] pydantic-field \u00b6 Excel column number or label of first column. Defaults to first assigned column. col_to : Union [ int , str ] pydantic-field \u00b6 Excel column number or label of last column. Defaults to last assigned column. download_config : AttrDict pydantic-field \u00b6 Configurations provided to a download strategy. header : List [ str ] pydantic-field \u00b6 Optional list of column names, specifying the columns to return. These names they should match cells in header_row . header_row : int pydantic-field \u00b6 Row number with the headers. Defaults to 1 if header is given, otherwise None . new_header : List [ str ] pydantic-field \u00b6 Optional list of new column names replacing header in the output. row_from : int pydantic-field \u00b6 Excel row number of first row. Defaults to first assigned row. row_to : int pydantic-field \u00b6 Excel row number of last row. Defaults to last assigned row. worksheet : str pydantic-field required \u00b6 Name of worksheet to load. XLSXParseStrategy dataclass \u00b6 Parse strategy for Excel XLSX files. Registers strategies : (\"mediaType\", \"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\") Source code in oteapi/strategies/parse/excel_xlsx.py @dataclass class XLSXParseStrategy : \"\"\"Parse strategy for Excel XLSX files. **Registers strategies**: - `(\"mediaType\", \"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\")` \"\"\" parse_config : \"ResourceConfig\" def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdate : \"\"\"Initialize.\"\"\" return SessionUpdate () def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdateXLSXParse : \"\"\"Parses selected region of an excel file. Returns: A dict with column-name/column-value pairs. The values are lists. \"\"\" model = XLSXParseDataModel ( ** self . parse_config . configuration ) download_config = self . parse_config . copy () download_config . configuration = model . download_config downloader = create_strategy ( \"download\" , download_config ) output = downloader . get () cache = DataCache ( self . parse_config . configuration ) with cache . getfile ( key = output [ \"key\" ], suffix = \".xlsx\" ) as filename : workbook = load_workbook ( filename = filename , read_only = True , data_only = True ) worksheet = workbook [ model . worksheet ] set_model_defaults ( model , worksheet ) columns = get_column_indices ( model , worksheet ) data = [] for row in worksheet . iter_rows ( min_row = model . row_from , max_row = model . row_to , min_col = min ( columns ), max_col = max ( columns ), ): data . append ([ row [ c - 1 ] . value for c in columns ]) if model . header_row : row = worksheet . iter_rows ( min_row = model . header_row , max_row = model . header_row , min_col = min ( columns ), max_col = max ( columns ), ) . __next__ () header = [ row [ c - 1 ] . value for c in columns ] else : header = None if model . new_header : nhead = len ( header ) if header else len ( data [ 0 ]) if data else 0 if len ( model . new_header ) != nhead : raise TypeError ( f \"length of `new_header` (= { len ( model . new_header ) } ) \" f \"doesn't match number of columns (= { len ( header ) if header else 0 } )\" ) if header : for i , val in enumerate ( model . new_header ): if val is not None : header [ i ] = val elif data : header = model . new_header if header is None : header = [ get_column_letter ( col + 1 ) for col in range ( len ( data ))] transposed = [ list ( datum ) for datum in zip ( * data )] return SessionUpdateXLSXParse ( data = { key : value for key , value in zip ( header , transposed )} ) get ( self , session = None ) \u00b6 Parses selected region of an excel file. Returns: Type Description SessionUpdateXLSXParse A dict with column-name/column-value pairs. The values are lists. Source code in oteapi/strategies/parse/excel_xlsx.py def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdateXLSXParse : \"\"\"Parses selected region of an excel file. Returns: A dict with column-name/column-value pairs. The values are lists. \"\"\" model = XLSXParseDataModel ( ** self . parse_config . configuration ) download_config = self . parse_config . copy () download_config . configuration = model . download_config downloader = create_strategy ( \"download\" , download_config ) output = downloader . get () cache = DataCache ( self . parse_config . configuration ) with cache . getfile ( key = output [ \"key\" ], suffix = \".xlsx\" ) as filename : workbook = load_workbook ( filename = filename , read_only = True , data_only = True ) worksheet = workbook [ model . worksheet ] set_model_defaults ( model , worksheet ) columns = get_column_indices ( model , worksheet ) data = [] for row in worksheet . iter_rows ( min_row = model . row_from , max_row = model . row_to , min_col = min ( columns ), max_col = max ( columns ), ): data . append ([ row [ c - 1 ] . value for c in columns ]) if model . header_row : row = worksheet . iter_rows ( min_row = model . header_row , max_row = model . header_row , min_col = min ( columns ), max_col = max ( columns ), ) . __next__ () header = [ row [ c - 1 ] . value for c in columns ] else : header = None if model . new_header : nhead = len ( header ) if header else len ( data [ 0 ]) if data else 0 if len ( model . new_header ) != nhead : raise TypeError ( f \"length of `new_header` (= { len ( model . new_header ) } ) \" f \"doesn't match number of columns (= { len ( header ) if header else 0 } )\" ) if header : for i , val in enumerate ( model . new_header ): if val is not None : header [ i ] = val elif data : header = model . new_header if header is None : header = [ get_column_letter ( col + 1 ) for col in range ( len ( data ))] transposed = [ list ( datum ) for datum in zip ( * data )] return SessionUpdateXLSXParse ( data = { key : value for key , value in zip ( header , transposed )} ) initialize ( self , session = None ) \u00b6 Initialize. Source code in oteapi/strategies/parse/excel_xlsx.py def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdate : \"\"\"Initialize.\"\"\" return SessionUpdate () get_column_indices ( model , worksheet ) \u00b6 Helper function returning a list of column indices. Parameters: Name Type Description Default model XLSXParseDataModel The parsed data model. required worksheet Worksheet Excel worksheet, from which the header values will be retrieved. required Returns: Type Description Iterable[int] A list of column indices. Source code in oteapi/strategies/parse/excel_xlsx.py def get_column_indices ( model : XLSXParseDataModel , worksheet : \"Worksheet\" ) -> \"Iterable[int]\" : \"\"\"Helper function returning a list of column indices. Parameters: model: The parsed data model. worksheet: Excel worksheet, from which the header values will be retrieved. Returns: A list of column indices. \"\"\" if not isinstance ( model . col_from , int ) or not isinstance ( model . col_to , int ): raise TypeError ( \"Expected `model.col_from` and `model.col_to` to be integers.\" ) if model . header : header_dict = { worksheet . cell ( model . header_row , col ) . value : col for col in range ( model . col_from , model . col_to + 1 ) } return [ header_dict [ h ] for h in model . header ] return range ( model . col_from , model . col_to + 1 ) set_model_defaults ( model , worksheet ) \u00b6 Update data model model with default values obtained from worksheet . Parameters: Name Type Description Default model XLSXParseDataModel The parsed data model. required worksheet Worksheet Excel worksheet, from which the default values will be obtained. required Source code in oteapi/strategies/parse/excel_xlsx.py def set_model_defaults ( model : XLSXParseDataModel , worksheet : \"Worksheet\" ) -> None : \"\"\"Update data model `model` with default values obtained from `worksheet`. Parameters: model: The parsed data model. worksheet: Excel worksheet, from which the default values will be obtained. \"\"\" if model . row_from is None : if model . header : # assume that data starts on the first row after the header model . row_from = model . header_row + 1 if model . header_row else 1 else : model . row_from = worksheet . min_row if model . row_to is None : model . row_to = worksheet . max_row if model . col_from is None : model . col_from = worksheet . min_column elif isinstance ( model . col_from , str ): model . col_from = column_index_from_string ( model . col_from ) if model . col_to is None : model . col_to = worksheet . max_column elif isinstance ( model . col_to , str ): model . col_to = column_index_from_string ( model . col_to ) if model . header and not model . header_row : model . header_row = 1","title":"excel_xlsx"},{"location":"api_reference/strategies/parse/excel_xlsx/#excel_xlsx","text":"Strategy class for workbook/xlsx.","title":"excel_xlsx"},{"location":"api_reference/strategies/parse/excel_xlsx/#oteapi.strategies.parse.excel_xlsx.SessionUpdateXLSXParse","text":"Class for returning values from XLSXParse. Source code in oteapi/strategies/parse/excel_xlsx.py class SessionUpdateXLSXParse ( SessionUpdate ): \"\"\"Class for returning values from XLSXParse.\"\"\" data : Dict [ str , list ] = Field ( ... , description = \"A dict with column-name/column-value pairs. The values are lists.\" , )","title":"SessionUpdateXLSXParse"},{"location":"api_reference/strategies/parse/excel_xlsx/#oteapi.strategies.parse.excel_xlsx.SessionUpdateXLSXParse.data","text":"A dict with column-name/column-value pairs. The values are lists.","title":"data"},{"location":"api_reference/strategies/parse/excel_xlsx/#oteapi.strategies.parse.excel_xlsx.XLSXParseDataModel","text":"Data model for retrieving a rectangular section of an Excel sheet. Source code in oteapi/strategies/parse/excel_xlsx.py class XLSXParseDataModel ( BaseModel ): \"\"\"Data model for retrieving a rectangular section of an Excel sheet.\"\"\" worksheet : str = Field ( ... , description = \"Name of worksheet to load.\" ) row_from : Optional [ int ] = Field ( None , description = \"Excel row number of first row. Defaults to first assigned row.\" , ) col_from : Optional [ Union [ int , str ]] = Field ( None , description = ( \"Excel column number or label of first column. Defaults to first assigned \" \"column.\" ), ) row_to : Optional [ int ] = Field ( None , description = \"Excel row number of last row. Defaults to last assigned row.\" ) col_to : Optional [ Union [ int , str ]] = Field ( None , description = ( \"Excel column number or label of last column. Defaults to last assigned \" \"column.\" ), ) header_row : Optional [ int ] = Field ( None , description = ( \"Row number with the headers. Defaults to `1` if header is given, \" \"otherwise `None`.\" ), ) header : Optional [ List [ str ]] = Field ( None , description = ( \"Optional list of column names, specifying the columns to return. \" \"These names they should match cells in `header_row`.\" ), ) new_header : Optional [ List [ str ]] = Field ( None , description = ( \"Optional list of new column names replacing `header` in the output.\" ), ) download_config : AttrDict = Field ( AttrDict (), description = \"Configurations provided to a download strategy.\" , )","title":"XLSXParseDataModel"},{"location":"api_reference/strategies/parse/excel_xlsx/#oteapi.strategies.parse.excel_xlsx.XLSXParseDataModel.col_from","text":"Excel column number or label of first column. Defaults to first assigned column.","title":"col_from"},{"location":"api_reference/strategies/parse/excel_xlsx/#oteapi.strategies.parse.excel_xlsx.XLSXParseDataModel.col_to","text":"Excel column number or label of last column. Defaults to last assigned column.","title":"col_to"},{"location":"api_reference/strategies/parse/excel_xlsx/#oteapi.strategies.parse.excel_xlsx.XLSXParseDataModel.download_config","text":"Configurations provided to a download strategy.","title":"download_config"},{"location":"api_reference/strategies/parse/excel_xlsx/#oteapi.strategies.parse.excel_xlsx.XLSXParseDataModel.header","text":"Optional list of column names, specifying the columns to return. These names they should match cells in header_row .","title":"header"},{"location":"api_reference/strategies/parse/excel_xlsx/#oteapi.strategies.parse.excel_xlsx.XLSXParseDataModel.header_row","text":"Row number with the headers. Defaults to 1 if header is given, otherwise None .","title":"header_row"},{"location":"api_reference/strategies/parse/excel_xlsx/#oteapi.strategies.parse.excel_xlsx.XLSXParseDataModel.new_header","text":"Optional list of new column names replacing header in the output.","title":"new_header"},{"location":"api_reference/strategies/parse/excel_xlsx/#oteapi.strategies.parse.excel_xlsx.XLSXParseDataModel.row_from","text":"Excel row number of first row. Defaults to first assigned row.","title":"row_from"},{"location":"api_reference/strategies/parse/excel_xlsx/#oteapi.strategies.parse.excel_xlsx.XLSXParseDataModel.row_to","text":"Excel row number of last row. Defaults to last assigned row.","title":"row_to"},{"location":"api_reference/strategies/parse/excel_xlsx/#oteapi.strategies.parse.excel_xlsx.XLSXParseDataModel.worksheet","text":"Name of worksheet to load.","title":"worksheet"},{"location":"api_reference/strategies/parse/excel_xlsx/#oteapi.strategies.parse.excel_xlsx.XLSXParseStrategy","text":"Parse strategy for Excel XLSX files. Registers strategies : (\"mediaType\", \"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\") Source code in oteapi/strategies/parse/excel_xlsx.py @dataclass class XLSXParseStrategy : \"\"\"Parse strategy for Excel XLSX files. **Registers strategies**: - `(\"mediaType\", \"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\")` \"\"\" parse_config : \"ResourceConfig\" def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdate : \"\"\"Initialize.\"\"\" return SessionUpdate () def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdateXLSXParse : \"\"\"Parses selected region of an excel file. Returns: A dict with column-name/column-value pairs. The values are lists. \"\"\" model = XLSXParseDataModel ( ** self . parse_config . configuration ) download_config = self . parse_config . copy () download_config . configuration = model . download_config downloader = create_strategy ( \"download\" , download_config ) output = downloader . get () cache = DataCache ( self . parse_config . configuration ) with cache . getfile ( key = output [ \"key\" ], suffix = \".xlsx\" ) as filename : workbook = load_workbook ( filename = filename , read_only = True , data_only = True ) worksheet = workbook [ model . worksheet ] set_model_defaults ( model , worksheet ) columns = get_column_indices ( model , worksheet ) data = [] for row in worksheet . iter_rows ( min_row = model . row_from , max_row = model . row_to , min_col = min ( columns ), max_col = max ( columns ), ): data . append ([ row [ c - 1 ] . value for c in columns ]) if model . header_row : row = worksheet . iter_rows ( min_row = model . header_row , max_row = model . header_row , min_col = min ( columns ), max_col = max ( columns ), ) . __next__ () header = [ row [ c - 1 ] . value for c in columns ] else : header = None if model . new_header : nhead = len ( header ) if header else len ( data [ 0 ]) if data else 0 if len ( model . new_header ) != nhead : raise TypeError ( f \"length of `new_header` (= { len ( model . new_header ) } ) \" f \"doesn't match number of columns (= { len ( header ) if header else 0 } )\" ) if header : for i , val in enumerate ( model . new_header ): if val is not None : header [ i ] = val elif data : header = model . new_header if header is None : header = [ get_column_letter ( col + 1 ) for col in range ( len ( data ))] transposed = [ list ( datum ) for datum in zip ( * data )] return SessionUpdateXLSXParse ( data = { key : value for key , value in zip ( header , transposed )} )","title":"XLSXParseStrategy"},{"location":"api_reference/strategies/parse/excel_xlsx/#oteapi.strategies.parse.excel_xlsx.XLSXParseStrategy.get","text":"Parses selected region of an excel file. Returns: Type Description SessionUpdateXLSXParse A dict with column-name/column-value pairs. The values are lists. Source code in oteapi/strategies/parse/excel_xlsx.py def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdateXLSXParse : \"\"\"Parses selected region of an excel file. Returns: A dict with column-name/column-value pairs. The values are lists. \"\"\" model = XLSXParseDataModel ( ** self . parse_config . configuration ) download_config = self . parse_config . copy () download_config . configuration = model . download_config downloader = create_strategy ( \"download\" , download_config ) output = downloader . get () cache = DataCache ( self . parse_config . configuration ) with cache . getfile ( key = output [ \"key\" ], suffix = \".xlsx\" ) as filename : workbook = load_workbook ( filename = filename , read_only = True , data_only = True ) worksheet = workbook [ model . worksheet ] set_model_defaults ( model , worksheet ) columns = get_column_indices ( model , worksheet ) data = [] for row in worksheet . iter_rows ( min_row = model . row_from , max_row = model . row_to , min_col = min ( columns ), max_col = max ( columns ), ): data . append ([ row [ c - 1 ] . value for c in columns ]) if model . header_row : row = worksheet . iter_rows ( min_row = model . header_row , max_row = model . header_row , min_col = min ( columns ), max_col = max ( columns ), ) . __next__ () header = [ row [ c - 1 ] . value for c in columns ] else : header = None if model . new_header : nhead = len ( header ) if header else len ( data [ 0 ]) if data else 0 if len ( model . new_header ) != nhead : raise TypeError ( f \"length of `new_header` (= { len ( model . new_header ) } ) \" f \"doesn't match number of columns (= { len ( header ) if header else 0 } )\" ) if header : for i , val in enumerate ( model . new_header ): if val is not None : header [ i ] = val elif data : header = model . new_header if header is None : header = [ get_column_letter ( col + 1 ) for col in range ( len ( data ))] transposed = [ list ( datum ) for datum in zip ( * data )] return SessionUpdateXLSXParse ( data = { key : value for key , value in zip ( header , transposed )} )","title":"get()"},{"location":"api_reference/strategies/parse/excel_xlsx/#oteapi.strategies.parse.excel_xlsx.XLSXParseStrategy.initialize","text":"Initialize. Source code in oteapi/strategies/parse/excel_xlsx.py def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdate : \"\"\"Initialize.\"\"\" return SessionUpdate ()","title":"initialize()"},{"location":"api_reference/strategies/parse/excel_xlsx/#oteapi.strategies.parse.excel_xlsx.get_column_indices","text":"Helper function returning a list of column indices. Parameters: Name Type Description Default model XLSXParseDataModel The parsed data model. required worksheet Worksheet Excel worksheet, from which the header values will be retrieved. required Returns: Type Description Iterable[int] A list of column indices. Source code in oteapi/strategies/parse/excel_xlsx.py def get_column_indices ( model : XLSXParseDataModel , worksheet : \"Worksheet\" ) -> \"Iterable[int]\" : \"\"\"Helper function returning a list of column indices. Parameters: model: The parsed data model. worksheet: Excel worksheet, from which the header values will be retrieved. Returns: A list of column indices. \"\"\" if not isinstance ( model . col_from , int ) or not isinstance ( model . col_to , int ): raise TypeError ( \"Expected `model.col_from` and `model.col_to` to be integers.\" ) if model . header : header_dict = { worksheet . cell ( model . header_row , col ) . value : col for col in range ( model . col_from , model . col_to + 1 ) } return [ header_dict [ h ] for h in model . header ] return range ( model . col_from , model . col_to + 1 )","title":"get_column_indices()"},{"location":"api_reference/strategies/parse/excel_xlsx/#oteapi.strategies.parse.excel_xlsx.set_model_defaults","text":"Update data model model with default values obtained from worksheet . Parameters: Name Type Description Default model XLSXParseDataModel The parsed data model. required worksheet Worksheet Excel worksheet, from which the default values will be obtained. required Source code in oteapi/strategies/parse/excel_xlsx.py def set_model_defaults ( model : XLSXParseDataModel , worksheet : \"Worksheet\" ) -> None : \"\"\"Update data model `model` with default values obtained from `worksheet`. Parameters: model: The parsed data model. worksheet: Excel worksheet, from which the default values will be obtained. \"\"\" if model . row_from is None : if model . header : # assume that data starts on the first row after the header model . row_from = model . header_row + 1 if model . header_row else 1 else : model . row_from = worksheet . min_row if model . row_to is None : model . row_to = worksheet . max_row if model . col_from is None : model . col_from = worksheet . min_column elif isinstance ( model . col_from , str ): model . col_from = column_index_from_string ( model . col_from ) if model . col_to is None : model . col_to = worksheet . max_column elif isinstance ( model . col_to , str ): model . col_to = column_index_from_string ( model . col_to ) if model . header and not model . header_row : model . header_row = 1","title":"set_model_defaults()"},{"location":"api_reference/strategies/parse/image/","text":"image \u00b6 Strategy class for image/jpg. ImageDataParseStrategy dataclass \u00b6 Parse strategy for images. Registers strategies : (\"mediaType\", \"image/jpg\") (\"mediaType\", \"image/jpeg\") (\"mediaType\", \"image/jp2\") (\"mediaType\", \"image/png\") (\"mediaType\", \"image/gif\") (\"mediaType\", \"image/tiff\") (\"mediaType\", \"image/eps\") Source code in oteapi/strategies/parse/image.py @dataclass class ImageDataParseStrategy : \"\"\"Parse strategy for images. **Registers strategies**: - `(\"mediaType\", \"image/jpg\")` - `(\"mediaType\", \"image/jpeg\")` - `(\"mediaType\", \"image/jp2\")` - `(\"mediaType\", \"image/png\")` - `(\"mediaType\", \"image/gif\")` - `(\"mediaType\", \"image/tiff\")` - `(\"mediaType\", \"image/eps\")` \"\"\" parse_config : \"ResourceConfig\" def __post_init__ ( self ): self . localpath = \"/ote-data\" self . filename = self . parse_config . configuration [ \"filename\" ] self . conf = self . parse_config . configuration if \"localpath\" in self . conf : self . localpath = self . conf [ \"localpath\" ] def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdate : \"\"\"Initialize.\"\"\" return SessionUpdate () def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdateImageParse : if session is not None : self . conf . update ( session ) parsedOutput = {} if \"crop\" in self . conf : print ( \"cropping!\" ) im = Image . open ( f \" { self . localpath } / { self . filename } \" ) crop = self . conf [ \"crop\" ] im_cropped = im . crop ( tuple ( crop )) cropped_filename = f \" { self . localpath } /cropped_ { self . filename } \" im_cropped . save ( cropped_filename ) parsedOutput [ \"cropped_filename\" ] = cropped_filename parsedOutput [ \"parseImage\" ] = \"Done\" return SessionUpdateImageParse ( parsedOutput = parsedOutput ) initialize ( self , session = None ) \u00b6 Initialize. Source code in oteapi/strategies/parse/image.py def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdate : \"\"\"Initialize.\"\"\" return SessionUpdate () SessionUpdateImageParse ( SessionUpdate ) pydantic-model \u00b6 Configuration model for ImageParse. Source code in oteapi/strategies/parse/image.py class SessionUpdateImageParse ( SessionUpdate ): \"\"\"Configuration model for ImageParse.\"\"\" parsedOutput : Dict [ str , str ] = Field ( ... , description = \"Parsed output from ImageParse.\" ) parsedOutput : Dict [ str , str ] pydantic-field required \u00b6 Parsed output from ImageParse.","title":"image"},{"location":"api_reference/strategies/parse/image/#image","text":"Strategy class for image/jpg.","title":"image"},{"location":"api_reference/strategies/parse/image/#oteapi.strategies.parse.image.ImageDataParseStrategy","text":"Parse strategy for images. Registers strategies : (\"mediaType\", \"image/jpg\") (\"mediaType\", \"image/jpeg\") (\"mediaType\", \"image/jp2\") (\"mediaType\", \"image/png\") (\"mediaType\", \"image/gif\") (\"mediaType\", \"image/tiff\") (\"mediaType\", \"image/eps\") Source code in oteapi/strategies/parse/image.py @dataclass class ImageDataParseStrategy : \"\"\"Parse strategy for images. **Registers strategies**: - `(\"mediaType\", \"image/jpg\")` - `(\"mediaType\", \"image/jpeg\")` - `(\"mediaType\", \"image/jp2\")` - `(\"mediaType\", \"image/png\")` - `(\"mediaType\", \"image/gif\")` - `(\"mediaType\", \"image/tiff\")` - `(\"mediaType\", \"image/eps\")` \"\"\" parse_config : \"ResourceConfig\" def __post_init__ ( self ): self . localpath = \"/ote-data\" self . filename = self . parse_config . configuration [ \"filename\" ] self . conf = self . parse_config . configuration if \"localpath\" in self . conf : self . localpath = self . conf [ \"localpath\" ] def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdate : \"\"\"Initialize.\"\"\" return SessionUpdate () def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdateImageParse : if session is not None : self . conf . update ( session ) parsedOutput = {} if \"crop\" in self . conf : print ( \"cropping!\" ) im = Image . open ( f \" { self . localpath } / { self . filename } \" ) crop = self . conf [ \"crop\" ] im_cropped = im . crop ( tuple ( crop )) cropped_filename = f \" { self . localpath } /cropped_ { self . filename } \" im_cropped . save ( cropped_filename ) parsedOutput [ \"cropped_filename\" ] = cropped_filename parsedOutput [ \"parseImage\" ] = \"Done\" return SessionUpdateImageParse ( parsedOutput = parsedOutput )","title":"ImageDataParseStrategy"},{"location":"api_reference/strategies/parse/image/#oteapi.strategies.parse.image.ImageDataParseStrategy.initialize","text":"Initialize. Source code in oteapi/strategies/parse/image.py def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdate : \"\"\"Initialize.\"\"\" return SessionUpdate ()","title":"initialize()"},{"location":"api_reference/strategies/parse/image/#oteapi.strategies.parse.image.SessionUpdateImageParse","text":"Configuration model for ImageParse. Source code in oteapi/strategies/parse/image.py class SessionUpdateImageParse ( SessionUpdate ): \"\"\"Configuration model for ImageParse.\"\"\" parsedOutput : Dict [ str , str ] = Field ( ... , description = \"Parsed output from ImageParse.\" )","title":"SessionUpdateImageParse"},{"location":"api_reference/strategies/parse/image/#oteapi.strategies.parse.image.SessionUpdateImageParse.parsedOutput","text":"Parsed output from ImageParse.","title":"parsedOutput"},{"location":"api_reference/strategies/parse/text_csv/","text":"text_csv \u00b6 Strategy class for text/csv. CSVParseStrategy dataclass \u00b6 Parse strategy for CSV files. Registers strategies : (\"mediaType\", \"text/csv\") Source code in oteapi/strategies/parse/text_csv.py @dataclass class CSVParseStrategy : \"\"\"Parse strategy for CSV files. **Registers strategies**: - `(\"mediaType\", \"text/csv\")` \"\"\" parse_config : \"ResourceConfig\" def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdate : \"\"\"Parse CSV.\"\"\" return SessionUpdate () def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdate : \"\"\"Initialize.\"\"\" return SessionUpdate () get ( self , session = None ) \u00b6 Parse CSV. Source code in oteapi/strategies/parse/text_csv.py def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdate : \"\"\"Parse CSV.\"\"\" return SessionUpdate () initialize ( self , session = None ) \u00b6 Initialize. Source code in oteapi/strategies/parse/text_csv.py def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdate : \"\"\"Initialize.\"\"\" return SessionUpdate ()","title":"text_csv"},{"location":"api_reference/strategies/parse/text_csv/#text_csv","text":"Strategy class for text/csv.","title":"text_csv"},{"location":"api_reference/strategies/parse/text_csv/#oteapi.strategies.parse.text_csv.CSVParseStrategy","text":"Parse strategy for CSV files. Registers strategies : (\"mediaType\", \"text/csv\") Source code in oteapi/strategies/parse/text_csv.py @dataclass class CSVParseStrategy : \"\"\"Parse strategy for CSV files. **Registers strategies**: - `(\"mediaType\", \"text/csv\")` \"\"\" parse_config : \"ResourceConfig\" def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdate : \"\"\"Parse CSV.\"\"\" return SessionUpdate () def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdate : \"\"\"Initialize.\"\"\" return SessionUpdate ()","title":"CSVParseStrategy"},{"location":"api_reference/strategies/parse/text_csv/#oteapi.strategies.parse.text_csv.CSVParseStrategy.get","text":"Parse CSV. Source code in oteapi/strategies/parse/text_csv.py def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdate : \"\"\"Parse CSV.\"\"\" return SessionUpdate ()","title":"get()"},{"location":"api_reference/strategies/parse/text_csv/#oteapi.strategies.parse.text_csv.CSVParseStrategy.initialize","text":"Initialize. Source code in oteapi/strategies/parse/text_csv.py def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdate : \"\"\"Initialize.\"\"\" return SessionUpdate ()","title":"initialize()"},{"location":"api_reference/strategies/transformation/celery_remote/","text":"celery_remote \u00b6 Transformation Plugin that uses the Celery framework to call remote workers. CeleryConfig ( BaseModel ) pydantic-model \u00b6 Celery configuration. Source code in oteapi/strategies/transformation/celery_remote.py class CeleryConfig ( BaseModel ): \"\"\"Celery configuration.\"\"\" task_name : str = Field ( ... , description = \"A task name.\" ) args : list = Field ( ... , description = \"List of arguments for the task.\" ) args : list pydantic-field required \u00b6 List of arguments for the task. task_name : str pydantic-field required \u00b6 A task name. CeleryRemoteStrategy dataclass \u00b6 Submit job to remote Celery runner. Registers strategies : (\"transformationType\", \"celery/remote\") Source code in oteapi/strategies/transformation/celery_remote.py @dataclass class CeleryRemoteStrategy : \"\"\"Submit job to remote Celery runner. **Registers strategies**: - `(\"transformationType\", \"celery/remote\")` \"\"\" transformation_config : \"TransformationConfig\" def run ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> TransformationStatus : \"\"\"Run a job, return a job ID.\"\"\" config = self . transformation_config . configuration celery_config = CeleryConfig () if config is None else CeleryConfig ( ** config ) result : \"Union[AsyncResult, Any]\" = app . send_task ( celery_config . task_name , celery_config . args , kwargs = session ) status = AsyncResult ( id = result . task_id , app = app ) return TransformationStatus ( id = result . task_id , status = status . status ) def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdate : \"\"\"Initialize a job.\"\"\" return SessionUpdate () def status ( self , task_id : str ) -> TransformationStatus : \"\"\"Get job status.\"\"\" result = AsyncResult ( id = task_id , app = app ) return TransformationStatus ( id = task_id , status = result . state ) def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"SessionUpdateCelery\" : \"\"\"Get transformation.\"\"\" # TODO: update and return global state # pylint: disable=fixme return SessionUpdateCelery ( data = {}) get ( self , session = None ) \u00b6 Get transformation. Source code in oteapi/strategies/transformation/celery_remote.py def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"SessionUpdateCelery\" : \"\"\"Get transformation.\"\"\" # TODO: update and return global state # pylint: disable=fixme return SessionUpdateCelery ( data = {}) initialize ( self , session = None ) \u00b6 Initialize a job. Source code in oteapi/strategies/transformation/celery_remote.py def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdate : \"\"\"Initialize a job.\"\"\" return SessionUpdate () run ( self , session = None ) \u00b6 Run a job, return a job ID. Source code in oteapi/strategies/transformation/celery_remote.py def run ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> TransformationStatus : \"\"\"Run a job, return a job ID.\"\"\" config = self . transformation_config . configuration celery_config = CeleryConfig () if config is None else CeleryConfig ( ** config ) result : \"Union[AsyncResult, Any]\" = app . send_task ( celery_config . task_name , celery_config . args , kwargs = session ) status = AsyncResult ( id = result . task_id , app = app ) return TransformationStatus ( id = result . task_id , status = status . status ) status ( self , task_id ) \u00b6 Get job status. Source code in oteapi/strategies/transformation/celery_remote.py def status ( self , task_id : str ) -> TransformationStatus : \"\"\"Get job status.\"\"\" result = AsyncResult ( id = task_id , app = app ) return TransformationStatus ( id = task_id , status = result . state ) SessionUpdateCelery ( SessionUpdate ) pydantic-model \u00b6 Class for returning values from XLSXParse. Source code in oteapi/strategies/transformation/celery_remote.py class SessionUpdateCelery ( SessionUpdate ): \"\"\"Class for returning values from XLSXParse.\"\"\" data : Dict [ str , list ] = Field ( ... , description = \"A dict with column-name/column-value pairs. The values are lists.\" , ) data : Dict [ str , list ] pydantic-field required \u00b6 A dict with column-name/column-value pairs. The values are lists.","title":"celery_remote"},{"location":"api_reference/strategies/transformation/celery_remote/#celery_remote","text":"Transformation Plugin that uses the Celery framework to call remote workers.","title":"celery_remote"},{"location":"api_reference/strategies/transformation/celery_remote/#oteapi.strategies.transformation.celery_remote.CeleryConfig","text":"Celery configuration. Source code in oteapi/strategies/transformation/celery_remote.py class CeleryConfig ( BaseModel ): \"\"\"Celery configuration.\"\"\" task_name : str = Field ( ... , description = \"A task name.\" ) args : list = Field ( ... , description = \"List of arguments for the task.\" )","title":"CeleryConfig"},{"location":"api_reference/strategies/transformation/celery_remote/#oteapi.strategies.transformation.celery_remote.CeleryConfig.args","text":"List of arguments for the task.","title":"args"},{"location":"api_reference/strategies/transformation/celery_remote/#oteapi.strategies.transformation.celery_remote.CeleryConfig.task_name","text":"A task name.","title":"task_name"},{"location":"api_reference/strategies/transformation/celery_remote/#oteapi.strategies.transformation.celery_remote.CeleryRemoteStrategy","text":"Submit job to remote Celery runner. Registers strategies : (\"transformationType\", \"celery/remote\") Source code in oteapi/strategies/transformation/celery_remote.py @dataclass class CeleryRemoteStrategy : \"\"\"Submit job to remote Celery runner. **Registers strategies**: - `(\"transformationType\", \"celery/remote\")` \"\"\" transformation_config : \"TransformationConfig\" def run ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> TransformationStatus : \"\"\"Run a job, return a job ID.\"\"\" config = self . transformation_config . configuration celery_config = CeleryConfig () if config is None else CeleryConfig ( ** config ) result : \"Union[AsyncResult, Any]\" = app . send_task ( celery_config . task_name , celery_config . args , kwargs = session ) status = AsyncResult ( id = result . task_id , app = app ) return TransformationStatus ( id = result . task_id , status = status . status ) def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdate : \"\"\"Initialize a job.\"\"\" return SessionUpdate () def status ( self , task_id : str ) -> TransformationStatus : \"\"\"Get job status.\"\"\" result = AsyncResult ( id = task_id , app = app ) return TransformationStatus ( id = task_id , status = result . state ) def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"SessionUpdateCelery\" : \"\"\"Get transformation.\"\"\" # TODO: update and return global state # pylint: disable=fixme return SessionUpdateCelery ( data = {})","title":"CeleryRemoteStrategy"},{"location":"api_reference/strategies/transformation/celery_remote/#oteapi.strategies.transformation.celery_remote.CeleryRemoteStrategy.get","text":"Get transformation. Source code in oteapi/strategies/transformation/celery_remote.py def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"SessionUpdateCelery\" : \"\"\"Get transformation.\"\"\" # TODO: update and return global state # pylint: disable=fixme return SessionUpdateCelery ( data = {})","title":"get()"},{"location":"api_reference/strategies/transformation/celery_remote/#oteapi.strategies.transformation.celery_remote.CeleryRemoteStrategy.initialize","text":"Initialize a job. Source code in oteapi/strategies/transformation/celery_remote.py def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> SessionUpdate : \"\"\"Initialize a job.\"\"\" return SessionUpdate ()","title":"initialize()"},{"location":"api_reference/strategies/transformation/celery_remote/#oteapi.strategies.transformation.celery_remote.CeleryRemoteStrategy.run","text":"Run a job, return a job ID. Source code in oteapi/strategies/transformation/celery_remote.py def run ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> TransformationStatus : \"\"\"Run a job, return a job ID.\"\"\" config = self . transformation_config . configuration celery_config = CeleryConfig () if config is None else CeleryConfig ( ** config ) result : \"Union[AsyncResult, Any]\" = app . send_task ( celery_config . task_name , celery_config . args , kwargs = session ) status = AsyncResult ( id = result . task_id , app = app ) return TransformationStatus ( id = result . task_id , status = status . status )","title":"run()"},{"location":"api_reference/strategies/transformation/celery_remote/#oteapi.strategies.transformation.celery_remote.CeleryRemoteStrategy.status","text":"Get job status. Source code in oteapi/strategies/transformation/celery_remote.py def status ( self , task_id : str ) -> TransformationStatus : \"\"\"Get job status.\"\"\" result = AsyncResult ( id = task_id , app = app ) return TransformationStatus ( id = task_id , status = result . state )","title":"status()"},{"location":"api_reference/strategies/transformation/celery_remote/#oteapi.strategies.transformation.celery_remote.SessionUpdateCelery","text":"Class for returning values from XLSXParse. Source code in oteapi/strategies/transformation/celery_remote.py class SessionUpdateCelery ( SessionUpdate ): \"\"\"Class for returning values from XLSXParse.\"\"\" data : Dict [ str , list ] = Field ( ... , description = \"A dict with column-name/column-value pairs. The values are lists.\" , )","title":"SessionUpdateCelery"},{"location":"api_reference/strategies/transformation/celery_remote/#oteapi.strategies.transformation.celery_remote.SessionUpdateCelery.data","text":"A dict with column-name/column-value pairs. The values are lists.","title":"data"}]}