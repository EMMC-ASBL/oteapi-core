{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Open Translation Environment (OTE) API Core \u00b6 Framework for accessing data resources, mapping data models, describing the data to ontologies and perform data transformations We highly recommend reading this page in the official documentation . About OTEAPI Core \u00b6 OTEAPI Core provides the core functionality of OTEAPI, which stands for the Open Translation Environment API . It uses the strategy software design pattern to implement a simple and easy to extend access to a large range of data resources. Semantic interoperability is supported via mapping of data models describing the data to ontologies. Transformations, mainly intended to transform data between representations, are also supported, but transformations can also be used for running simulations in a simple workflow. OTEAPI Core includes: A set of standard strategies; A plugin system for loading the standard strategies, as well as third party strategies; Data models for configuring the strategies; A Python library, through which the data can be accessed; and An efficient data cache module that avoids downloading the same content several times. Types of strategies \u00b6 Download strategy \u00b6 Download strategy patterns use a given protocol to download content into the data cache. They are configured with the ResourceConfig data model, using the scheme of the downloadUrl field for strategy selection. The configuration field can be used to configure how the downloaded content is stored in the cache using the DownloadConfig data model. Standard downloaded strategies: file , https , http , sftp , ftp Parse strategy \u00b6 Parse strategy patterns convert content from the data cache to a Python dict. Like download strategies, they are configured with the ResourceConfig data model, using the mediaType field for strategy selection. Additional strategy-specific configurations can be provided via the configuration field. Standard parse strategies: text_csv , text_json , image_jpeg , excel_xlsx Resource strategy \u00b6 Resource strategy patterns can retrieve/upload data to external data services. They are configured with the ResourceConfig data model, using the scheme of the accessUrl and accessService fields. The scheme of the accessUrl is used for strategy selection. Mapping strategy \u00b6 Strategies for mapping fields/properties in data models to ontological concepts. Filter strategy \u00b6 Filter strategies can update the configuration of other strategies. They can also update values in the data cache. Transformation strategy \u00b6 Transformation strategies are a special form of a filter strategy intended for long-running transformations. Entry points for plugins \u00b6 Suggestion: Use setuptools entry points to load plugins. The entry point groups could be named as something like this: \"oteapi.download_strategy\" , \"oteapi.filter_strategy\" \"oteapi.download\" , \"oteapi.filter\" \"oteapi.interfaces.download\" , \"oteapi.interfaces.filter\" The value for an entrypoint should then be: setup ( # ..., entry_points = { \"oteapi.download_strategy\" : [ \"my_plugin.p2p = my_plugin.strategies.download.peer_2_peer\" , \"my_plugin.mongo = my_plugin.strategies.download.mongo_get\" , ], }, ) or as part of a YAML/JSON/setup.cfg setup files as such: entry_points : oteapi.download_strategy : - \"my_plugin.p2p = my_plugin.strategies.download.peer_2_peer\" - \"my_plugin.mongo = my_plugin.strategies.download.mongo_get\" { \"entry_points\" : { \"oteapi.download_strategy\" : [ \"my_plugin.p2p = my_plugin.strategies.download.peer_2_peer\" , \"my_plugin.mongo = my_plugin.strategies.download.mongo_get\" ] } } [options.entry_points] oteapi.download_strategy = my_plugin.p2p = my_plugin.strategies.download.peer_2_peer my_plugin.mongo = my_plugin.strategies.download.mongo_get The plugins will then automagically load all installed strategy module plugins, registering the strategies according to the StrategyFactory decorator. Other OTEAPI-related repositories \u00b6 OTEAPI Services - a RESTful interface to OTEAPI Core OTELib - a Python interface to OTEAPI Services OTEAPI Plugin Template - a cookiecutter template for OTEAPI Plugins Installation \u00b6 OTEAPI Core can be installed with: $ pip install oteapi-core License \u00b6 OTEAPI Core is released under the MIT license with copyright \u00a9 SINTEF. Acknowledgment \u00b6 OTEAPI Core has been supported by the following projects: OntoTrans (2020-2024) that receives funding from the European Union\u2019s Horizon 2020 Research and Innovation Programme, under Grant Agreement n. 862136.","title":"Home"},{"location":"#open-translation-environment-ote-api-core","text":"Framework for accessing data resources, mapping data models, describing the data to ontologies and perform data transformations We highly recommend reading this page in the official documentation .","title":"Open Translation Environment (OTE) API Core"},{"location":"#about-oteapi-core","text":"OTEAPI Core provides the core functionality of OTEAPI, which stands for the Open Translation Environment API . It uses the strategy software design pattern to implement a simple and easy to extend access to a large range of data resources. Semantic interoperability is supported via mapping of data models describing the data to ontologies. Transformations, mainly intended to transform data between representations, are also supported, but transformations can also be used for running simulations in a simple workflow. OTEAPI Core includes: A set of standard strategies; A plugin system for loading the standard strategies, as well as third party strategies; Data models for configuring the strategies; A Python library, through which the data can be accessed; and An efficient data cache module that avoids downloading the same content several times.","title":"About OTEAPI Core"},{"location":"#types-of-strategies","text":"","title":"Types of strategies"},{"location":"#download-strategy","text":"Download strategy patterns use a given protocol to download content into the data cache. They are configured with the ResourceConfig data model, using the scheme of the downloadUrl field for strategy selection. The configuration field can be used to configure how the downloaded content is stored in the cache using the DownloadConfig data model. Standard downloaded strategies: file , https , http , sftp , ftp","title":"Download strategy"},{"location":"#parse-strategy","text":"Parse strategy patterns convert content from the data cache to a Python dict. Like download strategies, they are configured with the ResourceConfig data model, using the mediaType field for strategy selection. Additional strategy-specific configurations can be provided via the configuration field. Standard parse strategies: text_csv , text_json , image_jpeg , excel_xlsx","title":"Parse strategy"},{"location":"#resource-strategy","text":"Resource strategy patterns can retrieve/upload data to external data services. They are configured with the ResourceConfig data model, using the scheme of the accessUrl and accessService fields. The scheme of the accessUrl is used for strategy selection.","title":"Resource strategy"},{"location":"#mapping-strategy","text":"Strategies for mapping fields/properties in data models to ontological concepts.","title":"Mapping strategy"},{"location":"#filter-strategy","text":"Filter strategies can update the configuration of other strategies. They can also update values in the data cache.","title":"Filter strategy"},{"location":"#transformation-strategy","text":"Transformation strategies are a special form of a filter strategy intended for long-running transformations.","title":"Transformation strategy"},{"location":"#entry-points-for-plugins","text":"Suggestion: Use setuptools entry points to load plugins. The entry point groups could be named as something like this: \"oteapi.download_strategy\" , \"oteapi.filter_strategy\" \"oteapi.download\" , \"oteapi.filter\" \"oteapi.interfaces.download\" , \"oteapi.interfaces.filter\" The value for an entrypoint should then be: setup ( # ..., entry_points = { \"oteapi.download_strategy\" : [ \"my_plugin.p2p = my_plugin.strategies.download.peer_2_peer\" , \"my_plugin.mongo = my_plugin.strategies.download.mongo_get\" , ], }, ) or as part of a YAML/JSON/setup.cfg setup files as such: entry_points : oteapi.download_strategy : - \"my_plugin.p2p = my_plugin.strategies.download.peer_2_peer\" - \"my_plugin.mongo = my_plugin.strategies.download.mongo_get\" { \"entry_points\" : { \"oteapi.download_strategy\" : [ \"my_plugin.p2p = my_plugin.strategies.download.peer_2_peer\" , \"my_plugin.mongo = my_plugin.strategies.download.mongo_get\" ] } } [options.entry_points] oteapi.download_strategy = my_plugin.p2p = my_plugin.strategies.download.peer_2_peer my_plugin.mongo = my_plugin.strategies.download.mongo_get The plugins will then automagically load all installed strategy module plugins, registering the strategies according to the StrategyFactory decorator.","title":"Entry points for plugins"},{"location":"#other-oteapi-related-repositories","text":"OTEAPI Services - a RESTful interface to OTEAPI Core OTELib - a Python interface to OTEAPI Services OTEAPI Plugin Template - a cookiecutter template for OTEAPI Plugins","title":"Other OTEAPI-related repositories"},{"location":"#installation","text":"OTEAPI Core can be installed with: $ pip install oteapi-core","title":"Installation"},{"location":"#license","text":"OTEAPI Core is released under the MIT license with copyright \u00a9 SINTEF.","title":"License"},{"location":"#acknowledgment","text":"OTEAPI Core has been supported by the following projects: OntoTrans (2020-2024) that receives funding from the European Union\u2019s Horizon 2020 Research and Innovation Programme, under Grant Agreement n. 862136.","title":"Acknowledgment"},{"location":"CHANGELOG/","text":"Changelog \u00b6 v0.0.4 (2022-01-26) \u00b6 Full Changelog Implemented enhancements: Setup dependency handling via dependabot #31 Attempt simplifying strategy factory function #13 Fixed bugs: Update pytest command in CI to fix codecov #42 Publish workflow failing - invoke not installed #40 Closed issues: Use new TEAM 4.0[bot] email throughout #38 Make datacache safe to call from within a running asyncio event loop #26 Setup documentation framework #9 Merged pull requests: [Auto-generated] Update dependencies #45 ( TEAM4-0 ) Add pytest options to pyproject.toml #43 ( CasperWA ) Install the dev extra in publish workflow #41 ( CasperWA ) Use the updated @TEAM4-0 email address #39 ( CasperWA ) Implement CI/CD for dependabot #33 ( CasperWA ) Remove asyncio from datacache #32 ( jesper-friis ) Setup docs framework and implement creating any strategy function #29 ( CasperWA ) v0.0.3 (2022-01-21) \u00b6 Full Changelog Implemented enhancements: Remove non-\"standard\" strategies #14 Clean up the API #12 Fixed bugs: Update CI/CD to only use Python 3.9 #25 References in README are wrong #18 Closed issues: Bring back pre-commit #16 Publish docker image #15 Merged pull requests: Updated cd_release.yml to python 3.9 #28 ( kriwiik ) Add back pre-commit #22 ( CasperWA ) Fixed README.md References #20 ( anasayb ) Clean up Python API #17 ( CasperWA ) v0.0.2 (2022-01-14) \u00b6 Full Changelog Implemented enhancements: Release and tests CD/CI #1 ( CasperWA ) Fixed bugs: CD publish release workflow not working #4 CD release not working - wrong utils path #2 Merged pull requests: Cleanup #8 ( jesper-friis ) Renamed oteapi/strategy-interfaces to oteapi/interfaces and updated paths in all Python modules #6 ( jesper-friis ) Update workflows to make CD work #5 ( CasperWA ) Fix location of utility files for GH Actions #3 ( CasperWA ) * This Changelog was automatically generated by github_changelog_generator","title":"Changelog"},{"location":"CHANGELOG/#changelog","text":"","title":"Changelog"},{"location":"CHANGELOG/#v004-2022-01-26","text":"Full Changelog Implemented enhancements: Setup dependency handling via dependabot #31 Attempt simplifying strategy factory function #13 Fixed bugs: Update pytest command in CI to fix codecov #42 Publish workflow failing - invoke not installed #40 Closed issues: Use new TEAM 4.0[bot] email throughout #38 Make datacache safe to call from within a running asyncio event loop #26 Setup documentation framework #9 Merged pull requests: [Auto-generated] Update dependencies #45 ( TEAM4-0 ) Add pytest options to pyproject.toml #43 ( CasperWA ) Install the dev extra in publish workflow #41 ( CasperWA ) Use the updated @TEAM4-0 email address #39 ( CasperWA ) Implement CI/CD for dependabot #33 ( CasperWA ) Remove asyncio from datacache #32 ( jesper-friis ) Setup docs framework and implement creating any strategy function #29 ( CasperWA )","title":"v0.0.4 (2022-01-26)"},{"location":"CHANGELOG/#v003-2022-01-21","text":"Full Changelog Implemented enhancements: Remove non-\"standard\" strategies #14 Clean up the API #12 Fixed bugs: Update CI/CD to only use Python 3.9 #25 References in README are wrong #18 Closed issues: Bring back pre-commit #16 Publish docker image #15 Merged pull requests: Updated cd_release.yml to python 3.9 #28 ( kriwiik ) Add back pre-commit #22 ( CasperWA ) Fixed README.md References #20 ( anasayb ) Clean up Python API #17 ( CasperWA )","title":"v0.0.3 (2022-01-21)"},{"location":"CHANGELOG/#v002-2022-01-14","text":"Full Changelog Implemented enhancements: Release and tests CD/CI #1 ( CasperWA ) Fixed bugs: CD publish release workflow not working #4 CD release not working - wrong utils path #2 Merged pull requests: Cleanup #8 ( jesper-friis ) Renamed oteapi/strategy-interfaces to oteapi/interfaces and updated paths in all Python modules #6 ( jesper-friis ) Update workflows to make CD work #5 ( CasperWA ) Fix location of utility files for GH Actions #3 ( CasperWA ) * This Changelog was automatically generated by github_changelog_generator","title":"v0.0.2 (2022-01-14)"},{"location":"LICENSE/","text":"MIT License Copyright (c) 2020-2022 SINTEF Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"License"},{"location":"all_models/","text":"OTE-API Configuration Models \u00b6 This page provides documentation for the oteapi.models submodule, where all the OTE-API strategy configuration data models are located. When creating instances of these models, the data types are automatically validated. oteapi.models module. This module contains all the pydantic configuration models. datacacheconfig \u00b6 Pydantic DataCache Configuration Data Model. DataCacheConfig ( BaseModel ) pydantic-model \u00b6 DataCache Configuration. Source code in oteapi/models/datacacheconfig.py class DataCacheConfig ( BaseModel ): \"\"\"DataCache Configuration.\"\"\" cacheDir : Path = Field ( \"oteapi\" , description = \"Cache directory.\" ) accessKey : str = Field ( None , description = \"Key with which the downloaded content can be accessed. \" \"Should preferable be the hash (corresponding to `hashType`) of the \" \"content if it is known.\" , ) hashType : str = Field ( \"md5\" , description = \"Hash algorithm to use for creating hash keys for stored \" \"data. Can be any algorithm supported by hashlib.\" , ) expireTime : int = Field ( 3600 * 24 * 14 , description = \"Number of seconds before the cache entry expires. \" \"Zero means no expiration. Default is two weeks.\" , ) tag : str = Field ( None , description = \"Tag assigned to the downloaded content, typically \" \"identifying a session. Used with the `evict()` method to clean up a \" \"all cache entries with a given tag.\" , ) accessKey : str pydantic-field \u00b6 Key with which the downloaded content can be accessed. Should preferable be the hash (corresponding to hashType ) of the content if it is known. cacheDir : Path pydantic-field \u00b6 Cache directory. expireTime : int pydantic-field \u00b6 Number of seconds before the cache entry expires. Zero means no expiration. Default is two weeks. hashType : str pydantic-field \u00b6 Hash algorithm to use for creating hash keys for stored data. Can be any algorithm supported by hashlib. tag : str pydantic-field \u00b6 Tag assigned to the downloaded content, typically identifying a session. Used with the evict() method to clean up a all cache entries with a given tag. filterconfig \u00b6 Pydantic Filter Configuration Data Model. FilterConfig ( BaseModel ) pydantic-model \u00b6 Filter Strategy Data Configuration. Source code in oteapi/models/filterconfig.py class FilterConfig ( BaseModel ): \"\"\"Filter Strategy Data Configuration.\"\"\" filterType : str = Field ( ... , description = \"Type of registered filter strategy. E.g., `filter/sql`.\" ) query : Optional [ str ] = Field ( None , description = \"Define a query operation.\" ) condition : Optional [ str ] = Field ( None , description = \"Logical statement indicating when a filter should be applied.\" , ) limit : Optional [ int ] = Field ( None , description = \"Number of items remaining after a filter expression.\" ) configuration : Optional [ Dict ] = Field ( None , description = \"Filter-specific configuration options given as key/value-pairs.\" , ) condition : str pydantic-field \u00b6 Logical statement indicating when a filter should be applied. configuration : Dict pydantic-field \u00b6 Filter-specific configuration options given as key/value-pairs. filterType : str pydantic-field required \u00b6 Type of registered filter strategy. E.g., filter/sql . limit : int pydantic-field \u00b6 Number of items remaining after a filter expression. query : str pydantic-field \u00b6 Define a query operation. mappingconfig \u00b6 Pydantic Mapping Configuration Data Model. MappingConfig ( BaseModel ) pydantic-model \u00b6 Mapping Strategy Data Configuration. Source code in oteapi/models/mappingconfig.py class MappingConfig ( BaseModel ): \"\"\"Mapping Strategy Data Configuration.\"\"\" mappingType : str = Field ( ... , description = \"Type of registered mapping strategy. E.g., `mapping/demo`.\" ) prefixes : Optional [ Dict [ str , str ]] = Field ( None , description = ( \"List of shortnames that expands to an IRI \" \"given as local value/IRI-expansion-pairs.\" ), ) triples : Optional [ List [ SemanticTriple ]] = Field ( # type: ignore[valid-type] None , description = \"List of semantic triples given as (subject, predicate, object).\" , ) configuration : Optional [ Dict ] = Field ( None , description = \"Mapping-specific configuration options given as key/value-pairs.\" , ) configuration : Dict pydantic-field \u00b6 Mapping-specific configuration options given as key/value-pairs. mappingType : str pydantic-field required \u00b6 Type of registered mapping strategy. E.g., mapping/demo . prefixes : Dict [ str , str ] pydantic-field \u00b6 List of shortnames that expands to an IRI given as local value/IRI-expansion-pairs. triples : List [ types . ConstrainedListValue ] pydantic-field \u00b6 List of semantic triples given as (subject, predicate, object). resourceconfig \u00b6 Pydantic Resource Configuration Data Model. ResourceConfig ( BaseModel ) pydantic-model \u00b6 Resource Strategy Data Configuration. Important Either of the pairs of attributes downloadUrl / mediaType or accessUrl / accessService MUST be specified. Source code in oteapi/models/resourceconfig.py class ResourceConfig ( BaseModel ): \"\"\"Resource Strategy Data Configuration. Important: Either of the pairs of attributes `downloadUrl`/`mediaType` or `accessUrl`/`accessService` MUST be specified. \"\"\" downloadUrl : Optional [ AnyUrl ] = Field ( None , description = ( \"Definition: The URL of the downloadable file in a given format. E.g. CSV \" \"file or RDF file. \\n\\n Usage: `downloadURL` *SHOULD* be used for the URL at\" \" which this distribution is available directly, typically through a HTTPS\" \" GET request or SFTP.\" ), ) mediaType : Optional [ str ] = Field ( None , description = ( \"The media type of the distribution as defined by IANA \" \"[[IANA-MEDIA-TYPES](https://www.w3.org/TR/vocab-dcat-2/#bib-iana-media-types)]\" \". \\n\\n Usage: This property *SHOULD* be used when the media\" \" type of the distribution is defined in IANA \" \"[[IANA-MEDIA-TYPES](https://www.w3.org/TR/vocab-dcat-2/#bib-iana-media-types)].\" ), ) accessUrl : Optional [ AnyUrl ] = Field ( None , description = ( \"A URL of the resource that gives access to a distribution of \" \"the dataset. E.g. landing page, feed, SPARQL endpoint. \\n\\n Usage: \" \"`accessURL` *SHOULD* be used for the URL of a service or location that \" \"can provide access to this distribution, typically through a Web form, \" \"query or API call. \\n `downloadURL` is preferred for direct links to \" \"downloadable resources.\" ), ) accessService : Optional [ str ] = Field ( None , description = ( \"A data service that gives access to the distribution of the dataset.\" ), ) license : Optional [ str ] = Field ( None , description = ( \"A legal document under which the distribution is made available.\" ), ) accessRights : Optional [ str ] = Field ( None , description = ( \"A rights statement that concerns how the distribution is accessed.\" ), ) description : Optional [ str ] = Field ( None , description = \"A free-text account of the distribution.\" ) publisher : Optional [ str ] = Field ( None , description = \"The entity responsible for making the resource/item available.\" , ) configuration : Union [ DataCacheConfig , Dict [ str , Any ]] = Field ( {}, description = \"Resource-specific configuration options given as key/value-pairs.\" , ) @root_validator def ensure_unique_url_pairs ( # pylint: disable=no-self-use cls , values : Dict [ str , Any ] ) -> Dict [ str , Any ]: \"\"\"Ensure either downloadUrl/mediaType or accessUrl/accessService are defined. It's fine to define them all, but at least one complete pair MUST be specified.\"\"\" if not ( all ( values . get ( _ ) for _ in [ \"downloadUrl\" , \"mediaType\" ]) or all ( values . get ( _ ) for _ in [ \"accessUrl\" , \"accessService\" ]) ): raise ValueError ( \"Either of the pairs of attributes downloadUrl/mediaType or \" \"accessUrl/accessService MUST be specified.\" ) return values accessRights : str pydantic-field \u00b6 A rights statement that concerns how the distribution is accessed. accessService : str pydantic-field \u00b6 A data service that gives access to the distribution of the dataset. accessUrl : AnyUrl pydantic-field \u00b6 A URL of the resource that gives access to a distribution of the dataset. E.g. landing page, feed, SPARQL endpoint. Usage: accessURL SHOULD be used for the URL of a service or location that can provide access to this distribution, typically through a Web form, query or API call. downloadURL is preferred for direct links to downloadable resources. configuration : Union [ oteapi . models . datacacheconfig . DataCacheConfig , Dict [ str , Any ]] pydantic-field \u00b6 Resource-specific configuration options given as key/value-pairs. description : str pydantic-field \u00b6 A free-text account of the distribution. downloadUrl : AnyUrl pydantic-field \u00b6 Definition: The URL of the downloadable file in a given format. E.g. CSV file or RDF file. Usage: downloadURL SHOULD be used for the URL at which this distribution is available directly, typically through a HTTPS GET request or SFTP. license : str pydantic-field \u00b6 A legal document under which the distribution is made available. mediaType : str pydantic-field \u00b6 The media type of the distribution as defined by IANA [ IANA-MEDIA-TYPES ]. Usage: This property SHOULD be used when the media type of the distribution is defined in IANA [ IANA-MEDIA-TYPES ]. publisher : str pydantic-field \u00b6 The entity responsible for making the resource/item available. ensure_unique_url_pairs ( values ) classmethod \u00b6 Ensure either downloadUrl/mediaType or accessUrl/accessService are defined. It's fine to define them all, but at least one complete pair MUST be specified. Source code in oteapi/models/resourceconfig.py @root_validator def ensure_unique_url_pairs ( # pylint: disable=no-self-use cls , values : Dict [ str , Any ] ) -> Dict [ str , Any ]: \"\"\"Ensure either downloadUrl/mediaType or accessUrl/accessService are defined. It's fine to define them all, but at least one complete pair MUST be specified.\"\"\" if not ( all ( values . get ( _ ) for _ in [ \"downloadUrl\" , \"mediaType\" ]) or all ( values . get ( _ ) for _ in [ \"accessUrl\" , \"accessService\" ]) ): raise ValueError ( \"Either of the pairs of attributes downloadUrl/mediaType or \" \"accessUrl/accessService MUST be specified.\" ) return values transformationconfig \u00b6 Pydantic Transformation Configuration Data Model. A transformation status data model is provided as well. This data model represents what should be returned from the strategy's status() method. PriorityEnum ( str , Enum ) \u00b6 Defining process priority enumerators. Process priorities: Low Medium High Source code in oteapi/models/transformationconfig.py class PriorityEnum ( str , Enum ): \"\"\"Defining process priority enumerators. Process priorities: - Low - Medium - High \"\"\" LOW = \"Low\" MEDIUM = \"Medium\" HIGH = \"High\" TransformationConfig ( BaseModel ) pydantic-model \u00b6 Transformation Strategy Data Configuration. Source code in oteapi/models/transformationconfig.py class TransformationConfig ( BaseModel ): \"\"\"Transformation Strategy Data Configuration.\"\"\" transformation_type : str = Field ( ... , description = ( \"Type of registered transformation strategy. E.g., `celery/remote`.\" ), ) name : Optional [ str ] = Field ( None , description = \"Human-readable name of the transformation strategy.\" ) description : Optional [ str ] = Field ( None , description = \"A free-text account of the transformation.\" ) due : Optional [ datetime ] = Field ( None , description = ( \"Optional field to indicate a due data/time for when a transformation \" \"should finish.\" ), ) priority : Optional [ PriorityEnum ] = Field ( PriorityEnum . MEDIUM , description = \"Define the process priority of the transformation execution.\" , ) secret : Optional [ str ] = Field ( None , description = \"Authorization secret given when running a transformation.\" , ) configuration : Optional [ Dict ] = Field ( None , description = ( \"Transformation-specific configuration options given as key/value-pairs.\" ), ) configuration : Dict pydantic-field \u00b6 Transformation-specific configuration options given as key/value-pairs. description : str pydantic-field \u00b6 A free-text account of the transformation. due : datetime pydantic-field \u00b6 Optional field to indicate a due data/time for when a transformation should finish. name : str pydantic-field \u00b6 Human-readable name of the transformation strategy. priority : PriorityEnum pydantic-field \u00b6 Define the process priority of the transformation execution. secret : str pydantic-field \u00b6 Authorization secret given when running a transformation. transformation_type : str pydantic-field required \u00b6 Type of registered transformation strategy. E.g., celery/remote . TransformationStatus ( BaseModel ) pydantic-model \u00b6 Return from transformation status. Source code in oteapi/models/transformationconfig.py class TransformationStatus ( BaseModel ): \"\"\"Return from transformation status.\"\"\" id : str = Field ( ... , description = \"ID for the given transformation process.\" ) status : Optional [ str ] = Field ( None , description = \"Status for the transformation process.\" ) messages : Optional [ List [ str ]] = Field ( None , description = \"Messages related to the transformation process.\" ) created : Optional [ datetime ] = Field ( None , description = \"Time of creation for the transformation process. Given in UTC.\" , ) startTime : Optional [ datetime ] = Field ( None , description = \"Time when the transformation process started. Given in UTC.\" ) finishTime : Optional [ datetime ] = Field ( None , description = \"Time when the tranformation process finished. Given in UTC.\" ) created : datetime pydantic-field \u00b6 Time of creation for the transformation process. Given in UTC. finishTime : datetime pydantic-field \u00b6 Time when the tranformation process finished. Given in UTC. id : str pydantic-field required \u00b6 ID for the given transformation process. messages : List [ str ] pydantic-field \u00b6 Messages related to the transformation process. startTime : datetime pydantic-field \u00b6 Time when the transformation process started. Given in UTC. status : str pydantic-field \u00b6 Status for the transformation process.","title":"OTE-API Configuration Models"},{"location":"all_models/#ote-api-configuration-models","text":"This page provides documentation for the oteapi.models submodule, where all the OTE-API strategy configuration data models are located. When creating instances of these models, the data types are automatically validated. oteapi.models module. This module contains all the pydantic configuration models.","title":"OTE-API Configuration Models"},{"location":"all_models/#oteapi.models.datacacheconfig","text":"Pydantic DataCache Configuration Data Model.","title":"datacacheconfig"},{"location":"all_models/#oteapi.models.datacacheconfig.DataCacheConfig","text":"DataCache Configuration. Source code in oteapi/models/datacacheconfig.py class DataCacheConfig ( BaseModel ): \"\"\"DataCache Configuration.\"\"\" cacheDir : Path = Field ( \"oteapi\" , description = \"Cache directory.\" ) accessKey : str = Field ( None , description = \"Key with which the downloaded content can be accessed. \" \"Should preferable be the hash (corresponding to `hashType`) of the \" \"content if it is known.\" , ) hashType : str = Field ( \"md5\" , description = \"Hash algorithm to use for creating hash keys for stored \" \"data. Can be any algorithm supported by hashlib.\" , ) expireTime : int = Field ( 3600 * 24 * 14 , description = \"Number of seconds before the cache entry expires. \" \"Zero means no expiration. Default is two weeks.\" , ) tag : str = Field ( None , description = \"Tag assigned to the downloaded content, typically \" \"identifying a session. Used with the `evict()` method to clean up a \" \"all cache entries with a given tag.\" , )","title":"DataCacheConfig"},{"location":"all_models/#oteapi.models.datacacheconfig.DataCacheConfig.accessKey","text":"Key with which the downloaded content can be accessed. Should preferable be the hash (corresponding to hashType ) of the content if it is known.","title":"accessKey"},{"location":"all_models/#oteapi.models.datacacheconfig.DataCacheConfig.cacheDir","text":"Cache directory.","title":"cacheDir"},{"location":"all_models/#oteapi.models.datacacheconfig.DataCacheConfig.expireTime","text":"Number of seconds before the cache entry expires. Zero means no expiration. Default is two weeks.","title":"expireTime"},{"location":"all_models/#oteapi.models.datacacheconfig.DataCacheConfig.hashType","text":"Hash algorithm to use for creating hash keys for stored data. Can be any algorithm supported by hashlib.","title":"hashType"},{"location":"all_models/#oteapi.models.datacacheconfig.DataCacheConfig.tag","text":"Tag assigned to the downloaded content, typically identifying a session. Used with the evict() method to clean up a all cache entries with a given tag.","title":"tag"},{"location":"all_models/#oteapi.models.filterconfig","text":"Pydantic Filter Configuration Data Model.","title":"filterconfig"},{"location":"all_models/#oteapi.models.filterconfig.FilterConfig","text":"Filter Strategy Data Configuration. Source code in oteapi/models/filterconfig.py class FilterConfig ( BaseModel ): \"\"\"Filter Strategy Data Configuration.\"\"\" filterType : str = Field ( ... , description = \"Type of registered filter strategy. E.g., `filter/sql`.\" ) query : Optional [ str ] = Field ( None , description = \"Define a query operation.\" ) condition : Optional [ str ] = Field ( None , description = \"Logical statement indicating when a filter should be applied.\" , ) limit : Optional [ int ] = Field ( None , description = \"Number of items remaining after a filter expression.\" ) configuration : Optional [ Dict ] = Field ( None , description = \"Filter-specific configuration options given as key/value-pairs.\" , )","title":"FilterConfig"},{"location":"all_models/#oteapi.models.filterconfig.FilterConfig.condition","text":"Logical statement indicating when a filter should be applied.","title":"condition"},{"location":"all_models/#oteapi.models.filterconfig.FilterConfig.configuration","text":"Filter-specific configuration options given as key/value-pairs.","title":"configuration"},{"location":"all_models/#oteapi.models.filterconfig.FilterConfig.filterType","text":"Type of registered filter strategy. E.g., filter/sql .","title":"filterType"},{"location":"all_models/#oteapi.models.filterconfig.FilterConfig.limit","text":"Number of items remaining after a filter expression.","title":"limit"},{"location":"all_models/#oteapi.models.filterconfig.FilterConfig.query","text":"Define a query operation.","title":"query"},{"location":"all_models/#oteapi.models.mappingconfig","text":"Pydantic Mapping Configuration Data Model.","title":"mappingconfig"},{"location":"all_models/#oteapi.models.mappingconfig.MappingConfig","text":"Mapping Strategy Data Configuration. Source code in oteapi/models/mappingconfig.py class MappingConfig ( BaseModel ): \"\"\"Mapping Strategy Data Configuration.\"\"\" mappingType : str = Field ( ... , description = \"Type of registered mapping strategy. E.g., `mapping/demo`.\" ) prefixes : Optional [ Dict [ str , str ]] = Field ( None , description = ( \"List of shortnames that expands to an IRI \" \"given as local value/IRI-expansion-pairs.\" ), ) triples : Optional [ List [ SemanticTriple ]] = Field ( # type: ignore[valid-type] None , description = \"List of semantic triples given as (subject, predicate, object).\" , ) configuration : Optional [ Dict ] = Field ( None , description = \"Mapping-specific configuration options given as key/value-pairs.\" , )","title":"MappingConfig"},{"location":"all_models/#oteapi.models.mappingconfig.MappingConfig.configuration","text":"Mapping-specific configuration options given as key/value-pairs.","title":"configuration"},{"location":"all_models/#oteapi.models.mappingconfig.MappingConfig.mappingType","text":"Type of registered mapping strategy. E.g., mapping/demo .","title":"mappingType"},{"location":"all_models/#oteapi.models.mappingconfig.MappingConfig.prefixes","text":"List of shortnames that expands to an IRI given as local value/IRI-expansion-pairs.","title":"prefixes"},{"location":"all_models/#oteapi.models.mappingconfig.MappingConfig.triples","text":"List of semantic triples given as (subject, predicate, object).","title":"triples"},{"location":"all_models/#oteapi.models.resourceconfig","text":"Pydantic Resource Configuration Data Model.","title":"resourceconfig"},{"location":"all_models/#oteapi.models.resourceconfig.ResourceConfig","text":"Resource Strategy Data Configuration. Important Either of the pairs of attributes downloadUrl / mediaType or accessUrl / accessService MUST be specified. Source code in oteapi/models/resourceconfig.py class ResourceConfig ( BaseModel ): \"\"\"Resource Strategy Data Configuration. Important: Either of the pairs of attributes `downloadUrl`/`mediaType` or `accessUrl`/`accessService` MUST be specified. \"\"\" downloadUrl : Optional [ AnyUrl ] = Field ( None , description = ( \"Definition: The URL of the downloadable file in a given format. E.g. CSV \" \"file or RDF file. \\n\\n Usage: `downloadURL` *SHOULD* be used for the URL at\" \" which this distribution is available directly, typically through a HTTPS\" \" GET request or SFTP.\" ), ) mediaType : Optional [ str ] = Field ( None , description = ( \"The media type of the distribution as defined by IANA \" \"[[IANA-MEDIA-TYPES](https://www.w3.org/TR/vocab-dcat-2/#bib-iana-media-types)]\" \". \\n\\n Usage: This property *SHOULD* be used when the media\" \" type of the distribution is defined in IANA \" \"[[IANA-MEDIA-TYPES](https://www.w3.org/TR/vocab-dcat-2/#bib-iana-media-types)].\" ), ) accessUrl : Optional [ AnyUrl ] = Field ( None , description = ( \"A URL of the resource that gives access to a distribution of \" \"the dataset. E.g. landing page, feed, SPARQL endpoint. \\n\\n Usage: \" \"`accessURL` *SHOULD* be used for the URL of a service or location that \" \"can provide access to this distribution, typically through a Web form, \" \"query or API call. \\n `downloadURL` is preferred for direct links to \" \"downloadable resources.\" ), ) accessService : Optional [ str ] = Field ( None , description = ( \"A data service that gives access to the distribution of the dataset.\" ), ) license : Optional [ str ] = Field ( None , description = ( \"A legal document under which the distribution is made available.\" ), ) accessRights : Optional [ str ] = Field ( None , description = ( \"A rights statement that concerns how the distribution is accessed.\" ), ) description : Optional [ str ] = Field ( None , description = \"A free-text account of the distribution.\" ) publisher : Optional [ str ] = Field ( None , description = \"The entity responsible for making the resource/item available.\" , ) configuration : Union [ DataCacheConfig , Dict [ str , Any ]] = Field ( {}, description = \"Resource-specific configuration options given as key/value-pairs.\" , ) @root_validator def ensure_unique_url_pairs ( # pylint: disable=no-self-use cls , values : Dict [ str , Any ] ) -> Dict [ str , Any ]: \"\"\"Ensure either downloadUrl/mediaType or accessUrl/accessService are defined. It's fine to define them all, but at least one complete pair MUST be specified.\"\"\" if not ( all ( values . get ( _ ) for _ in [ \"downloadUrl\" , \"mediaType\" ]) or all ( values . get ( _ ) for _ in [ \"accessUrl\" , \"accessService\" ]) ): raise ValueError ( \"Either of the pairs of attributes downloadUrl/mediaType or \" \"accessUrl/accessService MUST be specified.\" ) return values","title":"ResourceConfig"},{"location":"all_models/#oteapi.models.resourceconfig.ResourceConfig.accessRights","text":"A rights statement that concerns how the distribution is accessed.","title":"accessRights"},{"location":"all_models/#oteapi.models.resourceconfig.ResourceConfig.accessService","text":"A data service that gives access to the distribution of the dataset.","title":"accessService"},{"location":"all_models/#oteapi.models.resourceconfig.ResourceConfig.accessUrl","text":"A URL of the resource that gives access to a distribution of the dataset. E.g. landing page, feed, SPARQL endpoint. Usage: accessURL SHOULD be used for the URL of a service or location that can provide access to this distribution, typically through a Web form, query or API call. downloadURL is preferred for direct links to downloadable resources.","title":"accessUrl"},{"location":"all_models/#oteapi.models.resourceconfig.ResourceConfig.configuration","text":"Resource-specific configuration options given as key/value-pairs.","title":"configuration"},{"location":"all_models/#oteapi.models.resourceconfig.ResourceConfig.description","text":"A free-text account of the distribution.","title":"description"},{"location":"all_models/#oteapi.models.resourceconfig.ResourceConfig.downloadUrl","text":"Definition: The URL of the downloadable file in a given format. E.g. CSV file or RDF file. Usage: downloadURL SHOULD be used for the URL at which this distribution is available directly, typically through a HTTPS GET request or SFTP.","title":"downloadUrl"},{"location":"all_models/#oteapi.models.resourceconfig.ResourceConfig.license","text":"A legal document under which the distribution is made available.","title":"license"},{"location":"all_models/#oteapi.models.resourceconfig.ResourceConfig.mediaType","text":"The media type of the distribution as defined by IANA [ IANA-MEDIA-TYPES ]. Usage: This property SHOULD be used when the media type of the distribution is defined in IANA [ IANA-MEDIA-TYPES ].","title":"mediaType"},{"location":"all_models/#oteapi.models.resourceconfig.ResourceConfig.publisher","text":"The entity responsible for making the resource/item available.","title":"publisher"},{"location":"all_models/#oteapi.models.resourceconfig.ResourceConfig.ensure_unique_url_pairs","text":"Ensure either downloadUrl/mediaType or accessUrl/accessService are defined. It's fine to define them all, but at least one complete pair MUST be specified. Source code in oteapi/models/resourceconfig.py @root_validator def ensure_unique_url_pairs ( # pylint: disable=no-self-use cls , values : Dict [ str , Any ] ) -> Dict [ str , Any ]: \"\"\"Ensure either downloadUrl/mediaType or accessUrl/accessService are defined. It's fine to define them all, but at least one complete pair MUST be specified.\"\"\" if not ( all ( values . get ( _ ) for _ in [ \"downloadUrl\" , \"mediaType\" ]) or all ( values . get ( _ ) for _ in [ \"accessUrl\" , \"accessService\" ]) ): raise ValueError ( \"Either of the pairs of attributes downloadUrl/mediaType or \" \"accessUrl/accessService MUST be specified.\" ) return values","title":"ensure_unique_url_pairs()"},{"location":"all_models/#oteapi.models.transformationconfig","text":"Pydantic Transformation Configuration Data Model. A transformation status data model is provided as well. This data model represents what should be returned from the strategy's status() method.","title":"transformationconfig"},{"location":"all_models/#oteapi.models.transformationconfig.PriorityEnum","text":"Defining process priority enumerators. Process priorities: Low Medium High Source code in oteapi/models/transformationconfig.py class PriorityEnum ( str , Enum ): \"\"\"Defining process priority enumerators. Process priorities: - Low - Medium - High \"\"\" LOW = \"Low\" MEDIUM = \"Medium\" HIGH = \"High\"","title":"PriorityEnum"},{"location":"all_models/#oteapi.models.transformationconfig.TransformationConfig","text":"Transformation Strategy Data Configuration. Source code in oteapi/models/transformationconfig.py class TransformationConfig ( BaseModel ): \"\"\"Transformation Strategy Data Configuration.\"\"\" transformation_type : str = Field ( ... , description = ( \"Type of registered transformation strategy. E.g., `celery/remote`.\" ), ) name : Optional [ str ] = Field ( None , description = \"Human-readable name of the transformation strategy.\" ) description : Optional [ str ] = Field ( None , description = \"A free-text account of the transformation.\" ) due : Optional [ datetime ] = Field ( None , description = ( \"Optional field to indicate a due data/time for when a transformation \" \"should finish.\" ), ) priority : Optional [ PriorityEnum ] = Field ( PriorityEnum . MEDIUM , description = \"Define the process priority of the transformation execution.\" , ) secret : Optional [ str ] = Field ( None , description = \"Authorization secret given when running a transformation.\" , ) configuration : Optional [ Dict ] = Field ( None , description = ( \"Transformation-specific configuration options given as key/value-pairs.\" ), )","title":"TransformationConfig"},{"location":"all_models/#oteapi.models.transformationconfig.TransformationConfig.configuration","text":"Transformation-specific configuration options given as key/value-pairs.","title":"configuration"},{"location":"all_models/#oteapi.models.transformationconfig.TransformationConfig.description","text":"A free-text account of the transformation.","title":"description"},{"location":"all_models/#oteapi.models.transformationconfig.TransformationConfig.due","text":"Optional field to indicate a due data/time for when a transformation should finish.","title":"due"},{"location":"all_models/#oteapi.models.transformationconfig.TransformationConfig.name","text":"Human-readable name of the transformation strategy.","title":"name"},{"location":"all_models/#oteapi.models.transformationconfig.TransformationConfig.priority","text":"Define the process priority of the transformation execution.","title":"priority"},{"location":"all_models/#oteapi.models.transformationconfig.TransformationConfig.secret","text":"Authorization secret given when running a transformation.","title":"secret"},{"location":"all_models/#oteapi.models.transformationconfig.TransformationConfig.transformation_type","text":"Type of registered transformation strategy. E.g., celery/remote .","title":"transformation_type"},{"location":"all_models/#oteapi.models.transformationconfig.TransformationStatus","text":"Return from transformation status. Source code in oteapi/models/transformationconfig.py class TransformationStatus ( BaseModel ): \"\"\"Return from transformation status.\"\"\" id : str = Field ( ... , description = \"ID for the given transformation process.\" ) status : Optional [ str ] = Field ( None , description = \"Status for the transformation process.\" ) messages : Optional [ List [ str ]] = Field ( None , description = \"Messages related to the transformation process.\" ) created : Optional [ datetime ] = Field ( None , description = \"Time of creation for the transformation process. Given in UTC.\" , ) startTime : Optional [ datetime ] = Field ( None , description = \"Time when the transformation process started. Given in UTC.\" ) finishTime : Optional [ datetime ] = Field ( None , description = \"Time when the tranformation process finished. Given in UTC.\" )","title":"TransformationStatus"},{"location":"all_models/#oteapi.models.transformationconfig.TransformationStatus.created","text":"Time of creation for the transformation process. Given in UTC.","title":"created"},{"location":"all_models/#oteapi.models.transformationconfig.TransformationStatus.finishTime","text":"Time when the tranformation process finished. Given in UTC.","title":"finishTime"},{"location":"all_models/#oteapi.models.transformationconfig.TransformationStatus.id","text":"ID for the given transformation process.","title":"id"},{"location":"all_models/#oteapi.models.transformationconfig.TransformationStatus.messages","text":"Messages related to the transformation process.","title":"messages"},{"location":"all_models/#oteapi.models.transformationconfig.TransformationStatus.startTime","text":"Time when the transformation process started. Given in UTC.","title":"startTime"},{"location":"all_models/#oteapi.models.transformationconfig.TransformationStatus.status","text":"Status for the transformation process.","title":"status"},{"location":"all_strategies/","text":"OTE-API Core Strategies \u00b6 This page provides documentation for the oteapi.strategies submodule, where all the core OTE-API strategies are located. These strategies will always be available when setting up a server based on the OTE-API Core package. download special \u00b6 file \u00b6 Download strategy class for the file scheme. FileConfig ( BaseModel ) pydantic-model \u00b6 File-specific Configuration Data Model. Source code in oteapi/strategies/download/file.py class FileConfig ( BaseModel ): \"\"\"File-specific Configuration Data Model.\"\"\" text : bool = Field ( False , description = ( \"Whether the file should be opened in text mode. If `False`, the file will\" \" be opened in bytes mode.\" ), ) encoding : Optional [ str ] = Field ( None , description = ( \"Encoding used when opening the file. The default is platform dependent.\" ), ) encoding : str pydantic-field \u00b6 Encoding used when opening the file. The default is platform dependent. text : bool pydantic-field \u00b6 Whether the file should be opened in text mode. If False , the file will be opened in bytes mode. FileStrategy dataclass \u00b6 Strategy for retrieving data from a local file. Registers strategies : (\"scheme\", \"file\") Source code in oteapi/strategies/download/file.py @dataclass @StrategyFactory . register (( \"scheme\" , \"file\" )) class FileStrategy : \"\"\"Strategy for retrieving data from a local file. **Registers strategies**: - `(\"scheme\", \"file\")` \"\"\" resource_config : \"ResourceConfig\" def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Initialize.\"\"\" return {} def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Read local file.\"\"\" if ( self . resource_config . downloadUrl is None or self . resource_config . downloadUrl . scheme != \"file\" ): raise ValueError ( \"Expected 'downloadUrl' to have scheme 'file' in the configuration.\" ) filename = Path ( self . resource_config . downloadUrl . host ) . resolve () cache = DataCache ( self . resource_config . configuration ) if cache . config . accessKey and cache . config . accessKey in cache : key = cache . config . accessKey else : config = FileConfig ( ** self . resource_config . configuration , extra = Extra . ignore ) key = cache . add ( filename . read_text ( encoding = config . encoding ) if config . text else filename . read_bytes () ) return { \"key\" : key } get ( self , session = None ) \u00b6 Read local file. Source code in oteapi/strategies/download/file.py def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Read local file.\"\"\" if ( self . resource_config . downloadUrl is None or self . resource_config . downloadUrl . scheme != \"file\" ): raise ValueError ( \"Expected 'downloadUrl' to have scheme 'file' in the configuration.\" ) filename = Path ( self . resource_config . downloadUrl . host ) . resolve () cache = DataCache ( self . resource_config . configuration ) if cache . config . accessKey and cache . config . accessKey in cache : key = cache . config . accessKey else : config = FileConfig ( ** self . resource_config . configuration , extra = Extra . ignore ) key = cache . add ( filename . read_text ( encoding = config . encoding ) if config . text else filename . read_bytes () ) return { \"key\" : key } initialize ( self , session = None ) \u00b6 Initialize. Source code in oteapi/strategies/download/file.py def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Initialize.\"\"\" return {} https \u00b6 Download strategy class for http/https HTTPSStrategy dataclass \u00b6 Strategy for retrieving data via http. Registers strategies : (\"scheme\", \"http\") (\"scheme\", \"https\") Source code in oteapi/strategies/download/https.py @dataclass @StrategyFactory . register (( \"scheme\" , \"http\" ), ( \"scheme\" , \"https\" )) class HTTPSStrategy : \"\"\"Strategy for retrieving data via http. **Registers strategies**: - `(\"scheme\", \"http\")` - `(\"scheme\", \"https\")` \"\"\" resource_config : \"ResourceConfig\" def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Initialize.\"\"\" return {} def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Download via http/https and store on local cache.\"\"\" cache = DataCache ( self . resource_config . configuration ) if cache . config . accessKey and cache . config . accessKey in cache : key = cache . config . accessKey else : if not self . resource_config . downloadUrl : raise ValueError ( \"downloadUrl not defined in configuration.\" ) req = requests . get ( self . resource_config . downloadUrl , allow_redirects = True ) key = cache . add ( req . content ) return { \"key\" : key } get ( self , session = None ) \u00b6 Download via http/https and store on local cache. Source code in oteapi/strategies/download/https.py def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Download via http/https and store on local cache.\"\"\" cache = DataCache ( self . resource_config . configuration ) if cache . config . accessKey and cache . config . accessKey in cache : key = cache . config . accessKey else : if not self . resource_config . downloadUrl : raise ValueError ( \"downloadUrl not defined in configuration.\" ) req = requests . get ( self . resource_config . downloadUrl , allow_redirects = True ) key = cache . add ( req . content ) return { \"key\" : key } initialize ( self , session = None ) \u00b6 Initialize. Source code in oteapi/strategies/download/https.py def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Initialize.\"\"\" return {} sftp \u00b6 Strategy class for sftp/ftp SFTPStrategy dataclass \u00b6 Strategy for retrieving data via sftp. Registers strategies : (\"scheme\", \"ftp\") (\"scheme\", \"sftp\") Source code in oteapi/strategies/download/sftp.py @dataclass @StrategyFactory . register (( \"scheme\" , \"sftp\" ), ( \"scheme\" , \"ftp\" )) class SFTPStrategy : \"\"\"Strategy for retrieving data via sftp. **Registers strategies**: - `(\"scheme\", \"ftp\")` - `(\"scheme\", \"sftp\")` \"\"\" resource_config : \"ResourceConfig\" def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Initialize.\"\"\" return {} def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Download via sftp\"\"\" cache = DataCache ( self . resource_config . configuration ) if cache . config . accessKey and cache . config . accessKey in cache : key = cache . config . accessKey else : # Setup connection options cnopts = pysftp . CnOpts () cnopts . hostkeys = None if not self . resource_config . accessUrl : raise ValueError ( \"accessUrl is not defined in configuration.\" ) # open connection and store data locally with pysftp . Connection ( host = self . resource_config . accessUrl . host , username = self . resource_config . accessUrl . user , password = self . resource_config . accessUrl . password , port = self . resource_config . accessUrl . port , cnopts = cnopts , ) as sftp : # Because of insane locking on Windows, we have to close # the downloaded file before adding it to the cache with NamedTemporaryFile ( prefix = \"oteapi-sftp-\" , delete = False ) as handle : localpath = Path ( handle . name ) . resolve () try : sftp . get ( self . resource_config . accessUrl . path , localpath = localpath ) key = cache . add ( localpath . read_bytes ()) finally : localpath . unlink () return { \"key\" : key } get ( self , session = None ) \u00b6 Download via sftp Source code in oteapi/strategies/download/sftp.py def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Download via sftp\"\"\" cache = DataCache ( self . resource_config . configuration ) if cache . config . accessKey and cache . config . accessKey in cache : key = cache . config . accessKey else : # Setup connection options cnopts = pysftp . CnOpts () cnopts . hostkeys = None if not self . resource_config . accessUrl : raise ValueError ( \"accessUrl is not defined in configuration.\" ) # open connection and store data locally with pysftp . Connection ( host = self . resource_config . accessUrl . host , username = self . resource_config . accessUrl . user , password = self . resource_config . accessUrl . password , port = self . resource_config . accessUrl . port , cnopts = cnopts , ) as sftp : # Because of insane locking on Windows, we have to close # the downloaded file before adding it to the cache with NamedTemporaryFile ( prefix = \"oteapi-sftp-\" , delete = False ) as handle : localpath = Path ( handle . name ) . resolve () try : sftp . get ( self . resource_config . accessUrl . path , localpath = localpath ) key = cache . add ( localpath . read_bytes ()) finally : localpath . unlink () return { \"key\" : key } initialize ( self , session = None ) \u00b6 Initialize. Source code in oteapi/strategies/download/sftp.py def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Initialize.\"\"\" return {} filter special \u00b6 crop_filter \u00b6 Demo-filter strategy CropDataModel ( BaseModel ) pydantic-model \u00b6 Configuration model for crop data. Source code in oteapi/strategies/filter/crop_filter.py class CropDataModel ( BaseModel ): \"\"\"Configuration model for crop data.\"\"\" crop : List [ int ] = Field ( ... , description = \"List of image cropping details.\" ) crop : List [ int ] pydantic-field required \u00b6 List of image cropping details. CropFilter dataclass \u00b6 Strategy for cropping an image. Registers strategies : (\"filterType\", \"filter/crop\") Source code in oteapi/strategies/filter/crop_filter.py @dataclass @StrategyFactory . register (( \"filterType\" , \"filter/crop\" )) class CropFilter : \"\"\"Strategy for cropping an image. **Registers strategies**: - `(\"filterType\", \"filter/crop\")` \"\"\" filter_config : \"FilterConfig\" def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Initialize strategy and return a dictionary.\"\"\" return { \"result\" : \"collectionid\" } def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Execute strategy and return a dictionary\"\"\" cropData = ( CropDataModel ( ** self . filter_config . configuration ) if self . filter_config . configuration else CropDataModel () ) return { \"imagecrop\" : cropData . crop } get ( self , session = None ) \u00b6 Execute strategy and return a dictionary Source code in oteapi/strategies/filter/crop_filter.py def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Execute strategy and return a dictionary\"\"\" cropData = ( CropDataModel ( ** self . filter_config . configuration ) if self . filter_config . configuration else CropDataModel () ) return { \"imagecrop\" : cropData . crop } initialize ( self , session = None ) \u00b6 Initialize strategy and return a dictionary. Source code in oteapi/strategies/filter/crop_filter.py def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Initialize strategy and return a dictionary.\"\"\" return { \"result\" : \"collectionid\" } sql_query_filter \u00b6 SQL query filter strategy. SQLQueryFilter dataclass \u00b6 Strategy for a SQL query filter. Registers strategies : (\"filterType\", \"filter/sql\") Source code in oteapi/strategies/filter/sql_query_filter.py @dataclass @StrategyFactory . register (( \"filterType\" , \"filter/sql\" )) class SQLQueryFilter : \"\"\"Strategy for a SQL query filter. **Registers strategies**: - `(\"filterType\", \"filter/sql\")` \"\"\" filter_config : \"FilterConfig\" def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Initialize strategy and return a dictionary\"\"\" queryData = SqlQueryDataModel ( ** { \"query\" : self . filter_config . query }) return { \"sqlquery\" : queryData . query } def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Execute strategy and return a dictionary\"\"\" return {} get ( self , session = None ) \u00b6 Execute strategy and return a dictionary Source code in oteapi/strategies/filter/sql_query_filter.py def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Execute strategy and return a dictionary\"\"\" return {} initialize ( self , session = None ) \u00b6 Initialize strategy and return a dictionary Source code in oteapi/strategies/filter/sql_query_filter.py def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Initialize strategy and return a dictionary\"\"\" queryData = SqlQueryDataModel ( ** { \"query\" : self . filter_config . query }) return { \"sqlquery\" : queryData . query } SqlQueryDataModel ( BaseModel ) pydantic-model \u00b6 SQL Query data model. Source code in oteapi/strategies/filter/sql_query_filter.py class SqlQueryDataModel ( BaseModel ): \"\"\"SQL Query data model.\"\"\" query : str = Field ( ... , description = \"A SQL query string.\" ) query : str pydantic-field required \u00b6 A SQL query string. parse special \u00b6 application_vnd_sqlite \u00b6 Strategy class for application/vnd.sqlite3. SqliteParseStrategy dataclass \u00b6 Parse strategy for SQLite. Registers strategies : (\"mediaType\", \"application/vnd.sqlite3\") Source code in oteapi/strategies/parse/application_vnd_sqlite.py @dataclass @StrategyFactory . register (( \"mediaType\" , \"application/vnd.sqlite3\" )) class SqliteParseStrategy : \"\"\"Parse strategy for SQLite. **Registers strategies**: - `(\"mediaType\", \"application/vnd.sqlite3\")` \"\"\" resource_config : \"ResourceConfig\" def parse ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Parse SQLite query responses.\"\"\" if session is None : raise ValueError ( \"Missing session\" ) if \"sqlquery\" in session : cn = create_connection ( session [ \"filename\" ]) cur = cn . cursor () rows = cur . execute ( session [ \"sqlquery\" ]) . fetchall () return { \"result\" : rows } return { \"result\" : \"No query given\" } def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Initialize.\"\"\" return {} initialize ( self , session = None ) \u00b6 Initialize. Source code in oteapi/strategies/parse/application_vnd_sqlite.py def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Initialize.\"\"\" return {} parse ( self , session = None ) \u00b6 Parse SQLite query responses. Source code in oteapi/strategies/parse/application_vnd_sqlite.py def parse ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Parse SQLite query responses.\"\"\" if session is None : raise ValueError ( \"Missing session\" ) if \"sqlquery\" in session : cn = create_connection ( session [ \"filename\" ]) cur = cn . cursor () rows = cur . execute ( session [ \"sqlquery\" ]) . fetchall () return { \"result\" : rows } return { \"result\" : \"No query given\" } create_connection ( db_file ) \u00b6 create a database connection to the SQLite database specified by db_file :param db_file: database file :return: Connection object or None Source code in oteapi/strategies/parse/application_vnd_sqlite.py def create_connection ( db_file ): \"\"\"create a database connection to the SQLite database specified by db_file :param db_file: database file :return: Connection object or None \"\"\" conn = None try : conn = sqlite3 . connect ( db_file ) return conn except sqlite3 . Error as exc : print ( exc ) return conn excel_xlsx \u00b6 Strategy class for workbook/xlsx. XLSXParseDataModel ( BaseModel ) pydantic-model \u00b6 Data model for retrieving a rectangular section of an Excel sheet. Source code in oteapi/strategies/parse/excel_xlsx.py class XLSXParseDataModel ( BaseModel ): \"\"\"Data model for retrieving a rectangular section of an Excel sheet.\"\"\" worksheet : str = Field ( ... , description = \"Name of worksheet to load.\" ) row_from : Optional [ int ] = Field ( None , description = \"Excel row number of first row. Defaults to first assigned row.\" , ) col_from : Optional [ Union [ int , str ]] = Field ( None , description = ( \"Excel column number or label of first column. Defaults to first assigned \" \"column.\" ), ) row_to : Optional [ int ] = Field ( None , description = \"Excel row number of last row. Defaults to last assigned row.\" ) col_to : Optional [ Union [ int , str ]] = Field ( None , description = ( \"Excel column number or label of last column. Defaults to last assigned \" \"column.\" ), ) header_row : Optional [ int ] = Field ( None , description = ( \"Row number with the headers. Defaults to `1` if header is given, \" \"otherwise `None`.\" ), ) header : Optional [ List [ str ]] = Field ( None , description = ( \"Optional list of column names, specifying the columns to return. \" \"These names they should match cells in `header_row`.\" ), ) new_header : Optional [ List [ str ]] = Field ( None , description = ( \"Optional list of new column names replacing `header` in the output.\" ), ) col_from : Union [ int , str ] pydantic-field \u00b6 Excel column number or label of first column. Defaults to first assigned column. col_to : Union [ int , str ] pydantic-field \u00b6 Excel column number or label of last column. Defaults to last assigned column. header : List [ str ] pydantic-field \u00b6 Optional list of column names, specifying the columns to return. These names they should match cells in header_row . header_row : int pydantic-field \u00b6 Row number with the headers. Defaults to 1 if header is given, otherwise None . new_header : List [ str ] pydantic-field \u00b6 Optional list of new column names replacing header in the output. row_from : int pydantic-field \u00b6 Excel row number of first row. Defaults to first assigned row. row_to : int pydantic-field \u00b6 Excel row number of last row. Defaults to last assigned row. worksheet : str pydantic-field required \u00b6 Name of worksheet to load. XLSXParseStrategy dataclass \u00b6 Parse strategy for Excel XLSX files. Registers strategies : (\"mediaType\", \"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\") Source code in oteapi/strategies/parse/excel_xlsx.py @dataclass @StrategyFactory . register ( ( \"mediaType\" , \"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\" ) ) class XLSXParseStrategy : \"\"\"Parse strategy for Excel XLSX files. **Registers strategies**: - `(\"mediaType\", \"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\")` \"\"\" resource_config : \"ResourceConfig\" def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Initialize.\"\"\" return {} def parse ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Parses selected region of an excel file. Returns: A dict with column-name/column-value pairs. The values are lists. \"\"\" model = XLSXParseDataModel ( ** self . resource_config . configuration , extra = Extra . ignore ) downloader = create_download_strategy ( self . resource_config ) output = downloader . get () cache = DataCache ( self . resource_config . configuration ) with cache . getfile ( key = output [ \"key\" ], suffix = \".xlsx\" ) as filename : workbook = load_workbook ( filename = filename , read_only = True , data_only = True ) worksheet = workbook [ model . worksheet ] set_model_defaults ( model , worksheet ) columns = get_column_indices ( model , worksheet ) data = [] for row in worksheet . iter_rows ( min_row = model . row_from , max_row = model . row_to , min_col = min ( columns ), max_col = max ( columns ), ): data . append ([ row [ c - 1 ] . value for c in columns ]) if model . header_row : row = worksheet . iter_rows ( min_row = model . header_row , max_row = model . header_row , min_col = min ( columns ), max_col = max ( columns ), ) . __next__ () header = [ row [ c - 1 ] . value for c in columns ] else : header = None if model . new_header : nhead = len ( header ) if header else len ( data [ 0 ]) if data else 0 if len ( model . new_header ) != nhead : raise TypeError ( f \"length of `new_header` (= { len ( model . new_header ) } ) \" f \"doesn't match number of columns (= { len ( header ) if header else 0 } )\" ) if header : for i , val in enumerate ( model . new_header ): if val is not None : header [ i ] = val elif data : header = model . new_header if header is None : header = [ get_column_letter ( col + 1 ) for col in range ( len ( data ))] transposed = list ( map ( list , zip ( * data ))) return { k : v for k , v in zip ( header , transposed )} initialize ( self , session = None ) \u00b6 Initialize. Source code in oteapi/strategies/parse/excel_xlsx.py def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Initialize.\"\"\" return {} parse ( self , session = None ) \u00b6 Parses selected region of an excel file. Returns: Type Description Dict[str, Any] A dict with column-name/column-value pairs. The values are lists. Source code in oteapi/strategies/parse/excel_xlsx.py def parse ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Parses selected region of an excel file. Returns: A dict with column-name/column-value pairs. The values are lists. \"\"\" model = XLSXParseDataModel ( ** self . resource_config . configuration , extra = Extra . ignore ) downloader = create_download_strategy ( self . resource_config ) output = downloader . get () cache = DataCache ( self . resource_config . configuration ) with cache . getfile ( key = output [ \"key\" ], suffix = \".xlsx\" ) as filename : workbook = load_workbook ( filename = filename , read_only = True , data_only = True ) worksheet = workbook [ model . worksheet ] set_model_defaults ( model , worksheet ) columns = get_column_indices ( model , worksheet ) data = [] for row in worksheet . iter_rows ( min_row = model . row_from , max_row = model . row_to , min_col = min ( columns ), max_col = max ( columns ), ): data . append ([ row [ c - 1 ] . value for c in columns ]) if model . header_row : row = worksheet . iter_rows ( min_row = model . header_row , max_row = model . header_row , min_col = min ( columns ), max_col = max ( columns ), ) . __next__ () header = [ row [ c - 1 ] . value for c in columns ] else : header = None if model . new_header : nhead = len ( header ) if header else len ( data [ 0 ]) if data else 0 if len ( model . new_header ) != nhead : raise TypeError ( f \"length of `new_header` (= { len ( model . new_header ) } ) \" f \"doesn't match number of columns (= { len ( header ) if header else 0 } )\" ) if header : for i , val in enumerate ( model . new_header ): if val is not None : header [ i ] = val elif data : header = model . new_header if header is None : header = [ get_column_letter ( col + 1 ) for col in range ( len ( data ))] transposed = list ( map ( list , zip ( * data ))) return { k : v for k , v in zip ( header , transposed )} get_column_indices ( model , worksheet ) \u00b6 Helper function returning a list of column indices. Parameters: Name Type Description Default model XLSXParseDataModel The parsed data model. required worksheet Worksheet Excel worksheet, from which the header values will be retrieved. required Returns: Type Description Iterable[int] A list of column indices. Source code in oteapi/strategies/parse/excel_xlsx.py def get_column_indices ( model : XLSXParseDataModel , worksheet : \"Worksheet\" ) -> \"Iterable[int]\" : \"\"\"Helper function returning a list of column indices. Parameters: model: The parsed data model. worksheet: Excel worksheet, from which the header values will be retrieved. Returns: A list of column indices. \"\"\" if not isinstance ( model . col_from , int ) or not isinstance ( model . col_to , int ): raise TypeError ( \"Expected `model.col_from` and `model.col_to` to be integers.\" ) if model . header : header_dict = { worksheet . cell ( model . header_row , col ) . value : col for col in range ( model . col_from , model . col_to + 1 ) } return [ header_dict [ h ] for h in model . header ] return range ( model . col_from , model . col_to + 1 ) set_model_defaults ( model , worksheet ) \u00b6 Update data model model with default values obtained from worksheet . Parameters: Name Type Description Default model XLSXParseDataModel The parsed data model. required worksheet Worksheet Excel worksheet, from which the default values will be obtained. required Source code in oteapi/strategies/parse/excel_xlsx.py def set_model_defaults ( model : XLSXParseDataModel , worksheet : \"Worksheet\" ) -> None : \"\"\"Update data model `model` with default values obtained from `worksheet`. Parameters: model: The parsed data model. worksheet: Excel worksheet, from which the default values will be obtained. \"\"\" if model . row_from is None : if model . header : # assume that data starts on the first row after the header model . row_from = model . header_row + 1 if model . header_row else 1 else : model . row_from = worksheet . min_row if model . row_to is None : model . row_to = worksheet . max_row if model . col_from is None : model . col_from = worksheet . min_column elif isinstance ( model . col_from , str ): model . col_from = column_index_from_string ( model . col_from ) if model . col_to is None : model . col_to = worksheet . max_column elif isinstance ( model . col_to , str ): model . col_to = column_index_from_string ( model . col_to ) if model . header and not model . header_row : model . header_row = 1 image_jpeg \u00b6 Strategy class for image/jpg. ImageDataParseStrategy dataclass \u00b6 Parse strategy for images. Registers strategies : (\"mediaType\", \"image/jpg\") (\"mediaType\", \"image/jpeg\") (\"mediaType\", \"image/j2p\") (\"mediaType\", \"image/png\") (\"mediaType\", \"image/gif\") (\"mediaType\", \"image/tiff\") (\"mediaType\", \"image/eps\") Source code in oteapi/strategies/parse/image_jpeg.py @dataclass @StrategyFactory . register ( ( \"mediaType\" , \"image/jpg\" ), ( \"mediaType\" , \"image/jpeg\" ), ( \"mediaType\" , \"image/j2p\" ), ( \"mediaType\" , \"image/png\" ), ( \"mediaType\" , \"image/gif\" ), ( \"mediaType\" , \"image/tiff\" ), ( \"mediaType\" , \"image/eps\" ), ) class ImageDataParseStrategy : \"\"\"Parse strategy for images. **Registers strategies**: - `(\"mediaType\", \"image/jpg\")` - `(\"mediaType\", \"image/jpeg\")` - `(\"mediaType\", \"image/j2p\")` - `(\"mediaType\", \"image/png\")` - `(\"mediaType\", \"image/gif\")` - `(\"mediaType\", \"image/tiff\")` - `(\"mediaType\", \"image/eps\")` \"\"\" resource_config : \"ResourceConfig\" def __post_init__ ( self ): self . localpath = \"/ote-data\" self . filename = self . resource_config . configuration [ \"artifactName\" ] if self . resource_config . configuration : self . conf = self . resource_config . configuration else : self . conf = {} def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Initialize.\"\"\" return {} def parse ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : if session is not None : self . conf . update ( session ) parsedOutput = {} if \"crop\" in self . conf : print ( \"cropping!\" ) im = Image . open ( f \" { self . localpath } / { self . filename } \" ) crop = self . conf [ \"crop\" ] im_cropped = im . crop ( tuple ( crop )) cropped_filename = f \" { self . localpath } /cropped_ { self . filename } \" im_cropped . save ( cropped_filename ) parsedOutput [ \"cropped_filename\" ] = cropped_filename parsedOutput [ \"parseImage\" ] = \"Done\" return parsedOutput initialize ( self , session = None ) \u00b6 Initialize. Source code in oteapi/strategies/parse/image_jpeg.py def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Initialize.\"\"\" return {} text_csv \u00b6 Strategy class for text/csv. CSVParseStrategy dataclass \u00b6 Parse strategy for CSV files. Registers strategies : (\"mediaType\", \"text/csv\") Source code in oteapi/strategies/parse/text_csv.py @dataclass @StrategyFactory . register (( \"mediaType\" , \"text/csv\" )) class CSVParseStrategy : \"\"\"Parse strategy for CSV files. **Registers strategies**: - `(\"mediaType\", \"text/csv\")` \"\"\" resource_config : \"ResourceConfig\" def parse ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Parse CSV.\"\"\" print ( \"CSV in action!\" ) return {} def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Initialize.\"\"\" return {} initialize ( self , session = None ) \u00b6 Initialize. Source code in oteapi/strategies/parse/text_csv.py def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Initialize.\"\"\" return {} parse ( self , session = None ) \u00b6 Parse CSV. Source code in oteapi/strategies/parse/text_csv.py def parse ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Parse CSV.\"\"\" print ( \"CSV in action!\" ) return {} text_json \u00b6 Strategy class for text/json. JSONDataParseStrategy dataclass \u00b6 Parse strategy for JSON. Registers strategies : (\"mediaType\", \"text/json\") Source code in oteapi/strategies/parse/text_json.py @dataclass @StrategyFactory . register (( \"mediaType\" , \"text/json\" )) class JSONDataParseStrategy : \"\"\"Parse strategy for JSON. **Registers strategies**: - `(\"mediaType\", \"text/json\")` \"\"\" resource_config : \"ResourceConfig\" def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Initialize.\"\"\" return {} def parse ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Parse json.\"\"\" downloader = create_download_strategy ( self . resource_config ) output = downloader . get () cache = DataCache ( self . resource_config . configuration ) content = cache . get ( output [ \"key\" ]) if isinstance ( content , dict ): return content return json . loads ( content ) initialize ( self , session = None ) \u00b6 Initialize. Source code in oteapi/strategies/parse/text_json.py def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Initialize.\"\"\" return {} parse ( self , session = None ) \u00b6 Parse json. Source code in oteapi/strategies/parse/text_json.py def parse ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Parse json.\"\"\" downloader = create_download_strategy ( self . resource_config ) output = downloader . get () cache = DataCache ( self . resource_config . configuration ) content = cache . get ( output [ \"key\" ]) if isinstance ( content , dict ): return content return json . loads ( content ) transformation special \u00b6 celery_remote \u00b6 Transformation Plugin that uses the Celery framework to call remote workers. CeleryConfig ( BaseModel ) pydantic-model \u00b6 Celery configuration. Source code in oteapi/strategies/transformation/celery_remote.py class CeleryConfig ( BaseModel ): \"\"\"Celery configuration.\"\"\" taskName : str = Field ( ... , description = \"A task name.\" ) args : List [ Any ] = Field ( ... , description = \"List of arguments for the task.\" ) args : List [ Any ] pydantic-field required \u00b6 List of arguments for the task. taskName : str pydantic-field required \u00b6 A task name. CeleryRemoteStrategy dataclass \u00b6 Submit job to remote Celery runner. Registers strategies : (\"transformation_type\", \"celery/remote\") Source code in oteapi/strategies/transformation/celery_remote.py @dataclass @StrategyFactory . register (( \"transformation_type\" , \"celery/remote\" )) class CeleryRemoteStrategy : \"\"\"Submit job to remote Celery runner. **Registers strategies**: - `(\"transformation_type\", \"celery/remote\")` \"\"\" transformation_config : \"TransformationConfig\" def run ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Run a job, return a job ID.\"\"\" config = self . transformation_config . configuration celeryConfig = CeleryConfig () if config is None else CeleryConfig ( ** config ) result = app . send_task ( celeryConfig . taskName , celeryConfig . args , kwargs = session ) return { \"result\" : result . task_id } def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Initialize a job.\"\"\" return {} def status ( self , task_id : str ) -> TransformationStatus : \"\"\"Get job status.\"\"\" result = AsyncResult ( id = task_id , app = app ) return TransformationStatus ( id = task_id , status = result . state ) def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Get transformation.\"\"\" # TODO: update and return global state # pylint: disable=fixme return {} get ( self , session = None ) \u00b6 Get transformation. Source code in oteapi/strategies/transformation/celery_remote.py def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Get transformation.\"\"\" # TODO: update and return global state # pylint: disable=fixme return {} initialize ( self , session = None ) \u00b6 Initialize a job. Source code in oteapi/strategies/transformation/celery_remote.py def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Initialize a job.\"\"\" return {} run ( self , session = None ) \u00b6 Run a job, return a job ID. Source code in oteapi/strategies/transformation/celery_remote.py def run ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Run a job, return a job ID.\"\"\" config = self . transformation_config . configuration celeryConfig = CeleryConfig () if config is None else CeleryConfig ( ** config ) result = app . send_task ( celeryConfig . taskName , celeryConfig . args , kwargs = session ) return { \"result\" : result . task_id } status ( self , task_id ) \u00b6 Get job status. Source code in oteapi/strategies/transformation/celery_remote.py def status ( self , task_id : str ) -> TransformationStatus : \"\"\"Get job status.\"\"\" result = AsyncResult ( id = task_id , app = app ) return TransformationStatus ( id = task_id , status = result . state )","title":"OTE-API Core Strategies"},{"location":"all_strategies/#ote-api-core-strategies","text":"This page provides documentation for the oteapi.strategies submodule, where all the core OTE-API strategies are located. These strategies will always be available when setting up a server based on the OTE-API Core package.","title":"OTE-API Core Strategies"},{"location":"all_strategies/#oteapi.strategies.download","text":"","title":"download"},{"location":"all_strategies/#oteapi.strategies.download.file","text":"Download strategy class for the file scheme.","title":"file"},{"location":"all_strategies/#oteapi.strategies.download.file.FileConfig","text":"File-specific Configuration Data Model. Source code in oteapi/strategies/download/file.py class FileConfig ( BaseModel ): \"\"\"File-specific Configuration Data Model.\"\"\" text : bool = Field ( False , description = ( \"Whether the file should be opened in text mode. If `False`, the file will\" \" be opened in bytes mode.\" ), ) encoding : Optional [ str ] = Field ( None , description = ( \"Encoding used when opening the file. The default is platform dependent.\" ), )","title":"FileConfig"},{"location":"all_strategies/#oteapi.strategies.download.file.FileConfig.encoding","text":"Encoding used when opening the file. The default is platform dependent.","title":"encoding"},{"location":"all_strategies/#oteapi.strategies.download.file.FileConfig.text","text":"Whether the file should be opened in text mode. If False , the file will be opened in bytes mode.","title":"text"},{"location":"all_strategies/#oteapi.strategies.download.file.FileStrategy","text":"Strategy for retrieving data from a local file. Registers strategies : (\"scheme\", \"file\") Source code in oteapi/strategies/download/file.py @dataclass @StrategyFactory . register (( \"scheme\" , \"file\" )) class FileStrategy : \"\"\"Strategy for retrieving data from a local file. **Registers strategies**: - `(\"scheme\", \"file\")` \"\"\" resource_config : \"ResourceConfig\" def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Initialize.\"\"\" return {} def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Read local file.\"\"\" if ( self . resource_config . downloadUrl is None or self . resource_config . downloadUrl . scheme != \"file\" ): raise ValueError ( \"Expected 'downloadUrl' to have scheme 'file' in the configuration.\" ) filename = Path ( self . resource_config . downloadUrl . host ) . resolve () cache = DataCache ( self . resource_config . configuration ) if cache . config . accessKey and cache . config . accessKey in cache : key = cache . config . accessKey else : config = FileConfig ( ** self . resource_config . configuration , extra = Extra . ignore ) key = cache . add ( filename . read_text ( encoding = config . encoding ) if config . text else filename . read_bytes () ) return { \"key\" : key }","title":"FileStrategy"},{"location":"all_strategies/#oteapi.strategies.download.file.FileStrategy.get","text":"Read local file. Source code in oteapi/strategies/download/file.py def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Read local file.\"\"\" if ( self . resource_config . downloadUrl is None or self . resource_config . downloadUrl . scheme != \"file\" ): raise ValueError ( \"Expected 'downloadUrl' to have scheme 'file' in the configuration.\" ) filename = Path ( self . resource_config . downloadUrl . host ) . resolve () cache = DataCache ( self . resource_config . configuration ) if cache . config . accessKey and cache . config . accessKey in cache : key = cache . config . accessKey else : config = FileConfig ( ** self . resource_config . configuration , extra = Extra . ignore ) key = cache . add ( filename . read_text ( encoding = config . encoding ) if config . text else filename . read_bytes () ) return { \"key\" : key }","title":"get()"},{"location":"all_strategies/#oteapi.strategies.download.file.FileStrategy.initialize","text":"Initialize. Source code in oteapi/strategies/download/file.py def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Initialize.\"\"\" return {}","title":"initialize()"},{"location":"all_strategies/#oteapi.strategies.download.https","text":"Download strategy class for http/https","title":"https"},{"location":"all_strategies/#oteapi.strategies.download.https.HTTPSStrategy","text":"Strategy for retrieving data via http. Registers strategies : (\"scheme\", \"http\") (\"scheme\", \"https\") Source code in oteapi/strategies/download/https.py @dataclass @StrategyFactory . register (( \"scheme\" , \"http\" ), ( \"scheme\" , \"https\" )) class HTTPSStrategy : \"\"\"Strategy for retrieving data via http. **Registers strategies**: - `(\"scheme\", \"http\")` - `(\"scheme\", \"https\")` \"\"\" resource_config : \"ResourceConfig\" def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Initialize.\"\"\" return {} def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Download via http/https and store on local cache.\"\"\" cache = DataCache ( self . resource_config . configuration ) if cache . config . accessKey and cache . config . accessKey in cache : key = cache . config . accessKey else : if not self . resource_config . downloadUrl : raise ValueError ( \"downloadUrl not defined in configuration.\" ) req = requests . get ( self . resource_config . downloadUrl , allow_redirects = True ) key = cache . add ( req . content ) return { \"key\" : key }","title":"HTTPSStrategy"},{"location":"all_strategies/#oteapi.strategies.download.https.HTTPSStrategy.get","text":"Download via http/https and store on local cache. Source code in oteapi/strategies/download/https.py def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Download via http/https and store on local cache.\"\"\" cache = DataCache ( self . resource_config . configuration ) if cache . config . accessKey and cache . config . accessKey in cache : key = cache . config . accessKey else : if not self . resource_config . downloadUrl : raise ValueError ( \"downloadUrl not defined in configuration.\" ) req = requests . get ( self . resource_config . downloadUrl , allow_redirects = True ) key = cache . add ( req . content ) return { \"key\" : key }","title":"get()"},{"location":"all_strategies/#oteapi.strategies.download.https.HTTPSStrategy.initialize","text":"Initialize. Source code in oteapi/strategies/download/https.py def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Initialize.\"\"\" return {}","title":"initialize()"},{"location":"all_strategies/#oteapi.strategies.download.sftp","text":"Strategy class for sftp/ftp","title":"sftp"},{"location":"all_strategies/#oteapi.strategies.download.sftp.SFTPStrategy","text":"Strategy for retrieving data via sftp. Registers strategies : (\"scheme\", \"ftp\") (\"scheme\", \"sftp\") Source code in oteapi/strategies/download/sftp.py @dataclass @StrategyFactory . register (( \"scheme\" , \"sftp\" ), ( \"scheme\" , \"ftp\" )) class SFTPStrategy : \"\"\"Strategy for retrieving data via sftp. **Registers strategies**: - `(\"scheme\", \"ftp\")` - `(\"scheme\", \"sftp\")` \"\"\" resource_config : \"ResourceConfig\" def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Initialize.\"\"\" return {} def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Download via sftp\"\"\" cache = DataCache ( self . resource_config . configuration ) if cache . config . accessKey and cache . config . accessKey in cache : key = cache . config . accessKey else : # Setup connection options cnopts = pysftp . CnOpts () cnopts . hostkeys = None if not self . resource_config . accessUrl : raise ValueError ( \"accessUrl is not defined in configuration.\" ) # open connection and store data locally with pysftp . Connection ( host = self . resource_config . accessUrl . host , username = self . resource_config . accessUrl . user , password = self . resource_config . accessUrl . password , port = self . resource_config . accessUrl . port , cnopts = cnopts , ) as sftp : # Because of insane locking on Windows, we have to close # the downloaded file before adding it to the cache with NamedTemporaryFile ( prefix = \"oteapi-sftp-\" , delete = False ) as handle : localpath = Path ( handle . name ) . resolve () try : sftp . get ( self . resource_config . accessUrl . path , localpath = localpath ) key = cache . add ( localpath . read_bytes ()) finally : localpath . unlink () return { \"key\" : key }","title":"SFTPStrategy"},{"location":"all_strategies/#oteapi.strategies.download.sftp.SFTPStrategy.get","text":"Download via sftp Source code in oteapi/strategies/download/sftp.py def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Download via sftp\"\"\" cache = DataCache ( self . resource_config . configuration ) if cache . config . accessKey and cache . config . accessKey in cache : key = cache . config . accessKey else : # Setup connection options cnopts = pysftp . CnOpts () cnopts . hostkeys = None if not self . resource_config . accessUrl : raise ValueError ( \"accessUrl is not defined in configuration.\" ) # open connection and store data locally with pysftp . Connection ( host = self . resource_config . accessUrl . host , username = self . resource_config . accessUrl . user , password = self . resource_config . accessUrl . password , port = self . resource_config . accessUrl . port , cnopts = cnopts , ) as sftp : # Because of insane locking on Windows, we have to close # the downloaded file before adding it to the cache with NamedTemporaryFile ( prefix = \"oteapi-sftp-\" , delete = False ) as handle : localpath = Path ( handle . name ) . resolve () try : sftp . get ( self . resource_config . accessUrl . path , localpath = localpath ) key = cache . add ( localpath . read_bytes ()) finally : localpath . unlink () return { \"key\" : key }","title":"get()"},{"location":"all_strategies/#oteapi.strategies.download.sftp.SFTPStrategy.initialize","text":"Initialize. Source code in oteapi/strategies/download/sftp.py def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Initialize.\"\"\" return {}","title":"initialize()"},{"location":"all_strategies/#oteapi.strategies.filter","text":"","title":"filter"},{"location":"all_strategies/#oteapi.strategies.filter.crop_filter","text":"Demo-filter strategy","title":"crop_filter"},{"location":"all_strategies/#oteapi.strategies.filter.crop_filter.CropDataModel","text":"Configuration model for crop data. Source code in oteapi/strategies/filter/crop_filter.py class CropDataModel ( BaseModel ): \"\"\"Configuration model for crop data.\"\"\" crop : List [ int ] = Field ( ... , description = \"List of image cropping details.\" )","title":"CropDataModel"},{"location":"all_strategies/#oteapi.strategies.filter.crop_filter.CropDataModel.crop","text":"List of image cropping details.","title":"crop"},{"location":"all_strategies/#oteapi.strategies.filter.crop_filter.CropFilter","text":"Strategy for cropping an image. Registers strategies : (\"filterType\", \"filter/crop\") Source code in oteapi/strategies/filter/crop_filter.py @dataclass @StrategyFactory . register (( \"filterType\" , \"filter/crop\" )) class CropFilter : \"\"\"Strategy for cropping an image. **Registers strategies**: - `(\"filterType\", \"filter/crop\")` \"\"\" filter_config : \"FilterConfig\" def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Initialize strategy and return a dictionary.\"\"\" return { \"result\" : \"collectionid\" } def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Execute strategy and return a dictionary\"\"\" cropData = ( CropDataModel ( ** self . filter_config . configuration ) if self . filter_config . configuration else CropDataModel () ) return { \"imagecrop\" : cropData . crop }","title":"CropFilter"},{"location":"all_strategies/#oteapi.strategies.filter.crop_filter.CropFilter.get","text":"Execute strategy and return a dictionary Source code in oteapi/strategies/filter/crop_filter.py def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Execute strategy and return a dictionary\"\"\" cropData = ( CropDataModel ( ** self . filter_config . configuration ) if self . filter_config . configuration else CropDataModel () ) return { \"imagecrop\" : cropData . crop }","title":"get()"},{"location":"all_strategies/#oteapi.strategies.filter.crop_filter.CropFilter.initialize","text":"Initialize strategy and return a dictionary. Source code in oteapi/strategies/filter/crop_filter.py def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Initialize strategy and return a dictionary.\"\"\" return { \"result\" : \"collectionid\" }","title":"initialize()"},{"location":"all_strategies/#oteapi.strategies.filter.sql_query_filter","text":"SQL query filter strategy.","title":"sql_query_filter"},{"location":"all_strategies/#oteapi.strategies.filter.sql_query_filter.SQLQueryFilter","text":"Strategy for a SQL query filter. Registers strategies : (\"filterType\", \"filter/sql\") Source code in oteapi/strategies/filter/sql_query_filter.py @dataclass @StrategyFactory . register (( \"filterType\" , \"filter/sql\" )) class SQLQueryFilter : \"\"\"Strategy for a SQL query filter. **Registers strategies**: - `(\"filterType\", \"filter/sql\")` \"\"\" filter_config : \"FilterConfig\" def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Initialize strategy and return a dictionary\"\"\" queryData = SqlQueryDataModel ( ** { \"query\" : self . filter_config . query }) return { \"sqlquery\" : queryData . query } def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Execute strategy and return a dictionary\"\"\" return {}","title":"SQLQueryFilter"},{"location":"all_strategies/#oteapi.strategies.filter.sql_query_filter.SQLQueryFilter.get","text":"Execute strategy and return a dictionary Source code in oteapi/strategies/filter/sql_query_filter.py def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Execute strategy and return a dictionary\"\"\" return {}","title":"get()"},{"location":"all_strategies/#oteapi.strategies.filter.sql_query_filter.SQLQueryFilter.initialize","text":"Initialize strategy and return a dictionary Source code in oteapi/strategies/filter/sql_query_filter.py def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Initialize strategy and return a dictionary\"\"\" queryData = SqlQueryDataModel ( ** { \"query\" : self . filter_config . query }) return { \"sqlquery\" : queryData . query }","title":"initialize()"},{"location":"all_strategies/#oteapi.strategies.filter.sql_query_filter.SqlQueryDataModel","text":"SQL Query data model. Source code in oteapi/strategies/filter/sql_query_filter.py class SqlQueryDataModel ( BaseModel ): \"\"\"SQL Query data model.\"\"\" query : str = Field ( ... , description = \"A SQL query string.\" )","title":"SqlQueryDataModel"},{"location":"all_strategies/#oteapi.strategies.filter.sql_query_filter.SqlQueryDataModel.query","text":"A SQL query string.","title":"query"},{"location":"all_strategies/#oteapi.strategies.parse","text":"","title":"parse"},{"location":"all_strategies/#oteapi.strategies.parse.application_vnd_sqlite","text":"Strategy class for application/vnd.sqlite3.","title":"application_vnd_sqlite"},{"location":"all_strategies/#oteapi.strategies.parse.application_vnd_sqlite.SqliteParseStrategy","text":"Parse strategy for SQLite. Registers strategies : (\"mediaType\", \"application/vnd.sqlite3\") Source code in oteapi/strategies/parse/application_vnd_sqlite.py @dataclass @StrategyFactory . register (( \"mediaType\" , \"application/vnd.sqlite3\" )) class SqliteParseStrategy : \"\"\"Parse strategy for SQLite. **Registers strategies**: - `(\"mediaType\", \"application/vnd.sqlite3\")` \"\"\" resource_config : \"ResourceConfig\" def parse ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Parse SQLite query responses.\"\"\" if session is None : raise ValueError ( \"Missing session\" ) if \"sqlquery\" in session : cn = create_connection ( session [ \"filename\" ]) cur = cn . cursor () rows = cur . execute ( session [ \"sqlquery\" ]) . fetchall () return { \"result\" : rows } return { \"result\" : \"No query given\" } def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Initialize.\"\"\" return {}","title":"SqliteParseStrategy"},{"location":"all_strategies/#oteapi.strategies.parse.application_vnd_sqlite.SqliteParseStrategy.initialize","text":"Initialize. Source code in oteapi/strategies/parse/application_vnd_sqlite.py def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Initialize.\"\"\" return {}","title":"initialize()"},{"location":"all_strategies/#oteapi.strategies.parse.application_vnd_sqlite.SqliteParseStrategy.parse","text":"Parse SQLite query responses. Source code in oteapi/strategies/parse/application_vnd_sqlite.py def parse ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Parse SQLite query responses.\"\"\" if session is None : raise ValueError ( \"Missing session\" ) if \"sqlquery\" in session : cn = create_connection ( session [ \"filename\" ]) cur = cn . cursor () rows = cur . execute ( session [ \"sqlquery\" ]) . fetchall () return { \"result\" : rows } return { \"result\" : \"No query given\" }","title":"parse()"},{"location":"all_strategies/#oteapi.strategies.parse.application_vnd_sqlite.create_connection","text":"create a database connection to the SQLite database specified by db_file :param db_file: database file :return: Connection object or None Source code in oteapi/strategies/parse/application_vnd_sqlite.py def create_connection ( db_file ): \"\"\"create a database connection to the SQLite database specified by db_file :param db_file: database file :return: Connection object or None \"\"\" conn = None try : conn = sqlite3 . connect ( db_file ) return conn except sqlite3 . Error as exc : print ( exc ) return conn","title":"create_connection()"},{"location":"all_strategies/#oteapi.strategies.parse.excel_xlsx","text":"Strategy class for workbook/xlsx.","title":"excel_xlsx"},{"location":"all_strategies/#oteapi.strategies.parse.excel_xlsx.XLSXParseDataModel","text":"Data model for retrieving a rectangular section of an Excel sheet. Source code in oteapi/strategies/parse/excel_xlsx.py class XLSXParseDataModel ( BaseModel ): \"\"\"Data model for retrieving a rectangular section of an Excel sheet.\"\"\" worksheet : str = Field ( ... , description = \"Name of worksheet to load.\" ) row_from : Optional [ int ] = Field ( None , description = \"Excel row number of first row. Defaults to first assigned row.\" , ) col_from : Optional [ Union [ int , str ]] = Field ( None , description = ( \"Excel column number or label of first column. Defaults to first assigned \" \"column.\" ), ) row_to : Optional [ int ] = Field ( None , description = \"Excel row number of last row. Defaults to last assigned row.\" ) col_to : Optional [ Union [ int , str ]] = Field ( None , description = ( \"Excel column number or label of last column. Defaults to last assigned \" \"column.\" ), ) header_row : Optional [ int ] = Field ( None , description = ( \"Row number with the headers. Defaults to `1` if header is given, \" \"otherwise `None`.\" ), ) header : Optional [ List [ str ]] = Field ( None , description = ( \"Optional list of column names, specifying the columns to return. \" \"These names they should match cells in `header_row`.\" ), ) new_header : Optional [ List [ str ]] = Field ( None , description = ( \"Optional list of new column names replacing `header` in the output.\" ), )","title":"XLSXParseDataModel"},{"location":"all_strategies/#oteapi.strategies.parse.excel_xlsx.XLSXParseDataModel.col_from","text":"Excel column number or label of first column. Defaults to first assigned column.","title":"col_from"},{"location":"all_strategies/#oteapi.strategies.parse.excel_xlsx.XLSXParseDataModel.col_to","text":"Excel column number or label of last column. Defaults to last assigned column.","title":"col_to"},{"location":"all_strategies/#oteapi.strategies.parse.excel_xlsx.XLSXParseDataModel.header","text":"Optional list of column names, specifying the columns to return. These names they should match cells in header_row .","title":"header"},{"location":"all_strategies/#oteapi.strategies.parse.excel_xlsx.XLSXParseDataModel.header_row","text":"Row number with the headers. Defaults to 1 if header is given, otherwise None .","title":"header_row"},{"location":"all_strategies/#oteapi.strategies.parse.excel_xlsx.XLSXParseDataModel.new_header","text":"Optional list of new column names replacing header in the output.","title":"new_header"},{"location":"all_strategies/#oteapi.strategies.parse.excel_xlsx.XLSXParseDataModel.row_from","text":"Excel row number of first row. Defaults to first assigned row.","title":"row_from"},{"location":"all_strategies/#oteapi.strategies.parse.excel_xlsx.XLSXParseDataModel.row_to","text":"Excel row number of last row. Defaults to last assigned row.","title":"row_to"},{"location":"all_strategies/#oteapi.strategies.parse.excel_xlsx.XLSXParseDataModel.worksheet","text":"Name of worksheet to load.","title":"worksheet"},{"location":"all_strategies/#oteapi.strategies.parse.excel_xlsx.XLSXParseStrategy","text":"Parse strategy for Excel XLSX files. Registers strategies : (\"mediaType\", \"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\") Source code in oteapi/strategies/parse/excel_xlsx.py @dataclass @StrategyFactory . register ( ( \"mediaType\" , \"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\" ) ) class XLSXParseStrategy : \"\"\"Parse strategy for Excel XLSX files. **Registers strategies**: - `(\"mediaType\", \"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\")` \"\"\" resource_config : \"ResourceConfig\" def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Initialize.\"\"\" return {} def parse ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Parses selected region of an excel file. Returns: A dict with column-name/column-value pairs. The values are lists. \"\"\" model = XLSXParseDataModel ( ** self . resource_config . configuration , extra = Extra . ignore ) downloader = create_download_strategy ( self . resource_config ) output = downloader . get () cache = DataCache ( self . resource_config . configuration ) with cache . getfile ( key = output [ \"key\" ], suffix = \".xlsx\" ) as filename : workbook = load_workbook ( filename = filename , read_only = True , data_only = True ) worksheet = workbook [ model . worksheet ] set_model_defaults ( model , worksheet ) columns = get_column_indices ( model , worksheet ) data = [] for row in worksheet . iter_rows ( min_row = model . row_from , max_row = model . row_to , min_col = min ( columns ), max_col = max ( columns ), ): data . append ([ row [ c - 1 ] . value for c in columns ]) if model . header_row : row = worksheet . iter_rows ( min_row = model . header_row , max_row = model . header_row , min_col = min ( columns ), max_col = max ( columns ), ) . __next__ () header = [ row [ c - 1 ] . value for c in columns ] else : header = None if model . new_header : nhead = len ( header ) if header else len ( data [ 0 ]) if data else 0 if len ( model . new_header ) != nhead : raise TypeError ( f \"length of `new_header` (= { len ( model . new_header ) } ) \" f \"doesn't match number of columns (= { len ( header ) if header else 0 } )\" ) if header : for i , val in enumerate ( model . new_header ): if val is not None : header [ i ] = val elif data : header = model . new_header if header is None : header = [ get_column_letter ( col + 1 ) for col in range ( len ( data ))] transposed = list ( map ( list , zip ( * data ))) return { k : v for k , v in zip ( header , transposed )}","title":"XLSXParseStrategy"},{"location":"all_strategies/#oteapi.strategies.parse.excel_xlsx.XLSXParseStrategy.initialize","text":"Initialize. Source code in oteapi/strategies/parse/excel_xlsx.py def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Initialize.\"\"\" return {}","title":"initialize()"},{"location":"all_strategies/#oteapi.strategies.parse.excel_xlsx.XLSXParseStrategy.parse","text":"Parses selected region of an excel file. Returns: Type Description Dict[str, Any] A dict with column-name/column-value pairs. The values are lists. Source code in oteapi/strategies/parse/excel_xlsx.py def parse ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Parses selected region of an excel file. Returns: A dict with column-name/column-value pairs. The values are lists. \"\"\" model = XLSXParseDataModel ( ** self . resource_config . configuration , extra = Extra . ignore ) downloader = create_download_strategy ( self . resource_config ) output = downloader . get () cache = DataCache ( self . resource_config . configuration ) with cache . getfile ( key = output [ \"key\" ], suffix = \".xlsx\" ) as filename : workbook = load_workbook ( filename = filename , read_only = True , data_only = True ) worksheet = workbook [ model . worksheet ] set_model_defaults ( model , worksheet ) columns = get_column_indices ( model , worksheet ) data = [] for row in worksheet . iter_rows ( min_row = model . row_from , max_row = model . row_to , min_col = min ( columns ), max_col = max ( columns ), ): data . append ([ row [ c - 1 ] . value for c in columns ]) if model . header_row : row = worksheet . iter_rows ( min_row = model . header_row , max_row = model . header_row , min_col = min ( columns ), max_col = max ( columns ), ) . __next__ () header = [ row [ c - 1 ] . value for c in columns ] else : header = None if model . new_header : nhead = len ( header ) if header else len ( data [ 0 ]) if data else 0 if len ( model . new_header ) != nhead : raise TypeError ( f \"length of `new_header` (= { len ( model . new_header ) } ) \" f \"doesn't match number of columns (= { len ( header ) if header else 0 } )\" ) if header : for i , val in enumerate ( model . new_header ): if val is not None : header [ i ] = val elif data : header = model . new_header if header is None : header = [ get_column_letter ( col + 1 ) for col in range ( len ( data ))] transposed = list ( map ( list , zip ( * data ))) return { k : v for k , v in zip ( header , transposed )}","title":"parse()"},{"location":"all_strategies/#oteapi.strategies.parse.excel_xlsx.get_column_indices","text":"Helper function returning a list of column indices. Parameters: Name Type Description Default model XLSXParseDataModel The parsed data model. required worksheet Worksheet Excel worksheet, from which the header values will be retrieved. required Returns: Type Description Iterable[int] A list of column indices. Source code in oteapi/strategies/parse/excel_xlsx.py def get_column_indices ( model : XLSXParseDataModel , worksheet : \"Worksheet\" ) -> \"Iterable[int]\" : \"\"\"Helper function returning a list of column indices. Parameters: model: The parsed data model. worksheet: Excel worksheet, from which the header values will be retrieved. Returns: A list of column indices. \"\"\" if not isinstance ( model . col_from , int ) or not isinstance ( model . col_to , int ): raise TypeError ( \"Expected `model.col_from` and `model.col_to` to be integers.\" ) if model . header : header_dict = { worksheet . cell ( model . header_row , col ) . value : col for col in range ( model . col_from , model . col_to + 1 ) } return [ header_dict [ h ] for h in model . header ] return range ( model . col_from , model . col_to + 1 )","title":"get_column_indices()"},{"location":"all_strategies/#oteapi.strategies.parse.excel_xlsx.set_model_defaults","text":"Update data model model with default values obtained from worksheet . Parameters: Name Type Description Default model XLSXParseDataModel The parsed data model. required worksheet Worksheet Excel worksheet, from which the default values will be obtained. required Source code in oteapi/strategies/parse/excel_xlsx.py def set_model_defaults ( model : XLSXParseDataModel , worksheet : \"Worksheet\" ) -> None : \"\"\"Update data model `model` with default values obtained from `worksheet`. Parameters: model: The parsed data model. worksheet: Excel worksheet, from which the default values will be obtained. \"\"\" if model . row_from is None : if model . header : # assume that data starts on the first row after the header model . row_from = model . header_row + 1 if model . header_row else 1 else : model . row_from = worksheet . min_row if model . row_to is None : model . row_to = worksheet . max_row if model . col_from is None : model . col_from = worksheet . min_column elif isinstance ( model . col_from , str ): model . col_from = column_index_from_string ( model . col_from ) if model . col_to is None : model . col_to = worksheet . max_column elif isinstance ( model . col_to , str ): model . col_to = column_index_from_string ( model . col_to ) if model . header and not model . header_row : model . header_row = 1","title":"set_model_defaults()"},{"location":"all_strategies/#oteapi.strategies.parse.image_jpeg","text":"Strategy class for image/jpg.","title":"image_jpeg"},{"location":"all_strategies/#oteapi.strategies.parse.image_jpeg.ImageDataParseStrategy","text":"Parse strategy for images. Registers strategies : (\"mediaType\", \"image/jpg\") (\"mediaType\", \"image/jpeg\") (\"mediaType\", \"image/j2p\") (\"mediaType\", \"image/png\") (\"mediaType\", \"image/gif\") (\"mediaType\", \"image/tiff\") (\"mediaType\", \"image/eps\") Source code in oteapi/strategies/parse/image_jpeg.py @dataclass @StrategyFactory . register ( ( \"mediaType\" , \"image/jpg\" ), ( \"mediaType\" , \"image/jpeg\" ), ( \"mediaType\" , \"image/j2p\" ), ( \"mediaType\" , \"image/png\" ), ( \"mediaType\" , \"image/gif\" ), ( \"mediaType\" , \"image/tiff\" ), ( \"mediaType\" , \"image/eps\" ), ) class ImageDataParseStrategy : \"\"\"Parse strategy for images. **Registers strategies**: - `(\"mediaType\", \"image/jpg\")` - `(\"mediaType\", \"image/jpeg\")` - `(\"mediaType\", \"image/j2p\")` - `(\"mediaType\", \"image/png\")` - `(\"mediaType\", \"image/gif\")` - `(\"mediaType\", \"image/tiff\")` - `(\"mediaType\", \"image/eps\")` \"\"\" resource_config : \"ResourceConfig\" def __post_init__ ( self ): self . localpath = \"/ote-data\" self . filename = self . resource_config . configuration [ \"artifactName\" ] if self . resource_config . configuration : self . conf = self . resource_config . configuration else : self . conf = {} def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Initialize.\"\"\" return {} def parse ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : if session is not None : self . conf . update ( session ) parsedOutput = {} if \"crop\" in self . conf : print ( \"cropping!\" ) im = Image . open ( f \" { self . localpath } / { self . filename } \" ) crop = self . conf [ \"crop\" ] im_cropped = im . crop ( tuple ( crop )) cropped_filename = f \" { self . localpath } /cropped_ { self . filename } \" im_cropped . save ( cropped_filename ) parsedOutput [ \"cropped_filename\" ] = cropped_filename parsedOutput [ \"parseImage\" ] = \"Done\" return parsedOutput","title":"ImageDataParseStrategy"},{"location":"all_strategies/#oteapi.strategies.parse.image_jpeg.ImageDataParseStrategy.initialize","text":"Initialize. Source code in oteapi/strategies/parse/image_jpeg.py def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Initialize.\"\"\" return {}","title":"initialize()"},{"location":"all_strategies/#oteapi.strategies.parse.text_csv","text":"Strategy class for text/csv.","title":"text_csv"},{"location":"all_strategies/#oteapi.strategies.parse.text_csv.CSVParseStrategy","text":"Parse strategy for CSV files. Registers strategies : (\"mediaType\", \"text/csv\") Source code in oteapi/strategies/parse/text_csv.py @dataclass @StrategyFactory . register (( \"mediaType\" , \"text/csv\" )) class CSVParseStrategy : \"\"\"Parse strategy for CSV files. **Registers strategies**: - `(\"mediaType\", \"text/csv\")` \"\"\" resource_config : \"ResourceConfig\" def parse ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Parse CSV.\"\"\" print ( \"CSV in action!\" ) return {} def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Initialize.\"\"\" return {}","title":"CSVParseStrategy"},{"location":"all_strategies/#oteapi.strategies.parse.text_csv.CSVParseStrategy.initialize","text":"Initialize. Source code in oteapi/strategies/parse/text_csv.py def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Initialize.\"\"\" return {}","title":"initialize()"},{"location":"all_strategies/#oteapi.strategies.parse.text_csv.CSVParseStrategy.parse","text":"Parse CSV. Source code in oteapi/strategies/parse/text_csv.py def parse ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Parse CSV.\"\"\" print ( \"CSV in action!\" ) return {}","title":"parse()"},{"location":"all_strategies/#oteapi.strategies.parse.text_json","text":"Strategy class for text/json.","title":"text_json"},{"location":"all_strategies/#oteapi.strategies.parse.text_json.JSONDataParseStrategy","text":"Parse strategy for JSON. Registers strategies : (\"mediaType\", \"text/json\") Source code in oteapi/strategies/parse/text_json.py @dataclass @StrategyFactory . register (( \"mediaType\" , \"text/json\" )) class JSONDataParseStrategy : \"\"\"Parse strategy for JSON. **Registers strategies**: - `(\"mediaType\", \"text/json\")` \"\"\" resource_config : \"ResourceConfig\" def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Initialize.\"\"\" return {} def parse ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Parse json.\"\"\" downloader = create_download_strategy ( self . resource_config ) output = downloader . get () cache = DataCache ( self . resource_config . configuration ) content = cache . get ( output [ \"key\" ]) if isinstance ( content , dict ): return content return json . loads ( content )","title":"JSONDataParseStrategy"},{"location":"all_strategies/#oteapi.strategies.parse.text_json.JSONDataParseStrategy.initialize","text":"Initialize. Source code in oteapi/strategies/parse/text_json.py def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Initialize.\"\"\" return {}","title":"initialize()"},{"location":"all_strategies/#oteapi.strategies.parse.text_json.JSONDataParseStrategy.parse","text":"Parse json. Source code in oteapi/strategies/parse/text_json.py def parse ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Parse json.\"\"\" downloader = create_download_strategy ( self . resource_config ) output = downloader . get () cache = DataCache ( self . resource_config . configuration ) content = cache . get ( output [ \"key\" ]) if isinstance ( content , dict ): return content return json . loads ( content )","title":"parse()"},{"location":"all_strategies/#oteapi.strategies.transformation","text":"","title":"transformation"},{"location":"all_strategies/#oteapi.strategies.transformation.celery_remote","text":"Transformation Plugin that uses the Celery framework to call remote workers.","title":"celery_remote"},{"location":"all_strategies/#oteapi.strategies.transformation.celery_remote.CeleryConfig","text":"Celery configuration. Source code in oteapi/strategies/transformation/celery_remote.py class CeleryConfig ( BaseModel ): \"\"\"Celery configuration.\"\"\" taskName : str = Field ( ... , description = \"A task name.\" ) args : List [ Any ] = Field ( ... , description = \"List of arguments for the task.\" )","title":"CeleryConfig"},{"location":"all_strategies/#oteapi.strategies.transformation.celery_remote.CeleryConfig.args","text":"List of arguments for the task.","title":"args"},{"location":"all_strategies/#oteapi.strategies.transformation.celery_remote.CeleryConfig.taskName","text":"A task name.","title":"taskName"},{"location":"all_strategies/#oteapi.strategies.transformation.celery_remote.CeleryRemoteStrategy","text":"Submit job to remote Celery runner. Registers strategies : (\"transformation_type\", \"celery/remote\") Source code in oteapi/strategies/transformation/celery_remote.py @dataclass @StrategyFactory . register (( \"transformation_type\" , \"celery/remote\" )) class CeleryRemoteStrategy : \"\"\"Submit job to remote Celery runner. **Registers strategies**: - `(\"transformation_type\", \"celery/remote\")` \"\"\" transformation_config : \"TransformationConfig\" def run ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Run a job, return a job ID.\"\"\" config = self . transformation_config . configuration celeryConfig = CeleryConfig () if config is None else CeleryConfig ( ** config ) result = app . send_task ( celeryConfig . taskName , celeryConfig . args , kwargs = session ) return { \"result\" : result . task_id } def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Initialize a job.\"\"\" return {} def status ( self , task_id : str ) -> TransformationStatus : \"\"\"Get job status.\"\"\" result = AsyncResult ( id = task_id , app = app ) return TransformationStatus ( id = task_id , status = result . state ) def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Get transformation.\"\"\" # TODO: update and return global state # pylint: disable=fixme return {}","title":"CeleryRemoteStrategy"},{"location":"all_strategies/#oteapi.strategies.transformation.celery_remote.CeleryRemoteStrategy.get","text":"Get transformation. Source code in oteapi/strategies/transformation/celery_remote.py def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Get transformation.\"\"\" # TODO: update and return global state # pylint: disable=fixme return {}","title":"get()"},{"location":"all_strategies/#oteapi.strategies.transformation.celery_remote.CeleryRemoteStrategy.initialize","text":"Initialize a job. Source code in oteapi/strategies/transformation/celery_remote.py def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Initialize a job.\"\"\" return {}","title":"initialize()"},{"location":"all_strategies/#oteapi.strategies.transformation.celery_remote.CeleryRemoteStrategy.run","text":"Run a job, return a job ID. Source code in oteapi/strategies/transformation/celery_remote.py def run ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Run a job, return a job ID.\"\"\" config = self . transformation_config . configuration celeryConfig = CeleryConfig () if config is None else CeleryConfig ( ** config ) result = app . send_task ( celeryConfig . taskName , celeryConfig . args , kwargs = session ) return { \"result\" : result . task_id }","title":"run()"},{"location":"all_strategies/#oteapi.strategies.transformation.celery_remote.CeleryRemoteStrategy.status","text":"Get job status. Source code in oteapi/strategies/transformation/celery_remote.py def status ( self , task_id : str ) -> TransformationStatus : \"\"\"Get job status.\"\"\" result = AsyncResult ( id = task_id , app = app ) return TransformationStatus ( id = task_id , status = result . state )","title":"status()"},{"location":"api_reference/datacache/datacache/","text":"datacache \u00b6 Data cache based on DiskCache. See Python-DiskCache . Features: Persistent cache between sessions. Default keys are hashes of the stored data. Automatic expiration of cached data. Sessions can selectively be cleaned up via tags. Store small values in SQLite database and large values in files. Underlying library is actively developed and tested on Linux, Mac and Windows. High performance. DataCache \u00b6 Initialize a cache instance with the given download configuration. This class is also available to import from oteapi.datacache , e.g.: from oteapi.datacache import DataCache Parameters: Name Type Description Default config Union[DataCacheConfig, Dict[str, Any]] Download configurations. None cache_dir Optional[Union[Path, str]] Cache directory overriding the config. None Attributes: Name Type Description config DataCacheConfig instance. cache_dir Subdirectory used for the Path to cache directory, e.g., \"my_oteapi\" . Source code in oteapi/datacache/datacache.py class DataCache : \"\"\"Initialize a cache instance with the given download configuration. This class is also available to import from `oteapi.datacache`, e.g.: ```python from oteapi.datacache import DataCache ``` Args: config: Download configurations. cache_dir: Cache directory overriding the config. Attributes: config: DataCacheConfig instance. cache_dir: Subdirectory used for the Path to cache directory, e.g., `\"my_oteapi\"`. \"\"\" def __init__ ( self , config : \"Union[DataCacheConfig, Dict[str, Any]]\" = None , cache_dir : \"Optional[Union[Path, str]]\" = None , ) -> None : if config is None : self . config = DataCacheConfig () elif isinstance ( config , dict ): self . config = DataCacheConfig ( ** config , extra = Extra . ignore ) elif isinstance ( config , DataCacheConfig ): self . config = config else : raise TypeError ( \"config should be either a `DataCacheConfig` data model or a \" \"dictionary.\" ) if not cache_dir : cache_dir = self . config . cacheDir if isinstance ( cache_dir , str ): cache_dir = Path ( cache_dir ) if cache_dir . is_absolute (): self . cache_dir = cache_dir else : self . cache_dir = Path ( tempfile . gettempdir ()) . resolve () / cache_dir self . diskcache = DiskCache ( directory = self . cache_dir ) def __contains__ ( self , key ) -> bool : return key in self . diskcache def __len__ ( self ) -> int : return len ( self . diskcache ) def __getitem__ ( self , key ) -> \"Any\" : return self . get ( key ) def __setitem__ ( self , key , value ) -> None : self . add ( value , key ) def __delitem__ ( self , key ) -> None : del self . diskcache [ key ] def __del__ ( self ) -> None : self . diskcache . expire () self . diskcache . close () def add ( self , value : \"Any\" , key : \"Optional[str]\" = None , expire : \"Optional[int]\" = None , tag : \"Optional[str]\" = None , ) -> str : \"\"\"Add a value to cache. Existing value is overwritten if `key` is given and it already exists in the cache. Args: value: The value to add to the cache. key: If given, use this as the retrieval key. Otherwise the key is either taken from the `accessKey` configuration or generated as a hash of `value`. expire: If given, the number of seconds before the value expire. Otherwise it is taken from the configuration. tag: Tag used with [`evict()`][oteapi.datacache.datacache.DataCache.evict] for cleaning up a session. Returns: A key that can be used to retrieve `value` from cache later. \"\"\" if not key : if self . config . accessKey : key = self . config . accessKey else : key = gethash ( value , hashtype = self . config . hashType ) if not expire : expire = self . config . expireTime self . diskcache . set ( key , value , expire = expire , tag = tag ) return key def get ( self , key : str ) -> \"Any\" : \"\"\"Return the value corresponding to `key`. Args: key: The requested cached object to retrieve a value for. Returns: The value corresponding to the `key` value. \"\"\" if key not in self . diskcache : raise KeyError ( key ) return self . diskcache . get ( key ) @contextmanager def getfile ( # pylint: disable=too-many-arguments self , key : str , filename : \"Optional[Union[Path, str]]\" = None , prefix : \"Optional[str]\" = None , suffix : \"Optional[str]\" = None , directory : \"Optional[str]\" = None , delete : bool = True , ) -> \"Iterator[Path]\" : \"\"\"Write the value for `key` to file and return the filename. The file is created in the default directory for temporary files (which can be controlled by the `TEMPDIR`, `TEMP` or `TMP` environment variables). It is readable and writable only for the current user. Example: This method is intended to be used in a `with` statement, to automatically delete the file when leaving the context: ```python cache = DataCache() with cache.getfile('mykey') as filename: # do something with filename... # filename is deleted ``` Args: key: Key of value to write to file. filename: Full path to created file. If not given, a unique filename will be created. prefix: Prefix to prepend to the returned file name (default is `\"oteapi-download-\"`). suffix: Suffix to append to the returned file name. directory: File directory if `filename` is not provided (is `None`). delete: Whether to automatically delete the created file when leaving the context. Yields: Path object, referencing and representing the created file. \"\"\" if filename : filename = Path ( filename ) . resolve () filename . write_bytes ( self . get ( key )) else : if prefix is None : prefix = \"oteapi-download-\" with tempfile . NamedTemporaryFile ( prefix = prefix , suffix = suffix , dir = directory , delete = False ) as handle : handle . write ( self . get ( key )) filename = Path ( handle . name ) . resolve () try : yield filename finally : if delete : filename . unlink () def evict ( self , tag : str ) -> None : \"\"\"Remove all cache items with the given tag. Useful for cleaning up a session. Args: tag: Tag identifying objects. \"\"\" self . diskcache . evict ( tag ) def clear ( self ) -> None : \"\"\"Remove all items from cache.\"\"\" self . diskcache . clear () add ( self , value , key = None , expire = None , tag = None ) \u00b6 Add a value to cache. Existing value is overwritten if key is given and it already exists in the cache. Parameters: Name Type Description Default value Any The value to add to the cache. required key Optional[str] If given, use this as the retrieval key. Otherwise the key is either taken from the accessKey configuration or generated as a hash of value . None expire Optional[int] If given, the number of seconds before the value expire. Otherwise it is taken from the configuration. None tag Optional[str] Tag used with evict() for cleaning up a session. None Returns: Type Description str A key that can be used to retrieve value from cache later. Source code in oteapi/datacache/datacache.py def add ( self , value : \"Any\" , key : \"Optional[str]\" = None , expire : \"Optional[int]\" = None , tag : \"Optional[str]\" = None , ) -> str : \"\"\"Add a value to cache. Existing value is overwritten if `key` is given and it already exists in the cache. Args: value: The value to add to the cache. key: If given, use this as the retrieval key. Otherwise the key is either taken from the `accessKey` configuration or generated as a hash of `value`. expire: If given, the number of seconds before the value expire. Otherwise it is taken from the configuration. tag: Tag used with [`evict()`][oteapi.datacache.datacache.DataCache.evict] for cleaning up a session. Returns: A key that can be used to retrieve `value` from cache later. \"\"\" if not key : if self . config . accessKey : key = self . config . accessKey else : key = gethash ( value , hashtype = self . config . hashType ) if not expire : expire = self . config . expireTime self . diskcache . set ( key , value , expire = expire , tag = tag ) return key clear ( self ) \u00b6 Remove all items from cache. Source code in oteapi/datacache/datacache.py def clear ( self ) -> None : \"\"\"Remove all items from cache.\"\"\" self . diskcache . clear () evict ( self , tag ) \u00b6 Remove all cache items with the given tag. Useful for cleaning up a session. Parameters: Name Type Description Default tag str Tag identifying objects. required Source code in oteapi/datacache/datacache.py def evict ( self , tag : str ) -> None : \"\"\"Remove all cache items with the given tag. Useful for cleaning up a session. Args: tag: Tag identifying objects. \"\"\" self . diskcache . evict ( tag ) get ( self , key ) \u00b6 Return the value corresponding to key . Parameters: Name Type Description Default key str The requested cached object to retrieve a value for. required Returns: Type Description Any The value corresponding to the key value. Source code in oteapi/datacache/datacache.py def get ( self , key : str ) -> \"Any\" : \"\"\"Return the value corresponding to `key`. Args: key: The requested cached object to retrieve a value for. Returns: The value corresponding to the `key` value. \"\"\" if key not in self . diskcache : raise KeyError ( key ) return self . diskcache . get ( key ) getfile ( self , key , filename = None , prefix = None , suffix = None , directory = None , delete = True ) \u00b6 Write the value for key to file and return the filename. The file is created in the default directory for temporary files (which can be controlled by the TEMPDIR , TEMP or TMP environment variables). It is readable and writable only for the current user. Examples: This method is intended to be used in a with statement, to automatically delete the file when leaving the context: cache = DataCache () with cache . getfile ( 'mykey' ) as filename : # do something with filename... # filename is deleted Parameters: Name Type Description Default key str Key of value to write to file. required filename Optional[Union[Path, str]] Full path to created file. If not given, a unique filename will be created. None prefix Optional[str] Prefix to prepend to the returned file name (default is \"oteapi-download-\" ). None suffix Optional[str] Suffix to append to the returned file name. None directory Optional[str] File directory if filename is not provided (is None ). None delete bool Whether to automatically delete the created file when leaving the context. True Yields: Type Description Iterator[Path] Path object, referencing and representing the created file. Source code in oteapi/datacache/datacache.py @contextmanager def getfile ( # pylint: disable=too-many-arguments self , key : str , filename : \"Optional[Union[Path, str]]\" = None , prefix : \"Optional[str]\" = None , suffix : \"Optional[str]\" = None , directory : \"Optional[str]\" = None , delete : bool = True , ) -> \"Iterator[Path]\" : \"\"\"Write the value for `key` to file and return the filename. The file is created in the default directory for temporary files (which can be controlled by the `TEMPDIR`, `TEMP` or `TMP` environment variables). It is readable and writable only for the current user. Example: This method is intended to be used in a `with` statement, to automatically delete the file when leaving the context: ```python cache = DataCache() with cache.getfile('mykey') as filename: # do something with filename... # filename is deleted ``` Args: key: Key of value to write to file. filename: Full path to created file. If not given, a unique filename will be created. prefix: Prefix to prepend to the returned file name (default is `\"oteapi-download-\"`). suffix: Suffix to append to the returned file name. directory: File directory if `filename` is not provided (is `None`). delete: Whether to automatically delete the created file when leaving the context. Yields: Path object, referencing and representing the created file. \"\"\" if filename : filename = Path ( filename ) . resolve () filename . write_bytes ( self . get ( key )) else : if prefix is None : prefix = \"oteapi-download-\" with tempfile . NamedTemporaryFile ( prefix = prefix , suffix = suffix , dir = directory , delete = False ) as handle : handle . write ( self . get ( key )) filename = Path ( handle . name ) . resolve () try : yield filename finally : if delete : filename . unlink () gethash ( value , hashtype = 'sha256' , encoding = 'utf-8' , json_encoder = None ) \u00b6 Return a hash of value . Can hash most python objects. Bytes and bytearrays are hashed directly. Strings are converted to bytes with the given encoding. All other objects are first serialised using json. Parameters: Name Type Description Default value Any Value to hash. required hashtype str Any of the hash algorithms supported by hashlib. 'sha256' encoding str Encoding used to convert strings to bytes before calculating the hash. 'utf-8' json_encoder Optional[Type[json.JSONEncoder]] Customised json encoder for complex Python objects. None Returns: Type Description str A hash of the input value . Source code in oteapi/datacache/datacache.py def gethash ( value : \"Any\" , hashtype : str = \"sha256\" , encoding : str = \"utf-8\" , json_encoder : \"Optional[Type[json.JSONEncoder]]\" = None , ) -> str : \"\"\"Return a hash of `value`. Can hash most python objects. Bytes and bytearrays are hashed directly. Strings are converted to bytes with the given encoding. All other objects are first serialised using json. Args: value: Value to hash. hashtype: Any of the hash algorithms supported by hashlib. encoding: Encoding used to convert strings to bytes before calculating the hash. json_encoder: Customised json encoder for complex Python objects. Returns: A hash of the input `value`. \"\"\" if isinstance ( value , ( bytes , bytearray )): data = value elif isinstance ( value , str ): data = value . encode ( encoding ) else : # Try to serialise using json data = json . dumps ( value , ensure_ascii = False , cls = json_encoder , sort_keys = True , ) . encode ( encoding ) hash_ = hashlib . new ( hashtype ) hash_ . update ( data ) return hash_ . hexdigest ()","title":"datacache"},{"location":"api_reference/datacache/datacache/#datacache","text":"Data cache based on DiskCache. See Python-DiskCache . Features: Persistent cache between sessions. Default keys are hashes of the stored data. Automatic expiration of cached data. Sessions can selectively be cleaned up via tags. Store small values in SQLite database and large values in files. Underlying library is actively developed and tested on Linux, Mac and Windows. High performance.","title":"datacache"},{"location":"api_reference/datacache/datacache/#oteapi.datacache.datacache.DataCache","text":"Initialize a cache instance with the given download configuration. This class is also available to import from oteapi.datacache , e.g.: from oteapi.datacache import DataCache Parameters: Name Type Description Default config Union[DataCacheConfig, Dict[str, Any]] Download configurations. None cache_dir Optional[Union[Path, str]] Cache directory overriding the config. None Attributes: Name Type Description config DataCacheConfig instance. cache_dir Subdirectory used for the Path to cache directory, e.g., \"my_oteapi\" . Source code in oteapi/datacache/datacache.py class DataCache : \"\"\"Initialize a cache instance with the given download configuration. This class is also available to import from `oteapi.datacache`, e.g.: ```python from oteapi.datacache import DataCache ``` Args: config: Download configurations. cache_dir: Cache directory overriding the config. Attributes: config: DataCacheConfig instance. cache_dir: Subdirectory used for the Path to cache directory, e.g., `\"my_oteapi\"`. \"\"\" def __init__ ( self , config : \"Union[DataCacheConfig, Dict[str, Any]]\" = None , cache_dir : \"Optional[Union[Path, str]]\" = None , ) -> None : if config is None : self . config = DataCacheConfig () elif isinstance ( config , dict ): self . config = DataCacheConfig ( ** config , extra = Extra . ignore ) elif isinstance ( config , DataCacheConfig ): self . config = config else : raise TypeError ( \"config should be either a `DataCacheConfig` data model or a \" \"dictionary.\" ) if not cache_dir : cache_dir = self . config . cacheDir if isinstance ( cache_dir , str ): cache_dir = Path ( cache_dir ) if cache_dir . is_absolute (): self . cache_dir = cache_dir else : self . cache_dir = Path ( tempfile . gettempdir ()) . resolve () / cache_dir self . diskcache = DiskCache ( directory = self . cache_dir ) def __contains__ ( self , key ) -> bool : return key in self . diskcache def __len__ ( self ) -> int : return len ( self . diskcache ) def __getitem__ ( self , key ) -> \"Any\" : return self . get ( key ) def __setitem__ ( self , key , value ) -> None : self . add ( value , key ) def __delitem__ ( self , key ) -> None : del self . diskcache [ key ] def __del__ ( self ) -> None : self . diskcache . expire () self . diskcache . close () def add ( self , value : \"Any\" , key : \"Optional[str]\" = None , expire : \"Optional[int]\" = None , tag : \"Optional[str]\" = None , ) -> str : \"\"\"Add a value to cache. Existing value is overwritten if `key` is given and it already exists in the cache. Args: value: The value to add to the cache. key: If given, use this as the retrieval key. Otherwise the key is either taken from the `accessKey` configuration or generated as a hash of `value`. expire: If given, the number of seconds before the value expire. Otherwise it is taken from the configuration. tag: Tag used with [`evict()`][oteapi.datacache.datacache.DataCache.evict] for cleaning up a session. Returns: A key that can be used to retrieve `value` from cache later. \"\"\" if not key : if self . config . accessKey : key = self . config . accessKey else : key = gethash ( value , hashtype = self . config . hashType ) if not expire : expire = self . config . expireTime self . diskcache . set ( key , value , expire = expire , tag = tag ) return key def get ( self , key : str ) -> \"Any\" : \"\"\"Return the value corresponding to `key`. Args: key: The requested cached object to retrieve a value for. Returns: The value corresponding to the `key` value. \"\"\" if key not in self . diskcache : raise KeyError ( key ) return self . diskcache . get ( key ) @contextmanager def getfile ( # pylint: disable=too-many-arguments self , key : str , filename : \"Optional[Union[Path, str]]\" = None , prefix : \"Optional[str]\" = None , suffix : \"Optional[str]\" = None , directory : \"Optional[str]\" = None , delete : bool = True , ) -> \"Iterator[Path]\" : \"\"\"Write the value for `key` to file and return the filename. The file is created in the default directory for temporary files (which can be controlled by the `TEMPDIR`, `TEMP` or `TMP` environment variables). It is readable and writable only for the current user. Example: This method is intended to be used in a `with` statement, to automatically delete the file when leaving the context: ```python cache = DataCache() with cache.getfile('mykey') as filename: # do something with filename... # filename is deleted ``` Args: key: Key of value to write to file. filename: Full path to created file. If not given, a unique filename will be created. prefix: Prefix to prepend to the returned file name (default is `\"oteapi-download-\"`). suffix: Suffix to append to the returned file name. directory: File directory if `filename` is not provided (is `None`). delete: Whether to automatically delete the created file when leaving the context. Yields: Path object, referencing and representing the created file. \"\"\" if filename : filename = Path ( filename ) . resolve () filename . write_bytes ( self . get ( key )) else : if prefix is None : prefix = \"oteapi-download-\" with tempfile . NamedTemporaryFile ( prefix = prefix , suffix = suffix , dir = directory , delete = False ) as handle : handle . write ( self . get ( key )) filename = Path ( handle . name ) . resolve () try : yield filename finally : if delete : filename . unlink () def evict ( self , tag : str ) -> None : \"\"\"Remove all cache items with the given tag. Useful for cleaning up a session. Args: tag: Tag identifying objects. \"\"\" self . diskcache . evict ( tag ) def clear ( self ) -> None : \"\"\"Remove all items from cache.\"\"\" self . diskcache . clear ()","title":"DataCache"},{"location":"api_reference/datacache/datacache/#oteapi.datacache.datacache.DataCache.add","text":"Add a value to cache. Existing value is overwritten if key is given and it already exists in the cache. Parameters: Name Type Description Default value Any The value to add to the cache. required key Optional[str] If given, use this as the retrieval key. Otherwise the key is either taken from the accessKey configuration or generated as a hash of value . None expire Optional[int] If given, the number of seconds before the value expire. Otherwise it is taken from the configuration. None tag Optional[str] Tag used with evict() for cleaning up a session. None Returns: Type Description str A key that can be used to retrieve value from cache later. Source code in oteapi/datacache/datacache.py def add ( self , value : \"Any\" , key : \"Optional[str]\" = None , expire : \"Optional[int]\" = None , tag : \"Optional[str]\" = None , ) -> str : \"\"\"Add a value to cache. Existing value is overwritten if `key` is given and it already exists in the cache. Args: value: The value to add to the cache. key: If given, use this as the retrieval key. Otherwise the key is either taken from the `accessKey` configuration or generated as a hash of `value`. expire: If given, the number of seconds before the value expire. Otherwise it is taken from the configuration. tag: Tag used with [`evict()`][oteapi.datacache.datacache.DataCache.evict] for cleaning up a session. Returns: A key that can be used to retrieve `value` from cache later. \"\"\" if not key : if self . config . accessKey : key = self . config . accessKey else : key = gethash ( value , hashtype = self . config . hashType ) if not expire : expire = self . config . expireTime self . diskcache . set ( key , value , expire = expire , tag = tag ) return key","title":"add()"},{"location":"api_reference/datacache/datacache/#oteapi.datacache.datacache.DataCache.clear","text":"Remove all items from cache. Source code in oteapi/datacache/datacache.py def clear ( self ) -> None : \"\"\"Remove all items from cache.\"\"\" self . diskcache . clear ()","title":"clear()"},{"location":"api_reference/datacache/datacache/#oteapi.datacache.datacache.DataCache.evict","text":"Remove all cache items with the given tag. Useful for cleaning up a session. Parameters: Name Type Description Default tag str Tag identifying objects. required Source code in oteapi/datacache/datacache.py def evict ( self , tag : str ) -> None : \"\"\"Remove all cache items with the given tag. Useful for cleaning up a session. Args: tag: Tag identifying objects. \"\"\" self . diskcache . evict ( tag )","title":"evict()"},{"location":"api_reference/datacache/datacache/#oteapi.datacache.datacache.DataCache.get","text":"Return the value corresponding to key . Parameters: Name Type Description Default key str The requested cached object to retrieve a value for. required Returns: Type Description Any The value corresponding to the key value. Source code in oteapi/datacache/datacache.py def get ( self , key : str ) -> \"Any\" : \"\"\"Return the value corresponding to `key`. Args: key: The requested cached object to retrieve a value for. Returns: The value corresponding to the `key` value. \"\"\" if key not in self . diskcache : raise KeyError ( key ) return self . diskcache . get ( key )","title":"get()"},{"location":"api_reference/datacache/datacache/#oteapi.datacache.datacache.DataCache.getfile","text":"Write the value for key to file and return the filename. The file is created in the default directory for temporary files (which can be controlled by the TEMPDIR , TEMP or TMP environment variables). It is readable and writable only for the current user. Examples: This method is intended to be used in a with statement, to automatically delete the file when leaving the context: cache = DataCache () with cache . getfile ( 'mykey' ) as filename : # do something with filename... # filename is deleted Parameters: Name Type Description Default key str Key of value to write to file. required filename Optional[Union[Path, str]] Full path to created file. If not given, a unique filename will be created. None prefix Optional[str] Prefix to prepend to the returned file name (default is \"oteapi-download-\" ). None suffix Optional[str] Suffix to append to the returned file name. None directory Optional[str] File directory if filename is not provided (is None ). None delete bool Whether to automatically delete the created file when leaving the context. True Yields: Type Description Iterator[Path] Path object, referencing and representing the created file. Source code in oteapi/datacache/datacache.py @contextmanager def getfile ( # pylint: disable=too-many-arguments self , key : str , filename : \"Optional[Union[Path, str]]\" = None , prefix : \"Optional[str]\" = None , suffix : \"Optional[str]\" = None , directory : \"Optional[str]\" = None , delete : bool = True , ) -> \"Iterator[Path]\" : \"\"\"Write the value for `key` to file and return the filename. The file is created in the default directory for temporary files (which can be controlled by the `TEMPDIR`, `TEMP` or `TMP` environment variables). It is readable and writable only for the current user. Example: This method is intended to be used in a `with` statement, to automatically delete the file when leaving the context: ```python cache = DataCache() with cache.getfile('mykey') as filename: # do something with filename... # filename is deleted ``` Args: key: Key of value to write to file. filename: Full path to created file. If not given, a unique filename will be created. prefix: Prefix to prepend to the returned file name (default is `\"oteapi-download-\"`). suffix: Suffix to append to the returned file name. directory: File directory if `filename` is not provided (is `None`). delete: Whether to automatically delete the created file when leaving the context. Yields: Path object, referencing and representing the created file. \"\"\" if filename : filename = Path ( filename ) . resolve () filename . write_bytes ( self . get ( key )) else : if prefix is None : prefix = \"oteapi-download-\" with tempfile . NamedTemporaryFile ( prefix = prefix , suffix = suffix , dir = directory , delete = False ) as handle : handle . write ( self . get ( key )) filename = Path ( handle . name ) . resolve () try : yield filename finally : if delete : filename . unlink ()","title":"getfile()"},{"location":"api_reference/datacache/datacache/#oteapi.datacache.datacache.gethash","text":"Return a hash of value . Can hash most python objects. Bytes and bytearrays are hashed directly. Strings are converted to bytes with the given encoding. All other objects are first serialised using json. Parameters: Name Type Description Default value Any Value to hash. required hashtype str Any of the hash algorithms supported by hashlib. 'sha256' encoding str Encoding used to convert strings to bytes before calculating the hash. 'utf-8' json_encoder Optional[Type[json.JSONEncoder]] Customised json encoder for complex Python objects. None Returns: Type Description str A hash of the input value . Source code in oteapi/datacache/datacache.py def gethash ( value : \"Any\" , hashtype : str = \"sha256\" , encoding : str = \"utf-8\" , json_encoder : \"Optional[Type[json.JSONEncoder]]\" = None , ) -> str : \"\"\"Return a hash of `value`. Can hash most python objects. Bytes and bytearrays are hashed directly. Strings are converted to bytes with the given encoding. All other objects are first serialised using json. Args: value: Value to hash. hashtype: Any of the hash algorithms supported by hashlib. encoding: Encoding used to convert strings to bytes before calculating the hash. json_encoder: Customised json encoder for complex Python objects. Returns: A hash of the input `value`. \"\"\" if isinstance ( value , ( bytes , bytearray )): data = value elif isinstance ( value , str ): data = value . encode ( encoding ) else : # Try to serialise using json data = json . dumps ( value , ensure_ascii = False , cls = json_encoder , sort_keys = True , ) . encode ( encoding ) hash_ = hashlib . new ( hashtype ) hash_ . update ( data ) return hash_ . hexdigest ()","title":"gethash()"},{"location":"api_reference/interfaces/idownloadstrategy/","text":"idownloadstrategy \u00b6 Download Strategy Interface IDownloadStrategy ( Protocol ) dataclass \u00b6 Download Strategy Interface. Source code in oteapi/interfaces/idownloadstrategy.py @dataclass # type: ignore[misc] @runtime_checkable class IDownloadStrategy ( Protocol ): \"\"\"Download Strategy Interface.\"\"\" resource_config : \"ResourceConfig\" def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Execute the strategy. Parameters: session: A session-specific dictionary context. Returns: Dictionary of key/value-pairs to be stored in the sessions-specific dictionary context. \"\"\" def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Initialize data class. This method will be called through the `/initialize` endpoint of the OTE-API Services. Parameters: session: A session-specific dictionary context. Returns: Dictionary of key/value-pairs to be stored in the sessions-specific dictionary context. \"\"\" get ( self , session = None ) \u00b6 Execute the strategy. Parameters: Name Type Description Default session Optional[Dict[str, Any]] A session-specific dictionary context. None Returns: Type Description Dict[str, Any] Dictionary of key/value-pairs to be stored in the sessions-specific dictionary context. Source code in oteapi/interfaces/idownloadstrategy.py def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Execute the strategy. Parameters: session: A session-specific dictionary context. Returns: Dictionary of key/value-pairs to be stored in the sessions-specific dictionary context. \"\"\" initialize ( self , session = None ) \u00b6 Initialize data class. This method will be called through the /initialize endpoint of the OTE-API Services. Parameters: Name Type Description Default session Optional[Dict[str, Any]] A session-specific dictionary context. None Returns: Type Description Dict[str, Any] Dictionary of key/value-pairs to be stored in the sessions-specific dictionary context. Source code in oteapi/interfaces/idownloadstrategy.py def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Initialize data class. This method will be called through the `/initialize` endpoint of the OTE-API Services. Parameters: session: A session-specific dictionary context. Returns: Dictionary of key/value-pairs to be stored in the sessions-specific dictionary context. \"\"\"","title":"idownloadstrategy"},{"location":"api_reference/interfaces/idownloadstrategy/#idownloadstrategy","text":"Download Strategy Interface","title":"idownloadstrategy"},{"location":"api_reference/interfaces/idownloadstrategy/#oteapi.interfaces.idownloadstrategy.IDownloadStrategy","text":"Download Strategy Interface. Source code in oteapi/interfaces/idownloadstrategy.py @dataclass # type: ignore[misc] @runtime_checkable class IDownloadStrategy ( Protocol ): \"\"\"Download Strategy Interface.\"\"\" resource_config : \"ResourceConfig\" def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Execute the strategy. Parameters: session: A session-specific dictionary context. Returns: Dictionary of key/value-pairs to be stored in the sessions-specific dictionary context. \"\"\" def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Initialize data class. This method will be called through the `/initialize` endpoint of the OTE-API Services. Parameters: session: A session-specific dictionary context. Returns: Dictionary of key/value-pairs to be stored in the sessions-specific dictionary context. \"\"\"","title":"IDownloadStrategy"},{"location":"api_reference/interfaces/idownloadstrategy/#oteapi.interfaces.idownloadstrategy.IDownloadStrategy.get","text":"Execute the strategy. Parameters: Name Type Description Default session Optional[Dict[str, Any]] A session-specific dictionary context. None Returns: Type Description Dict[str, Any] Dictionary of key/value-pairs to be stored in the sessions-specific dictionary context. Source code in oteapi/interfaces/idownloadstrategy.py def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Execute the strategy. Parameters: session: A session-specific dictionary context. Returns: Dictionary of key/value-pairs to be stored in the sessions-specific dictionary context. \"\"\"","title":"get()"},{"location":"api_reference/interfaces/idownloadstrategy/#oteapi.interfaces.idownloadstrategy.IDownloadStrategy.initialize","text":"Initialize data class. This method will be called through the /initialize endpoint of the OTE-API Services. Parameters: Name Type Description Default session Optional[Dict[str, Any]] A session-specific dictionary context. None Returns: Type Description Dict[str, Any] Dictionary of key/value-pairs to be stored in the sessions-specific dictionary context. Source code in oteapi/interfaces/idownloadstrategy.py def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Initialize data class. This method will be called through the `/initialize` endpoint of the OTE-API Services. Parameters: session: A session-specific dictionary context. Returns: Dictionary of key/value-pairs to be stored in the sessions-specific dictionary context. \"\"\"","title":"initialize()"},{"location":"api_reference/interfaces/ifilterstrategy/","text":"ifilterstrategy \u00b6 Filter Strategy Interface IFilterStrategy ( Protocol ) dataclass \u00b6 Filter Strategy Interface. Source code in oteapi/interfaces/ifilterstrategy.py @dataclass # type: ignore[misc] @runtime_checkable class IFilterStrategy ( Protocol ): \"\"\"Filter Strategy Interface.\"\"\" filter_config : \"FilterConfig\" def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Execute the strategy. Parameters: session: A session-specific dictionary context. Returns: Dictionary of key/value-pairs to be stored in the sessions-specific dictionary context. \"\"\" def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Initialize data class. This method will be called through the `/initialize` endpoint of the OTE-API Services. Parameters: session: A session-specific dictionary context. Returns: Dictionary of key/value-pairs to be stored in the sessions-specific dictionary context. \"\"\" get ( self , session = None ) \u00b6 Execute the strategy. Parameters: Name Type Description Default session Optional[Dict[str, Any]] A session-specific dictionary context. None Returns: Type Description Dict[str, Any] Dictionary of key/value-pairs to be stored in the sessions-specific dictionary context. Source code in oteapi/interfaces/ifilterstrategy.py def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Execute the strategy. Parameters: session: A session-specific dictionary context. Returns: Dictionary of key/value-pairs to be stored in the sessions-specific dictionary context. \"\"\" initialize ( self , session = None ) \u00b6 Initialize data class. This method will be called through the /initialize endpoint of the OTE-API Services. Parameters: Name Type Description Default session Optional[Dict[str, Any]] A session-specific dictionary context. None Returns: Type Description Dict[str, Any] Dictionary of key/value-pairs to be stored in the sessions-specific dictionary context. Source code in oteapi/interfaces/ifilterstrategy.py def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Initialize data class. This method will be called through the `/initialize` endpoint of the OTE-API Services. Parameters: session: A session-specific dictionary context. Returns: Dictionary of key/value-pairs to be stored in the sessions-specific dictionary context. \"\"\"","title":"ifilterstrategy"},{"location":"api_reference/interfaces/ifilterstrategy/#ifilterstrategy","text":"Filter Strategy Interface","title":"ifilterstrategy"},{"location":"api_reference/interfaces/ifilterstrategy/#oteapi.interfaces.ifilterstrategy.IFilterStrategy","text":"Filter Strategy Interface. Source code in oteapi/interfaces/ifilterstrategy.py @dataclass # type: ignore[misc] @runtime_checkable class IFilterStrategy ( Protocol ): \"\"\"Filter Strategy Interface.\"\"\" filter_config : \"FilterConfig\" def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Execute the strategy. Parameters: session: A session-specific dictionary context. Returns: Dictionary of key/value-pairs to be stored in the sessions-specific dictionary context. \"\"\" def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Initialize data class. This method will be called through the `/initialize` endpoint of the OTE-API Services. Parameters: session: A session-specific dictionary context. Returns: Dictionary of key/value-pairs to be stored in the sessions-specific dictionary context. \"\"\"","title":"IFilterStrategy"},{"location":"api_reference/interfaces/ifilterstrategy/#oteapi.interfaces.ifilterstrategy.IFilterStrategy.get","text":"Execute the strategy. Parameters: Name Type Description Default session Optional[Dict[str, Any]] A session-specific dictionary context. None Returns: Type Description Dict[str, Any] Dictionary of key/value-pairs to be stored in the sessions-specific dictionary context. Source code in oteapi/interfaces/ifilterstrategy.py def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Execute the strategy. Parameters: session: A session-specific dictionary context. Returns: Dictionary of key/value-pairs to be stored in the sessions-specific dictionary context. \"\"\"","title":"get()"},{"location":"api_reference/interfaces/ifilterstrategy/#oteapi.interfaces.ifilterstrategy.IFilterStrategy.initialize","text":"Initialize data class. This method will be called through the /initialize endpoint of the OTE-API Services. Parameters: Name Type Description Default session Optional[Dict[str, Any]] A session-specific dictionary context. None Returns: Type Description Dict[str, Any] Dictionary of key/value-pairs to be stored in the sessions-specific dictionary context. Source code in oteapi/interfaces/ifilterstrategy.py def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Initialize data class. This method will be called through the `/initialize` endpoint of the OTE-API Services. Parameters: session: A session-specific dictionary context. Returns: Dictionary of key/value-pairs to be stored in the sessions-specific dictionary context. \"\"\"","title":"initialize()"},{"location":"api_reference/interfaces/imappingstrategy/","text":"imappingstrategy \u00b6 Mapping Strategy Interface IMappingStrategy ( Protocol ) dataclass \u00b6 Mapping Strategy Interface. Source code in oteapi/interfaces/imappingstrategy.py @dataclass # type: ignore[misc] @runtime_checkable class IMappingStrategy ( Protocol ): \"\"\"Mapping Strategy Interface.\"\"\" mapping_config : \"MappingConfig\" def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Execute the strategy. Parameters: session: A session-specific dictionary context. Returns: Dictionary of key/value-pairs to be stored in the sessions-specific dictionary context. \"\"\" def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Initialize data class. This method will be called through the `/initialize` endpoint of the OTE-API Services. Parameters: session: A session-specific dictionary context. Returns: Dictionary of key/value-pairs to be stored in the sessions-specific dictionary context. \"\"\" get ( self , session = None ) \u00b6 Execute the strategy. Parameters: Name Type Description Default session Optional[Dict[str, Any]] A session-specific dictionary context. None Returns: Type Description Dict[str, Any] Dictionary of key/value-pairs to be stored in the sessions-specific dictionary context. Source code in oteapi/interfaces/imappingstrategy.py def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Execute the strategy. Parameters: session: A session-specific dictionary context. Returns: Dictionary of key/value-pairs to be stored in the sessions-specific dictionary context. \"\"\" initialize ( self , session = None ) \u00b6 Initialize data class. This method will be called through the /initialize endpoint of the OTE-API Services. Parameters: Name Type Description Default session Optional[Dict[str, Any]] A session-specific dictionary context. None Returns: Type Description Dict[str, Any] Dictionary of key/value-pairs to be stored in the sessions-specific dictionary context. Source code in oteapi/interfaces/imappingstrategy.py def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Initialize data class. This method will be called through the `/initialize` endpoint of the OTE-API Services. Parameters: session: A session-specific dictionary context. Returns: Dictionary of key/value-pairs to be stored in the sessions-specific dictionary context. \"\"\"","title":"imappingstrategy"},{"location":"api_reference/interfaces/imappingstrategy/#imappingstrategy","text":"Mapping Strategy Interface","title":"imappingstrategy"},{"location":"api_reference/interfaces/imappingstrategy/#oteapi.interfaces.imappingstrategy.IMappingStrategy","text":"Mapping Strategy Interface. Source code in oteapi/interfaces/imappingstrategy.py @dataclass # type: ignore[misc] @runtime_checkable class IMappingStrategy ( Protocol ): \"\"\"Mapping Strategy Interface.\"\"\" mapping_config : \"MappingConfig\" def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Execute the strategy. Parameters: session: A session-specific dictionary context. Returns: Dictionary of key/value-pairs to be stored in the sessions-specific dictionary context. \"\"\" def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Initialize data class. This method will be called through the `/initialize` endpoint of the OTE-API Services. Parameters: session: A session-specific dictionary context. Returns: Dictionary of key/value-pairs to be stored in the sessions-specific dictionary context. \"\"\"","title":"IMappingStrategy"},{"location":"api_reference/interfaces/imappingstrategy/#oteapi.interfaces.imappingstrategy.IMappingStrategy.get","text":"Execute the strategy. Parameters: Name Type Description Default session Optional[Dict[str, Any]] A session-specific dictionary context. None Returns: Type Description Dict[str, Any] Dictionary of key/value-pairs to be stored in the sessions-specific dictionary context. Source code in oteapi/interfaces/imappingstrategy.py def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Execute the strategy. Parameters: session: A session-specific dictionary context. Returns: Dictionary of key/value-pairs to be stored in the sessions-specific dictionary context. \"\"\"","title":"get()"},{"location":"api_reference/interfaces/imappingstrategy/#oteapi.interfaces.imappingstrategy.IMappingStrategy.initialize","text":"Initialize data class. This method will be called through the /initialize endpoint of the OTE-API Services. Parameters: Name Type Description Default session Optional[Dict[str, Any]] A session-specific dictionary context. None Returns: Type Description Dict[str, Any] Dictionary of key/value-pairs to be stored in the sessions-specific dictionary context. Source code in oteapi/interfaces/imappingstrategy.py def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Initialize data class. This method will be called through the `/initialize` endpoint of the OTE-API Services. Parameters: session: A session-specific dictionary context. Returns: Dictionary of key/value-pairs to be stored in the sessions-specific dictionary context. \"\"\"","title":"initialize()"},{"location":"api_reference/interfaces/iparsestrategy/","text":"iparsestrategy \u00b6 Parse Strategy Interface IParseStrategy ( Protocol ) dataclass \u00b6 Parse Strategy Interface. Source code in oteapi/interfaces/iparsestrategy.py @dataclass # type: ignore[misc] @runtime_checkable class IParseStrategy ( Protocol ): \"\"\"Parse Strategy Interface.\"\"\" resource_config : \"ResourceConfig\" def parse ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Execute the strategy. Parameters: session: A session-specific dictionary context. Returns: Dictionary of key/value-pairs to be stored in the sessions-specific dictionary context. \"\"\" def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Initialize data class. This method will be called through the `/initialize` endpoint of the OTE-API Services. Parameters: session: A session-specific dictionary context. Returns: Dictionary of key/value-pairs to be stored in the sessions-specific dictionary context. \"\"\" initialize ( self , session = None ) \u00b6 Initialize data class. This method will be called through the /initialize endpoint of the OTE-API Services. Parameters: Name Type Description Default session Optional[Dict[str, Any]] A session-specific dictionary context. None Returns: Type Description Dict[str, Any] Dictionary of key/value-pairs to be stored in the sessions-specific dictionary context. Source code in oteapi/interfaces/iparsestrategy.py def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Initialize data class. This method will be called through the `/initialize` endpoint of the OTE-API Services. Parameters: session: A session-specific dictionary context. Returns: Dictionary of key/value-pairs to be stored in the sessions-specific dictionary context. \"\"\" parse ( self , session = None ) \u00b6 Execute the strategy. Parameters: Name Type Description Default session Optional[Dict[str, Any]] A session-specific dictionary context. None Returns: Type Description Dict[str, Any] Dictionary of key/value-pairs to be stored in the sessions-specific dictionary context. Source code in oteapi/interfaces/iparsestrategy.py def parse ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Execute the strategy. Parameters: session: A session-specific dictionary context. Returns: Dictionary of key/value-pairs to be stored in the sessions-specific dictionary context. \"\"\"","title":"iparsestrategy"},{"location":"api_reference/interfaces/iparsestrategy/#iparsestrategy","text":"Parse Strategy Interface","title":"iparsestrategy"},{"location":"api_reference/interfaces/iparsestrategy/#oteapi.interfaces.iparsestrategy.IParseStrategy","text":"Parse Strategy Interface. Source code in oteapi/interfaces/iparsestrategy.py @dataclass # type: ignore[misc] @runtime_checkable class IParseStrategy ( Protocol ): \"\"\"Parse Strategy Interface.\"\"\" resource_config : \"ResourceConfig\" def parse ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Execute the strategy. Parameters: session: A session-specific dictionary context. Returns: Dictionary of key/value-pairs to be stored in the sessions-specific dictionary context. \"\"\" def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Initialize data class. This method will be called through the `/initialize` endpoint of the OTE-API Services. Parameters: session: A session-specific dictionary context. Returns: Dictionary of key/value-pairs to be stored in the sessions-specific dictionary context. \"\"\"","title":"IParseStrategy"},{"location":"api_reference/interfaces/iparsestrategy/#oteapi.interfaces.iparsestrategy.IParseStrategy.initialize","text":"Initialize data class. This method will be called through the /initialize endpoint of the OTE-API Services. Parameters: Name Type Description Default session Optional[Dict[str, Any]] A session-specific dictionary context. None Returns: Type Description Dict[str, Any] Dictionary of key/value-pairs to be stored in the sessions-specific dictionary context. Source code in oteapi/interfaces/iparsestrategy.py def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Initialize data class. This method will be called through the `/initialize` endpoint of the OTE-API Services. Parameters: session: A session-specific dictionary context. Returns: Dictionary of key/value-pairs to be stored in the sessions-specific dictionary context. \"\"\"","title":"initialize()"},{"location":"api_reference/interfaces/iparsestrategy/#oteapi.interfaces.iparsestrategy.IParseStrategy.parse","text":"Execute the strategy. Parameters: Name Type Description Default session Optional[Dict[str, Any]] A session-specific dictionary context. None Returns: Type Description Dict[str, Any] Dictionary of key/value-pairs to be stored in the sessions-specific dictionary context. Source code in oteapi/interfaces/iparsestrategy.py def parse ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Execute the strategy. Parameters: session: A session-specific dictionary context. Returns: Dictionary of key/value-pairs to be stored in the sessions-specific dictionary context. \"\"\"","title":"parse()"},{"location":"api_reference/interfaces/iresourcestrategy/","text":"iresourcestrategy \u00b6 Resource Strategy Interface IResourceStrategy ( Protocol ) dataclass \u00b6 Resource Strategy Interface. Source code in oteapi/interfaces/iresourcestrategy.py @dataclass # type: ignore[misc] @runtime_checkable class IResourceStrategy ( Protocol ): \"\"\"Resource Strategy Interface.\"\"\" resource_config : \"ResourceConfig\" def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Execute the strategy. Parameters: session: A session-specific dictionary context. Returns: Dictionary of key/value-pairs to be stored in the sessions-specific dictionary context. \"\"\" def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Initialize data class. This method will be called through the `/initialize` endpoint of the OTE-API Services. Parameters: session: A session-specific dictionary context. Returns: Dictionary of key/value-pairs to be stored in the sessions-specific dictionary context. \"\"\" get ( self , session = None ) \u00b6 Execute the strategy. Parameters: Name Type Description Default session Optional[Dict[str, Any]] A session-specific dictionary context. None Returns: Type Description Dict[str, Any] Dictionary of key/value-pairs to be stored in the sessions-specific dictionary context. Source code in oteapi/interfaces/iresourcestrategy.py def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Execute the strategy. Parameters: session: A session-specific dictionary context. Returns: Dictionary of key/value-pairs to be stored in the sessions-specific dictionary context. \"\"\" initialize ( self , session = None ) \u00b6 Initialize data class. This method will be called through the /initialize endpoint of the OTE-API Services. Parameters: Name Type Description Default session Optional[Dict[str, Any]] A session-specific dictionary context. None Returns: Type Description Dict[str, Any] Dictionary of key/value-pairs to be stored in the sessions-specific dictionary context. Source code in oteapi/interfaces/iresourcestrategy.py def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Initialize data class. This method will be called through the `/initialize` endpoint of the OTE-API Services. Parameters: session: A session-specific dictionary context. Returns: Dictionary of key/value-pairs to be stored in the sessions-specific dictionary context. \"\"\"","title":"iresourcestrategy"},{"location":"api_reference/interfaces/iresourcestrategy/#iresourcestrategy","text":"Resource Strategy Interface","title":"iresourcestrategy"},{"location":"api_reference/interfaces/iresourcestrategy/#oteapi.interfaces.iresourcestrategy.IResourceStrategy","text":"Resource Strategy Interface. Source code in oteapi/interfaces/iresourcestrategy.py @dataclass # type: ignore[misc] @runtime_checkable class IResourceStrategy ( Protocol ): \"\"\"Resource Strategy Interface.\"\"\" resource_config : \"ResourceConfig\" def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Execute the strategy. Parameters: session: A session-specific dictionary context. Returns: Dictionary of key/value-pairs to be stored in the sessions-specific dictionary context. \"\"\" def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Initialize data class. This method will be called through the `/initialize` endpoint of the OTE-API Services. Parameters: session: A session-specific dictionary context. Returns: Dictionary of key/value-pairs to be stored in the sessions-specific dictionary context. \"\"\"","title":"IResourceStrategy"},{"location":"api_reference/interfaces/iresourcestrategy/#oteapi.interfaces.iresourcestrategy.IResourceStrategy.get","text":"Execute the strategy. Parameters: Name Type Description Default session Optional[Dict[str, Any]] A session-specific dictionary context. None Returns: Type Description Dict[str, Any] Dictionary of key/value-pairs to be stored in the sessions-specific dictionary context. Source code in oteapi/interfaces/iresourcestrategy.py def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Execute the strategy. Parameters: session: A session-specific dictionary context. Returns: Dictionary of key/value-pairs to be stored in the sessions-specific dictionary context. \"\"\"","title":"get()"},{"location":"api_reference/interfaces/iresourcestrategy/#oteapi.interfaces.iresourcestrategy.IResourceStrategy.initialize","text":"Initialize data class. This method will be called through the /initialize endpoint of the OTE-API Services. Parameters: Name Type Description Default session Optional[Dict[str, Any]] A session-specific dictionary context. None Returns: Type Description Dict[str, Any] Dictionary of key/value-pairs to be stored in the sessions-specific dictionary context. Source code in oteapi/interfaces/iresourcestrategy.py def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Initialize data class. This method will be called through the `/initialize` endpoint of the OTE-API Services. Parameters: session: A session-specific dictionary context. Returns: Dictionary of key/value-pairs to be stored in the sessions-specific dictionary context. \"\"\"","title":"initialize()"},{"location":"api_reference/interfaces/itransformationstrategy/","text":"itransformationstrategy \u00b6 Tranformation Strategy Interface ITransformationStrategy ( Protocol ) dataclass \u00b6 Transformation Strategy Interface. Source code in oteapi/interfaces/itransformationstrategy.py @dataclass # type: ignore[misc] @runtime_checkable class ITransformationStrategy ( Protocol ): \"\"\"Transformation Strategy Interface.\"\"\" transformation_config : \"TransformationConfig\" def run ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Run a transformation job. Parameters: session: A session-specific dictionary context. Returns: Dictionary of key/value-pairs to be stored in the sessions-specific dictionary context. As a minimum, the dictionary will contain the job ID. \"\"\" def status ( self , task_id : str ) -> \"TransformationStatus\" : \"\"\"Get job status. Parameters: task_id: The transformation job ID. Returns: An overview of the transformation job's status, including relevant metadata. \"\"\" def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Execute the strategy. Parameters: session: A session-specific dictionary context. Returns: Dictionary of key/value-pairs to be stored in the sessions-specific dictionary context. \"\"\" def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Initialize data class. This method will be called through the `/initialize` endpoint of the OTE-API Services. Parameters: session: A session-specific dictionary context. Returns: Dictionary of key/value-pairs to be stored in the sessions-specific dictionary context. \"\"\" get ( self , session = None ) \u00b6 Execute the strategy. Parameters: Name Type Description Default session Optional[Dict[str, Any]] A session-specific dictionary context. None Returns: Type Description Dict[str, Any] Dictionary of key/value-pairs to be stored in the sessions-specific dictionary context. Source code in oteapi/interfaces/itransformationstrategy.py def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Execute the strategy. Parameters: session: A session-specific dictionary context. Returns: Dictionary of key/value-pairs to be stored in the sessions-specific dictionary context. \"\"\" initialize ( self , session = None ) \u00b6 Initialize data class. This method will be called through the /initialize endpoint of the OTE-API Services. Parameters: Name Type Description Default session Optional[Dict[str, Any]] A session-specific dictionary context. None Returns: Type Description Dict[str, Any] Dictionary of key/value-pairs to be stored in the sessions-specific dictionary context. Source code in oteapi/interfaces/itransformationstrategy.py def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Initialize data class. This method will be called through the `/initialize` endpoint of the OTE-API Services. Parameters: session: A session-specific dictionary context. Returns: Dictionary of key/value-pairs to be stored in the sessions-specific dictionary context. \"\"\" run ( self , session = None ) \u00b6 Run a transformation job. Parameters: Name Type Description Default session Optional[Dict[str, Any]] A session-specific dictionary context. None Returns: Type Description Dict[str, Any] Dictionary of key/value-pairs to be stored in the sessions-specific dictionary context. As a minimum, the dictionary will contain the job ID. Source code in oteapi/interfaces/itransformationstrategy.py def run ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Run a transformation job. Parameters: session: A session-specific dictionary context. Returns: Dictionary of key/value-pairs to be stored in the sessions-specific dictionary context. As a minimum, the dictionary will contain the job ID. \"\"\" status ( self , task_id ) \u00b6 Get job status. Parameters: Name Type Description Default task_id str The transformation job ID. required Returns: Type Description TransformationStatus An overview of the transformation job's status, including relevant metadata. Source code in oteapi/interfaces/itransformationstrategy.py def status ( self , task_id : str ) -> \"TransformationStatus\" : \"\"\"Get job status. Parameters: task_id: The transformation job ID. Returns: An overview of the transformation job's status, including relevant metadata. \"\"\"","title":"itransformationstrategy"},{"location":"api_reference/interfaces/itransformationstrategy/#itransformationstrategy","text":"Tranformation Strategy Interface","title":"itransformationstrategy"},{"location":"api_reference/interfaces/itransformationstrategy/#oteapi.interfaces.itransformationstrategy.ITransformationStrategy","text":"Transformation Strategy Interface. Source code in oteapi/interfaces/itransformationstrategy.py @dataclass # type: ignore[misc] @runtime_checkable class ITransformationStrategy ( Protocol ): \"\"\"Transformation Strategy Interface.\"\"\" transformation_config : \"TransformationConfig\" def run ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Run a transformation job. Parameters: session: A session-specific dictionary context. Returns: Dictionary of key/value-pairs to be stored in the sessions-specific dictionary context. As a minimum, the dictionary will contain the job ID. \"\"\" def status ( self , task_id : str ) -> \"TransformationStatus\" : \"\"\"Get job status. Parameters: task_id: The transformation job ID. Returns: An overview of the transformation job's status, including relevant metadata. \"\"\" def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Execute the strategy. Parameters: session: A session-specific dictionary context. Returns: Dictionary of key/value-pairs to be stored in the sessions-specific dictionary context. \"\"\" def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Initialize data class. This method will be called through the `/initialize` endpoint of the OTE-API Services. Parameters: session: A session-specific dictionary context. Returns: Dictionary of key/value-pairs to be stored in the sessions-specific dictionary context. \"\"\"","title":"ITransformationStrategy"},{"location":"api_reference/interfaces/itransformationstrategy/#oteapi.interfaces.itransformationstrategy.ITransformationStrategy.get","text":"Execute the strategy. Parameters: Name Type Description Default session Optional[Dict[str, Any]] A session-specific dictionary context. None Returns: Type Description Dict[str, Any] Dictionary of key/value-pairs to be stored in the sessions-specific dictionary context. Source code in oteapi/interfaces/itransformationstrategy.py def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Execute the strategy. Parameters: session: A session-specific dictionary context. Returns: Dictionary of key/value-pairs to be stored in the sessions-specific dictionary context. \"\"\"","title":"get()"},{"location":"api_reference/interfaces/itransformationstrategy/#oteapi.interfaces.itransformationstrategy.ITransformationStrategy.initialize","text":"Initialize data class. This method will be called through the /initialize endpoint of the OTE-API Services. Parameters: Name Type Description Default session Optional[Dict[str, Any]] A session-specific dictionary context. None Returns: Type Description Dict[str, Any] Dictionary of key/value-pairs to be stored in the sessions-specific dictionary context. Source code in oteapi/interfaces/itransformationstrategy.py def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Initialize data class. This method will be called through the `/initialize` endpoint of the OTE-API Services. Parameters: session: A session-specific dictionary context. Returns: Dictionary of key/value-pairs to be stored in the sessions-specific dictionary context. \"\"\"","title":"initialize()"},{"location":"api_reference/interfaces/itransformationstrategy/#oteapi.interfaces.itransformationstrategy.ITransformationStrategy.run","text":"Run a transformation job. Parameters: Name Type Description Default session Optional[Dict[str, Any]] A session-specific dictionary context. None Returns: Type Description Dict[str, Any] Dictionary of key/value-pairs to be stored in the sessions-specific dictionary context. As a minimum, the dictionary will contain the job ID. Source code in oteapi/interfaces/itransformationstrategy.py def run ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Run a transformation job. Parameters: session: A session-specific dictionary context. Returns: Dictionary of key/value-pairs to be stored in the sessions-specific dictionary context. As a minimum, the dictionary will contain the job ID. \"\"\"","title":"run()"},{"location":"api_reference/interfaces/itransformationstrategy/#oteapi.interfaces.itransformationstrategy.ITransformationStrategy.status","text":"Get job status. Parameters: Name Type Description Default task_id str The transformation job ID. required Returns: Type Description TransformationStatus An overview of the transformation job's status, including relevant metadata. Source code in oteapi/interfaces/itransformationstrategy.py def status ( self , task_id : str ) -> \"TransformationStatus\" : \"\"\"Get job status. Parameters: task_id: The transformation job ID. Returns: An overview of the transformation job's status, including relevant metadata. \"\"\"","title":"status()"},{"location":"api_reference/models/datacacheconfig/","text":"datacacheconfig \u00b6 Pydantic DataCache Configuration Data Model. DataCacheConfig ( BaseModel ) pydantic-model \u00b6 DataCache Configuration. Source code in oteapi/models/datacacheconfig.py class DataCacheConfig ( BaseModel ): \"\"\"DataCache Configuration.\"\"\" cacheDir : Path = Field ( \"oteapi\" , description = \"Cache directory.\" ) accessKey : str = Field ( None , description = \"Key with which the downloaded content can be accessed. \" \"Should preferable be the hash (corresponding to `hashType`) of the \" \"content if it is known.\" , ) hashType : str = Field ( \"md5\" , description = \"Hash algorithm to use for creating hash keys for stored \" \"data. Can be any algorithm supported by hashlib.\" , ) expireTime : int = Field ( 3600 * 24 * 14 , description = \"Number of seconds before the cache entry expires. \" \"Zero means no expiration. Default is two weeks.\" , ) tag : str = Field ( None , description = \"Tag assigned to the downloaded content, typically \" \"identifying a session. Used with the `evict()` method to clean up a \" \"all cache entries with a given tag.\" , ) accessKey : str pydantic-field \u00b6 Key with which the downloaded content can be accessed. Should preferable be the hash (corresponding to hashType ) of the content if it is known. cacheDir : Path pydantic-field \u00b6 Cache directory. expireTime : int pydantic-field \u00b6 Number of seconds before the cache entry expires. Zero means no expiration. Default is two weeks. hashType : str pydantic-field \u00b6 Hash algorithm to use for creating hash keys for stored data. Can be any algorithm supported by hashlib. tag : str pydantic-field \u00b6 Tag assigned to the downloaded content, typically identifying a session. Used with the evict() method to clean up a all cache entries with a given tag.","title":"datacacheconfig"},{"location":"api_reference/models/datacacheconfig/#datacacheconfig","text":"Pydantic DataCache Configuration Data Model.","title":"datacacheconfig"},{"location":"api_reference/models/datacacheconfig/#oteapi.models.datacacheconfig.DataCacheConfig","text":"DataCache Configuration. Source code in oteapi/models/datacacheconfig.py class DataCacheConfig ( BaseModel ): \"\"\"DataCache Configuration.\"\"\" cacheDir : Path = Field ( \"oteapi\" , description = \"Cache directory.\" ) accessKey : str = Field ( None , description = \"Key with which the downloaded content can be accessed. \" \"Should preferable be the hash (corresponding to `hashType`) of the \" \"content if it is known.\" , ) hashType : str = Field ( \"md5\" , description = \"Hash algorithm to use for creating hash keys for stored \" \"data. Can be any algorithm supported by hashlib.\" , ) expireTime : int = Field ( 3600 * 24 * 14 , description = \"Number of seconds before the cache entry expires. \" \"Zero means no expiration. Default is two weeks.\" , ) tag : str = Field ( None , description = \"Tag assigned to the downloaded content, typically \" \"identifying a session. Used with the `evict()` method to clean up a \" \"all cache entries with a given tag.\" , )","title":"DataCacheConfig"},{"location":"api_reference/models/datacacheconfig/#oteapi.models.datacacheconfig.DataCacheConfig.accessKey","text":"Key with which the downloaded content can be accessed. Should preferable be the hash (corresponding to hashType ) of the content if it is known.","title":"accessKey"},{"location":"api_reference/models/datacacheconfig/#oteapi.models.datacacheconfig.DataCacheConfig.cacheDir","text":"Cache directory.","title":"cacheDir"},{"location":"api_reference/models/datacacheconfig/#oteapi.models.datacacheconfig.DataCacheConfig.expireTime","text":"Number of seconds before the cache entry expires. Zero means no expiration. Default is two weeks.","title":"expireTime"},{"location":"api_reference/models/datacacheconfig/#oteapi.models.datacacheconfig.DataCacheConfig.hashType","text":"Hash algorithm to use for creating hash keys for stored data. Can be any algorithm supported by hashlib.","title":"hashType"},{"location":"api_reference/models/datacacheconfig/#oteapi.models.datacacheconfig.DataCacheConfig.tag","text":"Tag assigned to the downloaded content, typically identifying a session. Used with the evict() method to clean up a all cache entries with a given tag.","title":"tag"},{"location":"api_reference/models/filterconfig/","text":"filterconfig \u00b6 Pydantic Filter Configuration Data Model. FilterConfig ( BaseModel ) pydantic-model \u00b6 Filter Strategy Data Configuration. Source code in oteapi/models/filterconfig.py class FilterConfig ( BaseModel ): \"\"\"Filter Strategy Data Configuration.\"\"\" filterType : str = Field ( ... , description = \"Type of registered filter strategy. E.g., `filter/sql`.\" ) query : Optional [ str ] = Field ( None , description = \"Define a query operation.\" ) condition : Optional [ str ] = Field ( None , description = \"Logical statement indicating when a filter should be applied.\" , ) limit : Optional [ int ] = Field ( None , description = \"Number of items remaining after a filter expression.\" ) configuration : Optional [ Dict ] = Field ( None , description = \"Filter-specific configuration options given as key/value-pairs.\" , ) condition : str pydantic-field \u00b6 Logical statement indicating when a filter should be applied. configuration : Dict pydantic-field \u00b6 Filter-specific configuration options given as key/value-pairs. filterType : str pydantic-field required \u00b6 Type of registered filter strategy. E.g., filter/sql . limit : int pydantic-field \u00b6 Number of items remaining after a filter expression. query : str pydantic-field \u00b6 Define a query operation.","title":"filterconfig"},{"location":"api_reference/models/filterconfig/#filterconfig","text":"Pydantic Filter Configuration Data Model.","title":"filterconfig"},{"location":"api_reference/models/filterconfig/#oteapi.models.filterconfig.FilterConfig","text":"Filter Strategy Data Configuration. Source code in oteapi/models/filterconfig.py class FilterConfig ( BaseModel ): \"\"\"Filter Strategy Data Configuration.\"\"\" filterType : str = Field ( ... , description = \"Type of registered filter strategy. E.g., `filter/sql`.\" ) query : Optional [ str ] = Field ( None , description = \"Define a query operation.\" ) condition : Optional [ str ] = Field ( None , description = \"Logical statement indicating when a filter should be applied.\" , ) limit : Optional [ int ] = Field ( None , description = \"Number of items remaining after a filter expression.\" ) configuration : Optional [ Dict ] = Field ( None , description = \"Filter-specific configuration options given as key/value-pairs.\" , )","title":"FilterConfig"},{"location":"api_reference/models/filterconfig/#oteapi.models.filterconfig.FilterConfig.condition","text":"Logical statement indicating when a filter should be applied.","title":"condition"},{"location":"api_reference/models/filterconfig/#oteapi.models.filterconfig.FilterConfig.configuration","text":"Filter-specific configuration options given as key/value-pairs.","title":"configuration"},{"location":"api_reference/models/filterconfig/#oteapi.models.filterconfig.FilterConfig.filterType","text":"Type of registered filter strategy. E.g., filter/sql .","title":"filterType"},{"location":"api_reference/models/filterconfig/#oteapi.models.filterconfig.FilterConfig.limit","text":"Number of items remaining after a filter expression.","title":"limit"},{"location":"api_reference/models/filterconfig/#oteapi.models.filterconfig.FilterConfig.query","text":"Define a query operation.","title":"query"},{"location":"api_reference/models/mappingconfig/","text":"mappingconfig \u00b6 Pydantic Mapping Configuration Data Model. SemanticTriple \u00b6 MappingConfig ( BaseModel ) pydantic-model \u00b6 Mapping Strategy Data Configuration. Source code in oteapi/models/mappingconfig.py class MappingConfig ( BaseModel ): \"\"\"Mapping Strategy Data Configuration.\"\"\" mappingType : str = Field ( ... , description = \"Type of registered mapping strategy. E.g., `mapping/demo`.\" ) prefixes : Optional [ Dict [ str , str ]] = Field ( None , description = ( \"List of shortnames that expands to an IRI \" \"given as local value/IRI-expansion-pairs.\" ), ) triples : Optional [ List [ SemanticTriple ]] = Field ( # type: ignore[valid-type] None , description = \"List of semantic triples given as (subject, predicate, object).\" , ) configuration : Optional [ Dict ] = Field ( None , description = \"Mapping-specific configuration options given as key/value-pairs.\" , ) configuration : Dict pydantic-field \u00b6 Mapping-specific configuration options given as key/value-pairs. mappingType : str pydantic-field required \u00b6 Type of registered mapping strategy. E.g., mapping/demo . prefixes : Dict [ str , str ] pydantic-field \u00b6 List of shortnames that expands to an IRI given as local value/IRI-expansion-pairs. triples : List [ types . ConstrainedListValue ] pydantic-field \u00b6 List of semantic triples given as (subject, predicate, object).","title":"mappingconfig"},{"location":"api_reference/models/mappingconfig/#mappingconfig","text":"Pydantic Mapping Configuration Data Model.","title":"mappingconfig"},{"location":"api_reference/models/mappingconfig/#oteapi.models.mappingconfig.SemanticTriple","text":"","title":"SemanticTriple"},{"location":"api_reference/models/mappingconfig/#oteapi.models.mappingconfig.MappingConfig","text":"Mapping Strategy Data Configuration. Source code in oteapi/models/mappingconfig.py class MappingConfig ( BaseModel ): \"\"\"Mapping Strategy Data Configuration.\"\"\" mappingType : str = Field ( ... , description = \"Type of registered mapping strategy. E.g., `mapping/demo`.\" ) prefixes : Optional [ Dict [ str , str ]] = Field ( None , description = ( \"List of shortnames that expands to an IRI \" \"given as local value/IRI-expansion-pairs.\" ), ) triples : Optional [ List [ SemanticTriple ]] = Field ( # type: ignore[valid-type] None , description = \"List of semantic triples given as (subject, predicate, object).\" , ) configuration : Optional [ Dict ] = Field ( None , description = \"Mapping-specific configuration options given as key/value-pairs.\" , )","title":"MappingConfig"},{"location":"api_reference/models/mappingconfig/#oteapi.models.mappingconfig.MappingConfig.configuration","text":"Mapping-specific configuration options given as key/value-pairs.","title":"configuration"},{"location":"api_reference/models/mappingconfig/#oteapi.models.mappingconfig.MappingConfig.mappingType","text":"Type of registered mapping strategy. E.g., mapping/demo .","title":"mappingType"},{"location":"api_reference/models/mappingconfig/#oteapi.models.mappingconfig.MappingConfig.prefixes","text":"List of shortnames that expands to an IRI given as local value/IRI-expansion-pairs.","title":"prefixes"},{"location":"api_reference/models/mappingconfig/#oteapi.models.mappingconfig.MappingConfig.triples","text":"List of semantic triples given as (subject, predicate, object).","title":"triples"},{"location":"api_reference/models/resourceconfig/","text":"resourceconfig \u00b6 Pydantic Resource Configuration Data Model. ResourceConfig ( BaseModel ) pydantic-model \u00b6 Resource Strategy Data Configuration. Important Either of the pairs of attributes downloadUrl / mediaType or accessUrl / accessService MUST be specified. Source code in oteapi/models/resourceconfig.py class ResourceConfig ( BaseModel ): \"\"\"Resource Strategy Data Configuration. Important: Either of the pairs of attributes `downloadUrl`/`mediaType` or `accessUrl`/`accessService` MUST be specified. \"\"\" downloadUrl : Optional [ AnyUrl ] = Field ( None , description = ( \"Definition: The URL of the downloadable file in a given format. E.g. CSV \" \"file or RDF file. \\n\\n Usage: `downloadURL` *SHOULD* be used for the URL at\" \" which this distribution is available directly, typically through a HTTPS\" \" GET request or SFTP.\" ), ) mediaType : Optional [ str ] = Field ( None , description = ( \"The media type of the distribution as defined by IANA \" \"[[IANA-MEDIA-TYPES](https://www.w3.org/TR/vocab-dcat-2/#bib-iana-media-types)]\" \". \\n\\n Usage: This property *SHOULD* be used when the media\" \" type of the distribution is defined in IANA \" \"[[IANA-MEDIA-TYPES](https://www.w3.org/TR/vocab-dcat-2/#bib-iana-media-types)].\" ), ) accessUrl : Optional [ AnyUrl ] = Field ( None , description = ( \"A URL of the resource that gives access to a distribution of \" \"the dataset. E.g. landing page, feed, SPARQL endpoint. \\n\\n Usage: \" \"`accessURL` *SHOULD* be used for the URL of a service or location that \" \"can provide access to this distribution, typically through a Web form, \" \"query or API call. \\n `downloadURL` is preferred for direct links to \" \"downloadable resources.\" ), ) accessService : Optional [ str ] = Field ( None , description = ( \"A data service that gives access to the distribution of the dataset.\" ), ) license : Optional [ str ] = Field ( None , description = ( \"A legal document under which the distribution is made available.\" ), ) accessRights : Optional [ str ] = Field ( None , description = ( \"A rights statement that concerns how the distribution is accessed.\" ), ) description : Optional [ str ] = Field ( None , description = \"A free-text account of the distribution.\" ) publisher : Optional [ str ] = Field ( None , description = \"The entity responsible for making the resource/item available.\" , ) configuration : Union [ DataCacheConfig , Dict [ str , Any ]] = Field ( {}, description = \"Resource-specific configuration options given as key/value-pairs.\" , ) @root_validator def ensure_unique_url_pairs ( # pylint: disable=no-self-use cls , values : Dict [ str , Any ] ) -> Dict [ str , Any ]: \"\"\"Ensure either downloadUrl/mediaType or accessUrl/accessService are defined. It's fine to define them all, but at least one complete pair MUST be specified.\"\"\" if not ( all ( values . get ( _ ) for _ in [ \"downloadUrl\" , \"mediaType\" ]) or all ( values . get ( _ ) for _ in [ \"accessUrl\" , \"accessService\" ]) ): raise ValueError ( \"Either of the pairs of attributes downloadUrl/mediaType or \" \"accessUrl/accessService MUST be specified.\" ) return values accessRights : str pydantic-field \u00b6 A rights statement that concerns how the distribution is accessed. accessService : str pydantic-field \u00b6 A data service that gives access to the distribution of the dataset. accessUrl : AnyUrl pydantic-field \u00b6 A URL of the resource that gives access to a distribution of the dataset. E.g. landing page, feed, SPARQL endpoint. Usage: accessURL SHOULD be used for the URL of a service or location that can provide access to this distribution, typically through a Web form, query or API call. downloadURL is preferred for direct links to downloadable resources. configuration : Union [ oteapi . models . datacacheconfig . DataCacheConfig , Dict [ str , Any ]] pydantic-field \u00b6 Resource-specific configuration options given as key/value-pairs. description : str pydantic-field \u00b6 A free-text account of the distribution. downloadUrl : AnyUrl pydantic-field \u00b6 Definition: The URL of the downloadable file in a given format. E.g. CSV file or RDF file. Usage: downloadURL SHOULD be used for the URL at which this distribution is available directly, typically through a HTTPS GET request or SFTP. license : str pydantic-field \u00b6 A legal document under which the distribution is made available. mediaType : str pydantic-field \u00b6 The media type of the distribution as defined by IANA [ IANA-MEDIA-TYPES ]. Usage: This property SHOULD be used when the media type of the distribution is defined in IANA [ IANA-MEDIA-TYPES ]. publisher : str pydantic-field \u00b6 The entity responsible for making the resource/item available. ensure_unique_url_pairs ( values ) classmethod \u00b6 Ensure either downloadUrl/mediaType or accessUrl/accessService are defined. It's fine to define them all, but at least one complete pair MUST be specified. Source code in oteapi/models/resourceconfig.py @root_validator def ensure_unique_url_pairs ( # pylint: disable=no-self-use cls , values : Dict [ str , Any ] ) -> Dict [ str , Any ]: \"\"\"Ensure either downloadUrl/mediaType or accessUrl/accessService are defined. It's fine to define them all, but at least one complete pair MUST be specified.\"\"\" if not ( all ( values . get ( _ ) for _ in [ \"downloadUrl\" , \"mediaType\" ]) or all ( values . get ( _ ) for _ in [ \"accessUrl\" , \"accessService\" ]) ): raise ValueError ( \"Either of the pairs of attributes downloadUrl/mediaType or \" \"accessUrl/accessService MUST be specified.\" ) return values","title":"resourceconfig"},{"location":"api_reference/models/resourceconfig/#resourceconfig","text":"Pydantic Resource Configuration Data Model.","title":"resourceconfig"},{"location":"api_reference/models/resourceconfig/#oteapi.models.resourceconfig.ResourceConfig","text":"Resource Strategy Data Configuration. Important Either of the pairs of attributes downloadUrl / mediaType or accessUrl / accessService MUST be specified. Source code in oteapi/models/resourceconfig.py class ResourceConfig ( BaseModel ): \"\"\"Resource Strategy Data Configuration. Important: Either of the pairs of attributes `downloadUrl`/`mediaType` or `accessUrl`/`accessService` MUST be specified. \"\"\" downloadUrl : Optional [ AnyUrl ] = Field ( None , description = ( \"Definition: The URL of the downloadable file in a given format. E.g. CSV \" \"file or RDF file. \\n\\n Usage: `downloadURL` *SHOULD* be used for the URL at\" \" which this distribution is available directly, typically through a HTTPS\" \" GET request or SFTP.\" ), ) mediaType : Optional [ str ] = Field ( None , description = ( \"The media type of the distribution as defined by IANA \" \"[[IANA-MEDIA-TYPES](https://www.w3.org/TR/vocab-dcat-2/#bib-iana-media-types)]\" \". \\n\\n Usage: This property *SHOULD* be used when the media\" \" type of the distribution is defined in IANA \" \"[[IANA-MEDIA-TYPES](https://www.w3.org/TR/vocab-dcat-2/#bib-iana-media-types)].\" ), ) accessUrl : Optional [ AnyUrl ] = Field ( None , description = ( \"A URL of the resource that gives access to a distribution of \" \"the dataset. E.g. landing page, feed, SPARQL endpoint. \\n\\n Usage: \" \"`accessURL` *SHOULD* be used for the URL of a service or location that \" \"can provide access to this distribution, typically through a Web form, \" \"query or API call. \\n `downloadURL` is preferred for direct links to \" \"downloadable resources.\" ), ) accessService : Optional [ str ] = Field ( None , description = ( \"A data service that gives access to the distribution of the dataset.\" ), ) license : Optional [ str ] = Field ( None , description = ( \"A legal document under which the distribution is made available.\" ), ) accessRights : Optional [ str ] = Field ( None , description = ( \"A rights statement that concerns how the distribution is accessed.\" ), ) description : Optional [ str ] = Field ( None , description = \"A free-text account of the distribution.\" ) publisher : Optional [ str ] = Field ( None , description = \"The entity responsible for making the resource/item available.\" , ) configuration : Union [ DataCacheConfig , Dict [ str , Any ]] = Field ( {}, description = \"Resource-specific configuration options given as key/value-pairs.\" , ) @root_validator def ensure_unique_url_pairs ( # pylint: disable=no-self-use cls , values : Dict [ str , Any ] ) -> Dict [ str , Any ]: \"\"\"Ensure either downloadUrl/mediaType or accessUrl/accessService are defined. It's fine to define them all, but at least one complete pair MUST be specified.\"\"\" if not ( all ( values . get ( _ ) for _ in [ \"downloadUrl\" , \"mediaType\" ]) or all ( values . get ( _ ) for _ in [ \"accessUrl\" , \"accessService\" ]) ): raise ValueError ( \"Either of the pairs of attributes downloadUrl/mediaType or \" \"accessUrl/accessService MUST be specified.\" ) return values","title":"ResourceConfig"},{"location":"api_reference/models/resourceconfig/#oteapi.models.resourceconfig.ResourceConfig.accessRights","text":"A rights statement that concerns how the distribution is accessed.","title":"accessRights"},{"location":"api_reference/models/resourceconfig/#oteapi.models.resourceconfig.ResourceConfig.accessService","text":"A data service that gives access to the distribution of the dataset.","title":"accessService"},{"location":"api_reference/models/resourceconfig/#oteapi.models.resourceconfig.ResourceConfig.accessUrl","text":"A URL of the resource that gives access to a distribution of the dataset. E.g. landing page, feed, SPARQL endpoint. Usage: accessURL SHOULD be used for the URL of a service or location that can provide access to this distribution, typically through a Web form, query or API call. downloadURL is preferred for direct links to downloadable resources.","title":"accessUrl"},{"location":"api_reference/models/resourceconfig/#oteapi.models.resourceconfig.ResourceConfig.configuration","text":"Resource-specific configuration options given as key/value-pairs.","title":"configuration"},{"location":"api_reference/models/resourceconfig/#oteapi.models.resourceconfig.ResourceConfig.description","text":"A free-text account of the distribution.","title":"description"},{"location":"api_reference/models/resourceconfig/#oteapi.models.resourceconfig.ResourceConfig.downloadUrl","text":"Definition: The URL of the downloadable file in a given format. E.g. CSV file or RDF file. Usage: downloadURL SHOULD be used for the URL at which this distribution is available directly, typically through a HTTPS GET request or SFTP.","title":"downloadUrl"},{"location":"api_reference/models/resourceconfig/#oteapi.models.resourceconfig.ResourceConfig.license","text":"A legal document under which the distribution is made available.","title":"license"},{"location":"api_reference/models/resourceconfig/#oteapi.models.resourceconfig.ResourceConfig.mediaType","text":"The media type of the distribution as defined by IANA [ IANA-MEDIA-TYPES ]. Usage: This property SHOULD be used when the media type of the distribution is defined in IANA [ IANA-MEDIA-TYPES ].","title":"mediaType"},{"location":"api_reference/models/resourceconfig/#oteapi.models.resourceconfig.ResourceConfig.publisher","text":"The entity responsible for making the resource/item available.","title":"publisher"},{"location":"api_reference/models/resourceconfig/#oteapi.models.resourceconfig.ResourceConfig.ensure_unique_url_pairs","text":"Ensure either downloadUrl/mediaType or accessUrl/accessService are defined. It's fine to define them all, but at least one complete pair MUST be specified. Source code in oteapi/models/resourceconfig.py @root_validator def ensure_unique_url_pairs ( # pylint: disable=no-self-use cls , values : Dict [ str , Any ] ) -> Dict [ str , Any ]: \"\"\"Ensure either downloadUrl/mediaType or accessUrl/accessService are defined. It's fine to define them all, but at least one complete pair MUST be specified.\"\"\" if not ( all ( values . get ( _ ) for _ in [ \"downloadUrl\" , \"mediaType\" ]) or all ( values . get ( _ ) for _ in [ \"accessUrl\" , \"accessService\" ]) ): raise ValueError ( \"Either of the pairs of attributes downloadUrl/mediaType or \" \"accessUrl/accessService MUST be specified.\" ) return values","title":"ensure_unique_url_pairs()"},{"location":"api_reference/models/transformationconfig/","text":"transformationconfig \u00b6 Pydantic Transformation Configuration Data Model. A transformation status data model is provided as well. This data model represents what should be returned from the strategy's status() method. PriorityEnum ( str , Enum ) \u00b6 Defining process priority enumerators. Process priorities: Low Medium High Source code in oteapi/models/transformationconfig.py class PriorityEnum ( str , Enum ): \"\"\"Defining process priority enumerators. Process priorities: - Low - Medium - High \"\"\" LOW = \"Low\" MEDIUM = \"Medium\" HIGH = \"High\" HIGH \u00b6 LOW \u00b6 MEDIUM \u00b6 TransformationConfig ( BaseModel ) pydantic-model \u00b6 Transformation Strategy Data Configuration. Source code in oteapi/models/transformationconfig.py class TransformationConfig ( BaseModel ): \"\"\"Transformation Strategy Data Configuration.\"\"\" transformation_type : str = Field ( ... , description = ( \"Type of registered transformation strategy. E.g., `celery/remote`.\" ), ) name : Optional [ str ] = Field ( None , description = \"Human-readable name of the transformation strategy.\" ) description : Optional [ str ] = Field ( None , description = \"A free-text account of the transformation.\" ) due : Optional [ datetime ] = Field ( None , description = ( \"Optional field to indicate a due data/time for when a transformation \" \"should finish.\" ), ) priority : Optional [ PriorityEnum ] = Field ( PriorityEnum . MEDIUM , description = \"Define the process priority of the transformation execution.\" , ) secret : Optional [ str ] = Field ( None , description = \"Authorization secret given when running a transformation.\" , ) configuration : Optional [ Dict ] = Field ( None , description = ( \"Transformation-specific configuration options given as key/value-pairs.\" ), ) configuration : Dict pydantic-field \u00b6 Transformation-specific configuration options given as key/value-pairs. description : str pydantic-field \u00b6 A free-text account of the transformation. due : datetime pydantic-field \u00b6 Optional field to indicate a due data/time for when a transformation should finish. name : str pydantic-field \u00b6 Human-readable name of the transformation strategy. priority : PriorityEnum pydantic-field \u00b6 Define the process priority of the transformation execution. secret : str pydantic-field \u00b6 Authorization secret given when running a transformation. transformation_type : str pydantic-field required \u00b6 Type of registered transformation strategy. E.g., celery/remote . TransformationStatus ( BaseModel ) pydantic-model \u00b6 Return from transformation status. Source code in oteapi/models/transformationconfig.py class TransformationStatus ( BaseModel ): \"\"\"Return from transformation status.\"\"\" id : str = Field ( ... , description = \"ID for the given transformation process.\" ) status : Optional [ str ] = Field ( None , description = \"Status for the transformation process.\" ) messages : Optional [ List [ str ]] = Field ( None , description = \"Messages related to the transformation process.\" ) created : Optional [ datetime ] = Field ( None , description = \"Time of creation for the transformation process. Given in UTC.\" , ) startTime : Optional [ datetime ] = Field ( None , description = \"Time when the transformation process started. Given in UTC.\" ) finishTime : Optional [ datetime ] = Field ( None , description = \"Time when the tranformation process finished. Given in UTC.\" ) created : datetime pydantic-field \u00b6 Time of creation for the transformation process. Given in UTC. finishTime : datetime pydantic-field \u00b6 Time when the tranformation process finished. Given in UTC. id : str pydantic-field required \u00b6 ID for the given transformation process. messages : List [ str ] pydantic-field \u00b6 Messages related to the transformation process. startTime : datetime pydantic-field \u00b6 Time when the transformation process started. Given in UTC. status : str pydantic-field \u00b6 Status for the transformation process.","title":"transformationconfig"},{"location":"api_reference/models/transformationconfig/#transformationconfig","text":"Pydantic Transformation Configuration Data Model. A transformation status data model is provided as well. This data model represents what should be returned from the strategy's status() method.","title":"transformationconfig"},{"location":"api_reference/models/transformationconfig/#oteapi.models.transformationconfig.PriorityEnum","text":"Defining process priority enumerators. Process priorities: Low Medium High Source code in oteapi/models/transformationconfig.py class PriorityEnum ( str , Enum ): \"\"\"Defining process priority enumerators. Process priorities: - Low - Medium - High \"\"\" LOW = \"Low\" MEDIUM = \"Medium\" HIGH = \"High\"","title":"PriorityEnum"},{"location":"api_reference/models/transformationconfig/#oteapi.models.transformationconfig.PriorityEnum.HIGH","text":"","title":"HIGH"},{"location":"api_reference/models/transformationconfig/#oteapi.models.transformationconfig.PriorityEnum.LOW","text":"","title":"LOW"},{"location":"api_reference/models/transformationconfig/#oteapi.models.transformationconfig.PriorityEnum.MEDIUM","text":"","title":"MEDIUM"},{"location":"api_reference/models/transformationconfig/#oteapi.models.transformationconfig.TransformationConfig","text":"Transformation Strategy Data Configuration. Source code in oteapi/models/transformationconfig.py class TransformationConfig ( BaseModel ): \"\"\"Transformation Strategy Data Configuration.\"\"\" transformation_type : str = Field ( ... , description = ( \"Type of registered transformation strategy. E.g., `celery/remote`.\" ), ) name : Optional [ str ] = Field ( None , description = \"Human-readable name of the transformation strategy.\" ) description : Optional [ str ] = Field ( None , description = \"A free-text account of the transformation.\" ) due : Optional [ datetime ] = Field ( None , description = ( \"Optional field to indicate a due data/time for when a transformation \" \"should finish.\" ), ) priority : Optional [ PriorityEnum ] = Field ( PriorityEnum . MEDIUM , description = \"Define the process priority of the transformation execution.\" , ) secret : Optional [ str ] = Field ( None , description = \"Authorization secret given when running a transformation.\" , ) configuration : Optional [ Dict ] = Field ( None , description = ( \"Transformation-specific configuration options given as key/value-pairs.\" ), )","title":"TransformationConfig"},{"location":"api_reference/models/transformationconfig/#oteapi.models.transformationconfig.TransformationConfig.configuration","text":"Transformation-specific configuration options given as key/value-pairs.","title":"configuration"},{"location":"api_reference/models/transformationconfig/#oteapi.models.transformationconfig.TransformationConfig.description","text":"A free-text account of the transformation.","title":"description"},{"location":"api_reference/models/transformationconfig/#oteapi.models.transformationconfig.TransformationConfig.due","text":"Optional field to indicate a due data/time for when a transformation should finish.","title":"due"},{"location":"api_reference/models/transformationconfig/#oteapi.models.transformationconfig.TransformationConfig.name","text":"Human-readable name of the transformation strategy.","title":"name"},{"location":"api_reference/models/transformationconfig/#oteapi.models.transformationconfig.TransformationConfig.priority","text":"Define the process priority of the transformation execution.","title":"priority"},{"location":"api_reference/models/transformationconfig/#oteapi.models.transformationconfig.TransformationConfig.secret","text":"Authorization secret given when running a transformation.","title":"secret"},{"location":"api_reference/models/transformationconfig/#oteapi.models.transformationconfig.TransformationConfig.transformation_type","text":"Type of registered transformation strategy. E.g., celery/remote .","title":"transformation_type"},{"location":"api_reference/models/transformationconfig/#oteapi.models.transformationconfig.TransformationStatus","text":"Return from transformation status. Source code in oteapi/models/transformationconfig.py class TransformationStatus ( BaseModel ): \"\"\"Return from transformation status.\"\"\" id : str = Field ( ... , description = \"ID for the given transformation process.\" ) status : Optional [ str ] = Field ( None , description = \"Status for the transformation process.\" ) messages : Optional [ List [ str ]] = Field ( None , description = \"Messages related to the transformation process.\" ) created : Optional [ datetime ] = Field ( None , description = \"Time of creation for the transformation process. Given in UTC.\" , ) startTime : Optional [ datetime ] = Field ( None , description = \"Time when the transformation process started. Given in UTC.\" ) finishTime : Optional [ datetime ] = Field ( None , description = \"Time when the tranformation process finished. Given in UTC.\" )","title":"TransformationStatus"},{"location":"api_reference/models/transformationconfig/#oteapi.models.transformationconfig.TransformationStatus.created","text":"Time of creation for the transformation process. Given in UTC.","title":"created"},{"location":"api_reference/models/transformationconfig/#oteapi.models.transformationconfig.TransformationStatus.finishTime","text":"Time when the tranformation process finished. Given in UTC.","title":"finishTime"},{"location":"api_reference/models/transformationconfig/#oteapi.models.transformationconfig.TransformationStatus.id","text":"ID for the given transformation process.","title":"id"},{"location":"api_reference/models/transformationconfig/#oteapi.models.transformationconfig.TransformationStatus.messages","text":"Messages related to the transformation process.","title":"messages"},{"location":"api_reference/models/transformationconfig/#oteapi.models.transformationconfig.TransformationStatus.startTime","text":"Time when the transformation process started. Given in UTC.","title":"startTime"},{"location":"api_reference/models/transformationconfig/#oteapi.models.transformationconfig.TransformationStatus.status","text":"Status for the transformation process.","title":"status"},{"location":"api_reference/plugins/factories/","text":"factories \u00b6 Factory class for registering and creating strategy instances. Factory wrapper methods for creating the individual strategies. StrategyFactory \u00b6 Decorator-based Factory class. Attributes: Name Type Description strategy_create_func A local cache of all registerred strategies with their accompanying class. Source code in oteapi/plugins/factories.py class StrategyFactory : \"\"\"Decorator-based Factory class. Attributes: strategy_create_func: A local cache of all registerred strategies with their accompanying class. \"\"\" strategy_create_func : \"Dict[Tuple[str, ValueType], Type[IStrategy]]\" = {} @classmethod def make_strategy ( cls , model : \"StrategyConfig\" , field : \"Optional[str]\" = None , index : \"Optional[Tuple[str, ValueType]]\" = None , ) -> \"IStrategy\" : \"\"\"Instantiate a strategy in a context class. Parameters: model: A strategy configuration. field: The strategy index type, e.g., `\"scheme\"`, `\"mediaType\"` or similar. index: A tuple of the `field` and a unique strategy name for the strategy index type/`field`. Returns: An instantiated strategy. The strategy is instantiated with the provided configuration, through the `model` parameter. \"\"\" try : if not index and field : index = ( field , model . dict ()[ field ]) elif not index : raise ValueError ( \"field or index must be specified.\" ) retval = cls . strategy_create_func [ index ] except KeyError as err : raise NotImplementedError ( f \" { index =!r} does not exist\" ) from err return retval ( model ) @classmethod def register ( cls , * args : \"Tuple[str, ValueType]\" ) -> \"Callable[[Any], Type[IStrategy]]\" : \"\"\"Register a strategy. The identifier for the strategy is defined by a set of key-value tuple pairs. \"\"\" def decorator ( strategy_class : \"Type[IStrategy]\" ) -> \"Type[IStrategy]\" : for index in args : if index not in cls . strategy_create_func : print ( f \"Registering { strategy_class . __name__ } with { index } \" ) cls . strategy_create_func [ index ] = strategy_class else : raise KeyError ( f \" { index =!r} is already registered.\" ) return strategy_class return decorator @classmethod def unregister ( cls , * args : \"Tuple[str, ValueType]\" ) -> None : \"\"\"Unregister a strategy.\"\"\" for index in args : cls . strategy_create_func . pop ( index , None ) make_strategy ( model , field = None , index = None ) classmethod \u00b6 Instantiate a strategy in a context class. Parameters: Name Type Description Default model StrategyConfig A strategy configuration. required field Optional[str] The strategy index type, e.g., \"scheme\" , \"mediaType\" or similar. None index Optional[Tuple[str, ValueType]] A tuple of the field and a unique strategy name for the strategy index type/ field . None Returns: Type Description IStrategy An instantiated strategy. The strategy is instantiated with the provided configuration, through the model parameter. Source code in oteapi/plugins/factories.py @classmethod def make_strategy ( cls , model : \"StrategyConfig\" , field : \"Optional[str]\" = None , index : \"Optional[Tuple[str, ValueType]]\" = None , ) -> \"IStrategy\" : \"\"\"Instantiate a strategy in a context class. Parameters: model: A strategy configuration. field: The strategy index type, e.g., `\"scheme\"`, `\"mediaType\"` or similar. index: A tuple of the `field` and a unique strategy name for the strategy index type/`field`. Returns: An instantiated strategy. The strategy is instantiated with the provided configuration, through the `model` parameter. \"\"\" try : if not index and field : index = ( field , model . dict ()[ field ]) elif not index : raise ValueError ( \"field or index must be specified.\" ) retval = cls . strategy_create_func [ index ] except KeyError as err : raise NotImplementedError ( f \" { index =!r} does not exist\" ) from err return retval ( model ) register ( * args ) classmethod \u00b6 Register a strategy. The identifier for the strategy is defined by a set of key-value tuple pairs. Source code in oteapi/plugins/factories.py @classmethod def register ( cls , * args : \"Tuple[str, ValueType]\" ) -> \"Callable[[Any], Type[IStrategy]]\" : \"\"\"Register a strategy. The identifier for the strategy is defined by a set of key-value tuple pairs. \"\"\" def decorator ( strategy_class : \"Type[IStrategy]\" ) -> \"Type[IStrategy]\" : for index in args : if index not in cls . strategy_create_func : print ( f \"Registering { strategy_class . __name__ } with { index } \" ) cls . strategy_create_func [ index ] = strategy_class else : raise KeyError ( f \" { index =!r} is already registered.\" ) return strategy_class return decorator unregister ( * args ) classmethod \u00b6 Unregister a strategy. Source code in oteapi/plugins/factories.py @classmethod def unregister ( cls , * args : \"Tuple[str, ValueType]\" ) -> None : \"\"\"Unregister a strategy.\"\"\" for index in args : cls . strategy_create_func . pop ( index , None ) StrategyType ( Enum ) \u00b6 An enumeration of available strategy types. Available strategy types: download filter mapping parse resource transformation Source code in oteapi/plugins/factories.py class StrategyType ( Enum ): \"\"\"An enumeration of available strategy types. Available strategy types: - download - filter - mapping - parse - resource - transformation \"\"\" DOWNLOAD = \"download\" FILTER = \"filter\" MAPPING = \"mapping\" PARSE = \"parse\" RESOURCE = \"resource\" TRANSFORMATION = \"transformation\" @lru_cache def map_to_field ( self ) -> str : \"\"\"Map strategy type to [`make_strategy()`][oteapi.plugins.factories.StrategyFactory.make_strategy] field value.\"\"\" return { \"download\" : \"scheme\" , \"filter\" : \"filterType\" , \"mapping\" : \"mappingType\" , \"parse\" : \"mediaType\" , \"resource\" : \"accessService\" , \"transformation\" : \"transformation_type\" , }[ self . value ] @lru_cache def get_make_strategy_kwargs ( self , config : \"StrategyConfig\" ) -> \"Dict[str, Any]\" : \"\"\"Get `make_strategy` kwargs. Parameters: config: A strategy configuration. Returns: The expected [`make_strategy()`][oteapi.plugins.factories.StrategyFactory.make_strategy] key-word-arguments (kwargs), meaning either a `field` or `index` key with an appropriate value. \"\"\" if self . value == \"download\" : # index return { \"index\" : ( \"scheme\" , config . downloadUrl . scheme if config . downloadUrl is not None else \"\" , ) } # field return { \"field\" : self . map_to_field ()} create_download_strategy ( config ) \u00b6 Helper function to simplify creating a download strategy. Parameters: Name Type Description Default config ResourceConfig A download strategy configuration. required Returns: Type Description IDownloadStrategy The created download strategy. Source code in oteapi/plugins/factories.py def create_download_strategy ( config : \"ResourceConfig\" ) -> IDownloadStrategy : \"\"\"Helper function to simplify creating a download strategy. Parameters: config: A download strategy configuration. Returns: The created download strategy. \"\"\" strategy = StrategyFactory . make_strategy ( config , index = ( \"scheme\" , config . downloadUrl . scheme if config . downloadUrl is not None else \"\" , ), ) if not isinstance ( strategy , IDownloadStrategy ): raise TypeError ( \"Got back unexpected type from `StrategyFactory.make_strategy`. \" \"Expected a download strategy.\" ) return strategy create_filter_strategy ( config ) \u00b6 Helper function to simplify creating a filter strategy. Parameters: Name Type Description Default config FilterConfig A filter strategy configuration. required Returns: Type Description IFilterStrategy The created filter strategy. Source code in oteapi/plugins/factories.py def create_filter_strategy ( config : \"FilterConfig\" ) -> IFilterStrategy : \"\"\"Helper function to simplify creating a filter strategy. Parameters: config: A filter strategy configuration. Returns: The created filter strategy. \"\"\" strategy = StrategyFactory . make_strategy ( config , field = \"filterType\" ) if not isinstance ( strategy , IFilterStrategy ): raise TypeError ( \"Got back unexpected type from `StrategyFactory.make_strategy`. \" \"Expected a filter strategy.\" ) return strategy create_mapping_strategy ( config ) \u00b6 Helper function to simplify creating a filter strategy. Parameters: Name Type Description Default config MappingConfig A mapping strategy configuration. required Returns: Type Description IMappingStrategy The created mapping strategy. Source code in oteapi/plugins/factories.py def create_mapping_strategy ( config : \"MappingConfig\" ) -> IMappingStrategy : \"\"\"Helper function to simplify creating a filter strategy. Parameters: config: A mapping strategy configuration. Returns: The created mapping strategy. \"\"\" strategy = StrategyFactory . make_strategy ( config , field = \"mappingType\" ) if not isinstance ( strategy , IMappingStrategy ): raise TypeError ( \"Got back unexpected type from `StrategyFactory.make_strategy`. \" \"Expected a mapping strategy.\" ) return strategy create_parse_strategy ( config ) \u00b6 Helper function to simplify creating a parse strategy. Parameters: Name Type Description Default config ResourceConfig A parse strategy configuration. required Returns: Type Description IParseStrategy The created parse strategy. Source code in oteapi/plugins/factories.py def create_parse_strategy ( config : \"ResourceConfig\" ) -> IParseStrategy : \"\"\"Helper function to simplify creating a parse strategy. Parameters: config: A parse strategy configuration. Returns: The created parse strategy. \"\"\" strategy = StrategyFactory . make_strategy ( config , field = \"mediaType\" ) if not isinstance ( strategy , IParseStrategy ): raise TypeError ( \"Got back unexpected type from `StrategyFactory.make_strategy`. \" \"Expected a parse strategy.\" ) return strategy create_resource_strategy ( config ) \u00b6 Helper function to instanciate a resource strategy. Parameters: Name Type Description Default config ResourceConfig A resource strategy configuration. required Returns: Type Description IResourceStrategy The created resource strategy. Source code in oteapi/plugins/factories.py def create_resource_strategy ( config : \"ResourceConfig\" ) -> IResourceStrategy : \"\"\"Helper function to instanciate a resource strategy. Parameters: config: A resource strategy configuration. Returns: The created resource strategy. \"\"\" strategy = StrategyFactory . make_strategy ( config , field = \"accessService\" ) if not isinstance ( strategy , IResourceStrategy ): raise TypeError ( \"Got back unexpected type from `StrategyFactory.make_strategy`. \" \"Expected a resource strategy.\" ) return strategy create_strategy ( strategy_type , config ) \u00b6 General helper function to simplify creating any strategy. Parameters: Name Type Description Default strategy_type Union[StrategyType, str] A valid strategy type. See the StrategyType enumeration for a definition of valid strategy types. required config StrategyConfig A strategy configuration. required Exceptions: Type Description ValueError If the strategy_type is not a valid strategy type. See the StrategyType enumeration for a definition of valid strategy types. Returns: Type Description IStrategy The created strategy. Source code in oteapi/plugins/factories.py def create_strategy ( strategy_type : \"Union[StrategyType, str]\" , config : \"StrategyConfig\" ) -> \"IStrategy\" : \"\"\"General helper function to simplify creating any strategy. Parameters: strategy_type: A valid strategy type. See the [`StrategyType`][oteapi.plugins.factories.StrategyType] enumeration for a definition of valid strategy types. config: A strategy configuration. Raises: ValueError: If the `strategy_type` is not a valid strategy type. See the [`StrategyType`][oteapi.plugins.factories.StrategyType] enumeration for a definition of valid strategy types. Returns: The created strategy. \"\"\" strategy_type = StrategyType ( strategy_type ) strategy_kwargs = strategy_type . get_make_strategy_kwargs () return StrategyFactory . make_strategy ( model = config , ** strategy_kwargs ) create_transformation_strategy ( config ) \u00b6 Helper function to instanciate a transformation strategy. Parameters: Name Type Description Default config TransformationConfig A transformation strategy configuration. required Returns: Type Description ITransformationStrategy The created transformation strategy. Source code in oteapi/plugins/factories.py def create_transformation_strategy ( config : \"TransformationConfig\" , ) -> ITransformationStrategy : \"\"\"Helper function to instanciate a transformation strategy. Parameters: config: A transformation strategy configuration. Returns: The created transformation strategy. \"\"\" strategy = StrategyFactory . make_strategy ( config , field = \"transformation_type\" ) if not isinstance ( strategy , ITransformationStrategy ): raise TypeError ( \"Got back unexpected type from `StrategyFactory.make_strategy`. \" \"Expected a transformation strategy.\" ) return strategy","title":"factories"},{"location":"api_reference/plugins/factories/#factories","text":"Factory class for registering and creating strategy instances. Factory wrapper methods for creating the individual strategies.","title":"factories"},{"location":"api_reference/plugins/factories/#oteapi.plugins.factories.StrategyFactory","text":"Decorator-based Factory class. Attributes: Name Type Description strategy_create_func A local cache of all registerred strategies with their accompanying class. Source code in oteapi/plugins/factories.py class StrategyFactory : \"\"\"Decorator-based Factory class. Attributes: strategy_create_func: A local cache of all registerred strategies with their accompanying class. \"\"\" strategy_create_func : \"Dict[Tuple[str, ValueType], Type[IStrategy]]\" = {} @classmethod def make_strategy ( cls , model : \"StrategyConfig\" , field : \"Optional[str]\" = None , index : \"Optional[Tuple[str, ValueType]]\" = None , ) -> \"IStrategy\" : \"\"\"Instantiate a strategy in a context class. Parameters: model: A strategy configuration. field: The strategy index type, e.g., `\"scheme\"`, `\"mediaType\"` or similar. index: A tuple of the `field` and a unique strategy name for the strategy index type/`field`. Returns: An instantiated strategy. The strategy is instantiated with the provided configuration, through the `model` parameter. \"\"\" try : if not index and field : index = ( field , model . dict ()[ field ]) elif not index : raise ValueError ( \"field or index must be specified.\" ) retval = cls . strategy_create_func [ index ] except KeyError as err : raise NotImplementedError ( f \" { index =!r} does not exist\" ) from err return retval ( model ) @classmethod def register ( cls , * args : \"Tuple[str, ValueType]\" ) -> \"Callable[[Any], Type[IStrategy]]\" : \"\"\"Register a strategy. The identifier for the strategy is defined by a set of key-value tuple pairs. \"\"\" def decorator ( strategy_class : \"Type[IStrategy]\" ) -> \"Type[IStrategy]\" : for index in args : if index not in cls . strategy_create_func : print ( f \"Registering { strategy_class . __name__ } with { index } \" ) cls . strategy_create_func [ index ] = strategy_class else : raise KeyError ( f \" { index =!r} is already registered.\" ) return strategy_class return decorator @classmethod def unregister ( cls , * args : \"Tuple[str, ValueType]\" ) -> None : \"\"\"Unregister a strategy.\"\"\" for index in args : cls . strategy_create_func . pop ( index , None )","title":"StrategyFactory"},{"location":"api_reference/plugins/factories/#oteapi.plugins.factories.StrategyFactory.make_strategy","text":"Instantiate a strategy in a context class. Parameters: Name Type Description Default model StrategyConfig A strategy configuration. required field Optional[str] The strategy index type, e.g., \"scheme\" , \"mediaType\" or similar. None index Optional[Tuple[str, ValueType]] A tuple of the field and a unique strategy name for the strategy index type/ field . None Returns: Type Description IStrategy An instantiated strategy. The strategy is instantiated with the provided configuration, through the model parameter. Source code in oteapi/plugins/factories.py @classmethod def make_strategy ( cls , model : \"StrategyConfig\" , field : \"Optional[str]\" = None , index : \"Optional[Tuple[str, ValueType]]\" = None , ) -> \"IStrategy\" : \"\"\"Instantiate a strategy in a context class. Parameters: model: A strategy configuration. field: The strategy index type, e.g., `\"scheme\"`, `\"mediaType\"` or similar. index: A tuple of the `field` and a unique strategy name for the strategy index type/`field`. Returns: An instantiated strategy. The strategy is instantiated with the provided configuration, through the `model` parameter. \"\"\" try : if not index and field : index = ( field , model . dict ()[ field ]) elif not index : raise ValueError ( \"field or index must be specified.\" ) retval = cls . strategy_create_func [ index ] except KeyError as err : raise NotImplementedError ( f \" { index =!r} does not exist\" ) from err return retval ( model )","title":"make_strategy()"},{"location":"api_reference/plugins/factories/#oteapi.plugins.factories.StrategyFactory.register","text":"Register a strategy. The identifier for the strategy is defined by a set of key-value tuple pairs. Source code in oteapi/plugins/factories.py @classmethod def register ( cls , * args : \"Tuple[str, ValueType]\" ) -> \"Callable[[Any], Type[IStrategy]]\" : \"\"\"Register a strategy. The identifier for the strategy is defined by a set of key-value tuple pairs. \"\"\" def decorator ( strategy_class : \"Type[IStrategy]\" ) -> \"Type[IStrategy]\" : for index in args : if index not in cls . strategy_create_func : print ( f \"Registering { strategy_class . __name__ } with { index } \" ) cls . strategy_create_func [ index ] = strategy_class else : raise KeyError ( f \" { index =!r} is already registered.\" ) return strategy_class return decorator","title":"register()"},{"location":"api_reference/plugins/factories/#oteapi.plugins.factories.StrategyFactory.unregister","text":"Unregister a strategy. Source code in oteapi/plugins/factories.py @classmethod def unregister ( cls , * args : \"Tuple[str, ValueType]\" ) -> None : \"\"\"Unregister a strategy.\"\"\" for index in args : cls . strategy_create_func . pop ( index , None )","title":"unregister()"},{"location":"api_reference/plugins/factories/#oteapi.plugins.factories.StrategyType","text":"An enumeration of available strategy types. Available strategy types: download filter mapping parse resource transformation Source code in oteapi/plugins/factories.py class StrategyType ( Enum ): \"\"\"An enumeration of available strategy types. Available strategy types: - download - filter - mapping - parse - resource - transformation \"\"\" DOWNLOAD = \"download\" FILTER = \"filter\" MAPPING = \"mapping\" PARSE = \"parse\" RESOURCE = \"resource\" TRANSFORMATION = \"transformation\" @lru_cache def map_to_field ( self ) -> str : \"\"\"Map strategy type to [`make_strategy()`][oteapi.plugins.factories.StrategyFactory.make_strategy] field value.\"\"\" return { \"download\" : \"scheme\" , \"filter\" : \"filterType\" , \"mapping\" : \"mappingType\" , \"parse\" : \"mediaType\" , \"resource\" : \"accessService\" , \"transformation\" : \"transformation_type\" , }[ self . value ] @lru_cache def get_make_strategy_kwargs ( self , config : \"StrategyConfig\" ) -> \"Dict[str, Any]\" : \"\"\"Get `make_strategy` kwargs. Parameters: config: A strategy configuration. Returns: The expected [`make_strategy()`][oteapi.plugins.factories.StrategyFactory.make_strategy] key-word-arguments (kwargs), meaning either a `field` or `index` key with an appropriate value. \"\"\" if self . value == \"download\" : # index return { \"index\" : ( \"scheme\" , config . downloadUrl . scheme if config . downloadUrl is not None else \"\" , ) } # field return { \"field\" : self . map_to_field ()}","title":"StrategyType"},{"location":"api_reference/plugins/factories/#oteapi.plugins.factories.create_download_strategy","text":"Helper function to simplify creating a download strategy. Parameters: Name Type Description Default config ResourceConfig A download strategy configuration. required Returns: Type Description IDownloadStrategy The created download strategy. Source code in oteapi/plugins/factories.py def create_download_strategy ( config : \"ResourceConfig\" ) -> IDownloadStrategy : \"\"\"Helper function to simplify creating a download strategy. Parameters: config: A download strategy configuration. Returns: The created download strategy. \"\"\" strategy = StrategyFactory . make_strategy ( config , index = ( \"scheme\" , config . downloadUrl . scheme if config . downloadUrl is not None else \"\" , ), ) if not isinstance ( strategy , IDownloadStrategy ): raise TypeError ( \"Got back unexpected type from `StrategyFactory.make_strategy`. \" \"Expected a download strategy.\" ) return strategy","title":"create_download_strategy()"},{"location":"api_reference/plugins/factories/#oteapi.plugins.factories.create_filter_strategy","text":"Helper function to simplify creating a filter strategy. Parameters: Name Type Description Default config FilterConfig A filter strategy configuration. required Returns: Type Description IFilterStrategy The created filter strategy. Source code in oteapi/plugins/factories.py def create_filter_strategy ( config : \"FilterConfig\" ) -> IFilterStrategy : \"\"\"Helper function to simplify creating a filter strategy. Parameters: config: A filter strategy configuration. Returns: The created filter strategy. \"\"\" strategy = StrategyFactory . make_strategy ( config , field = \"filterType\" ) if not isinstance ( strategy , IFilterStrategy ): raise TypeError ( \"Got back unexpected type from `StrategyFactory.make_strategy`. \" \"Expected a filter strategy.\" ) return strategy","title":"create_filter_strategy()"},{"location":"api_reference/plugins/factories/#oteapi.plugins.factories.create_mapping_strategy","text":"Helper function to simplify creating a filter strategy. Parameters: Name Type Description Default config MappingConfig A mapping strategy configuration. required Returns: Type Description IMappingStrategy The created mapping strategy. Source code in oteapi/plugins/factories.py def create_mapping_strategy ( config : \"MappingConfig\" ) -> IMappingStrategy : \"\"\"Helper function to simplify creating a filter strategy. Parameters: config: A mapping strategy configuration. Returns: The created mapping strategy. \"\"\" strategy = StrategyFactory . make_strategy ( config , field = \"mappingType\" ) if not isinstance ( strategy , IMappingStrategy ): raise TypeError ( \"Got back unexpected type from `StrategyFactory.make_strategy`. \" \"Expected a mapping strategy.\" ) return strategy","title":"create_mapping_strategy()"},{"location":"api_reference/plugins/factories/#oteapi.plugins.factories.create_parse_strategy","text":"Helper function to simplify creating a parse strategy. Parameters: Name Type Description Default config ResourceConfig A parse strategy configuration. required Returns: Type Description IParseStrategy The created parse strategy. Source code in oteapi/plugins/factories.py def create_parse_strategy ( config : \"ResourceConfig\" ) -> IParseStrategy : \"\"\"Helper function to simplify creating a parse strategy. Parameters: config: A parse strategy configuration. Returns: The created parse strategy. \"\"\" strategy = StrategyFactory . make_strategy ( config , field = \"mediaType\" ) if not isinstance ( strategy , IParseStrategy ): raise TypeError ( \"Got back unexpected type from `StrategyFactory.make_strategy`. \" \"Expected a parse strategy.\" ) return strategy","title":"create_parse_strategy()"},{"location":"api_reference/plugins/factories/#oteapi.plugins.factories.create_resource_strategy","text":"Helper function to instanciate a resource strategy. Parameters: Name Type Description Default config ResourceConfig A resource strategy configuration. required Returns: Type Description IResourceStrategy The created resource strategy. Source code in oteapi/plugins/factories.py def create_resource_strategy ( config : \"ResourceConfig\" ) -> IResourceStrategy : \"\"\"Helper function to instanciate a resource strategy. Parameters: config: A resource strategy configuration. Returns: The created resource strategy. \"\"\" strategy = StrategyFactory . make_strategy ( config , field = \"accessService\" ) if not isinstance ( strategy , IResourceStrategy ): raise TypeError ( \"Got back unexpected type from `StrategyFactory.make_strategy`. \" \"Expected a resource strategy.\" ) return strategy","title":"create_resource_strategy()"},{"location":"api_reference/plugins/factories/#oteapi.plugins.factories.create_strategy","text":"General helper function to simplify creating any strategy. Parameters: Name Type Description Default strategy_type Union[StrategyType, str] A valid strategy type. See the StrategyType enumeration for a definition of valid strategy types. required config StrategyConfig A strategy configuration. required Exceptions: Type Description ValueError If the strategy_type is not a valid strategy type. See the StrategyType enumeration for a definition of valid strategy types. Returns: Type Description IStrategy The created strategy. Source code in oteapi/plugins/factories.py def create_strategy ( strategy_type : \"Union[StrategyType, str]\" , config : \"StrategyConfig\" ) -> \"IStrategy\" : \"\"\"General helper function to simplify creating any strategy. Parameters: strategy_type: A valid strategy type. See the [`StrategyType`][oteapi.plugins.factories.StrategyType] enumeration for a definition of valid strategy types. config: A strategy configuration. Raises: ValueError: If the `strategy_type` is not a valid strategy type. See the [`StrategyType`][oteapi.plugins.factories.StrategyType] enumeration for a definition of valid strategy types. Returns: The created strategy. \"\"\" strategy_type = StrategyType ( strategy_type ) strategy_kwargs = strategy_type . get_make_strategy_kwargs () return StrategyFactory . make_strategy ( model = config , ** strategy_kwargs )","title":"create_strategy()"},{"location":"api_reference/plugins/factories/#oteapi.plugins.factories.create_transformation_strategy","text":"Helper function to instanciate a transformation strategy. Parameters: Name Type Description Default config TransformationConfig A transformation strategy configuration. required Returns: Type Description ITransformationStrategy The created transformation strategy. Source code in oteapi/plugins/factories.py def create_transformation_strategy ( config : \"TransformationConfig\" , ) -> ITransformationStrategy : \"\"\"Helper function to instanciate a transformation strategy. Parameters: config: A transformation strategy configuration. Returns: The created transformation strategy. \"\"\" strategy = StrategyFactory . make_strategy ( config , field = \"transformation_type\" ) if not isinstance ( strategy , ITransformationStrategy ): raise TypeError ( \"Got back unexpected type from `StrategyFactory.make_strategy`. \" \"Expected a transformation strategy.\" ) return strategy","title":"create_transformation_strategy()"},{"location":"api_reference/plugins/plugins/","text":"plugins \u00b6 Plugin loader. PluginInterface \u00b6 Call the plugin to be initialized. Source code in oteapi/plugins/plugins.py class PluginInterface : \"\"\"Call the plugin to be initialized.\"\"\" @staticmethod def initialize () -> None : \"\"\"Initialize the plugin.\"\"\" initialize () staticmethod \u00b6 Initialize the plugin. Source code in oteapi/plugins/plugins.py @staticmethod def initialize () -> None : \"\"\"Initialize the plugin.\"\"\" get_all_entry_points () \u00b6 Retrieve all importable OTE-API entry points. Returns: Type Description List[str] An alphabetically sorted list of module paths for importable OTE-API strategies in OTE-API plugins. Source code in oteapi/plugins/plugins.py def get_all_entry_points () -> \"List[str]\" : \"\"\"Retrieve all importable OTE-API entry points. Returns: An alphabetically sorted list of module paths for importable OTE-API strategies in OTE-API plugins. \"\"\" plugin_strategies : \"Set[str]\" = set () for group , entry_point in entry_points () . items (): if group . startswith ( \"oteapi.\" ): plugin_strategies |= set ( _ . module for _ in entry_point ) return sorted ( plugin_strategies ) import_module ( name ) \u00b6 Import module. Parameters: Name Type Description Default name str The module to import. Must be a proper importable python module path, e.g., \"oteapi.plugins.plugins\" . required Returns: Type Description ModuleType The imported module. Source code in oteapi/plugins/plugins.py def import_module ( name : str ) -> \"ModuleType\" : \"\"\"Import module. Parameters: name: The module to import. Must be a proper importable python module path, e.g., `\"oteapi.plugins.plugins\"`. Returns: The imported module. \"\"\" return importlib . import_module ( name ) load_plugins () \u00b6 Load plugins from the environment's entry points. Source code in oteapi/plugins/plugins.py def load_plugins () -> None : \"\"\"Load plugins from the environment's entry points.\"\"\" for plugin_name in get_all_entry_points (): import_module ( plugin_name )","title":"plugins"},{"location":"api_reference/plugins/plugins/#plugins","text":"Plugin loader.","title":"plugins"},{"location":"api_reference/plugins/plugins/#oteapi.plugins.plugins.PluginInterface","text":"Call the plugin to be initialized. Source code in oteapi/plugins/plugins.py class PluginInterface : \"\"\"Call the plugin to be initialized.\"\"\" @staticmethod def initialize () -> None : \"\"\"Initialize the plugin.\"\"\"","title":"PluginInterface"},{"location":"api_reference/plugins/plugins/#oteapi.plugins.plugins.PluginInterface.initialize","text":"Initialize the plugin. Source code in oteapi/plugins/plugins.py @staticmethod def initialize () -> None : \"\"\"Initialize the plugin.\"\"\"","title":"initialize()"},{"location":"api_reference/plugins/plugins/#oteapi.plugins.plugins.get_all_entry_points","text":"Retrieve all importable OTE-API entry points. Returns: Type Description List[str] An alphabetically sorted list of module paths for importable OTE-API strategies in OTE-API plugins. Source code in oteapi/plugins/plugins.py def get_all_entry_points () -> \"List[str]\" : \"\"\"Retrieve all importable OTE-API entry points. Returns: An alphabetically sorted list of module paths for importable OTE-API strategies in OTE-API plugins. \"\"\" plugin_strategies : \"Set[str]\" = set () for group , entry_point in entry_points () . items (): if group . startswith ( \"oteapi.\" ): plugin_strategies |= set ( _ . module for _ in entry_point ) return sorted ( plugin_strategies )","title":"get_all_entry_points()"},{"location":"api_reference/plugins/plugins/#oteapi.plugins.plugins.import_module","text":"Import module. Parameters: Name Type Description Default name str The module to import. Must be a proper importable python module path, e.g., \"oteapi.plugins.plugins\" . required Returns: Type Description ModuleType The imported module. Source code in oteapi/plugins/plugins.py def import_module ( name : str ) -> \"ModuleType\" : \"\"\"Import module. Parameters: name: The module to import. Must be a proper importable python module path, e.g., `\"oteapi.plugins.plugins\"`. Returns: The imported module. \"\"\" return importlib . import_module ( name )","title":"import_module()"},{"location":"api_reference/plugins/plugins/#oteapi.plugins.plugins.load_plugins","text":"Load plugins from the environment's entry points. Source code in oteapi/plugins/plugins.py def load_plugins () -> None : \"\"\"Load plugins from the environment's entry points.\"\"\" for plugin_name in get_all_entry_points (): import_module ( plugin_name )","title":"load_plugins()"},{"location":"api_reference/strategies/download/file/","text":"file \u00b6 Download strategy class for the file scheme. FileConfig ( BaseModel ) pydantic-model \u00b6 File-specific Configuration Data Model. Source code in oteapi/strategies/download/file.py class FileConfig ( BaseModel ): \"\"\"File-specific Configuration Data Model.\"\"\" text : bool = Field ( False , description = ( \"Whether the file should be opened in text mode. If `False`, the file will\" \" be opened in bytes mode.\" ), ) encoding : Optional [ str ] = Field ( None , description = ( \"Encoding used when opening the file. The default is platform dependent.\" ), ) encoding : str pydantic-field \u00b6 Encoding used when opening the file. The default is platform dependent. text : bool pydantic-field \u00b6 Whether the file should be opened in text mode. If False , the file will be opened in bytes mode. FileStrategy dataclass \u00b6 Strategy for retrieving data from a local file. Registers strategies : (\"scheme\", \"file\") Source code in oteapi/strategies/download/file.py @dataclass @StrategyFactory . register (( \"scheme\" , \"file\" )) class FileStrategy : \"\"\"Strategy for retrieving data from a local file. **Registers strategies**: - `(\"scheme\", \"file\")` \"\"\" resource_config : \"ResourceConfig\" def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Initialize.\"\"\" return {} def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Read local file.\"\"\" if ( self . resource_config . downloadUrl is None or self . resource_config . downloadUrl . scheme != \"file\" ): raise ValueError ( \"Expected 'downloadUrl' to have scheme 'file' in the configuration.\" ) filename = Path ( self . resource_config . downloadUrl . host ) . resolve () cache = DataCache ( self . resource_config . configuration ) if cache . config . accessKey and cache . config . accessKey in cache : key = cache . config . accessKey else : config = FileConfig ( ** self . resource_config . configuration , extra = Extra . ignore ) key = cache . add ( filename . read_text ( encoding = config . encoding ) if config . text else filename . read_bytes () ) return { \"key\" : key } get ( self , session = None ) \u00b6 Read local file. Source code in oteapi/strategies/download/file.py def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Read local file.\"\"\" if ( self . resource_config . downloadUrl is None or self . resource_config . downloadUrl . scheme != \"file\" ): raise ValueError ( \"Expected 'downloadUrl' to have scheme 'file' in the configuration.\" ) filename = Path ( self . resource_config . downloadUrl . host ) . resolve () cache = DataCache ( self . resource_config . configuration ) if cache . config . accessKey and cache . config . accessKey in cache : key = cache . config . accessKey else : config = FileConfig ( ** self . resource_config . configuration , extra = Extra . ignore ) key = cache . add ( filename . read_text ( encoding = config . encoding ) if config . text else filename . read_bytes () ) return { \"key\" : key } initialize ( self , session = None ) \u00b6 Initialize. Source code in oteapi/strategies/download/file.py def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Initialize.\"\"\" return {}","title":"file"},{"location":"api_reference/strategies/download/file/#file","text":"Download strategy class for the file scheme.","title":"file"},{"location":"api_reference/strategies/download/file/#oteapi.strategies.download.file.FileConfig","text":"File-specific Configuration Data Model. Source code in oteapi/strategies/download/file.py class FileConfig ( BaseModel ): \"\"\"File-specific Configuration Data Model.\"\"\" text : bool = Field ( False , description = ( \"Whether the file should be opened in text mode. If `False`, the file will\" \" be opened in bytes mode.\" ), ) encoding : Optional [ str ] = Field ( None , description = ( \"Encoding used when opening the file. The default is platform dependent.\" ), )","title":"FileConfig"},{"location":"api_reference/strategies/download/file/#oteapi.strategies.download.file.FileConfig.encoding","text":"Encoding used when opening the file. The default is platform dependent.","title":"encoding"},{"location":"api_reference/strategies/download/file/#oteapi.strategies.download.file.FileConfig.text","text":"Whether the file should be opened in text mode. If False , the file will be opened in bytes mode.","title":"text"},{"location":"api_reference/strategies/download/file/#oteapi.strategies.download.file.FileStrategy","text":"Strategy for retrieving data from a local file. Registers strategies : (\"scheme\", \"file\") Source code in oteapi/strategies/download/file.py @dataclass @StrategyFactory . register (( \"scheme\" , \"file\" )) class FileStrategy : \"\"\"Strategy for retrieving data from a local file. **Registers strategies**: - `(\"scheme\", \"file\")` \"\"\" resource_config : \"ResourceConfig\" def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Initialize.\"\"\" return {} def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Read local file.\"\"\" if ( self . resource_config . downloadUrl is None or self . resource_config . downloadUrl . scheme != \"file\" ): raise ValueError ( \"Expected 'downloadUrl' to have scheme 'file' in the configuration.\" ) filename = Path ( self . resource_config . downloadUrl . host ) . resolve () cache = DataCache ( self . resource_config . configuration ) if cache . config . accessKey and cache . config . accessKey in cache : key = cache . config . accessKey else : config = FileConfig ( ** self . resource_config . configuration , extra = Extra . ignore ) key = cache . add ( filename . read_text ( encoding = config . encoding ) if config . text else filename . read_bytes () ) return { \"key\" : key }","title":"FileStrategy"},{"location":"api_reference/strategies/download/file/#oteapi.strategies.download.file.FileStrategy.get","text":"Read local file. Source code in oteapi/strategies/download/file.py def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Read local file.\"\"\" if ( self . resource_config . downloadUrl is None or self . resource_config . downloadUrl . scheme != \"file\" ): raise ValueError ( \"Expected 'downloadUrl' to have scheme 'file' in the configuration.\" ) filename = Path ( self . resource_config . downloadUrl . host ) . resolve () cache = DataCache ( self . resource_config . configuration ) if cache . config . accessKey and cache . config . accessKey in cache : key = cache . config . accessKey else : config = FileConfig ( ** self . resource_config . configuration , extra = Extra . ignore ) key = cache . add ( filename . read_text ( encoding = config . encoding ) if config . text else filename . read_bytes () ) return { \"key\" : key }","title":"get()"},{"location":"api_reference/strategies/download/file/#oteapi.strategies.download.file.FileStrategy.initialize","text":"Initialize. Source code in oteapi/strategies/download/file.py def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Initialize.\"\"\" return {}","title":"initialize()"},{"location":"api_reference/strategies/download/https/","text":"https \u00b6 Download strategy class for http/https HTTPSStrategy dataclass \u00b6 Strategy for retrieving data via http. Registers strategies : (\"scheme\", \"http\") (\"scheme\", \"https\") Source code in oteapi/strategies/download/https.py @dataclass @StrategyFactory . register (( \"scheme\" , \"http\" ), ( \"scheme\" , \"https\" )) class HTTPSStrategy : \"\"\"Strategy for retrieving data via http. **Registers strategies**: - `(\"scheme\", \"http\")` - `(\"scheme\", \"https\")` \"\"\" resource_config : \"ResourceConfig\" def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Initialize.\"\"\" return {} def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Download via http/https and store on local cache.\"\"\" cache = DataCache ( self . resource_config . configuration ) if cache . config . accessKey and cache . config . accessKey in cache : key = cache . config . accessKey else : if not self . resource_config . downloadUrl : raise ValueError ( \"downloadUrl not defined in configuration.\" ) req = requests . get ( self . resource_config . downloadUrl , allow_redirects = True ) key = cache . add ( req . content ) return { \"key\" : key } get ( self , session = None ) \u00b6 Download via http/https and store on local cache. Source code in oteapi/strategies/download/https.py def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Download via http/https and store on local cache.\"\"\" cache = DataCache ( self . resource_config . configuration ) if cache . config . accessKey and cache . config . accessKey in cache : key = cache . config . accessKey else : if not self . resource_config . downloadUrl : raise ValueError ( \"downloadUrl not defined in configuration.\" ) req = requests . get ( self . resource_config . downloadUrl , allow_redirects = True ) key = cache . add ( req . content ) return { \"key\" : key } initialize ( self , session = None ) \u00b6 Initialize. Source code in oteapi/strategies/download/https.py def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Initialize.\"\"\" return {}","title":"https"},{"location":"api_reference/strategies/download/https/#https","text":"Download strategy class for http/https","title":"https"},{"location":"api_reference/strategies/download/https/#oteapi.strategies.download.https.HTTPSStrategy","text":"Strategy for retrieving data via http. Registers strategies : (\"scheme\", \"http\") (\"scheme\", \"https\") Source code in oteapi/strategies/download/https.py @dataclass @StrategyFactory . register (( \"scheme\" , \"http\" ), ( \"scheme\" , \"https\" )) class HTTPSStrategy : \"\"\"Strategy for retrieving data via http. **Registers strategies**: - `(\"scheme\", \"http\")` - `(\"scheme\", \"https\")` \"\"\" resource_config : \"ResourceConfig\" def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Initialize.\"\"\" return {} def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Download via http/https and store on local cache.\"\"\" cache = DataCache ( self . resource_config . configuration ) if cache . config . accessKey and cache . config . accessKey in cache : key = cache . config . accessKey else : if not self . resource_config . downloadUrl : raise ValueError ( \"downloadUrl not defined in configuration.\" ) req = requests . get ( self . resource_config . downloadUrl , allow_redirects = True ) key = cache . add ( req . content ) return { \"key\" : key }","title":"HTTPSStrategy"},{"location":"api_reference/strategies/download/https/#oteapi.strategies.download.https.HTTPSStrategy.get","text":"Download via http/https and store on local cache. Source code in oteapi/strategies/download/https.py def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Download via http/https and store on local cache.\"\"\" cache = DataCache ( self . resource_config . configuration ) if cache . config . accessKey and cache . config . accessKey in cache : key = cache . config . accessKey else : if not self . resource_config . downloadUrl : raise ValueError ( \"downloadUrl not defined in configuration.\" ) req = requests . get ( self . resource_config . downloadUrl , allow_redirects = True ) key = cache . add ( req . content ) return { \"key\" : key }","title":"get()"},{"location":"api_reference/strategies/download/https/#oteapi.strategies.download.https.HTTPSStrategy.initialize","text":"Initialize. Source code in oteapi/strategies/download/https.py def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Initialize.\"\"\" return {}","title":"initialize()"},{"location":"api_reference/strategies/download/sftp/","text":"sftp \u00b6 Strategy class for sftp/ftp SFTPStrategy dataclass \u00b6 Strategy for retrieving data via sftp. Registers strategies : (\"scheme\", \"ftp\") (\"scheme\", \"sftp\") Source code in oteapi/strategies/download/sftp.py @dataclass @StrategyFactory . register (( \"scheme\" , \"sftp\" ), ( \"scheme\" , \"ftp\" )) class SFTPStrategy : \"\"\"Strategy for retrieving data via sftp. **Registers strategies**: - `(\"scheme\", \"ftp\")` - `(\"scheme\", \"sftp\")` \"\"\" resource_config : \"ResourceConfig\" def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Initialize.\"\"\" return {} def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Download via sftp\"\"\" cache = DataCache ( self . resource_config . configuration ) if cache . config . accessKey and cache . config . accessKey in cache : key = cache . config . accessKey else : # Setup connection options cnopts = pysftp . CnOpts () cnopts . hostkeys = None if not self . resource_config . accessUrl : raise ValueError ( \"accessUrl is not defined in configuration.\" ) # open connection and store data locally with pysftp . Connection ( host = self . resource_config . accessUrl . host , username = self . resource_config . accessUrl . user , password = self . resource_config . accessUrl . password , port = self . resource_config . accessUrl . port , cnopts = cnopts , ) as sftp : # Because of insane locking on Windows, we have to close # the downloaded file before adding it to the cache with NamedTemporaryFile ( prefix = \"oteapi-sftp-\" , delete = False ) as handle : localpath = Path ( handle . name ) . resolve () try : sftp . get ( self . resource_config . accessUrl . path , localpath = localpath ) key = cache . add ( localpath . read_bytes ()) finally : localpath . unlink () return { \"key\" : key } get ( self , session = None ) \u00b6 Download via sftp Source code in oteapi/strategies/download/sftp.py def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Download via sftp\"\"\" cache = DataCache ( self . resource_config . configuration ) if cache . config . accessKey and cache . config . accessKey in cache : key = cache . config . accessKey else : # Setup connection options cnopts = pysftp . CnOpts () cnopts . hostkeys = None if not self . resource_config . accessUrl : raise ValueError ( \"accessUrl is not defined in configuration.\" ) # open connection and store data locally with pysftp . Connection ( host = self . resource_config . accessUrl . host , username = self . resource_config . accessUrl . user , password = self . resource_config . accessUrl . password , port = self . resource_config . accessUrl . port , cnopts = cnopts , ) as sftp : # Because of insane locking on Windows, we have to close # the downloaded file before adding it to the cache with NamedTemporaryFile ( prefix = \"oteapi-sftp-\" , delete = False ) as handle : localpath = Path ( handle . name ) . resolve () try : sftp . get ( self . resource_config . accessUrl . path , localpath = localpath ) key = cache . add ( localpath . read_bytes ()) finally : localpath . unlink () return { \"key\" : key } initialize ( self , session = None ) \u00b6 Initialize. Source code in oteapi/strategies/download/sftp.py def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Initialize.\"\"\" return {}","title":"sftp"},{"location":"api_reference/strategies/download/sftp/#sftp","text":"Strategy class for sftp/ftp","title":"sftp"},{"location":"api_reference/strategies/download/sftp/#oteapi.strategies.download.sftp.SFTPStrategy","text":"Strategy for retrieving data via sftp. Registers strategies : (\"scheme\", \"ftp\") (\"scheme\", \"sftp\") Source code in oteapi/strategies/download/sftp.py @dataclass @StrategyFactory . register (( \"scheme\" , \"sftp\" ), ( \"scheme\" , \"ftp\" )) class SFTPStrategy : \"\"\"Strategy for retrieving data via sftp. **Registers strategies**: - `(\"scheme\", \"ftp\")` - `(\"scheme\", \"sftp\")` \"\"\" resource_config : \"ResourceConfig\" def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Initialize.\"\"\" return {} def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Download via sftp\"\"\" cache = DataCache ( self . resource_config . configuration ) if cache . config . accessKey and cache . config . accessKey in cache : key = cache . config . accessKey else : # Setup connection options cnopts = pysftp . CnOpts () cnopts . hostkeys = None if not self . resource_config . accessUrl : raise ValueError ( \"accessUrl is not defined in configuration.\" ) # open connection and store data locally with pysftp . Connection ( host = self . resource_config . accessUrl . host , username = self . resource_config . accessUrl . user , password = self . resource_config . accessUrl . password , port = self . resource_config . accessUrl . port , cnopts = cnopts , ) as sftp : # Because of insane locking on Windows, we have to close # the downloaded file before adding it to the cache with NamedTemporaryFile ( prefix = \"oteapi-sftp-\" , delete = False ) as handle : localpath = Path ( handle . name ) . resolve () try : sftp . get ( self . resource_config . accessUrl . path , localpath = localpath ) key = cache . add ( localpath . read_bytes ()) finally : localpath . unlink () return { \"key\" : key }","title":"SFTPStrategy"},{"location":"api_reference/strategies/download/sftp/#oteapi.strategies.download.sftp.SFTPStrategy.get","text":"Download via sftp Source code in oteapi/strategies/download/sftp.py def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Download via sftp\"\"\" cache = DataCache ( self . resource_config . configuration ) if cache . config . accessKey and cache . config . accessKey in cache : key = cache . config . accessKey else : # Setup connection options cnopts = pysftp . CnOpts () cnopts . hostkeys = None if not self . resource_config . accessUrl : raise ValueError ( \"accessUrl is not defined in configuration.\" ) # open connection and store data locally with pysftp . Connection ( host = self . resource_config . accessUrl . host , username = self . resource_config . accessUrl . user , password = self . resource_config . accessUrl . password , port = self . resource_config . accessUrl . port , cnopts = cnopts , ) as sftp : # Because of insane locking on Windows, we have to close # the downloaded file before adding it to the cache with NamedTemporaryFile ( prefix = \"oteapi-sftp-\" , delete = False ) as handle : localpath = Path ( handle . name ) . resolve () try : sftp . get ( self . resource_config . accessUrl . path , localpath = localpath ) key = cache . add ( localpath . read_bytes ()) finally : localpath . unlink () return { \"key\" : key }","title":"get()"},{"location":"api_reference/strategies/download/sftp/#oteapi.strategies.download.sftp.SFTPStrategy.initialize","text":"Initialize. Source code in oteapi/strategies/download/sftp.py def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Initialize.\"\"\" return {}","title":"initialize()"},{"location":"api_reference/strategies/filter/crop_filter/","text":"crop_filter \u00b6 Demo-filter strategy CropDataModel ( BaseModel ) pydantic-model \u00b6 Configuration model for crop data. Source code in oteapi/strategies/filter/crop_filter.py class CropDataModel ( BaseModel ): \"\"\"Configuration model for crop data.\"\"\" crop : List [ int ] = Field ( ... , description = \"List of image cropping details.\" ) crop : List [ int ] pydantic-field required \u00b6 List of image cropping details. CropFilter dataclass \u00b6 Strategy for cropping an image. Registers strategies : (\"filterType\", \"filter/crop\") Source code in oteapi/strategies/filter/crop_filter.py @dataclass @StrategyFactory . register (( \"filterType\" , \"filter/crop\" )) class CropFilter : \"\"\"Strategy for cropping an image. **Registers strategies**: - `(\"filterType\", \"filter/crop\")` \"\"\" filter_config : \"FilterConfig\" def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Initialize strategy and return a dictionary.\"\"\" return { \"result\" : \"collectionid\" } def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Execute strategy and return a dictionary\"\"\" cropData = ( CropDataModel ( ** self . filter_config . configuration ) if self . filter_config . configuration else CropDataModel () ) return { \"imagecrop\" : cropData . crop } get ( self , session = None ) \u00b6 Execute strategy and return a dictionary Source code in oteapi/strategies/filter/crop_filter.py def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Execute strategy and return a dictionary\"\"\" cropData = ( CropDataModel ( ** self . filter_config . configuration ) if self . filter_config . configuration else CropDataModel () ) return { \"imagecrop\" : cropData . crop } initialize ( self , session = None ) \u00b6 Initialize strategy and return a dictionary. Source code in oteapi/strategies/filter/crop_filter.py def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Initialize strategy and return a dictionary.\"\"\" return { \"result\" : \"collectionid\" }","title":"crop_filter"},{"location":"api_reference/strategies/filter/crop_filter/#crop_filter","text":"Demo-filter strategy","title":"crop_filter"},{"location":"api_reference/strategies/filter/crop_filter/#oteapi.strategies.filter.crop_filter.CropDataModel","text":"Configuration model for crop data. Source code in oteapi/strategies/filter/crop_filter.py class CropDataModel ( BaseModel ): \"\"\"Configuration model for crop data.\"\"\" crop : List [ int ] = Field ( ... , description = \"List of image cropping details.\" )","title":"CropDataModel"},{"location":"api_reference/strategies/filter/crop_filter/#oteapi.strategies.filter.crop_filter.CropDataModel.crop","text":"List of image cropping details.","title":"crop"},{"location":"api_reference/strategies/filter/crop_filter/#oteapi.strategies.filter.crop_filter.CropFilter","text":"Strategy for cropping an image. Registers strategies : (\"filterType\", \"filter/crop\") Source code in oteapi/strategies/filter/crop_filter.py @dataclass @StrategyFactory . register (( \"filterType\" , \"filter/crop\" )) class CropFilter : \"\"\"Strategy for cropping an image. **Registers strategies**: - `(\"filterType\", \"filter/crop\")` \"\"\" filter_config : \"FilterConfig\" def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Initialize strategy and return a dictionary.\"\"\" return { \"result\" : \"collectionid\" } def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Execute strategy and return a dictionary\"\"\" cropData = ( CropDataModel ( ** self . filter_config . configuration ) if self . filter_config . configuration else CropDataModel () ) return { \"imagecrop\" : cropData . crop }","title":"CropFilter"},{"location":"api_reference/strategies/filter/crop_filter/#oteapi.strategies.filter.crop_filter.CropFilter.get","text":"Execute strategy and return a dictionary Source code in oteapi/strategies/filter/crop_filter.py def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Execute strategy and return a dictionary\"\"\" cropData = ( CropDataModel ( ** self . filter_config . configuration ) if self . filter_config . configuration else CropDataModel () ) return { \"imagecrop\" : cropData . crop }","title":"get()"},{"location":"api_reference/strategies/filter/crop_filter/#oteapi.strategies.filter.crop_filter.CropFilter.initialize","text":"Initialize strategy and return a dictionary. Source code in oteapi/strategies/filter/crop_filter.py def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Initialize strategy and return a dictionary.\"\"\" return { \"result\" : \"collectionid\" }","title":"initialize()"},{"location":"api_reference/strategies/filter/sql_query_filter/","text":"sql_query_filter \u00b6 SQL query filter strategy. SQLQueryFilter dataclass \u00b6 Strategy for a SQL query filter. Registers strategies : (\"filterType\", \"filter/sql\") Source code in oteapi/strategies/filter/sql_query_filter.py @dataclass @StrategyFactory . register (( \"filterType\" , \"filter/sql\" )) class SQLQueryFilter : \"\"\"Strategy for a SQL query filter. **Registers strategies**: - `(\"filterType\", \"filter/sql\")` \"\"\" filter_config : \"FilterConfig\" def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Initialize strategy and return a dictionary\"\"\" queryData = SqlQueryDataModel ( ** { \"query\" : self . filter_config . query }) return { \"sqlquery\" : queryData . query } def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Execute strategy and return a dictionary\"\"\" return {} get ( self , session = None ) \u00b6 Execute strategy and return a dictionary Source code in oteapi/strategies/filter/sql_query_filter.py def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Execute strategy and return a dictionary\"\"\" return {} initialize ( self , session = None ) \u00b6 Initialize strategy and return a dictionary Source code in oteapi/strategies/filter/sql_query_filter.py def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Initialize strategy and return a dictionary\"\"\" queryData = SqlQueryDataModel ( ** { \"query\" : self . filter_config . query }) return { \"sqlquery\" : queryData . query } SqlQueryDataModel ( BaseModel ) pydantic-model \u00b6 SQL Query data model. Source code in oteapi/strategies/filter/sql_query_filter.py class SqlQueryDataModel ( BaseModel ): \"\"\"SQL Query data model.\"\"\" query : str = Field ( ... , description = \"A SQL query string.\" ) query : str pydantic-field required \u00b6 A SQL query string.","title":"sql_query_filter"},{"location":"api_reference/strategies/filter/sql_query_filter/#sql_query_filter","text":"SQL query filter strategy.","title":"sql_query_filter"},{"location":"api_reference/strategies/filter/sql_query_filter/#oteapi.strategies.filter.sql_query_filter.SQLQueryFilter","text":"Strategy for a SQL query filter. Registers strategies : (\"filterType\", \"filter/sql\") Source code in oteapi/strategies/filter/sql_query_filter.py @dataclass @StrategyFactory . register (( \"filterType\" , \"filter/sql\" )) class SQLQueryFilter : \"\"\"Strategy for a SQL query filter. **Registers strategies**: - `(\"filterType\", \"filter/sql\")` \"\"\" filter_config : \"FilterConfig\" def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Initialize strategy and return a dictionary\"\"\" queryData = SqlQueryDataModel ( ** { \"query\" : self . filter_config . query }) return { \"sqlquery\" : queryData . query } def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Execute strategy and return a dictionary\"\"\" return {}","title":"SQLQueryFilter"},{"location":"api_reference/strategies/filter/sql_query_filter/#oteapi.strategies.filter.sql_query_filter.SQLQueryFilter.get","text":"Execute strategy and return a dictionary Source code in oteapi/strategies/filter/sql_query_filter.py def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Execute strategy and return a dictionary\"\"\" return {}","title":"get()"},{"location":"api_reference/strategies/filter/sql_query_filter/#oteapi.strategies.filter.sql_query_filter.SQLQueryFilter.initialize","text":"Initialize strategy and return a dictionary Source code in oteapi/strategies/filter/sql_query_filter.py def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Initialize strategy and return a dictionary\"\"\" queryData = SqlQueryDataModel ( ** { \"query\" : self . filter_config . query }) return { \"sqlquery\" : queryData . query }","title":"initialize()"},{"location":"api_reference/strategies/filter/sql_query_filter/#oteapi.strategies.filter.sql_query_filter.SqlQueryDataModel","text":"SQL Query data model. Source code in oteapi/strategies/filter/sql_query_filter.py class SqlQueryDataModel ( BaseModel ): \"\"\"SQL Query data model.\"\"\" query : str = Field ( ... , description = \"A SQL query string.\" )","title":"SqlQueryDataModel"},{"location":"api_reference/strategies/filter/sql_query_filter/#oteapi.strategies.filter.sql_query_filter.SqlQueryDataModel.query","text":"A SQL query string.","title":"query"},{"location":"api_reference/strategies/parse/application_vnd_sqlite/","text":"application_vnd_sqlite \u00b6 Strategy class for application/vnd.sqlite3. SqliteParseStrategy dataclass \u00b6 Parse strategy for SQLite. Registers strategies : (\"mediaType\", \"application/vnd.sqlite3\") Source code in oteapi/strategies/parse/application_vnd_sqlite.py @dataclass @StrategyFactory . register (( \"mediaType\" , \"application/vnd.sqlite3\" )) class SqliteParseStrategy : \"\"\"Parse strategy for SQLite. **Registers strategies**: - `(\"mediaType\", \"application/vnd.sqlite3\")` \"\"\" resource_config : \"ResourceConfig\" def parse ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Parse SQLite query responses.\"\"\" if session is None : raise ValueError ( \"Missing session\" ) if \"sqlquery\" in session : cn = create_connection ( session [ \"filename\" ]) cur = cn . cursor () rows = cur . execute ( session [ \"sqlquery\" ]) . fetchall () return { \"result\" : rows } return { \"result\" : \"No query given\" } def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Initialize.\"\"\" return {} initialize ( self , session = None ) \u00b6 Initialize. Source code in oteapi/strategies/parse/application_vnd_sqlite.py def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Initialize.\"\"\" return {} parse ( self , session = None ) \u00b6 Parse SQLite query responses. Source code in oteapi/strategies/parse/application_vnd_sqlite.py def parse ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Parse SQLite query responses.\"\"\" if session is None : raise ValueError ( \"Missing session\" ) if \"sqlquery\" in session : cn = create_connection ( session [ \"filename\" ]) cur = cn . cursor () rows = cur . execute ( session [ \"sqlquery\" ]) . fetchall () return { \"result\" : rows } return { \"result\" : \"No query given\" } create_connection ( db_file ) \u00b6 create a database connection to the SQLite database specified by db_file :param db_file: database file :return: Connection object or None Source code in oteapi/strategies/parse/application_vnd_sqlite.py def create_connection ( db_file ): \"\"\"create a database connection to the SQLite database specified by db_file :param db_file: database file :return: Connection object or None \"\"\" conn = None try : conn = sqlite3 . connect ( db_file ) return conn except sqlite3 . Error as exc : print ( exc ) return conn","title":"application_vnd_sqlite"},{"location":"api_reference/strategies/parse/application_vnd_sqlite/#application_vnd_sqlite","text":"Strategy class for application/vnd.sqlite3.","title":"application_vnd_sqlite"},{"location":"api_reference/strategies/parse/application_vnd_sqlite/#oteapi.strategies.parse.application_vnd_sqlite.SqliteParseStrategy","text":"Parse strategy for SQLite. Registers strategies : (\"mediaType\", \"application/vnd.sqlite3\") Source code in oteapi/strategies/parse/application_vnd_sqlite.py @dataclass @StrategyFactory . register (( \"mediaType\" , \"application/vnd.sqlite3\" )) class SqliteParseStrategy : \"\"\"Parse strategy for SQLite. **Registers strategies**: - `(\"mediaType\", \"application/vnd.sqlite3\")` \"\"\" resource_config : \"ResourceConfig\" def parse ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Parse SQLite query responses.\"\"\" if session is None : raise ValueError ( \"Missing session\" ) if \"sqlquery\" in session : cn = create_connection ( session [ \"filename\" ]) cur = cn . cursor () rows = cur . execute ( session [ \"sqlquery\" ]) . fetchall () return { \"result\" : rows } return { \"result\" : \"No query given\" } def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Initialize.\"\"\" return {}","title":"SqliteParseStrategy"},{"location":"api_reference/strategies/parse/application_vnd_sqlite/#oteapi.strategies.parse.application_vnd_sqlite.SqliteParseStrategy.initialize","text":"Initialize. Source code in oteapi/strategies/parse/application_vnd_sqlite.py def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Initialize.\"\"\" return {}","title":"initialize()"},{"location":"api_reference/strategies/parse/application_vnd_sqlite/#oteapi.strategies.parse.application_vnd_sqlite.SqliteParseStrategy.parse","text":"Parse SQLite query responses. Source code in oteapi/strategies/parse/application_vnd_sqlite.py def parse ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Parse SQLite query responses.\"\"\" if session is None : raise ValueError ( \"Missing session\" ) if \"sqlquery\" in session : cn = create_connection ( session [ \"filename\" ]) cur = cn . cursor () rows = cur . execute ( session [ \"sqlquery\" ]) . fetchall () return { \"result\" : rows } return { \"result\" : \"No query given\" }","title":"parse()"},{"location":"api_reference/strategies/parse/application_vnd_sqlite/#oteapi.strategies.parse.application_vnd_sqlite.create_connection","text":"create a database connection to the SQLite database specified by db_file :param db_file: database file :return: Connection object or None Source code in oteapi/strategies/parse/application_vnd_sqlite.py def create_connection ( db_file ): \"\"\"create a database connection to the SQLite database specified by db_file :param db_file: database file :return: Connection object or None \"\"\" conn = None try : conn = sqlite3 . connect ( db_file ) return conn except sqlite3 . Error as exc : print ( exc ) return conn","title":"create_connection()"},{"location":"api_reference/strategies/parse/excel_xlsx/","text":"excel_xlsx \u00b6 Strategy class for workbook/xlsx. XLSXParseDataModel ( BaseModel ) pydantic-model \u00b6 Data model for retrieving a rectangular section of an Excel sheet. Source code in oteapi/strategies/parse/excel_xlsx.py class XLSXParseDataModel ( BaseModel ): \"\"\"Data model for retrieving a rectangular section of an Excel sheet.\"\"\" worksheet : str = Field ( ... , description = \"Name of worksheet to load.\" ) row_from : Optional [ int ] = Field ( None , description = \"Excel row number of first row. Defaults to first assigned row.\" , ) col_from : Optional [ Union [ int , str ]] = Field ( None , description = ( \"Excel column number or label of first column. Defaults to first assigned \" \"column.\" ), ) row_to : Optional [ int ] = Field ( None , description = \"Excel row number of last row. Defaults to last assigned row.\" ) col_to : Optional [ Union [ int , str ]] = Field ( None , description = ( \"Excel column number or label of last column. Defaults to last assigned \" \"column.\" ), ) header_row : Optional [ int ] = Field ( None , description = ( \"Row number with the headers. Defaults to `1` if header is given, \" \"otherwise `None`.\" ), ) header : Optional [ List [ str ]] = Field ( None , description = ( \"Optional list of column names, specifying the columns to return. \" \"These names they should match cells in `header_row`.\" ), ) new_header : Optional [ List [ str ]] = Field ( None , description = ( \"Optional list of new column names replacing `header` in the output.\" ), ) col_from : Union [ int , str ] pydantic-field \u00b6 Excel column number or label of first column. Defaults to first assigned column. col_to : Union [ int , str ] pydantic-field \u00b6 Excel column number or label of last column. Defaults to last assigned column. header : List [ str ] pydantic-field \u00b6 Optional list of column names, specifying the columns to return. These names they should match cells in header_row . header_row : int pydantic-field \u00b6 Row number with the headers. Defaults to 1 if header is given, otherwise None . new_header : List [ str ] pydantic-field \u00b6 Optional list of new column names replacing header in the output. row_from : int pydantic-field \u00b6 Excel row number of first row. Defaults to first assigned row. row_to : int pydantic-field \u00b6 Excel row number of last row. Defaults to last assigned row. worksheet : str pydantic-field required \u00b6 Name of worksheet to load. XLSXParseStrategy dataclass \u00b6 Parse strategy for Excel XLSX files. Registers strategies : (\"mediaType\", \"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\") Source code in oteapi/strategies/parse/excel_xlsx.py @dataclass @StrategyFactory . register ( ( \"mediaType\" , \"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\" ) ) class XLSXParseStrategy : \"\"\"Parse strategy for Excel XLSX files. **Registers strategies**: - `(\"mediaType\", \"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\")` \"\"\" resource_config : \"ResourceConfig\" def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Initialize.\"\"\" return {} def parse ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Parses selected region of an excel file. Returns: A dict with column-name/column-value pairs. The values are lists. \"\"\" model = XLSXParseDataModel ( ** self . resource_config . configuration , extra = Extra . ignore ) downloader = create_download_strategy ( self . resource_config ) output = downloader . get () cache = DataCache ( self . resource_config . configuration ) with cache . getfile ( key = output [ \"key\" ], suffix = \".xlsx\" ) as filename : workbook = load_workbook ( filename = filename , read_only = True , data_only = True ) worksheet = workbook [ model . worksheet ] set_model_defaults ( model , worksheet ) columns = get_column_indices ( model , worksheet ) data = [] for row in worksheet . iter_rows ( min_row = model . row_from , max_row = model . row_to , min_col = min ( columns ), max_col = max ( columns ), ): data . append ([ row [ c - 1 ] . value for c in columns ]) if model . header_row : row = worksheet . iter_rows ( min_row = model . header_row , max_row = model . header_row , min_col = min ( columns ), max_col = max ( columns ), ) . __next__ () header = [ row [ c - 1 ] . value for c in columns ] else : header = None if model . new_header : nhead = len ( header ) if header else len ( data [ 0 ]) if data else 0 if len ( model . new_header ) != nhead : raise TypeError ( f \"length of `new_header` (= { len ( model . new_header ) } ) \" f \"doesn't match number of columns (= { len ( header ) if header else 0 } )\" ) if header : for i , val in enumerate ( model . new_header ): if val is not None : header [ i ] = val elif data : header = model . new_header if header is None : header = [ get_column_letter ( col + 1 ) for col in range ( len ( data ))] transposed = list ( map ( list , zip ( * data ))) return { k : v for k , v in zip ( header , transposed )} initialize ( self , session = None ) \u00b6 Initialize. Source code in oteapi/strategies/parse/excel_xlsx.py def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Initialize.\"\"\" return {} parse ( self , session = None ) \u00b6 Parses selected region of an excel file. Returns: Type Description Dict[str, Any] A dict with column-name/column-value pairs. The values are lists. Source code in oteapi/strategies/parse/excel_xlsx.py def parse ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Parses selected region of an excel file. Returns: A dict with column-name/column-value pairs. The values are lists. \"\"\" model = XLSXParseDataModel ( ** self . resource_config . configuration , extra = Extra . ignore ) downloader = create_download_strategy ( self . resource_config ) output = downloader . get () cache = DataCache ( self . resource_config . configuration ) with cache . getfile ( key = output [ \"key\" ], suffix = \".xlsx\" ) as filename : workbook = load_workbook ( filename = filename , read_only = True , data_only = True ) worksheet = workbook [ model . worksheet ] set_model_defaults ( model , worksheet ) columns = get_column_indices ( model , worksheet ) data = [] for row in worksheet . iter_rows ( min_row = model . row_from , max_row = model . row_to , min_col = min ( columns ), max_col = max ( columns ), ): data . append ([ row [ c - 1 ] . value for c in columns ]) if model . header_row : row = worksheet . iter_rows ( min_row = model . header_row , max_row = model . header_row , min_col = min ( columns ), max_col = max ( columns ), ) . __next__ () header = [ row [ c - 1 ] . value for c in columns ] else : header = None if model . new_header : nhead = len ( header ) if header else len ( data [ 0 ]) if data else 0 if len ( model . new_header ) != nhead : raise TypeError ( f \"length of `new_header` (= { len ( model . new_header ) } ) \" f \"doesn't match number of columns (= { len ( header ) if header else 0 } )\" ) if header : for i , val in enumerate ( model . new_header ): if val is not None : header [ i ] = val elif data : header = model . new_header if header is None : header = [ get_column_letter ( col + 1 ) for col in range ( len ( data ))] transposed = list ( map ( list , zip ( * data ))) return { k : v for k , v in zip ( header , transposed )} get_column_indices ( model , worksheet ) \u00b6 Helper function returning a list of column indices. Parameters: Name Type Description Default model XLSXParseDataModel The parsed data model. required worksheet Worksheet Excel worksheet, from which the header values will be retrieved. required Returns: Type Description Iterable[int] A list of column indices. Source code in oteapi/strategies/parse/excel_xlsx.py def get_column_indices ( model : XLSXParseDataModel , worksheet : \"Worksheet\" ) -> \"Iterable[int]\" : \"\"\"Helper function returning a list of column indices. Parameters: model: The parsed data model. worksheet: Excel worksheet, from which the header values will be retrieved. Returns: A list of column indices. \"\"\" if not isinstance ( model . col_from , int ) or not isinstance ( model . col_to , int ): raise TypeError ( \"Expected `model.col_from` and `model.col_to` to be integers.\" ) if model . header : header_dict = { worksheet . cell ( model . header_row , col ) . value : col for col in range ( model . col_from , model . col_to + 1 ) } return [ header_dict [ h ] for h in model . header ] return range ( model . col_from , model . col_to + 1 ) set_model_defaults ( model , worksheet ) \u00b6 Update data model model with default values obtained from worksheet . Parameters: Name Type Description Default model XLSXParseDataModel The parsed data model. required worksheet Worksheet Excel worksheet, from which the default values will be obtained. required Source code in oteapi/strategies/parse/excel_xlsx.py def set_model_defaults ( model : XLSXParseDataModel , worksheet : \"Worksheet\" ) -> None : \"\"\"Update data model `model` with default values obtained from `worksheet`. Parameters: model: The parsed data model. worksheet: Excel worksheet, from which the default values will be obtained. \"\"\" if model . row_from is None : if model . header : # assume that data starts on the first row after the header model . row_from = model . header_row + 1 if model . header_row else 1 else : model . row_from = worksheet . min_row if model . row_to is None : model . row_to = worksheet . max_row if model . col_from is None : model . col_from = worksheet . min_column elif isinstance ( model . col_from , str ): model . col_from = column_index_from_string ( model . col_from ) if model . col_to is None : model . col_to = worksheet . max_column elif isinstance ( model . col_to , str ): model . col_to = column_index_from_string ( model . col_to ) if model . header and not model . header_row : model . header_row = 1","title":"excel_xlsx"},{"location":"api_reference/strategies/parse/excel_xlsx/#excel_xlsx","text":"Strategy class for workbook/xlsx.","title":"excel_xlsx"},{"location":"api_reference/strategies/parse/excel_xlsx/#oteapi.strategies.parse.excel_xlsx.XLSXParseDataModel","text":"Data model for retrieving a rectangular section of an Excel sheet. Source code in oteapi/strategies/parse/excel_xlsx.py class XLSXParseDataModel ( BaseModel ): \"\"\"Data model for retrieving a rectangular section of an Excel sheet.\"\"\" worksheet : str = Field ( ... , description = \"Name of worksheet to load.\" ) row_from : Optional [ int ] = Field ( None , description = \"Excel row number of first row. Defaults to first assigned row.\" , ) col_from : Optional [ Union [ int , str ]] = Field ( None , description = ( \"Excel column number or label of first column. Defaults to first assigned \" \"column.\" ), ) row_to : Optional [ int ] = Field ( None , description = \"Excel row number of last row. Defaults to last assigned row.\" ) col_to : Optional [ Union [ int , str ]] = Field ( None , description = ( \"Excel column number or label of last column. Defaults to last assigned \" \"column.\" ), ) header_row : Optional [ int ] = Field ( None , description = ( \"Row number with the headers. Defaults to `1` if header is given, \" \"otherwise `None`.\" ), ) header : Optional [ List [ str ]] = Field ( None , description = ( \"Optional list of column names, specifying the columns to return. \" \"These names they should match cells in `header_row`.\" ), ) new_header : Optional [ List [ str ]] = Field ( None , description = ( \"Optional list of new column names replacing `header` in the output.\" ), )","title":"XLSXParseDataModel"},{"location":"api_reference/strategies/parse/excel_xlsx/#oteapi.strategies.parse.excel_xlsx.XLSXParseDataModel.col_from","text":"Excel column number or label of first column. Defaults to first assigned column.","title":"col_from"},{"location":"api_reference/strategies/parse/excel_xlsx/#oteapi.strategies.parse.excel_xlsx.XLSXParseDataModel.col_to","text":"Excel column number or label of last column. Defaults to last assigned column.","title":"col_to"},{"location":"api_reference/strategies/parse/excel_xlsx/#oteapi.strategies.parse.excel_xlsx.XLSXParseDataModel.header","text":"Optional list of column names, specifying the columns to return. These names they should match cells in header_row .","title":"header"},{"location":"api_reference/strategies/parse/excel_xlsx/#oteapi.strategies.parse.excel_xlsx.XLSXParseDataModel.header_row","text":"Row number with the headers. Defaults to 1 if header is given, otherwise None .","title":"header_row"},{"location":"api_reference/strategies/parse/excel_xlsx/#oteapi.strategies.parse.excel_xlsx.XLSXParseDataModel.new_header","text":"Optional list of new column names replacing header in the output.","title":"new_header"},{"location":"api_reference/strategies/parse/excel_xlsx/#oteapi.strategies.parse.excel_xlsx.XLSXParseDataModel.row_from","text":"Excel row number of first row. Defaults to first assigned row.","title":"row_from"},{"location":"api_reference/strategies/parse/excel_xlsx/#oteapi.strategies.parse.excel_xlsx.XLSXParseDataModel.row_to","text":"Excel row number of last row. Defaults to last assigned row.","title":"row_to"},{"location":"api_reference/strategies/parse/excel_xlsx/#oteapi.strategies.parse.excel_xlsx.XLSXParseDataModel.worksheet","text":"Name of worksheet to load.","title":"worksheet"},{"location":"api_reference/strategies/parse/excel_xlsx/#oteapi.strategies.parse.excel_xlsx.XLSXParseStrategy","text":"Parse strategy for Excel XLSX files. Registers strategies : (\"mediaType\", \"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\") Source code in oteapi/strategies/parse/excel_xlsx.py @dataclass @StrategyFactory . register ( ( \"mediaType\" , \"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\" ) ) class XLSXParseStrategy : \"\"\"Parse strategy for Excel XLSX files. **Registers strategies**: - `(\"mediaType\", \"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\")` \"\"\" resource_config : \"ResourceConfig\" def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Initialize.\"\"\" return {} def parse ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Parses selected region of an excel file. Returns: A dict with column-name/column-value pairs. The values are lists. \"\"\" model = XLSXParseDataModel ( ** self . resource_config . configuration , extra = Extra . ignore ) downloader = create_download_strategy ( self . resource_config ) output = downloader . get () cache = DataCache ( self . resource_config . configuration ) with cache . getfile ( key = output [ \"key\" ], suffix = \".xlsx\" ) as filename : workbook = load_workbook ( filename = filename , read_only = True , data_only = True ) worksheet = workbook [ model . worksheet ] set_model_defaults ( model , worksheet ) columns = get_column_indices ( model , worksheet ) data = [] for row in worksheet . iter_rows ( min_row = model . row_from , max_row = model . row_to , min_col = min ( columns ), max_col = max ( columns ), ): data . append ([ row [ c - 1 ] . value for c in columns ]) if model . header_row : row = worksheet . iter_rows ( min_row = model . header_row , max_row = model . header_row , min_col = min ( columns ), max_col = max ( columns ), ) . __next__ () header = [ row [ c - 1 ] . value for c in columns ] else : header = None if model . new_header : nhead = len ( header ) if header else len ( data [ 0 ]) if data else 0 if len ( model . new_header ) != nhead : raise TypeError ( f \"length of `new_header` (= { len ( model . new_header ) } ) \" f \"doesn't match number of columns (= { len ( header ) if header else 0 } )\" ) if header : for i , val in enumerate ( model . new_header ): if val is not None : header [ i ] = val elif data : header = model . new_header if header is None : header = [ get_column_letter ( col + 1 ) for col in range ( len ( data ))] transposed = list ( map ( list , zip ( * data ))) return { k : v for k , v in zip ( header , transposed )}","title":"XLSXParseStrategy"},{"location":"api_reference/strategies/parse/excel_xlsx/#oteapi.strategies.parse.excel_xlsx.XLSXParseStrategy.initialize","text":"Initialize. Source code in oteapi/strategies/parse/excel_xlsx.py def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Initialize.\"\"\" return {}","title":"initialize()"},{"location":"api_reference/strategies/parse/excel_xlsx/#oteapi.strategies.parse.excel_xlsx.XLSXParseStrategy.parse","text":"Parses selected region of an excel file. Returns: Type Description Dict[str, Any] A dict with column-name/column-value pairs. The values are lists. Source code in oteapi/strategies/parse/excel_xlsx.py def parse ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Parses selected region of an excel file. Returns: A dict with column-name/column-value pairs. The values are lists. \"\"\" model = XLSXParseDataModel ( ** self . resource_config . configuration , extra = Extra . ignore ) downloader = create_download_strategy ( self . resource_config ) output = downloader . get () cache = DataCache ( self . resource_config . configuration ) with cache . getfile ( key = output [ \"key\" ], suffix = \".xlsx\" ) as filename : workbook = load_workbook ( filename = filename , read_only = True , data_only = True ) worksheet = workbook [ model . worksheet ] set_model_defaults ( model , worksheet ) columns = get_column_indices ( model , worksheet ) data = [] for row in worksheet . iter_rows ( min_row = model . row_from , max_row = model . row_to , min_col = min ( columns ), max_col = max ( columns ), ): data . append ([ row [ c - 1 ] . value for c in columns ]) if model . header_row : row = worksheet . iter_rows ( min_row = model . header_row , max_row = model . header_row , min_col = min ( columns ), max_col = max ( columns ), ) . __next__ () header = [ row [ c - 1 ] . value for c in columns ] else : header = None if model . new_header : nhead = len ( header ) if header else len ( data [ 0 ]) if data else 0 if len ( model . new_header ) != nhead : raise TypeError ( f \"length of `new_header` (= { len ( model . new_header ) } ) \" f \"doesn't match number of columns (= { len ( header ) if header else 0 } )\" ) if header : for i , val in enumerate ( model . new_header ): if val is not None : header [ i ] = val elif data : header = model . new_header if header is None : header = [ get_column_letter ( col + 1 ) for col in range ( len ( data ))] transposed = list ( map ( list , zip ( * data ))) return { k : v for k , v in zip ( header , transposed )}","title":"parse()"},{"location":"api_reference/strategies/parse/excel_xlsx/#oteapi.strategies.parse.excel_xlsx.get_column_indices","text":"Helper function returning a list of column indices. Parameters: Name Type Description Default model XLSXParseDataModel The parsed data model. required worksheet Worksheet Excel worksheet, from which the header values will be retrieved. required Returns: Type Description Iterable[int] A list of column indices. Source code in oteapi/strategies/parse/excel_xlsx.py def get_column_indices ( model : XLSXParseDataModel , worksheet : \"Worksheet\" ) -> \"Iterable[int]\" : \"\"\"Helper function returning a list of column indices. Parameters: model: The parsed data model. worksheet: Excel worksheet, from which the header values will be retrieved. Returns: A list of column indices. \"\"\" if not isinstance ( model . col_from , int ) or not isinstance ( model . col_to , int ): raise TypeError ( \"Expected `model.col_from` and `model.col_to` to be integers.\" ) if model . header : header_dict = { worksheet . cell ( model . header_row , col ) . value : col for col in range ( model . col_from , model . col_to + 1 ) } return [ header_dict [ h ] for h in model . header ] return range ( model . col_from , model . col_to + 1 )","title":"get_column_indices()"},{"location":"api_reference/strategies/parse/excel_xlsx/#oteapi.strategies.parse.excel_xlsx.set_model_defaults","text":"Update data model model with default values obtained from worksheet . Parameters: Name Type Description Default model XLSXParseDataModel The parsed data model. required worksheet Worksheet Excel worksheet, from which the default values will be obtained. required Source code in oteapi/strategies/parse/excel_xlsx.py def set_model_defaults ( model : XLSXParseDataModel , worksheet : \"Worksheet\" ) -> None : \"\"\"Update data model `model` with default values obtained from `worksheet`. Parameters: model: The parsed data model. worksheet: Excel worksheet, from which the default values will be obtained. \"\"\" if model . row_from is None : if model . header : # assume that data starts on the first row after the header model . row_from = model . header_row + 1 if model . header_row else 1 else : model . row_from = worksheet . min_row if model . row_to is None : model . row_to = worksheet . max_row if model . col_from is None : model . col_from = worksheet . min_column elif isinstance ( model . col_from , str ): model . col_from = column_index_from_string ( model . col_from ) if model . col_to is None : model . col_to = worksheet . max_column elif isinstance ( model . col_to , str ): model . col_to = column_index_from_string ( model . col_to ) if model . header and not model . header_row : model . header_row = 1","title":"set_model_defaults()"},{"location":"api_reference/strategies/parse/image_jpeg/","text":"image_jpeg \u00b6 Strategy class for image/jpg. ImageDataParseStrategy dataclass \u00b6 Parse strategy for images. Registers strategies : (\"mediaType\", \"image/jpg\") (\"mediaType\", \"image/jpeg\") (\"mediaType\", \"image/j2p\") (\"mediaType\", \"image/png\") (\"mediaType\", \"image/gif\") (\"mediaType\", \"image/tiff\") (\"mediaType\", \"image/eps\") Source code in oteapi/strategies/parse/image_jpeg.py @dataclass @StrategyFactory . register ( ( \"mediaType\" , \"image/jpg\" ), ( \"mediaType\" , \"image/jpeg\" ), ( \"mediaType\" , \"image/j2p\" ), ( \"mediaType\" , \"image/png\" ), ( \"mediaType\" , \"image/gif\" ), ( \"mediaType\" , \"image/tiff\" ), ( \"mediaType\" , \"image/eps\" ), ) class ImageDataParseStrategy : \"\"\"Parse strategy for images. **Registers strategies**: - `(\"mediaType\", \"image/jpg\")` - `(\"mediaType\", \"image/jpeg\")` - `(\"mediaType\", \"image/j2p\")` - `(\"mediaType\", \"image/png\")` - `(\"mediaType\", \"image/gif\")` - `(\"mediaType\", \"image/tiff\")` - `(\"mediaType\", \"image/eps\")` \"\"\" resource_config : \"ResourceConfig\" def __post_init__ ( self ): self . localpath = \"/ote-data\" self . filename = self . resource_config . configuration [ \"artifactName\" ] if self . resource_config . configuration : self . conf = self . resource_config . configuration else : self . conf = {} def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Initialize.\"\"\" return {} def parse ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : if session is not None : self . conf . update ( session ) parsedOutput = {} if \"crop\" in self . conf : print ( \"cropping!\" ) im = Image . open ( f \" { self . localpath } / { self . filename } \" ) crop = self . conf [ \"crop\" ] im_cropped = im . crop ( tuple ( crop )) cropped_filename = f \" { self . localpath } /cropped_ { self . filename } \" im_cropped . save ( cropped_filename ) parsedOutput [ \"cropped_filename\" ] = cropped_filename parsedOutput [ \"parseImage\" ] = \"Done\" return parsedOutput initialize ( self , session = None ) \u00b6 Initialize. Source code in oteapi/strategies/parse/image_jpeg.py def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Initialize.\"\"\" return {}","title":"image_jpeg"},{"location":"api_reference/strategies/parse/image_jpeg/#image_jpeg","text":"Strategy class for image/jpg.","title":"image_jpeg"},{"location":"api_reference/strategies/parse/image_jpeg/#oteapi.strategies.parse.image_jpeg.ImageDataParseStrategy","text":"Parse strategy for images. Registers strategies : (\"mediaType\", \"image/jpg\") (\"mediaType\", \"image/jpeg\") (\"mediaType\", \"image/j2p\") (\"mediaType\", \"image/png\") (\"mediaType\", \"image/gif\") (\"mediaType\", \"image/tiff\") (\"mediaType\", \"image/eps\") Source code in oteapi/strategies/parse/image_jpeg.py @dataclass @StrategyFactory . register ( ( \"mediaType\" , \"image/jpg\" ), ( \"mediaType\" , \"image/jpeg\" ), ( \"mediaType\" , \"image/j2p\" ), ( \"mediaType\" , \"image/png\" ), ( \"mediaType\" , \"image/gif\" ), ( \"mediaType\" , \"image/tiff\" ), ( \"mediaType\" , \"image/eps\" ), ) class ImageDataParseStrategy : \"\"\"Parse strategy for images. **Registers strategies**: - `(\"mediaType\", \"image/jpg\")` - `(\"mediaType\", \"image/jpeg\")` - `(\"mediaType\", \"image/j2p\")` - `(\"mediaType\", \"image/png\")` - `(\"mediaType\", \"image/gif\")` - `(\"mediaType\", \"image/tiff\")` - `(\"mediaType\", \"image/eps\")` \"\"\" resource_config : \"ResourceConfig\" def __post_init__ ( self ): self . localpath = \"/ote-data\" self . filename = self . resource_config . configuration [ \"artifactName\" ] if self . resource_config . configuration : self . conf = self . resource_config . configuration else : self . conf = {} def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Initialize.\"\"\" return {} def parse ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : if session is not None : self . conf . update ( session ) parsedOutput = {} if \"crop\" in self . conf : print ( \"cropping!\" ) im = Image . open ( f \" { self . localpath } / { self . filename } \" ) crop = self . conf [ \"crop\" ] im_cropped = im . crop ( tuple ( crop )) cropped_filename = f \" { self . localpath } /cropped_ { self . filename } \" im_cropped . save ( cropped_filename ) parsedOutput [ \"cropped_filename\" ] = cropped_filename parsedOutput [ \"parseImage\" ] = \"Done\" return parsedOutput","title":"ImageDataParseStrategy"},{"location":"api_reference/strategies/parse/image_jpeg/#oteapi.strategies.parse.image_jpeg.ImageDataParseStrategy.initialize","text":"Initialize. Source code in oteapi/strategies/parse/image_jpeg.py def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Initialize.\"\"\" return {}","title":"initialize()"},{"location":"api_reference/strategies/parse/text_csv/","text":"text_csv \u00b6 Strategy class for text/csv. CSVParseStrategy dataclass \u00b6 Parse strategy for CSV files. Registers strategies : (\"mediaType\", \"text/csv\") Source code in oteapi/strategies/parse/text_csv.py @dataclass @StrategyFactory . register (( \"mediaType\" , \"text/csv\" )) class CSVParseStrategy : \"\"\"Parse strategy for CSV files. **Registers strategies**: - `(\"mediaType\", \"text/csv\")` \"\"\" resource_config : \"ResourceConfig\" def parse ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Parse CSV.\"\"\" print ( \"CSV in action!\" ) return {} def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Initialize.\"\"\" return {} initialize ( self , session = None ) \u00b6 Initialize. Source code in oteapi/strategies/parse/text_csv.py def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Initialize.\"\"\" return {} parse ( self , session = None ) \u00b6 Parse CSV. Source code in oteapi/strategies/parse/text_csv.py def parse ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Parse CSV.\"\"\" print ( \"CSV in action!\" ) return {}","title":"text_csv"},{"location":"api_reference/strategies/parse/text_csv/#text_csv","text":"Strategy class for text/csv.","title":"text_csv"},{"location":"api_reference/strategies/parse/text_csv/#oteapi.strategies.parse.text_csv.CSVParseStrategy","text":"Parse strategy for CSV files. Registers strategies : (\"mediaType\", \"text/csv\") Source code in oteapi/strategies/parse/text_csv.py @dataclass @StrategyFactory . register (( \"mediaType\" , \"text/csv\" )) class CSVParseStrategy : \"\"\"Parse strategy for CSV files. **Registers strategies**: - `(\"mediaType\", \"text/csv\")` \"\"\" resource_config : \"ResourceConfig\" def parse ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Parse CSV.\"\"\" print ( \"CSV in action!\" ) return {} def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Initialize.\"\"\" return {}","title":"CSVParseStrategy"},{"location":"api_reference/strategies/parse/text_csv/#oteapi.strategies.parse.text_csv.CSVParseStrategy.initialize","text":"Initialize. Source code in oteapi/strategies/parse/text_csv.py def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Initialize.\"\"\" return {}","title":"initialize()"},{"location":"api_reference/strategies/parse/text_csv/#oteapi.strategies.parse.text_csv.CSVParseStrategy.parse","text":"Parse CSV. Source code in oteapi/strategies/parse/text_csv.py def parse ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Parse CSV.\"\"\" print ( \"CSV in action!\" ) return {}","title":"parse()"},{"location":"api_reference/strategies/parse/text_json/","text":"text_json \u00b6 Strategy class for text/json. JSONDataParseStrategy dataclass \u00b6 Parse strategy for JSON. Registers strategies : (\"mediaType\", \"text/json\") Source code in oteapi/strategies/parse/text_json.py @dataclass @StrategyFactory . register (( \"mediaType\" , \"text/json\" )) class JSONDataParseStrategy : \"\"\"Parse strategy for JSON. **Registers strategies**: - `(\"mediaType\", \"text/json\")` \"\"\" resource_config : \"ResourceConfig\" def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Initialize.\"\"\" return {} def parse ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Parse json.\"\"\" downloader = create_download_strategy ( self . resource_config ) output = downloader . get () cache = DataCache ( self . resource_config . configuration ) content = cache . get ( output [ \"key\" ]) if isinstance ( content , dict ): return content return json . loads ( content ) initialize ( self , session = None ) \u00b6 Initialize. Source code in oteapi/strategies/parse/text_json.py def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Initialize.\"\"\" return {} parse ( self , session = None ) \u00b6 Parse json. Source code in oteapi/strategies/parse/text_json.py def parse ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Parse json.\"\"\" downloader = create_download_strategy ( self . resource_config ) output = downloader . get () cache = DataCache ( self . resource_config . configuration ) content = cache . get ( output [ \"key\" ]) if isinstance ( content , dict ): return content return json . loads ( content )","title":"text_json"},{"location":"api_reference/strategies/parse/text_json/#text_json","text":"Strategy class for text/json.","title":"text_json"},{"location":"api_reference/strategies/parse/text_json/#oteapi.strategies.parse.text_json.JSONDataParseStrategy","text":"Parse strategy for JSON. Registers strategies : (\"mediaType\", \"text/json\") Source code in oteapi/strategies/parse/text_json.py @dataclass @StrategyFactory . register (( \"mediaType\" , \"text/json\" )) class JSONDataParseStrategy : \"\"\"Parse strategy for JSON. **Registers strategies**: - `(\"mediaType\", \"text/json\")` \"\"\" resource_config : \"ResourceConfig\" def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Initialize.\"\"\" return {} def parse ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Parse json.\"\"\" downloader = create_download_strategy ( self . resource_config ) output = downloader . get () cache = DataCache ( self . resource_config . configuration ) content = cache . get ( output [ \"key\" ]) if isinstance ( content , dict ): return content return json . loads ( content )","title":"JSONDataParseStrategy"},{"location":"api_reference/strategies/parse/text_json/#oteapi.strategies.parse.text_json.JSONDataParseStrategy.initialize","text":"Initialize. Source code in oteapi/strategies/parse/text_json.py def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Initialize.\"\"\" return {}","title":"initialize()"},{"location":"api_reference/strategies/parse/text_json/#oteapi.strategies.parse.text_json.JSONDataParseStrategy.parse","text":"Parse json. Source code in oteapi/strategies/parse/text_json.py def parse ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Parse json.\"\"\" downloader = create_download_strategy ( self . resource_config ) output = downloader . get () cache = DataCache ( self . resource_config . configuration ) content = cache . get ( output [ \"key\" ]) if isinstance ( content , dict ): return content return json . loads ( content )","title":"parse()"},{"location":"api_reference/strategies/transformation/celery_remote/","text":"celery_remote \u00b6 Transformation Plugin that uses the Celery framework to call remote workers. CeleryConfig ( BaseModel ) pydantic-model \u00b6 Celery configuration. Source code in oteapi/strategies/transformation/celery_remote.py class CeleryConfig ( BaseModel ): \"\"\"Celery configuration.\"\"\" taskName : str = Field ( ... , description = \"A task name.\" ) args : List [ Any ] = Field ( ... , description = \"List of arguments for the task.\" ) args : List [ Any ] pydantic-field required \u00b6 List of arguments for the task. taskName : str pydantic-field required \u00b6 A task name. CeleryRemoteStrategy dataclass \u00b6 Submit job to remote Celery runner. Registers strategies : (\"transformation_type\", \"celery/remote\") Source code in oteapi/strategies/transformation/celery_remote.py @dataclass @StrategyFactory . register (( \"transformation_type\" , \"celery/remote\" )) class CeleryRemoteStrategy : \"\"\"Submit job to remote Celery runner. **Registers strategies**: - `(\"transformation_type\", \"celery/remote\")` \"\"\" transformation_config : \"TransformationConfig\" def run ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Run a job, return a job ID.\"\"\" config = self . transformation_config . configuration celeryConfig = CeleryConfig () if config is None else CeleryConfig ( ** config ) result = app . send_task ( celeryConfig . taskName , celeryConfig . args , kwargs = session ) return { \"result\" : result . task_id } def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Initialize a job.\"\"\" return {} def status ( self , task_id : str ) -> TransformationStatus : \"\"\"Get job status.\"\"\" result = AsyncResult ( id = task_id , app = app ) return TransformationStatus ( id = task_id , status = result . state ) def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Get transformation.\"\"\" # TODO: update and return global state # pylint: disable=fixme return {} get ( self , session = None ) \u00b6 Get transformation. Source code in oteapi/strategies/transformation/celery_remote.py def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Get transformation.\"\"\" # TODO: update and return global state # pylint: disable=fixme return {} initialize ( self , session = None ) \u00b6 Initialize a job. Source code in oteapi/strategies/transformation/celery_remote.py def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Initialize a job.\"\"\" return {} run ( self , session = None ) \u00b6 Run a job, return a job ID. Source code in oteapi/strategies/transformation/celery_remote.py def run ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Run a job, return a job ID.\"\"\" config = self . transformation_config . configuration celeryConfig = CeleryConfig () if config is None else CeleryConfig ( ** config ) result = app . send_task ( celeryConfig . taskName , celeryConfig . args , kwargs = session ) return { \"result\" : result . task_id } status ( self , task_id ) \u00b6 Get job status. Source code in oteapi/strategies/transformation/celery_remote.py def status ( self , task_id : str ) -> TransformationStatus : \"\"\"Get job status.\"\"\" result = AsyncResult ( id = task_id , app = app ) return TransformationStatus ( id = task_id , status = result . state )","title":"celery_remote"},{"location":"api_reference/strategies/transformation/celery_remote/#celery_remote","text":"Transformation Plugin that uses the Celery framework to call remote workers.","title":"celery_remote"},{"location":"api_reference/strategies/transformation/celery_remote/#oteapi.strategies.transformation.celery_remote.CeleryConfig","text":"Celery configuration. Source code in oteapi/strategies/transformation/celery_remote.py class CeleryConfig ( BaseModel ): \"\"\"Celery configuration.\"\"\" taskName : str = Field ( ... , description = \"A task name.\" ) args : List [ Any ] = Field ( ... , description = \"List of arguments for the task.\" )","title":"CeleryConfig"},{"location":"api_reference/strategies/transformation/celery_remote/#oteapi.strategies.transformation.celery_remote.CeleryConfig.args","text":"List of arguments for the task.","title":"args"},{"location":"api_reference/strategies/transformation/celery_remote/#oteapi.strategies.transformation.celery_remote.CeleryConfig.taskName","text":"A task name.","title":"taskName"},{"location":"api_reference/strategies/transformation/celery_remote/#oteapi.strategies.transformation.celery_remote.CeleryRemoteStrategy","text":"Submit job to remote Celery runner. Registers strategies : (\"transformation_type\", \"celery/remote\") Source code in oteapi/strategies/transformation/celery_remote.py @dataclass @StrategyFactory . register (( \"transformation_type\" , \"celery/remote\" )) class CeleryRemoteStrategy : \"\"\"Submit job to remote Celery runner. **Registers strategies**: - `(\"transformation_type\", \"celery/remote\")` \"\"\" transformation_config : \"TransformationConfig\" def run ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Run a job, return a job ID.\"\"\" config = self . transformation_config . configuration celeryConfig = CeleryConfig () if config is None else CeleryConfig ( ** config ) result = app . send_task ( celeryConfig . taskName , celeryConfig . args , kwargs = session ) return { \"result\" : result . task_id } def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Initialize a job.\"\"\" return {} def status ( self , task_id : str ) -> TransformationStatus : \"\"\"Get job status.\"\"\" result = AsyncResult ( id = task_id , app = app ) return TransformationStatus ( id = task_id , status = result . state ) def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Get transformation.\"\"\" # TODO: update and return global state # pylint: disable=fixme return {}","title":"CeleryRemoteStrategy"},{"location":"api_reference/strategies/transformation/celery_remote/#oteapi.strategies.transformation.celery_remote.CeleryRemoteStrategy.get","text":"Get transformation. Source code in oteapi/strategies/transformation/celery_remote.py def get ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Get transformation.\"\"\" # TODO: update and return global state # pylint: disable=fixme return {}","title":"get()"},{"location":"api_reference/strategies/transformation/celery_remote/#oteapi.strategies.transformation.celery_remote.CeleryRemoteStrategy.initialize","text":"Initialize a job. Source code in oteapi/strategies/transformation/celery_remote.py def initialize ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Initialize a job.\"\"\" return {}","title":"initialize()"},{"location":"api_reference/strategies/transformation/celery_remote/#oteapi.strategies.transformation.celery_remote.CeleryRemoteStrategy.run","text":"Run a job, return a job ID. Source code in oteapi/strategies/transformation/celery_remote.py def run ( self , session : \"Optional[Dict[str, Any]]\" = None ) -> \"Dict[str, Any]\" : \"\"\"Run a job, return a job ID.\"\"\" config = self . transformation_config . configuration celeryConfig = CeleryConfig () if config is None else CeleryConfig ( ** config ) result = app . send_task ( celeryConfig . taskName , celeryConfig . args , kwargs = session ) return { \"result\" : result . task_id }","title":"run()"},{"location":"api_reference/strategies/transformation/celery_remote/#oteapi.strategies.transformation.celery_remote.CeleryRemoteStrategy.status","text":"Get job status. Source code in oteapi/strategies/transformation/celery_remote.py def status ( self , task_id : str ) -> TransformationStatus : \"\"\"Get job status.\"\"\" result = AsyncResult ( id = task_id , app = app ) return TransformationStatus ( id = task_id , status = result . state )","title":"status()"}]}